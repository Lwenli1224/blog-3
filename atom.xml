<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Taobao FED | 淘宝前端团队]]></title>
  <subtitle><![CDATA[淘宝前端团队（FED）]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://taobaofed.org/"/>
  <updated>2016-10-12T02:02:15.000Z</updated>
  <id>http://taobaofed.org/</id>
  
  <author>
    <name><![CDATA[Taobao FED]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Velocity NYC 2016 参会总结]]></title>
    <link href="http://taobaofed.org/blog/2016/10/11/thinking-in-velocity-nyc-2016/"/>
    <id>http://taobaofed.org/blog/2016/10/11/thinking-in-velocity-nyc-2016/</id>
    <published>2016-10-11T10:38:34.000Z</published>
    <updated>2016-10-12T02:02:15.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img.alicdn.com/tfs/TB1H9LFNFXXXXb_aXXXXXXXXXXX-900-500.jpg" alt="Velocity NYC 2016 参会总结"></p>
<p>就在刚刚过去的九月，作为 FED 团队的代表有幸参加了美国纽约的 Velocity Web 性能和敏捷运维大会。在大约一周的行程中，会议团队组织了十分丰富的行程，会议团队也在内部对于 Velocity 的演讲内容做了多次讨论。整个行程在我看来是十分圆满的。</p>
<h1 id="Velocity-NYC"><a href="#Velocity-NYC" class="headerlink" title="Velocity @ NYC"></a>Velocity @ NYC</h1><p>Velocity 作为 <a href="http://www.oreilly.com/conferences/" target="_blank" rel="external">O’Reilly</a> 旗下的老牌会议品牌，从 2008 年开始专著 Web 性能、DevOps（运维或开发自运维）等领域。在会议组织、开发者关系和商业运作等方面都十分老道。国内的开发者社区方兴未艾，也有诸如 SegmentFault D-Day、JSConf、D2 等类似定位的会议，但从各方面来讲都与 Velocity 有云泥之别。这也是为何在汇报中把会议组织本身感想放在了最前面。</p>
<p>会议组织方固定在圣克拉拉（美国加州）、纽约（美国纽约州）、阿姆斯特丹（荷兰）、北京（中国）四个城市巡回举办，可见其国际化程度之高。正是如此的多元化的组织形式，不仅吸引了全球不同国家的参会者，对于赞助商和讲师来说，也让自己的思想和意志传播到得更广。另一方面，由于有固定的巡回议程，举办方在现场把控上容易积累更多的经验。这是体现在各种细节上的，例如：</p>
<ul>
<li>会场位于纽约中央公园旁边，对于第一次来纽约的人来说，太好找了；另外由于地处曼哈顿中心，即使当日会议日程安排的很晚，也不用担心治安问题；</li>
<li>会议前夕，收到邮件告知参会信息以及领取胸牌的操作指南，并且提供了一个会议伴侣 App，方便当天查询会日日程；</li>
<li>茶歇区即赞助商展位，互利互惠；作为参会者，还是很有激情一边吃吃喝喝一边参观摊位的；</li>
<li>赞助商的展位都有非常专业的一对一讲解、游戏、抽奖等各类活动；</li>
<li>赞助商参与的演讲均有明显标示，参会者可以自行选择；</li>
<li>…</li>
</ul>
<p>当然，国内的技术会议也办的的越来越好了。</p>
<p>补充下没有论据的一家之言：健康良好的开发者社区不应该只是默默的搞开源项目，而是应该包括线上和线下；如今开发者 BBS、博客、微博大V、公众号等富媒体已经产生了大量的技术内容，但是还以搬运国外原创内容和互相捧臭脚为主；而线下的会议和其他形式活动（编程马拉松、培训等）缺乏成熟稳健的商业模式，导致要么昙花一现，要么沦为大厂的宣传和招聘工具。</p>
<p>根据 <a href="https://www.infoq.com/news/2014/01/IDC-software-developers" target="_blank" rel="external">IDC 数据</a>，国内 2014 年开发者人群约有 185 万，相信随着互联网的火爆发展，近几年这个数据只会增长的更快。阿里作为国内首屈一指的互联网综合体，拥有丰富的开发者资源、良好品牌效应，理应在这个领域发出更大的声音。</p>
<h1 id="Keynote-心得：意料之外，情理之中"><a href="#Keynote-心得：意料之外，情理之中" class="headerlink" title="Keynote 心得：意料之外，情理之中"></a>Keynote 心得：意料之外，情理之中</h1><p>Velocity 的主题限定了 Web 性能和 DevOps 两个领域，但实际上这两个领域又都非常宽泛，所以导致一次会议中演讲的具体内容并没有非常清晰的关联关系。本次的会议有一个宴会厅和五个会议室，每个会议室至多一天分为五场演讲顺序进行。作为参与者，是不可能全部全部听完的。但整体上还是有有不少热门主题被多次提到，所以后文还是以这些较为聚焦的话题进行归纳总结。</p>
<h2 id="微服务趋于理性"><a href="#微服务趋于理性" class="headerlink" title="微服务趋于理性"></a>微服务趋于理性</h2><p>微服务架构至少被个大厂商（Google、Facebook、Twitter、Netflix）布道有两年有余，那些能够接受的公司早已改造完毕。如今甜蜜期已过，新架构带来的各种问题也接踵而来。</p>
<p>这次直接和微服务有关的演讲有：</p>
<ul>
<li><a href="http://conferences.oreilly.com/velocity/devops-web-performance-ny/public/schedule/detail/51097" target="_blank" rel="external">Mitigating sprawl with microservices and containerization</a></li>
<li><a href="http://conferences.oreilly.com/velocity/devops-web-performance-ny/public/schedule/detail/51220" target="_blank" rel="external">Running Consul at scale: Service discovery in the cloud</a></li>
<li><a href="http://conferences.oreilly.com/velocity/devops-web-performance-ny/public/schedule/detail/51313" target="_blank" rel="external">Distributed tracing: How to do latency analysis for microservices-based applications</a></li>
<li><a href="http://conferences.oreilly.com/velocity/devops-web-performance-ny/public/schedule/detail/51230" target="_blank" rel="external">The once and future layer 5: Resilient, Twitter-style microservices</a></li>
</ul>
<p>这些话题（包括其他的话题）大多有一个特征——它们聚焦一个问题，给出一个思路，结合一个解决方案，最后给出实践成果。被各位演讲者提到的问题：</p>
<ol>
<li>编码成本提高：代码越来越复杂，一个是在代码行数上，另外就是服务组件越来越多</li>
<li>人员成本提高：团队越来越复杂，细化后的组件总会依赖至少一个团队去负责维护</li>
<li>调试成本提高：新架构下的会话跟踪、重放、日志以及自动测试等中间件都要改造以及积累经验</li>
<li>稳定性成本提高：监控、容灾和资源调度也都出现了新的问题</li>
</ol>
<p><img src="https://img.alicdn.com/tps/TB17.vVNFXXXXcVXFXXXXXXXXXX-668-384.png" alt="2"></p>
<p>社区里针对这些问题给了不少开源方案，例如 <a href="https://www.consul.io/" target="_blank" rel="external">Consul</a>、<a href="https://twitter.github.io/finagle/" target="_blank" rel="external">Finage</a>、<a href="https://github.com/openzipkin/zipkin" target="_blank" rel="external">Zipkin</a>。</p>
<p>阿里内部由于有一个强大的中间件团队，所以这些基础设施均为自建。虽然实现不一样，其实大家的理论都基本类似。集团的 HSF 服务出现的很早，如今也是 PandoraBoot 的实现基础；EagleEye 也是老牌的 Tracer，基本能适配到任何应用场景了。</p>
<p>除了在部分细节不如开源方案来得好。例如，HSF 对超时处理、分布式事物等处理欠缺、容灾方案常常只有机房热冷备诸如此类的问题。但阿里的中间件实际表现是十分出色的，并且经过了时间的考验。</p>
<p>反过来想也有些后怕，在中小型企业对极为积极的采纳这些开源方案并玩的正欢的时候，集团的技术人员由于没有实际的应用场景，其实并不是很热衷于去了解这些东西，是否会和外界社区脱节呢？当然大厂留着各种私货是很正常的事情（包括 Google、Facebook）。</p>
<h2 id="DevOps-全家桶越来越大：Serverless、CloudNative、Infrastructure-as-Code…"><a href="#DevOps-全家桶越来越大：Serverless、CloudNative、Infrastructure-as-Code…" class="headerlink" title="DevOps 全家桶越来越大：Serverless、CloudNative、Infrastructure as Code…"></a>DevOps 全家桶越来越大：Serverless、CloudNative、Infrastructure as Code…</h2><p>今年围绕 DevOps 的新名词 Serverless、CloudNative、Infrastructure as Code 等新名词如数出现在了演讲的标题中。</p>
<p>对技术人员来讲，是大家开始从吹捧 DevOps 概念，到了各种实践和解决方案，然后并进入下一轮概念炒作的过程了（注意此处炒作并不是贬义）。</p>
<p>Serverless 是一种和微服务有关的开发和部署形式（即 DevOps 的一种实践方案）。Serverless 的模式下，开发者不再关注计算资源（集群、服务器等）、不再关心虚拟化（VM、Docker 等）、不再关心进程模型（进程启动、停止、重启等），只需利用各种云计算资源（对象存储、消息服务、离线任务等）提供实现业务逻辑的函数或方法。Amazon 的 AWS 最近提供的一种新的服务类型 <a href="https://aws.amazon.com/cn/documentation/lambda/" target="_blank" rel="external">Lambda</a> 所掀起的新一轮浪潮，预计其他云服务厂商会迅速跟进。这种模式也非常适合在集团内部推广，为业务开发减负，同时提高整体资源利用率。当然，目前 AWS 推的还是动态语言的服务类型，诸如 Node.js、Python，预计 Scala 也快了，也许这也是让多语言在业务层面得到支持的一个好机会。</p>
<p>Serverless 的主题演讲有：</p>
<ul>
<li><a href="http://conferences.oreilly.com/velocity/devops-web-performance-ny/public/schedule/detail/51002" target="_blank" rel="external">Managing serverless: Ops for NoOps</a></li>
<li><a href="http://conferences.oreilly.com/velocity/devops-web-performance-ny/public/schedule/detail/53601" target="_blank" rel="external">Ops in the time of serverless containerized webscale</a></li>
</ul>
<p>由于时间关系我只去了第二个，但比较失望的是一个多人对话形式的访谈，并没有什么逻辑可言。多为介绍自己公司的在 Docker、Serverless（沾了点边）方面的实践。透过第一个演讲的 Keynote 可以判断内容还是有很高价值的，讲的是第一轮 Serverless 实践中遇到的各种问题，主要集中在监控方法、编程模式、安全模型的变化，并且讽刺的是其内容透出的担忧标示 Serverless 并不能让开发者完全不关心服务器。</p>
<p><a href="http://conferences.oreilly.com/velocity/devops-web-performance-ny/public/schedule/detail/51192" target="_blank" rel="external">Implementing infrastructure as code</a> 是一个布道性质的演讲，从零开始介绍了其概念、组成部分（以及顺便推销了自己的书）。</p>
<p>Infrastructure as Code 也不是什么全新的概念，是指利用软件工程的工具和方法来管理基础设施的一种思路。近几年 Docker 火的的一塌糊涂，其一大特性就是所有资源都可以通过 API 操控，这也是 Infrastructure as Code 在实践上成为可能的一大支柱。在此之上的 <a href="http://kubernetes.io/" target="_blank" rel="external">kubernetes</a> 等开源项目又在集群纬度提供了可编程的编排能力。这样开发者是能够面向集群编程管理的，这才是真正意义上的 DevOps。题外话，这里也期望明年的 Docker 改造中起码能把 DockerCompose 的能力开放出来。</p>
<p><img src="https://img.alicdn.com/tps/TB1tGweNFXXXXa7XXXXXXXXXXXX-1017-576.png" alt="4.png"></p>
<p>最后，CloudNative 是一套包括 CD（持续交付）、Microservice（微服务）、DevOps、容器思想的集合，所以这次会议的演讲中不会直接将其作为主题，但都命中 CloudNative 这个关键字。再说几个厂商的名字 Pivotal、Cloud Foundry，都是这些概念的布道者，也是此次 Velocity 会议的演讲者和赞助商。</p>
<h2 id="Web-相关"><a href="#Web-相关" class="headerlink" title="Web 相关"></a>Web 相关</h2><h3 id="MobileWeb-性能优化和趋势"><a href="#MobileWeb-性能优化和趋势" class="headerlink" title="MobileWeb 性能优化和趋势"></a>MobileWeb 性能优化和趋势</h3><p>这次来自 Google 的两场演讲分别介绍了 PWA、AMP</p>
<ul>
<li><a href="http://conferences.oreilly.com/velocity/devops-web-performance-ny/public/schedule/detail/50799" target="_blank" rel="external">The future of the mobile Web</a></li>
<li><a href="http://conferences.oreilly.com/velocity/devops-web-performance-ny/public/schedule/detail/50798" target="_blank" rel="external">The Accelerated Mobile Pages (AMP) Project: What lies ahead?</a></li>
</ul>
<p>总的来讲，Google 作为 Chrome、ChormeOS、V8、Blink 等 Web 技术产品的维护者，自然对 MobileWeb 的前景相当看好，因此每年都会推出一些新的技术来增强 Web 平台的能力。AMP推广的时间很长了，其本质是一套前端优化的最佳实践。PWA 是今年的新技术，也为未来的 MobileWeb 注入了新的活力，但基于 H5 的 MobileWeb 的颓势是不会改变的。</p>
<p>此次也有演讲对 Web 和 App 重新做了对比和思考：<a href="http://conferences.oreilly.com/velocity/devops-web-performance-ny/public/schedule/detail/54229" target="_blank" rel="external"> Web versus apps revisited</a>。里面的数据是血淋淋的，只有 13% 的用户时间花在 MobileWeb 上。</p>
<p>个人观点是，虽然以 HTML5 页面再也不可能成为入口或主要产品，但在碎片场景下是有巨大发挥空间的。例如微信公众号、微信微应用等场景，均是以 HTML5 技术为基础的。</p>
<p>当然 Web 和 App 的竞争还在继续，<a href="https://developer.android.com/topic/instant-apps/index.html" target="_blank" rel="external">Android Instant Apps</a> 这样的技术出现意味着原声应用正在挑战 Web 应用的易传播性这样的优势。而 ReactNative 这样的技术，则在结合 Web 技术和 App 技术来挑战传统 App 的开发成本问题。</p>
<p>阿里旗下产品都有自己的航母应用，所以更多考虑的在闭环生态下增强用户体验的技术改进，Weex、ZCache 这类技术从实际效果来讲远超 Google 给的任何方案，但是 Google 的这些方案是通用方案，我们的是限于 App 内的方案。</p>
<h3 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h3><p>正如上文指出的，大多数演讲都是围绕某个开源项目或自家公司产品进行的，很少有讲解基础技术或原理的。由于时间排期，我听到的数量有限的演讲中，只有 <a href="http://conferences.oreilly.com/velocity/devops-web-performance-ny/public/schedule/detail/51303" target="_blank" rel="external">HTTP/2: What no one is telling you</a> 是讲解 HTTP2 原理和应用的。碍于 40 分钟的时长限制，演讲者也大多在讲时间过程中遇到的问题和一些关键数据。</p>
<p>目前来看 HTTP2 最大的问题就是它并没有想象中的那么好。头压缩、socket 复用等技术在效果上并没有各大浏览器厂商优化了多年的 HTTP1.1 效果好，反而在弱网环境下，简单粗暴占用多连接的 HTTP1.1 效果更好。</p>
<p>HTTP2 在草案期间就广受开发者追捧，可如今标准确定，却罕见实质改变。也许 HTTP2 会让 HTTP 技术在一些 RPC 场景中会有明显优势，但在传统页面浏览方面，并不会得到非常迅速的应用。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Velocity 的会议总的来说，在演讲内容上是中规中矩的，毕竟也不是专门的学术会议或事领域论坛。但正是成熟稳定的运作，让厂商和开发者有持续的交流机会。DevOps 相关话题依然热门，微服务和容器必然成为互联网公司的必备武器。新技术在国内都是慢热的，但最终结果会保持和社区同步，可预见集团在未来也会在这些领域有所沉淀和输出。</p>
<p><img src="https://img.alicdn.com/tps/TB1jK3cNFXXXXbZXXXXXXXXXXXX-800-600.jpg" alt="5.png"></p>
<p>多元化的社会和多元化的会议组成，让我们对于此次美国之行十分充实。行程的最后我们短暂的参观了谷歌位于纽约的分公司。几位华人研发的同事接待了我们，听了他们讲的经历和工作，也感受到在多元化冲击下对于企业和员工的种种机遇是巨大的。也很是期待，阿里集团能拓展更多的国际业务，成为在国际上更具影响力的跨国企业。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img.alicdn.com/tfs/TB1H9LFNFXXXXb_aXXXXXXXXXXX-900-500.jpg" alt="Velocity NYC 2016 参会总结"></p>
<p>就在刚刚过去的九月，作为 FED 团队的代表有]]>
    </summary>
    
      <category term="Velocity" scheme="http://taobaofed.org/tags/Velocity/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[理解 Babel 插件]]></title>
    <link href="http://taobaofed.org/blog/2016/09/29/babel-plugins/"/>
    <id>http://taobaofed.org/blog/2016/09/29/babel-plugins/</id>
    <published>2016-09-29T10:58:03.000Z</published>
    <updated>2016-10-12T02:02:15.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img.alicdn.com/tfs/TB1cVgDNpXXXXb2XFXXXXXXXXXX-900-500.jpg" alt="理解 Babel 插件"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>相信目前常与 ES6 代码打交道的同学对 Babel 应该不会陌生，在 ES6 代码被编译转化为 ES5 代码的过程中，Babel 插件显得尤为重要，我们最后经由 Babel 生成的代码取决于插件在这一层中做了什么事，在探索这其中的过程之前，我们先来了解下一些所需的基础知识。</p>
<h2 id="抽象语法树"><a href="#抽象语法树" class="headerlink" title="抽象语法树"></a>抽象语法树</h2><p>Babel 的工作流可以用下面一张图来表示，代码首先经由 <code>babylon</code> 解析成<a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" target="_blank" rel="external">抽象语法树</a>（AST），后经一些遍历和分析转换（主要过程），最后根据转换后的 AST 生成新的常规代码。</p>
<p><img src="https://img.alicdn.com/tps/TB1nP2ONpXXXXb_XpXXXXXXXXXX-1958-812.png" alt=""></p>
<p>在这其中，理解清楚 AST 十分重要，我们之所以需要将代码转换为 AST 也是为了让计算机能够更好地进行理解。我们可以来看看下面这段代码被解析成 AST 后对应的结构图：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abs</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (number &gt;= <span class="number">0</span>) &#123;  <span class="comment">// test</span></span><br><span class="line">    <span class="keyword">return</span> number;  <span class="comment">// consequent</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> -number; <span class="comment">// alternate</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img.alicdn.com/tps/TB1NnDQNpXXXXXmXFXXXXXXXXXX-1015-756.png" alt=""></p>
<p>所有的 AST 根节点都是 Program 节点，从上图中我们可以看到解析生成的 AST 的结构的各个 Node 节点都很细微，<a href="https://github.com/babel/babylon/blob/master/ast/spec.md" target="_blank" rel="external">Babylon AST</a> 有个文档对每个节点类型都做了详细的说明，你可以对照各个节点类型在这查找到所需要的信息。在这个例子中，我们主要关注函数声明里的内容， <code>IfStatement</code> 对应代码中的 <code>if...else</code> 区块的内容，我们先对条件（<code>test</code>）进行判断，这里是个简单的二进制表达式，我们的分支也会从这个条件继续进行下去，<code>consequent</code> 代表条件值为 true 的分支，<code>alternate</code> 代表条件值为 false 的分支，最后两条分支各自在 <code>ReturnStatement</code> 节点进行返回。</p>
<p>了解 AST 各个节点的类型是后续编写插件的关紧，AST 通常情况下都是比较复杂的，上述一段简单的函数定义也生成了比较大的 AST，对于一些复杂的程序，我们可以借助 <a href="https://astexplorer.net/" target="_blank" rel="external">astexplorer</a> 来帮我们分析 AST 的结构。</p>
<h2 id="遍历节点"><a href="#遍历节点" class="headerlink" title="遍历节点"></a>遍历节点</h2><p>在插件里进行节点遍历需要先了解 visitor 和 path 的概念，前者相当于从众多节点类型中选择开发者所需要的节点，后者相当于对节点之间的关系的访问。</p>
<h3 id="visitor"><a href="#visitor" class="headerlink" title="visitor"></a>visitor</h3><p>Babel 使用 <code>babel-traverse</code> 进行树状的遍历，对于 AST 树上的每一个分支我们都会先向下遍历走到尽头，然后向上遍历退出遍历过的节点寻找下一个分支。Babel 提供我们一个 <a href="https://en.wikipedia.org/wiki/Visitor_pattern" target="_blank" rel="external">visitor</a> 对象供我们获取 AST 里所需的具体节点来进行访问，比如我只想访问 <code>if...else</code> 生成的节点，我们可以在 visitor 里指定获取它所对应的节点：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> visitor = &#123;</span><br><span class="line">  IfStatement() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'get if'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>继续上述所说的遍历，其实这种遍历会让每个节点都会被访问两次，一次是向下遍历代表进入（enter），一次是向上退出（exit）。因此实际上每个节点都会有 <code>enter</code> 和 <code>exit</code> 方法，在实际操作的时候需要注意这种遍历方式可能会引起的一些问题，上述例子是省略掉 <code>enter</code> 的简写。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> visitor = &#123;</span><br><span class="line">  IfStatement: &#123;</span><br><span class="line">    enter() &#123;&#125;,</span><br><span class="line">    exit() &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="path"><a href="#path" class="headerlink" title="path"></a>path</h3><p>visitor 模式中我们对节点的访问实际上是对节点路径的访问，在这个模式中我们一般把 <code>path</code> 当作参数传入节点选择器中。<code>path</code> 表示两个节点之间的连接，通过这个对象我们可以访问到节点、父节点以及进行一系列跟节点操作相关的方法（类似 DOM 的操作）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> babel = <span class="built_in">require</span>(<span class="string">'babel-core'</span>);</span><br><span class="line"><span class="keyword">var</span> t = <span class="built_in">require</span>(<span class="string">'babel-types'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> code = <span class="string">`d = a + b + c`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> visitor = &#123;</span><br><span class="line">	Identifier(path) &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(path.node.name);  <span class="comment">// d a b c</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = babel.transform(code, &#123;</span><br><span class="line">	plugins: [&#123;</span><br><span class="line">		visitor: visitor</span><br><span class="line">	&#125;]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="替换节点"><a href="#替换节点" class="headerlink" title="替换节点"></a>替换节点</h2><p>具备了 AST 相关知识和了解 visitor、path 后，就可以编写一个简单的 Babel 插件了。我们要把上述的 <code>abs</code> 函数换成原生支持的 <code>Math.abs</code> 来进行调用 。</p>
<p>首先我们先解析下 <code>abs(-8)</code> 的 AST 结构，直接从表达式语句（ExpressionStatement）开始：</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="symbol">  type:</span> <span class="string">"ExpressionStatement"</span>,</span><br><span class="line"><span class="symbol">  expression:</span> &#123;</span><br><span class="line"><span class="symbol">    type:</span> <span class="string">"CallExpression"</span>,</span><br><span class="line"><span class="symbol">    callee:</span> &#123;</span><br><span class="line"><span class="symbol">      type:</span> <span class="string">"Identifier"</span>,</span><br><span class="line"><span class="symbol">      name:</span> <span class="string">"abs"</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="symbol">    arguments:</span> [&#123;</span><br><span class="line"><span class="symbol">      type:</span> <span class="string">"UnaryExpression"</span>,</span><br><span class="line"><span class="symbol">      operator:</span> <span class="string">"-"</span>,</span><br><span class="line"><span class="symbol">      prefix:</span> true,</span><br><span class="line"><span class="symbol">      arguments:</span> &#123;</span><br><span class="line"><span class="symbol">        type:</span> <span class="string">"NumericLiteral"</span>,</span><br><span class="line"><span class="symbol">        value:</span> <span class="number">8</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到表达式语句下面的 <code>expression</code> 主要是函数调用表达式（<code>CallExpression</code>），因此我们也需要创建一个函数调用表达式，此外，<code>Math.abs</code> 是一个二元操作表达式，属于 <code>MemberExpression</code> 类型。上述两个 AST 节点我们可以借助 <a href="https://github.com/babel/babel/tree/master/packages/babel-types" target="_blank" rel="external">babel-types</a> 里提供的一些方法帮我们快速创建。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建函数调用表达式</span></span><br><span class="line">t.CallExpression(</span><br><span class="line">  <span class="comment">// 创建对象属性引用</span></span><br><span class="line">	t.MemberExpression(t.identifier(<span class="string">'Math'</span>), t.identifier(<span class="string">'abs'</span>)), </span><br><span class="line">	<span class="comment">// 原始节点函数调用参数</span></span><br><span class="line">	path.node.arguments </span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>最后我们需要对此次函数调用不符合的节点进行过滤，过滤掉名字不等于 abs 的函数调用，因为 Babel 在遍历的过程是递归的，如果不过滤做限制的话，程序将会一直运行最终报调用栈超过阈值的错误。</p>
<p><code>RangeError: unknown: Maximum call stack size exceeded</code></p>
<p>最终代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> babel = <span class="built_in">require</span>(<span class="string">'babel-core'</span>);</span><br><span class="line"><span class="keyword">var</span> t = <span class="built_in">require</span>(<span class="string">'babel-types'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> code = <span class="string">`abs(-8);`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> visitor = &#123;</span><br><span class="line">	CallExpression(path) &#123;</span><br><span class="line">		<span class="keyword">if</span> (path.node.callee.name !== <span class="string">'abs'</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">		path.replaceWith(t.CallExpression(</span><br><span class="line">			t.MemberExpression(t.identifier(<span class="string">'Math'</span>), t.identifier(<span class="string">'abs'</span>)),</span><br><span class="line">			path.node.arguments</span><br><span class="line">		));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = babel.transform(code, &#123;</span><br><span class="line">	plugins: [&#123;</span><br><span class="line">		visitor: visitor</span><br><span class="line">	&#125;]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Math.abs(-8)</span></span><br><span class="line"><span class="built_in">console</span>.log(result.code);</span><br></pre></td></tr></table></figure>
<p>上述例子使用了 <code>transform</code> api 直接解析转换生成了新的代码，另外在单独编写 Babel 插件的时候，暴露的参数里一般都含有常用的 <code>babel-types</code> 对象供使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">&#123; types: t &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    visitor: &#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过编写 Babel 插件我们能对 AST 有一定的了解，另外，我认为现阶段 Babel 插件不仅仅止于对 ES6 代码的转换上，<a href="https://www.npmjs.com/search?q=babel-plugin" target="_blank" rel="external">npm</a> 上有一系列的插件覆盖了许多适合的应用场景，后续具有一定的探索性。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://github.com/babel/babylon/blob/master/ast/spec.md" target="_blank" rel="external">babylon-spec</a></li>
<li><a href="https://github.com/babel/babel/tree/master/packages/babel-types" target="_blank" rel="external">babel-types</a></li>
<li><a href="https://www.h5jun.com/post/babel-for-es6-and-beyond.html" target="_blank" rel="external">babel-for-es6-and-beyond</a></li>
<li><a href="https://www.sitepoint.com/understanding-asts-building-babel-plugin/" target="_blank" rel="external">understanding-asts-building-babel-plugin</a></li>
<li><a href="https://github.com/thejameskyle/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#toc-visitors" target="_blank" rel="external">babel-handbook</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img.alicdn.com/tfs/TB1cVgDNpXXXXb2XFXXXXXXXXXX-900-500.jpg" alt="理解 Babel 插件"></p>
<h2 id="前言"><a href="#前言" class="head]]>
    </summary>
    
      <category term="Babel" scheme="http://taobaofed.org/tags/Babel/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Node.js 和 C++ 之间的类型转换]]></title>
    <link href="http://taobaofed.org/blog/2016/09/20/type-casts-between-node-and-cpp/"/>
    <id>http://taobaofed.org/blog/2016/09/20/type-casts-between-node-and-cpp/</id>
    <published>2016-09-20T03:18:23.000Z</published>
    <updated>2016-10-12T02:02:15.000Z</updated>
    <content type="html"><![CDATA[<p><img src="//img.alicdn.com/tfs/TB1h_SoNpXXXXcMXXXXXXXXXXXX-900-500.jpg" alt="Node.js 和 C++ 之间的类型转换"></p>
<p>我非常喜欢使用 Node.js，但是当涉及到计算密集型的场景时 Node.js 就不能够很好地胜任了。而在这样的情况下 C++  是一个很好的选择，非常幸运 Node.js 官方提供了 <a href="https://nodejs.org/dist/latest-v6.x/docs/api/addons.html" target="_blank" rel="external">C/C++ Addons</a> 的机制让我们能够使用 V8 API 把 Node.js 和 C++ 结合起来。</p>
<p>虽然在 Node.js 官方网站有很多的关于怎么使用这些 API 的文档，但是在 JavaScript 和 C++ 之间传递数据是一件非常麻烦的事情，C++ 是强类型语言（”1024” 是字符串类型而不是整数类型），而 JavaScript 却总是默认的帮我们做一些类型转换。</p>
<p>JavaScript 的基本类型包括 String，Number，Boolean，null，undefined，V8 使用类继承的方式来定义这类型，这些类型都继承了 <code>Primitive</code> 类，而 <code>Primitive</code> 继承了 <code>Value</code>，v8 也支持整型（包括 <code>Int32</code> 和 <code>Uint32</code>），而所有的类型定义都可以从 V8 <a href="https://v8docs.nodesource.com/node-6.0/d0/d4a/classv8_1_1_primitive.html" target="_blank" rel="external">类型文档</a>中看到，除了基本的类型，还有 Object，Array，Map 等类型的定义。</p>
<p>基本类型的继承关系如下图：<br><img src="https://img.alicdn.com/tfs/TB1JspRNpXXXXajapXXXXXXXXXX-804-860.png" alt="primitive"></p>
<p>在 V8 中所有 JavaScript 值都是被放在 <code>Local</code> 对象中，通过这个对象指定了 JavaScript 运行时的内存单元。</p>
<p>下面这段代定义了一个 <code>Number</code> 类型的值，其中 Test 函数中声明的 isolate 变量代表着 V8 虚拟机中的堆内存，当创建新变量的时候就需要用到它，接下来的一行代码就通过 isolate 声明了一个 <code>Number</code> 类型的变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;node.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;v8.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> v8;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">const</span> v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">    Isolate* isolate = args.GetIsolate();</span><br><span class="line">    <span class="comment">// 声明变量</span></span><br><span class="line">    Local&lt;Number&gt; retval = v8::Number::New(isolate, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Local &lt;Object&gt; exports, Local&lt;Object&gt; module)</span> </span>&#123;</span><br><span class="line">    NODE_SET_METHOD(exports, <span class="string">"getTestValue"</span>, Test);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NODE_MODULE(returnValue, init)</span><br></pre></td></tr></table></figure>
<p>看了 V8 <a href="https://v8docs.nodesource.com/node-6.0/d0/d4a/classv8_1_1_primitive.html" target="_blank" rel="external">类型 API 文档</a> 你会发现对于基本的 JavaScript 类型，只有变量的声明而没有变量的赋值。最初想可能觉得这个非常的奇怪，可是仔细想一想后发现这个是合理的。主要由以下几点原因：</p>
<ul>
<li>JavaScript 的基本类型是不可变类型，变量都是指向一个不可变的内存单元，var a = 10，则 a 指向的内存单元中包含的值为 5，重新赋值 a = 100，没有改变这个内存单元的值，而是使得 a 指向了另外一个内存单元，其中的值为 100。如果声明两个变量 x，y 的值都为 10，则他们指向的是同一个内存单元。</li>
<li>函数的传参都是传值，而不是传引用，当在 JavaScript 中调用 C++ 的函数时，如果参数是基本类型则每次都是把这个值拷贝过去，改变参数的值不会影响原来的值。</li>
<li>使用 <code>Local&lt;Value&gt;</code> 声明基本类型的变量都是对内存单元的引用，因为第一条原因不可能改变引用的值使其指向另外一个内存单元，因此不存在变量的重新赋值。</li>
</ul>
<h3 id="数据流向-C-gt-JavaScript"><a href="#数据流向-C-gt-JavaScript" class="headerlink" title="数据流向 C++ -&gt; JavaScript"></a>数据流向 C++ -&gt; JavaScript</h3><p>下面 demo 定义了一些常用的 JavaScript 类型，包括基本类型的以及 Object, Array, Fuction。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;node.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;v8.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> v8;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyFunction</span><span class="params">(<span class="keyword">const</span> v8::FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">    Isolate* isolate = args.GetIsolate();</span><br><span class="line">    args.GetReturnValue().Set(String::NewFromUtf8(isolate, <span class="string">"Hello World!"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">const</span> v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">    Isolate* isolate = args.GetIsolate();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Number 类型的声明</span></span><br><span class="line">    Local&lt;Number&gt; retval = v8::Number::New(isolate, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// String 类型的声明</span></span><br><span class="line">    Local&lt;String&gt; str = v8::String::NewFromUtf8(isolate, <span class="string">"Hello World!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Object 类型的声明</span></span><br><span class="line">    Local&lt;Object&gt; obj = v8::Object::New(isolate);</span><br><span class="line">    <span class="comment">// 对象的赋值</span></span><br><span class="line">    obj-&gt;Set(v8::String::NewFromUtf8(isolate, <span class="string">"arg1"</span>), str);</span><br><span class="line">    obj-&gt;Set(v8::String::NewFromUtf8(isolate, <span class="string">"arg2"</span>), retval);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Function 类型的声明并赋值</span></span><br><span class="line">    Local&lt;FunctionTemplate&gt; tpl = v8::FunctionTemplate::New(isolate, MyFunction);</span><br><span class="line">    Local&lt;Function&gt; fn = tpl-&gt;GetFunction();</span><br><span class="line">    <span class="comment">// 函数名字</span></span><br><span class="line">    fn-&gt;SetName(String::NewFromUtf8(isolate, <span class="string">"theFunction"</span>));</span><br><span class="line">    obj-&gt;Set(v8::String::NewFromUtf8(isolate, <span class="string">"arg3"</span>), fn);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Boolean 类型的声明</span></span><br><span class="line">    Local&lt;Boolean&gt; flag = Boolean::New(isolate, <span class="literal">true</span>);</span><br><span class="line">    obj-&gt;Set(String::NewFromUtf8(isolate, <span class="string">"arg4"</span>), flag);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Array 类型的声明</span></span><br><span class="line">    Local&lt;Array&gt; arr = Array::New(isolate);</span><br><span class="line">    <span class="comment">// Array 赋值</span></span><br><span class="line">    arr-&gt;Set(<span class="number">0</span>, Number::New(isolate, <span class="number">1</span>));</span><br><span class="line">    arr-&gt;Set(<span class="number">1</span>, Number::New(isolate, <span class="number">10</span>));</span><br><span class="line">    arr-&gt;Set(<span class="number">2</span>, Number::New(isolate, <span class="number">100</span>));</span><br><span class="line">    arr-&gt;Set(<span class="number">3</span>, Number::New(isolate, <span class="number">1000</span>));</span><br><span class="line">    obj-&gt;Set(String::NewFromUtf8(isolate, <span class="string">"arg5"</span>), arr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Undefined 类型的声明</span></span><br><span class="line">    Local&lt;Value&gt; und = Undefined(isolate);</span><br><span class="line">    obj-&gt;Set(String::NewFromUtf8(isolate, <span class="string">"arg6"</span>), und);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// null 类型的声明</span></span><br><span class="line">    Local&lt;Value&gt; null = Null(isolate);</span><br><span class="line">    obj-&gt;Set(String::NewFromUtf8(isolate, <span class="string">"arg7"</span>), null);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回给 JavaScript 调用时的返回值</span></span><br><span class="line">    args.GetReturnValue().Set(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Local &lt;Object&gt; exports, Local&lt;Object&gt; module)</span> </span>&#123;</span><br><span class="line">    NODE_SET_METHOD(exports, <span class="string">"getTestValue"</span>, Test);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NODE_MODULE(returnValue, init)</span><br></pre></td></tr></table></figure>
<p>所有的 addon 都需要一个初始化的函数，如下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Initialize</span><span class="params">(Local&lt;Object&gt; exports)</span></span>;</span><br><span class="line">NODE_MODULE(module_name, Initialize)</span><br></pre></td></tr></table></figure>
<p><code>Initialize</code> 是初始化的函数，<code>module_name</code> 是编译后产生的二进制文件名，上述代码的模块名为 <code>returnValue</code>。</p>
<p>上述代码通过 node-gyp 编译后（编译过程官方文档 <a href="https://nodejs.org/dist/latest-v6.x/docs/api/addons.html" target="_blank" rel="external">C/C++ Addons</a> 有详细的介绍），可以通过如下的方式调用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// returnValue.node 这个文件就是编译后产生的文件，通过 NODE_MODULE(returnValue, init) 决定的文件名</span></span><br><span class="line"><span class="keyword">const</span> returnValue = <span class="built_in">require</span>(<span class="string">'./build/Release/returnValue.node'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(returnValue.getTestValue());</span><br></pre></td></tr></table></figure>
<p>运行结果如下:<br><img src="https://img.alicdn.com/tfs/TB1jb80NpXXXXXYaXXXXXXXXXXX-840-324.png" alt="returnValue"></p>
<h3 id="数据流向-javaScript-gt-C"><a href="#数据流向-javaScript-gt-C" class="headerlink" title="数据流向 javaScript -&gt; C++"></a>数据流向 javaScript -&gt; C++</h3><p>上面的 demo 展示了怎样在在 C++ 定义 JavaScript 类型，数据的是从 C++ 流向 JavaScript，反过来数据也需要从 javaScript 流向 C++，也就是调用 C++ 函数的时候需要传入一些参数。</p>
<p>下面的代码展示了参数个数判断，参数类型判断，以及参数类型装换成 V8 类型的过程，包括基本类型以及 Object, Array, Fuction。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;node.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;v8.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> v8;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetArgument</span><span class="params">(<span class="keyword">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">    Isolate* isolate = args.GetIsolate();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数长度判断</span></span><br><span class="line">    <span class="keyword">if</span> (args.Length() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        isolate-&gt;ThrowException(Exception::TypeError(</span><br><span class="line">            String::NewFromUtf8(isolate, <span class="string">"Wrong number of arguments"</span>)));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数类型判断</span></span><br><span class="line">    <span class="keyword">if</span> (!args[<span class="number">0</span>]-&gt;IsNumber() || !args[<span class="number">1</span>]-&gt;IsNumber()) &#123;</span><br><span class="line">        <span class="comment">//抛出错误</span></span><br><span class="line">        isolate-&gt;ThrowException(Exception::TypeError(</span><br><span class="line">            String::NewFromUtf8(isolate, <span class="string">"argumnets must be number"</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!args[<span class="number">0</span>]-&gt;IsObject()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I am not Object\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!args[<span class="number">0</span>]-&gt;IsBoolean()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I am not Boolean\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!args[<span class="number">0</span>]-&gt;IsArray()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I am not Array\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!args[<span class="number">0</span>]-&gt;IsString()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I am not String\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!args[<span class="number">0</span>]-&gt;IsFunction()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I am not Function\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!args[<span class="number">0</span>]-&gt;IsNull()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I am not Null\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!args[<span class="number">0</span>]-&gt;IsUndefined()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I am not Undefined\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// js Number 类型转换成 v8 Number 类型</span></span><br><span class="line">    Local&lt;Number&gt; value1 = Local&lt;Number&gt;::Cast(args[<span class="number">0</span>]);</span><br><span class="line">    Local&lt;Number&gt; value2 = Local&lt;Number&gt;::Cast(args[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">double</span> value = value1-&gt;NumberValue() + value2-&gt;NumberValue();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// js String 类型转换成 v8 String 类型</span></span><br><span class="line">    Local&lt;String&gt; str = Local&lt;String&gt;::Cast(args[<span class="number">2</span>]);</span><br><span class="line">    String::<span class="function">Utf8Value <span class="title">utfValue</span><span class="params">(str)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">string</span>(*utfValue)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// js Array 类型转换成 v8 Array 类型</span></span><br><span class="line">    Local&lt;Array&gt; input_array = Local&lt;Array&gt;::Cast(args[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d, %f %f\n"</span>, input_array-&gt;Length(), input_array-&gt;Get(<span class="number">0</span>)-&gt;NumberValue(), input_array-&gt;Get(<span class="number">1</span>)-&gt;NumberValue());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// js Object 类型转换成 v8 Object 类型</span></span><br><span class="line">    Local&lt;Object&gt; obj = Local&lt;Object&gt;::Cast(args[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 key 获取对象中的值</span></span><br><span class="line">    Local&lt;Value&gt; a = obj-&gt;Get(String::NewFromUtf8(isolate, <span class="string">"a"</span>));</span><br><span class="line">    Local&lt;Value&gt; b = obj-&gt;Get(String::NewFromUtf8(isolate, <span class="string">"b"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// js Array 类型转换成 v8 Array 类型</span></span><br><span class="line">    Local&lt;Array&gt; c = Local&lt;Array&gt;::Cast(obj-&gt;Get(String::NewFromUtf8(isolate, <span class="string">"c"</span>)));</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a-&gt;NumberValue()&lt;&lt;<span class="string">"   "</span>&lt;&lt;b-&gt;NumberValue()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d, %f %f\n"</span>, c-&gt;Length(), c-&gt;Get(<span class="number">0</span>)-&gt;NumberValue(), c-&gt;Get(<span class="number">1</span>)-&gt;NumberValue());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// js String 类型转换成 v8 String 类型</span></span><br><span class="line">    Local&lt;String&gt; cString = Local&lt;String&gt;::Cast(c-&gt;Get(<span class="number">2</span>));</span><br><span class="line">    String::<span class="function">Utf8Value <span class="title">utfValueD</span><span class="params">(cString)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">string</span>(*utfValueD)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 key 获取对象中的值</span></span><br><span class="line">    Local&lt;Object&gt; d = Local&lt;Object&gt;::Cast(obj-&gt;Get(String::NewFromUtf8(isolate, <span class="string">"d"</span>)));</span><br><span class="line">    Local&lt;String&gt; dString1 = Local&lt;String&gt;::Cast(d-&gt;Get(String::NewFromUtf8(isolate, <span class="string">"m"</span>)));</span><br><span class="line">    String::<span class="function">Utf8Value <span class="title">utfValued1</span><span class="params">(dString1)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">string</span>(*utfValued1)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 key 获取对象中的值</span></span><br><span class="line">    Local&lt;String&gt; dString2 = Local&lt;String&gt;::Cast(d-&gt;Get(String::NewFromUtf8(isolate, <span class="string">"n"</span>)));</span><br><span class="line">    String::<span class="function">Utf8Value <span class="title">utfValued2</span><span class="params">(dString2)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">string</span>(*utfValued2)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// js Booelan 类型转换成 v8 Boolean 类型</span></span><br><span class="line">    Local&lt;Boolean&gt; FlagTrue = Local&lt;Boolean&gt;::Cast(args[<span class="number">5</span>]);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Flag: "</span>&lt;&lt;FlagTrue-&gt;BooleanValue()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// js Function 类型转换成 v8 Function 类型</span></span><br><span class="line">    Local&lt;Function&gt; cb = Local&lt;Function&gt;::Cast(args[<span class="number">8</span>]);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> argc = <span class="number">2</span>;</span><br><span class="line">    Local&lt;Value&gt; argv[<span class="number">2</span>];</span><br><span class="line">    argv[<span class="number">0</span>] = a;</span><br><span class="line">    argv[<span class="number">1</span>] = b;</span><br><span class="line">    cb-&gt;Call(Null(isolate), argc, argv);</span><br><span class="line"></span><br><span class="line">    args.GetReturnValue().Set(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(Local &lt;Object&gt; exports, Local &lt;Object&gt; module)</span> </span>&#123;</span><br><span class="line">    NODE_SET_METHOD(module, <span class="string">"exports"</span>, GetArgument);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NODE_MODULE(argumentss, Init)</span><br></pre></td></tr></table></figure>
<p>通过 node-gyp 编译后，可以通过如下的方式调用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getArguments = <span class="built_in">require</span>(<span class="string">'./build/Release/arguments'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getArguments(<span class="number">2</span>, <span class="number">3</span>, <span class="string">'Hello Arguments'</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], &#123;</span><br><span class="line">        a: <span class="number">10</span>,</span><br><span class="line">        b: <span class="number">100</span>,</span><br><span class="line">        c: [<span class="number">23</span>, <span class="number">22</span>, <span class="string">"我是33"</span>],</span><br><span class="line">        d: &#123; m: <span class="string">'我是22'</span>, n: <span class="string">'我是23'</span> &#125;</span><br><span class="line">    &#125;, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">undefined</span>,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'I am Function!'</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(...args);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'I am Function!'</span>);</span><br><span class="line">    &#125;));</span><br></pre></td></tr></table></figure>
<p>运行结果如下:</p>
<p><img src="https://img.alicdn.com/tfs/TB11tB4NpXXXXaLXVXXXXXXXXXX-796-796.png" alt="argument"></p>
<p>关于其他的类型，我这里就就不一一介绍，V8 文档里面都有对应的 API。</p>
<h3 id="NAN"><a href="#NAN" class="headerlink" title="NAN"></a>NAN</h3><p>由于 V8 的 API 还没有彻底稳定下来，所以对于不同版本的 Node.js 类型相关的 API 会发生变化，而 <a href="https://github.com/nodejs/nan" target="_blank" rel="external">NAN</a> 帮我们做了封装，在编码的时候不需要关心版本问题，只需要引入相应的头文件即可。</p>
<p>引入头文件后，可以如下使用方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v8::Local&lt;v8::Primitive&gt; Nan::Undefined()</span><br><span class="line">v8::Local&lt;v8::Primitive&gt; Nan::Null()</span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="http://blog.scottfrees.com/type-conversions-from-javascript-to-c-in-v8" target="_blank" rel="external">Type conversions from JavaScript to C++ in V8</a></li>
<li><a href="https://nodejs.org/dist/latest-v6.x/docs/api/addons.html" target="_blank" rel="external">node addon</a></li>
<li><a href="https://v8docs.nodesource.com/node-6.0/d0/d4a/classv8_1_1_primitive.html" target="_blank" rel="external">v8 types documentation</a></li>
<li><a href="https://github.com/nodejs/node-gyp" target="_blank" rel="external">node-gyp</a></li>
<li><a href="https://gyp.gsrc.io/docs/UserDocumentation.md" target="_blank" rel="external">gyp user documentation</a></li>
<li><a href="https://github.com/nodejs/nan" target="_blank" rel="external">nan</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="//img.alicdn.com/tfs/TB1h_SoNpXXXXcMXXXXXXXXXXXX-900-500.jpg" alt="Node.js 和 C++ 之间的类型转换"></p>
<p>我非常喜欢使用 Node.js，但是当涉及到计算密集型的场]]>
    </summary>
    
      <category term="类型转换" scheme="http://taobaofed.org/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    
      <category term="addons" scheme="http://taobaofed.org/tags/addons/"/>
    
      <category term="Node.js" scheme="http://taobaofed.org/categories/Node-js/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[细说 webpack 之流程篇]]></title>
    <link href="http://taobaofed.org/blog/2016/09/09/webpack-flow/"/>
    <id>http://taobaofed.org/blog/2016/09/09/webpack-flow/</id>
    <published>2016-09-09T04:02:58.000Z</published>
    <updated>2016-10-12T02:02:15.000Z</updated>
    <content type="html"><![CDATA[<p><img src="//img.alicdn.com/tfs/TB1_ZnHNXXXXXXBXpXXXXXXXXXX-900-500.jpg" alt="细说 webpack 之流程篇"></p>
<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>目前，几乎所有业务的开发构建都会用到 webpack 。的确，作为模块加载和打包神器，只需配置几个文件，加载各种 loader 就可以享受无痛流程化开发。但对于 webpack 这样一个复杂度较高的插件集合，它的整体流程及思想对我们来说还是很透明的。那么接下来我会带你了解 webpack 这样一个构建黑盒，首先来谈谈它的流程。</p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h5 id="1-webstorm-中配置-webpack-webstorm-debugger-script"><a href="#1-webstorm-中配置-webpack-webstorm-debugger-script" class="headerlink" title="1. webstorm 中配置 webpack-webstorm-debugger-script"></a>1. webstorm 中配置 webpack-webstorm-debugger-script</h5><p>在开始了解之前，必须要能对 webpack 整个流程进行 debug ，配置过程比较简单。</p>
<p>先将 <a href="https://www.npmjs.com/package/webpack-webstorm-debugger-script" target="_blank" rel="external">webpack-webstorm-debugger-script</a> 中的 <code>webstorm-debugger.js</code> 置于 <code>webpack.config.js</code> 的同一目录下，搭建好你的脚手架后就可以直接 Debug 这个 webstorm-debugger.js 文件了。</p>
<h5 id="2-webpack-config-js-配置"><a href="#2-webpack-config-js-配置" class="headerlink" title="2. webpack.config.js 配置"></a>2. webpack.config.js 配置</h5><p>估计大家对 webpack.config.js 的配置也尝试过不少次了，这里就大致对这个配置文件进行个分析。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">var</span> node_modules = path.resolve(__dirname, <span class="string">'node_modules'</span>);</span><br><span class="line"><span class="keyword">var</span> pathToReact = path.resolve(node_modules, <span class="string">'react/dist/react.min.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 入口文件，是模块构建的起点，同时每一个入口文件对应最后生成的一个 chunk。</span></span><br><span class="line">  entry: &#123;</span><br><span class="line">    bundle: [</span><br><span class="line">      <span class="string">'webpack/hot/dev-server'</span>,</span><br><span class="line">      <span class="string">'webpack-dev-server/client?http://localhost:8080'</span>,</span><br><span class="line">      path.resolve(__dirname, <span class="string">'app/app.js'</span>)</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 文件路径指向(可加快打包过程)。</span></span><br><span class="line">  resolve: &#123;</span><br><span class="line">    alias: &#123;</span><br><span class="line">      <span class="string">'react'</span>: pathToReact</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 生成文件，是模块构建的终点，包括输出文件与输出路径。</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'build'</span>),</span><br><span class="line">    filename: <span class="string">'[name].js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 这里配置了处理各模块的 loader ，包括 css 预处理 loader ，es6 编译 loader，图片处理 loader。</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    loaders: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        loader: <span class="string">'babel'</span>,</span><br><span class="line">        query: &#123;</span><br><span class="line">          presets: [<span class="string">'es2015'</span>, <span class="string">'react'</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    noParse: [pathToReact]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// webpack 各插件对象，在 webpack 的事件流中执行对应的方法。</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>除此之外再大致介绍下 webpack 的一些核心概念：</p>
<ul>
<li>loader：能转换各类资源，并处理成对应模块的加载器。loader 间可以串行使用。</li>
<li>chunk：code splitting 后的产物，也就是按需加载的分块，装载了不同的 module。</li>
</ul>
<p>对于 module 和 chunk 的关系可以参照 webpack 官方的这张图：</p>
<p><img src="https://img.alicdn.com/tps/TB1B0DXNXXXXXXdXFXXXXXXXXXX-368-522.jpg" alt=""></p>
<ul>
<li><p>plugin：webpack 的插件实体，这里以 UglifyJsPlugin 为例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UglifyJsPlugin</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.options = options;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = UglifyJsPlugin;</span><br><span class="line"></span><br><span class="line">UglifyJsPlugin.prototype.apply = <span class="function"><span class="keyword">function</span>(<span class="params">compiler</span>) </span>&#123;</span><br><span class="line">  compiler.plugin(<span class="string">"compilation"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">compilation</span>) </span>&#123;</span><br><span class="line">    compilation.plugin(<span class="string">"build-module"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">module</span>) </span>&#123;</span><br><span class="line">    &#125;);</span><br><span class="line">    compilation.plugin(<span class="string">"optimize-chunk-assets"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunks, callback</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// Uglify 逻辑</span></span><br><span class="line">    &#125;);</span><br><span class="line">    compilation.plugin(<span class="string">"normal-module-loader"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在 webpack 中你经常可以看到 compilation.plugin(‘xxx’, callback) ，你可以把它当作是一个事件的绑定，这些事件在打包时由 webpack 来触发。</p>
</li>
</ul>
<h5 id="3-流程总览"><a href="#3-流程总览" class="headerlink" title="3. 流程总览"></a>3. 流程总览</h5><p>在具体流程学习前，可以先通过这幅 <a href="https://img.alicdn.com/tps/TB1GVGFNXXXXXaTapXXXXXXXXXX-4436-4244.jpg" target="_blank" rel="external">webpack 整体流程图</a> 了解一下大致流程（建议保存下来查看）。</p>
<p><img src="https://img.alicdn.com/tps/TB1GVGFNXXXXXaTapXXXXXXXXXX-4436-4244.jpg" alt=""></p>
<h3 id="shell-与-config-解析"><a href="#shell-与-config-解析" class="headerlink" title="shell 与 config 解析"></a>shell 与 config 解析</h3><p>每次在命令行输入 webpack 后，操作系统都会去调用 <code>./node_modules/.bin/webpack</code> 这个 shell 脚本。这个脚本会去调用 <code>./node_modules/webpack/bin/webpack.js</code> 并追加输入的参数，如 -p , -w 。(图中 webpack.js 是 webpack 的启动文件，而 $@ 是后缀参数)</p>
<p><img src="https://img.alicdn.com/tps/TB1kvfbNXXXXXarXpXXXXXXXXXX-500-111.jpg" alt=""></p>
<p>在 webpack.js 这个文件中 webpack 通过 optimist 将用户配置的 webpack.config.js 和 shell 脚本传过来的参数整合成 options 对象传到了下一个流程的控制对象中。</p>
<h5 id="1-optimist"><a href="#1-optimist" class="headerlink" title="1. optimist"></a>1. optimist</h5><p>和 commander 一样，<a href="https://github.com/substack/node-optimist" target="_blank" rel="external">optimist</a> 实现了 node 命令行的解析，其 API 调用非常方便。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> optimist = <span class="built_in">require</span>(<span class="string">"optimist"</span>);</span><br><span class="line"></span><br><span class="line">optimist</span><br><span class="line">  .boolean(<span class="string">"json"</span>).alias(<span class="string">"json"</span>, <span class="string">"j"</span>).describe(<span class="string">"json"</span>)</span><br><span class="line">  .boolean(<span class="string">"colors"</span>).alias(<span class="string">"colors"</span>, <span class="string">"c"</span>).describe(<span class="string">"colors"</span>)</span><br><span class="line">  .boolean(<span class="string">"watch"</span>).alias(<span class="string">"watch"</span>, <span class="string">"w"</span>).describe(<span class="string">"watch"</span>)</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>获取到后缀参数后，optimist 分析参数并以键值对的形式把参数对象保存在 optimist.argv 中，来看看 argv 究竟有什么？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// webpack --hot -w</span><br><span class="line">&#123;</span><br><span class="line">  hot: true,</span><br><span class="line">  profile: false,</span><br><span class="line">  watch: true,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-config-合并与插件加载"><a href="#2-config-合并与插件加载" class="headerlink" title="2. config 合并与插件加载"></a>2. config 合并与插件加载</h5><p>在加载插件之前，webpack 将 webpack.config.js 中的各个配置项拷贝到 options 对象中，并加载用户配置在 webpack.config.js 的 plugins 。接着 optimist.argv 会被传入到 <code>./node_modules/webpack/bin/convert-argv.js</code> 中，通过判断 argv 中参数的值决定是否去加载对应插件。(至于 webpack 插件运行机制，在之后的运行机制篇会提到)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ifBooleanArg(<span class="string">"hot"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ensureArray(options, <span class="string">"plugins"</span>);</span><br><span class="line">  <span class="keyword">var</span> HotModuleReplacementPlugin = <span class="built_in">require</span>(<span class="string">"../lib/HotModuleReplacementPlugin"</span>);</span><br><span class="line">  options.plugins.push(<span class="keyword">new</span> HotModuleReplacementPlugin());</span><br><span class="line">&#125;);</span><br><span class="line">...</span><br><span class="line">return options;</span><br></pre></td></tr></table></figure>
<p><code>options</code> 作为最后返回结果，包含了之后构建阶段所需的重要信息。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  entry: &#123;&#125;,//入口配置</span><br><span class="line">  output: &#123;&#125;, //输出配置</span><br><span class="line">  plugins: [], //插件集合(配置文件 + shell指令) </span><br><span class="line">  module: &#123; loaders: [ [Object] ] &#125;, //模块配置</span><br><span class="line">  context: //工程路径</span><br><span class="line">  ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这和 webpack.config.js 的配置非常相似，只是多了一些经 shell 传入的插件对象。插件对象一初始化完毕， options 也就传入到了下个流程中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">"../lib/webpack.js"</span>);</span><br><span class="line"><span class="keyword">var</span> compiler = webpack(options);</span><br></pre></td></tr></table></figure>
<h3 id="编译与构建流程"><a href="#编译与构建流程" class="headerlink" title="编译与构建流程"></a>编译与构建流程</h3><p>在加载配置文件和 shell 后缀参数申明的插件，并传入构建信息 options 对象后，开始整个 webpack 打包最漫长的一步。而这个时候，真正的 webpack 对象才刚被初始化，具体的初始化逻辑在 <code>lib/webpack.js</code> 中，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">webpack</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> compiler = <span class="keyword">new</span> Compiler();</span><br><span class="line">  ...<span class="comment">// 检查options,若watch字段为true,则开启watch线程</span></span><br><span class="line">  <span class="keyword">return</span> compiler;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>webpack 的实际入口是 Compiler 中的 run 方法，run 一旦执行后，就开始了编译和构建流程 ，其中有几个比较关键的 webpack 事件节点。</p>
<ul>
<li><code>compile</code>    开始编译</li>
<li><code>make</code>    从入口点分析模块及其依赖的模块，创建这些模块对象</li>
<li><code>build-module</code>    构建模块</li>
<li><code>after-compile</code>     完成构建</li>
<li><code>seal</code>     封装构建结果</li>
<li><code>emit</code>     把各个chunk输出到结果文件</li>
<li><code>after-emit</code>     完成输出</li>
</ul>
<h5 id="1-核心对象-Compilation"><a href="#1-核心对象-Compilation" class="headerlink" title="1. 核心对象 Compilation"></a>1. 核心对象 Compilation</h5><p>compiler.run 后首先会触发 compile ，这一步会构建出 Compilation 对象：</p>
<p><img src="https://img.alicdn.com/tps/TB1UgS4NXXXXXXZXVXXXXXXXXXX-693-940.png" alt="compilation类图"></p>
<p>这个对象有两个作用，一是负责组织整个打包过程，包含了每个构建环节及输出环节所对应的方法，可以从图中看到比较关键的步骤，如 <code>addEntry()</code> ,  <code>_addModuleChain()</code> ,  <code>buildModule()</code> ,  <code>seal()</code> ,  <code>createChunkAssets()</code>  (在每一个节点都会触发 webpack 事件去调用各插件)。二是该对象内部存放着所有 module ，chunk，生成的 asset 以及用来生成最后打包文件的 template 的信息。</p>
<h5 id="2-编译与构建主流程"><a href="#2-编译与构建主流程" class="headerlink" title="2. 编译与构建主流程"></a>2. 编译与构建主流程</h5><p>在创建 module 之前，Compiler 会触发 make，并调用 <code>Compilation.addEntry</code> 方法，通过 options 对象的 entry 字段找到我们的入口js文件。之后，在 addEntry 中调用私有方法 <code>_addModuleChain</code> ，这个方法主要做了两件事情。一是根据模块的类型获取对应的模块工厂并创建模块，二是构建模块。</p>
<p>而构建模块作为最耗时的一步，又可细化为三步：</p>
<ul>
<li><p>调用各 loader 处理模块之间的依赖</p>
<p>webpack 提供的一个很大的便利就是能将所有资源都整合成模块，不仅仅是 js 文件。所以需要一些 loader ，比如 <code>url-loader</code> ， <code>jsx-loader</code> ， <code>css-loader</code> 等等来让我们可以直接在源文件中引用各类资源。webpack 调用 <code>doBuild()</code> ，对每一个 require() 用对应的 loader 进行加工，最后生成一个 js module。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Compilation.prototype._addModuleChain = <span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">context, dependency, onModule, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> start = <span class="keyword">this</span>.profile &amp;&amp; +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 根据模块的类型获取对应的模块工厂并创建模块</span></span><br><span class="line">  <span class="keyword">var</span> moduleFactory = <span class="keyword">this</span>.dependencyFactories.get(dependency.constructor);</span><br><span class="line">  ...</span><br><span class="line">  moduleFactory.create(context, dependency, <span class="function"><span class="keyword">function</span>(<span class="params">err, module</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">this</span>.addModule(<span class="built_in">module</span>);</span><br><span class="line">    ...</span><br><span class="line">    this.buildModule(<span class="built_in">module</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">// 构建模块，添加依赖模块</span></span><br><span class="line">    &#125;.bind(<span class="keyword">this</span>));</span><br><span class="line">  &#125;.bind(<span class="keyword">this</span>));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用 <a href="https://github.com/ternjs/acorn" target="_blank" rel="external">acorn</a> 解析经 loader 处理后的源文件生成抽象语法树 AST</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> Parser.prototype.parse = <span class="function"><span class="keyword">function</span> <span class="title">parse</span>(<span class="params">source, initialState</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ast;</span><br><span class="line">  <span class="keyword">if</span> (!ast) &#123;</span><br><span class="line">    <span class="comment">// acorn以es6的语法进行解析</span></span><br><span class="line">    ast = acorn.parse(source, &#123;</span><br><span class="line">      ranges: <span class="literal">true</span>,</span><br><span class="line">      locations: <span class="literal">true</span>,</span><br><span class="line">      ecmaVersion: <span class="number">6</span>,</span><br><span class="line">      sourceType: <span class="string">"module"</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历 AST，构建该模块所依赖的模块</p>
<p>对于当前模块，或许存在着多个依赖模块。当前模块会开辟一个依赖模块的数组，在遍历 AST 时，将 require() 中的模块通过 <code>addDependency()</code> 添加到数组中。当前模块构建完成后，webpack 调用 <code>processModuleDependencies</code> 开始递归处理依赖的 module，接着就会重复之前的构建步骤。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> Compilation.prototype.addModuleDependencies = <span class="function"><span class="keyword">function</span>(<span class="params">module, dependencies, bail, cacheGroup, recursive, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 根据依赖数组(dependencies)创建依赖模块对象</span></span><br><span class="line">  <span class="keyword">var</span> factories = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; dependencies.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> factory = _this.dependencyFactories.get(dependencies[i][<span class="number">0</span>].constructor);</span><br><span class="line">    factories[i] = [factory, dependencies[i]];</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 与当前模块构建步骤相同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="3-构建细节"><a href="#3-构建细节" class="headerlink" title="3. 构建细节"></a>3. 构建细节</h5><p>module 是 webpack 构建的核心实体，也是所有 module 的 父类，它有几种不同子类：<code>NormalModule</code> ,  <code>MultiModule</code> ,  <code>ContextModule</code> , <code>DelegatedModule</code>  等。但这些核心实体都是在构建中都会去调用对应方法，也就是 <code>build()</code> 。来看看其中具体做了什么：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化module信息，如context,id,chunks,dependencies等。</span></span><br><span class="line">NormalModule.prototype.build = <span class="function"><span class="keyword">function</span> <span class="title">build</span>(<span class="params">options, compilation, resolver, fs, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.buildTimestamp = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime(); <span class="comment">// 构建计时</span></span><br><span class="line">  <span class="keyword">this</span>.built = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.doBuild(options, compilation, resolver, fs, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 指定模块引用，不经acorn解析</span></span><br><span class="line">    <span class="keyword">if</span> (options.module &amp;&amp; options.module.noParse) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(options.module.noParse)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (options.module.noParse.some(<span class="function"><span class="keyword">function</span>(<span class="params">regExp</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">typeof</span> regExp === <span class="string">"string"</span> ?</span><br><span class="line">            <span class="keyword">this</span>.request.indexOf(regExp) === <span class="number">0</span> :</span><br><span class="line">              regExp.test(<span class="keyword">this</span>.request);</span><br><span class="line">          &#125;, <span class="keyword">this</span>)) &#123;</span><br><span class="line">          <span class="keyword">return</span> callback();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> options.module.noParse === <span class="string">"string"</span> ?</span><br><span class="line">        <span class="keyword">this</span>.request.indexOf(options.module.noParse) === <span class="number">0</span> :</span><br><span class="line">          options.module.noParse.test(<span class="keyword">this</span>.request)) &#123;</span><br><span class="line">        <span class="keyword">return</span> callback();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 由acorn解析生成ast</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.parser.parse(<span class="keyword">this</span>._source.source(), &#123;</span><br><span class="line">        current: <span class="keyword">this</span>,</span><br><span class="line">        <span class="built_in">module</span>: <span class="keyword">this</span>,</span><br><span class="line">        compilation: compilation,</span><br><span class="line">        options: options</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">var</span> source = <span class="keyword">this</span>._source.source();</span><br><span class="line">      <span class="keyword">this</span>._source = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">return</span> callback(<span class="keyword">new</span> ModuleParseError(<span class="keyword">this</span>, source, e));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> callback();</span><br><span class="line">  &#125;.bind(<span class="keyword">this</span>));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于每一个 module ，它都会有这样一个构建方法。当然，它还包括了从构建到输出的一系列的有关 module 生命周期的函数，我们通过 module 父类类图其子类类图(这里以 NormalModule 为例)来观察其真实形态：</p>
<p><img src="https://img.alicdn.com/tps/TB1WOiRNXXXXXcJaXXXXXXXXXXX-445-1228.png" alt="module类图"></p>
<p>可以看到无论是构建流程，处理依赖流程，包括后面的封装流程都是与 module 密切相关的。</p>
<h3 id="打包输出"><a href="#打包输出" class="headerlink" title="打包输出"></a>打包输出</h3><p>在所有模块及其依赖模块 build 完成后，webpack 会监听 <code>seal</code> 事件调用各插件对构建后的结果进行封装，要逐次对每个 module 和 chunk 进行整理，生成编译后的源码，合并，拆分，生成 hash 。 同时这是我们在开发时进行代码优化和功能添加的关键环节。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Compilation.prototype.seal = <span class="function"><span class="keyword">function</span> <span class="title">seal</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.applyPlugins(<span class="string">"seal"</span>); <span class="comment">// 触发插件的seal事件</span></span><br><span class="line">  <span class="keyword">this</span>.preparedChunks.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.name &lt; b.name) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a.name &gt; b.name) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">this</span>.preparedChunks.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">preparedChunk</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">module</span> = preparedChunk.module;</span><br><span class="line">    <span class="keyword">var</span> chunk = <span class="keyword">this</span>.addChunk(preparedChunk.name, <span class="built_in">module</span>);</span><br><span class="line">    chunk.initial = chunk.entry = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 整理每个Module和chunk，每个chunk对应一个输出文件。</span></span><br><span class="line">    chunk.addModule(<span class="built_in">module</span>);</span><br><span class="line">    <span class="built_in">module</span>.addChunk(chunk);</span><br><span class="line">  &#125;, <span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.applyPluginsAsync(<span class="string">"optimize-tree"</span>, <span class="keyword">this</span>.chunks, <span class="keyword">this</span>.modules, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span> callback(err);</span><br><span class="line">    &#125;</span><br><span class="line">    ... <span class="comment">// 触发插件的事件</span></span><br><span class="line">    <span class="keyword">this</span>.createChunkAssets(); <span class="comment">// 生成最终assets</span></span><br><span class="line">    ... <span class="comment">// 触发插件的事件</span></span><br><span class="line">  &#125;.bind(<span class="keyword">this</span>));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="1-生成最终-assets"><a href="#1-生成最终-assets" class="headerlink" title="1. 生成最终 assets"></a>1. 生成最终 assets</h5><p>在封装过程中，webpack 会调用 Compilation 中的 <code>createChunkAssets</code> 方法进行打包后代码的生成。 createChunkAssets 流程如下：</p>
<p><img src="https://img.alicdn.com/tps/TB1cz5.NXXXXXc7XpXXXXXXXXXX-959-807.png" alt="createChunkAssets流程"></p>
<ul>
<li><p>不同的 Template</p>
<p>从上图可以看出通过判断是入口 js 还是需要异步加载的 js 来选择不同的模板对象进行封装，入口 js 会采用 webpack 事件流的 render 事件来触发 <code>Template类</code> 中的 <code>renderChunkModules()</code> (异步加载的 js 会调用 chunkTemplate 中的 render 方法)。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(chunk.entry) &#123;</span><br><span class="line">  source = <span class="keyword">this</span>.mainTemplate.render(<span class="keyword">this</span>.hash, chunk, <span class="keyword">this</span>.moduleTemplate, <span class="keyword">this</span>.dependencyTemplates);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  source = <span class="keyword">this</span>.chunkTemplate.render(chunk, <span class="keyword">this</span>.moduleTemplate, <span class="keyword">this</span>.dependencyTemplates);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 webpack 中有四个 Template 的子类，分别是 <code>MainTemplate.js</code>  ， <code>ChunkTemplate.js</code> ，<code>ModuleTemplate.js</code> ， <code>HotUpdateChunkTemplate.js</code> ，前两者先前已大致有介绍，而 ModuleTemplate 是对所有模块进行一个代码生成，HotUpdateChunkTemplate 是对热替换模块的一个处理。</p>
</li>
<li><p>模块封装</p>
<p>模块在封装的时候和它在构建时一样，都是调用各模块类中的方法。封装通过调用 <code>module.source()</code> 来进行各操作，比如说 require() 的替换。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MainTemplate.prototype.requireFn = <span class="string">"__webpack_require__"</span>;</span><br><span class="line">MainTemplate.prototype.render = <span class="function"><span class="keyword">function</span>(<span class="params">hash, chunk, moduleTemplate, dependencyTemplates</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> buf = [];</span><br><span class="line">    <span class="comment">// 每一个module都有一个moduleId,在最后会替换。</span></span><br><span class="line">    buf.push(<span class="string">"function "</span> + <span class="keyword">this</span>.requireFn + <span class="string">"(moduleId) &#123;"</span>);</span><br><span class="line">    buf.push(<span class="keyword">this</span>.indent(<span class="keyword">this</span>.applyPluginsWaterfall(<span class="string">"require"</span>, <span class="string">""</span>, chunk, hash)));</span><br><span class="line">    buf.push(<span class="string">"&#125;"</span>);</span><br><span class="line">    buf.push(<span class="string">""</span>);</span><br><span class="line">    ... <span class="comment">// 其余封装操作</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成 assets</p>
<p>各模块进行 doBlock 后，把 module 的最终代码循环添加到 source 中。一个 source 对应着一个 asset 对象，该对象保存了单个文件的文件名( name )和最终代码( value )。</p>
</li>
</ul>
<h5 id="2-输出"><a href="#2-输出" class="headerlink" title="2. 输出"></a>2. 输出</h5><p>最后一步，webpack 调用 Compiler 中的 <code>emitAssets()</code> ，按照 output 中的配置项将文件输出到了对应的 path 中，从而 webpack 整个打包过程结束。要注意的是，若想对结果进行处理，则需要在 <code>emit</code> 触发后对自定义插件进行扩展。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>webpack 的整体流程主要还是依赖于 <code>compilation</code> 和 <code>module</code> 这两个对象，但其思想远不止这么简单。最开始也说过，webpack 本质是个插件集合，并且由 <code>tapable</code> 控制各插件在 webpack 事件流上运行，至于具体的思想和细节，将会在后一篇文章中提到。同时，在业务开发中，无论是为了提升构建效率，或是减小打包文件大小，我们都可以通过编写 webpack 插件来进行流程上的控制，这个也会在之后提到。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="//img.alicdn.com/tfs/TB1_ZnHNXXXXXXBXpXXXXXXXXXX-900-500.jpg" alt="细说 webpack 之流程篇"></p>
<h3 id="引言"><a href="#引言" class="heade]]>
    </summary>
    
      <category term="webpack" scheme="http://taobaofed.org/tags/webpack/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[React 实践心得：key 属性的原理和用法]]></title>
    <link href="http://taobaofed.org/blog/2016/08/24/react-key/"/>
    <id>http://taobaofed.org/blog/2016/08/24/react-key/</id>
    <published>2016-08-24T11:38:35.000Z</published>
    <updated>2016-10-12T02:02:15.000Z</updated>
    <content type="html"><![CDATA[<p><img src="//img.alicdn.com/tfs/TB1sJ2wMVXXXXbyaXXXXXXXXXXX-900-500.jpg" alt="React 实践心得：key 属性的原理和用法"></p>
<p>我们知道，React 元素可以具有一个特殊的属性 key，这个属性不是给用户自己用的，而是给 React 自己用的。如果我们动态地创建 React 元素，而且 React 元素内包含数量或顺序不确定的子元素时，我们就需要提供 key 这个特殊的属性。</p>
<p>如果你有下面这样的代码：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> UserList = props =&gt; (</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>用户列表<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    &#123;props.users.map(u =&gt; <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;u.id&#125;:&#123;u.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>)&#125;  // 没有提供 key</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>React 会在控制台打印出报警信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Warning: Each child <span class="keyword">in</span> an array or iterator should have a unique <span class="string">"key"</span> prop. Check the render method of `App`. See https://fb.me/react-warning-keys <span class="keyword">for</span> more information.</span><br></pre></td></tr></table></figure></p>
<p>你必须为数组中的元素提供唯一的 <code>key</code> 属性，就像下面这样：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> UserList = props =&gt; (</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>用户列表<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    &#123;props.users.map(u =&gt; <span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&#123;u.id&#125;</span>&gt;</span>&#123;u.id&#125;:&#123;u.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>)&#125;  // 提供了 key</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>为什么呢？我们知道当组件的属性发生了变化，其 render 方法会被重新调用，组件会被重新渲染。比如 UserList 组件的 users 属性改变了，就得重新渲染 UserList 组件，包括外部的 <code>&lt;div&gt;</code>（容器），内部的一个 <code>&lt;h3&gt;</code> 和若干个 <code>&lt;div&gt;</code>（每一个描述一个用户）。</p>
<p>对后一种 <code>&lt;div&gt;</code>（表示用户的），由于其处在一个长度不确定的数组中，React 需要判断，对数组中的每一项，到底是新建一个元素加入到页面中，还是更新原来的元素。比如以下几种情况：</p>
<ul>
<li><code>[{name: &#39;张三&#39;, age: 20}]</code> =&gt; <code>[{name: &#39;张三&#39;, age: 21}]</code>：这种情况明显只需要更新元素，没有必要重新创建元素。因为人还是那个人，除了 age，其他信息没有变，显示用户姓名的那个（更小的）元素，是不需要更新（被 ReactDOM 操作到）的。</li>
<li><code>[{name: &#39;张三&#39;}]</code> =&gt; <code>[{name: &#39;张三&#39;}, {name: &#39;李四&#39;}]</code> 这种情况，显然需要添加一个新元素来表示李四，这个新元素对应的 DOM 元素会被插入到页面中。</li>
<li><code>[{name: &#39;张三&#39;}]</code> =&gt; <code>[{name: &#39;李四&#39;}]</code>：这种情况就有点复杂了，似乎两种方案都可以。可以把表示张三的元素删掉，为李四新建一个，当然是非常合理的选择。但是直接把张三的元素换成李四，似乎也无不可。</li>
</ul>
<p>实际上，如果真的认为上述第3种的后一种方案也无不可，那可是大错特错了。为什么呢：</p>
<ul>
<li>考虑这种情况：<code>[{name: &#39;张三&#39;}, {name: &#39;李四&#39;}]</code> =&gt; <code>[{name: &#39;李四&#39;}, {name: &#39;张三&#39;}]</code>，难道也需要把张三的元素更新成李四的，李四的元素更新成张三的吗？</li>
</ul>
<p>那么，为数组中的元素传一个唯一的 key（比如用户的 ID），就很好地解决了这个问题。React 比较更新前后的元素 key 值，如果相同则更新，如果不同则销毁之前的，重新创建一个元素。</p>
<p>那么，为什么只有数组中的元素需要有唯一的 key，而其他的元素（比如上面的<code>&lt;h3&gt;用户列表&lt;/h3&gt;</code>）则不需要呢？答案是：React 有能力辨别出，更新前后元素的对应关系。这一点，也许直接看 JSX 不够明显，看 Babel 转换后的 React.createElement 则清晰很多：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转换前</span></span><br><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>example<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    &#123;[<span class="tag">&lt;<span class="name">p</span> <span class="attr">key</span>=<span class="string">&#123;1&#125;</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span>, <span class="tag">&lt;<span class="name">p</span> <span class="attr">key</span>=<span class="string">&#123;2&#125;</span>&gt;</span>world<span class="tag">&lt;/<span class="name">p</span>&gt;</span>]&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换后</span></span><br><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> element = React.createElement(</span><br><span class="line">  <span class="string">"div"</span>,</span><br><span class="line">  <span class="literal">null</span>,</span><br><span class="line">  React.createElement(<span class="string">"h3"</span>,<span class="literal">null</span>,<span class="string">"example"</span>),</span><br><span class="line">  [</span><br><span class="line">    React.createElement(<span class="string">"p"</span>,&#123; key: <span class="number">1</span> &#125;,<span class="string">"hello"</span>), </span><br><span class="line">    React.createElement(<span class="string">"p"</span>,&#123; key: <span class="number">2</span> &#125;,<span class="string">"world"</span>)</span><br><span class="line">  ]</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>不管 props 如何变化，数组外的每个元素始终出现在 React.createElement() 参数列表中的固定位置，这个位置就是天然的 key。</p>
<blockquote>
<p>题外话</p>
<p>初学 React 时还容易产生另一个困惑，那就是为什么 JSX 不支持 if 表达式来有选择地输出（不能这样：<code>{if(yes){ &lt;div {...props}/&gt; }}</code>），而必须采用三元运算符来完成这项工作（必须这样：<code>{yes ? &lt;div {...props}/&gt;} : null</code>）。那是因为，React 需要一个 null 去占住那个元素本来的位置。</p>
</blockquote>
<p>曾经，我天真的以为 <code>key</code> 这个元素只应在数组中使用。直到我在一个复杂的项目中写出了及其恶心的 <code>componentWillReceiveProps</code>方法。我尝试寻找销毁和重建组件，触发 <code>componentDidMount</code> 方法，重置 <code>state</code>，然后才突然发现 <code>key</code> 这个属性已经在那里了。</p>
<p>举个例子，我们有一个展示用户信息的 <code>UserDashboard</code> 组件。传给组件的 <code>props</code> 只有用户的 基本信息（ID，姓名等），而有关用户的详细信息（比如当前是否在线等）是需要请求过来的。组件内的一些操作（比如尝试与该用户聊天）也会使用请求，组件本身也有各种状态（比如是否显示聊天框）。</p>
<p>整个界面上最多只有一个 <code>UserDashboard</code>，但某些操作（比如点击旁边的 <code>UserList</code>）可能会切换 <code>UserDashboard</code> 的目标用户，那么问题就来了：当目标用户切换的时候，<code>UserDashboard</code> 仅仅是一个普通的<strong>更新</strong>操作，触发的是 <code>componentWillReceiveProps</code>，<code>shouldComponentUpdate</code>，<code>componentWillUpdate</code>，<code>componentDidUpdate</code> 这一套方法。我们需要在 <code>componentWillReceiveProps</code> 中做太多的事情：检测这次 props 的更新是否改变了用户的 ID，如果是的话，我们需要检查 <code>UserDashboard</code> 发出去的请求是否都得到了响应，对还未收到响应的请求注销其响应函数（否则上一个用户的在线状态有可能显示在这一个用户上）；我们还要更新 <code>UserDashboard</code> 上的几乎所有状态（切换用户的时候总要把聊天框关闭吧）；如果我们还不幸地用的 <code>ref</code> 做了一些神奇的 hack，那么你还要去手动把之前做的事情复原回来，这简直要成一团乱麻了！当 <code>UserDashborad</code> 的逻辑，你的 <code>componentWillReceiveProps</code> 方法里会充斥着晦涩难懂的只有你能看懂的代码（两周后你自己也看不懂了）。</p>
<p>解决方案是什么？就是用 <code>key</code> 属性。在 JSX 中使用 <code>UserDashboard</code> 的时候，不仅把 <code>userInfo</code> 传入，把 <code>userInfo.id</code> 作为名为 <code>key</code> 的 <code>props</code> 传入（尽管 <code>UserDashboard</code> 不是数组中的组件）。这样切换目标用户的时候，<code>key</code> 属性也变了，React 会自动销毁之前的组件，用一个全新的组件来渲染新的用户：我们可以从容地在 <code>componentWillUnmount</code> 里作清理工作（注销请求的响应函数，防止其更新一个 unmounted component），至于重置 <code>state</code> 这些工作已经不需要做了，由于组件不再是更新，而是销毁和重建，已经是天然完成的。</p>
<p>当然，你可以质疑这样做是否会影响性能。我认为，只要目标用户的切换不够频繁，对性能的影响是很小的。如果不使用 <code>key</code> 触发组件的销毁和重建，任由组件自行「更新」，每次切换时更新的内容也是很多的。这时，我们使用 <code>key</code> 带来的性能损耗是完全可以接受的，而带来的收益却非常大。</p>
<p>所以，我想说的结论是：为了组件内部逻辑的清晰，你几乎应该在任何复杂的有状态组件（尤其是有具体<strong>对应</strong>对象的）上使用<code>key</code>属性（只要 <code>key</code> 属性的改变不是很频繁），这样做，才能在合适的时候触发组件的销毁与重建，组件才能有一个健康的生命周期。</p>
<blockquote>
<p>题外话</p>
<p>配合 react-router 时，通常要为 route 组件赋 key，但通常情况下我们是没法传 props 给 route 组件的。解决的方案是 <code>createElement</code> 方法，如下所示。</p>
</blockquote>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">class App extends Component </span><span class="template-variable">&#123;</span><br><span class="line">  static createElement = (Component, ownProps) =&gt; &#123;</span><br><span class="line">    const &#123;userId&#125;</span><span class="xml"> = ownProps.params;</span><br><span class="line">    switch (Component) </span><span class="template-variable">&#123;</span><br><span class="line">      case UserDashboard:</span><br><span class="line">        return &lt;Component key=&#123;userId&#125;</span><span class="xml"> </span><span class="template-variable">&#123;...ownProps&#125;</span><span class="xml">/&gt;;</span><br><span class="line">      default:</span><br><span class="line">        return <span class="tag">&lt;<span class="name">Component</span> </span></span><span class="template-variable">&#123;...ownProps&#125;</span><span class="xml"><span class="tag">/&gt;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  render() </span><span class="template-variable">&#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;Provider store=&#123;store&#125;</span><span class="xml">&gt;</span><br><span class="line">        <span class="tag">&lt;<span class="name">Router</span> <span class="attr">createElement</span>=</span></span><span class="template-variable">&#123;App.createElement&#125;</span><span class="xml"><span class="tag"> </span><br><span class="line">                <span class="attr">history</span>=</span></span><span class="template-variable">&#123;syncHistoryWithStore(hashHistory, store)&#125;</span><span class="xml"><span class="tag">&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">"/"</span> <span class="attr">component</span>=</span></span><span class="template-variable">&#123;Home&#125;</span><span class="xml"><span class="tag">&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">IndexRoute</span> <span class="attr">component</span>=</span></span><span class="template-variable">&#123;Index&#125;</span><span class="xml"><span class="tag">/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">"users/:userId"</span> <span class="attr">component</span>=</span></span><span class="template-variable">&#123;UserDashboard&#125;</span><span class="xml"><span class="tag">/&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Router</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>（完）</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="//img.alicdn.com/tfs/TB1sJ2wMVXXXXbyaXXXXXXXXXXX-900-500.jpg" alt="React 实践心得：key 属性的原理和用法"></p>
<p>我们知道，React 元素可以具有一个特殊的属性 ke]]>
    </summary>
    
      <category term="React" scheme="http://taobaofed.org/tags/React/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[React 实践心得：react-redux 之 connect 方法详解]]></title>
    <link href="http://taobaofed.org/blog/2016/08/18/react-redux-connect/"/>
    <id>http://taobaofed.org/blog/2016/08/18/react-redux-connect/</id>
    <published>2016-08-18T07:15:12.000Z</published>
    <updated>2016-10-12T02:02:15.000Z</updated>
    <content type="html"><![CDATA[<p><img src="//img.alicdn.com/tfs/TB1fYYeLpXXXXbtXFXXXXXXXXXX-900-500.jpg" alt="React 实践心得：react-redux 之 connect 方法详解"></p>
<p>Redux 是「React 全家桶」中极为重要的一员，它试图为 React 应用提供「可预测化的状态管理」机制。Redux 本身足够简单，除了 React，它还能够支持其他界面框架。所以如果要将 Redux 和 React 结合起来使用，就还需要一些额外的工具，其中最重要的莫过于 react-redux 了。</p>
<p>react-redux 提供了两个重要的对象，<code>Provider</code> 和 <code>connect</code>，前者使 React 组件可被连接（connectable），后者把 React 组件和 Redux 的 store 真正连接起来。react-redux 的文档中，对 <code>connect</code> 的描述是一段晦涩难懂的英文，在初学 redux 的时候，我对着这段文档阅读了很久，都没有全部弄明白其中的意思（大概就是，单词我都认识，连起来啥意思就不明白了的感觉吧）。</p>
<p>在使用了一段时间 redux 后，本文尝试再次回到这里，给<a href="https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options" target="_blank" rel="external">这段文档</a>（同时摘抄在附录中）一个靠谱的解读。</p>
<h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>首先回顾一下 redux 的基本用法。如果你还没有阅读过 redux 的文档，你一定要先去<a href="https://github.com/reactjs/redux/blob/master/docs/README.md" target="_blank" rel="external">阅读一下</a>。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reducer = (state = &#123;count: <span class="number">0</span>&#125;, action) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'INCREASE'</span>: <span class="keyword">return</span> &#123;count: state.count + <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'DECREASE'</span>: <span class="keyword">return</span> &#123;count: state.count - <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">  increase: () =&gt; (&#123;type: <span class="string">'INCREASE'</span>&#125;),</span><br><span class="line">  decrease: () =&gt; (&#123;type: <span class="string">'DECREASE'</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer);</span><br><span class="line"></span><br><span class="line">store.subscribe(() =&gt;</span><br><span class="line">  <span class="built_in">console</span>.log(store.getState())</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">store.dispatch(actions.increase()) <span class="comment">// &#123;count: 1&#125;</span></span><br><span class="line">store.dispatch(actions.increase()) <span class="comment">// &#123;count: 2&#125;</span></span><br><span class="line">store.dispatch(actions.increase()) <span class="comment">// &#123;count: 3&#125;</span></span><br></pre></td></tr></table></figure>
<p>通过 <code>reducer</code> 创建一个 <code>store</code>，每当我们在 <code>store</code> 上 <code>dispatch</code> 一个 <code>action</code>，<code>store</code> 内的数据就会相应地发生变化。</p>
<p>我们当然可以<strong>直接</strong>在 React 中使用 Redux：在最外层容器组件中初始化 <code>store</code>，然后将 <code>state</code> 上的属性作为 <code>props</code> 层层传递下去。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  componentWillMount()&#123;</span><br><span class="line">    store.subscribe((state)=&gt;<span class="keyword">this</span>.setState(state))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Comp</span> <span class="attr">state</span>=<span class="string">&#123;this.state&#125;</span></span><br><span class="line">                 <span class="attr">onIncrease</span>=<span class="string">&#123;()</span>=&gt;</span>store.dispatch(actions.increase())&#125;</span><br><span class="line">                 onDecrease=&#123;()=&gt;store.dispatch(actions.decrease())&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>但这并不是最佳的方式。最佳的方式是使用 react-redux 提供的 <code>Provider</code> 和 <code>connect</code> 方法。</p>
<h2 id="使用-react-redux"><a href="#使用-react-redux" class="headerlink" title="使用 react-redux"></a>使用 react-redux</h2><p>首先在最外层容器中，把所有内容包裹在 <code>Provider</code> 组件中，将之前创建的 <code>store</code> 作为 <code>prop</code> 传给 <code>Provider</code>。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> App = () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Comp</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>Provider</code> 内的任何一个组件（比如这里的 <code>Comp</code>），如果需要使用 <code>state</code> 中的数据，就必须是「被 connect 过的」组件——使用 <code>connect</code> 方法对「你编写的组件（<code>MyComp</code>）」进行包装后的产物。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComp</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// content...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Comp = connect(...args)(MyComp);</span><br></pre></td></tr></table></figure>
<p>可见，<code>connect</code> 方法是重中之重。</p>
<h2 id="connect-详解"><a href="#connect-详解" class="headerlink" title="connect 详解"></a><code>connect</code> 详解</h2><p>究竟 <code>connect</code> 方法到底做了什么，我们来一探究竟。</p>
<p>首先看下函数的签名：</p>
<blockquote>
<p>connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])</p>
</blockquote>
<p><code>connect()</code> 接收四个参数，它们分别是 <code>mapStateToProps</code>，<code>mapDispatchToProps</code>，<code>mergeProps</code>和<code>options</code>。</p>
<h3 id="mapStateToProps-state-ownProps-stateProps"><a href="#mapStateToProps-state-ownProps-stateProps" class="headerlink" title="mapStateToProps(state, ownProps) : stateProps"></a><code>mapStateToProps(state, ownProps) : stateProps</code></h3><p>这个函数允许我们将 <code>store</code> 中的数据作为 <code>props</code> 绑定到组件上。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapStateToProps = (state) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    count: state.count</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的第一个参数就是 Redux 的 <code>store</code>，我们从中摘取了 <code>count</code> 属性。因为返回了具有 <code>count</code> 属性的对象，所以 <code>MyComp</code> 会有名为 <code>count</code> 的 <code>props</code> 字段。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComp</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>计数：&#123;this.props.count&#125;次<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Comp = connect(...args)(MyComp);</span><br></pre></td></tr></table></figure>
<p>当然，你不必将 <code>state</code> 中的数据原封不动地传入组件，可以根据 <code>state</code> 中的数据，动态地输出组件需要的（最小）属性。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapStateToProps = (state) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    greaterThanFive: state.count &gt; <span class="number">5</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数的第二个参数 <code>ownProps</code>，是 <code>MyComp</code> 自己的 <code>props</code>。有的时候，<code>ownProps</code> 也会对其产生影响。比如，当你在 <code>store</code> 中维护了一个用户列表，而你的组件 <code>MyComp</code> 只关心一个用户（通过 <code>props</code> 中的 <code>userId</code> 体现）。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapStateToProps = (state, ownProps) =&gt; &#123;</span><br><span class="line">  <span class="comment">// state 是 &#123;userList: [&#123;id: 0, name: '王二'&#125;]&#125;</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    user: _.find(state.userList, &#123;id: ownProps.userId&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComp</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> PropTypes = &#123;</span><br><span class="line">    userId: PropTypes.string.isRequired,</span><br><span class="line">    user: PropTypes.object</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>用户名：&#123;this.props.user.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Comp = connect(mapStateToProps)(MyComp);</span><br></pre></td></tr></table></figure>
<p>当 <code>state</code> 变化，或者 <code>ownProps</code> 变化的时候，<code>mapStateToProps</code> 都会被调用，计算出一个新的 <code>stateProps</code>，（在与 <code>ownProps</code> merge 后）更新给 <code>MyComp</code>。</p>
<p>这就是将 Redux <code>store</code> 中的数据连接到组件的基本方式。</p>
<h3 id="mapDispatchToProps-dispatch-ownProps-dispatchProps"><a href="#mapDispatchToProps-dispatch-ownProps-dispatchProps" class="headerlink" title="mapDispatchToProps(dispatch, ownProps): dispatchProps"></a><code>mapDispatchToProps(dispatch, ownProps): dispatchProps</code></h3><p><code>connect</code> 的第二个参数是 <code>mapDispatchToProps</code>，它的功能是，将 action 作为 <code>props</code> 绑定到 <code>MyComp</code> 上。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapDispatchToProps = (dispatch, ownProps) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    increase: (...args) =&gt; dispatch(actions.increase(...args)),</span><br><span class="line">    decrease: (...args) =&gt; dispatch(actions.decrease(...args))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComp</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;count, increase, decrease&#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>计数：&#123;this.props.count&#125;次<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;increase&#125;</span>&gt;</span>增加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;decrease&#125;</span>&gt;</span>减少<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Comp = connect(mapStateToProps， mapDispatchToProps)(MyComp);</span><br></pre></td></tr></table></figure>
<p>由于 <code>mapDispatchToProps</code> 方法返回了具有 <code>increase</code> 属性和 <code>decrease</code> 属性的对象，这两个属性也会成为 <code>MyComp</code> 的 <code>props</code>。</p>
<p>如上所示，调用 <code>actions.increase()</code> 只能得到一个 <code>action</code> 对象 <code>{type:&#39;INCREASE&#39;}</code>，要触发这个 <code>action</code> 必须在 <code>store</code> 上调用 <code>dispatch</code> 方法。<code>diapatch</code> 正是 <code>mapDispatchToProps</code> 的第一个参数。但是，为了不让 <code>MyComp</code> 组件感知到 <code>dispatch</code> 的存在，我们需要将 <code>increase</code> 和 <code>decrease</code> 两个函数包装一下，使之成为直接可被调用的函数（即，调用该方法就会触发 <code>dispatch</code>）。</p>
<p>Redux 本身提供了 <code>bindActionCreators</code> 函数，来将 action 包装成直接可被调用的函数。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;bindActionCreators&#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps = (dispatch, ownProps) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> bindActionCreators(&#123;</span><br><span class="line">    increase: action.increase,</span><br><span class="line">    decrease: action.decrease</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样，当 <code>ownProps</code> 变化的时候，该函数也会被调用，生成一个新的 <code>dispatchProps</code>，（在与 <code>statePrope</code> 和 <code>ownProps</code> merge 后）更新给 <code>MyComp</code>。注意，<code>action</code> 的变化不会引起上述过程，默认 <code>action</code> 在组件的生命周期中是固定的。</p>
<h3 id="mergeProps-stateProps-dispatchProps-ownProps-props"><a href="#mergeProps-stateProps-dispatchProps-ownProps-props" class="headerlink" title="[mergeProps(stateProps, dispatchProps, ownProps): props]"></a><code>[mergeProps(stateProps, dispatchProps, ownProps): props]</code></h3><p>之前说过，不管是 <code>stateProps</code> 还是 <code>dispatchProps</code>，都需要和 <code>ownProps</code> merge 之后才会被赋给 <code>MyComp</code>。<code>connect</code> 的第三个参数就是用来做这件事。通常情况下，你可以不传这个参数，<code>connect</code> 就会使用 <code>Object.assign</code> 替代该方法。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>最后还有一个 <code>options</code> 选项，比较简单，基本上也不大会用到（尤其是你遵循了其他的一些 React 的「最佳实践」的时候），本文就略过了。希望了解的同学可以直接看文档。</p>
<p>（完）</p>
<h2 id="附：connect-方法的官方英文文档"><a href="#附：connect-方法的官方英文文档" class="headerlink" title="附：connect 方法的官方英文文档"></a>附：connect 方法的官方英文文档</h2><blockquote>
<h4 id="connect-mapStateToProps-mapDispatchToProps-mergeProps-options"><a href="#connect-mapStateToProps-mapDispatchToProps-mergeProps-options" class="headerlink" title="connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])"></a><code>connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])</code></h4><p>Connects a React component to a Redux store.</p>
<p>It does not modify the component class passed to it. Instead, it returns a new, connected component class, for you to use.</p>
<h4 id="Arguments"><a href="#Arguments" class="headerlink" title="Arguments"></a>Arguments</h4><ul>
<li><p>[mapStateToProps(state, [ownProps]): stateProps] (Function): If specified, the component will subscribe to Redux store updates. Any time it updates, mapStateToProps will be called. Its result must be a plain object*, and it will be merged into the component’s props. If you omit it, the component will not be subscribed to the Redux store. If ownProps is specified as a second argument, its value will be the props passed to your component, and mapStateToProps will be additionally re-invoked whenever the component receives new props (e.g. if props received from a parent component have shallowly changed, and you use the ownProps argument, mapStateToProps is re-evaluated).</p>
</li>
<li><p>[mapDispatchToProps(dispatch, [ownProps]): dispatchProps] (Object or Function): If an object is passed, each function inside it will be assumed to be a Redux action creator. An object with the same function names, but with every action creator wrapped into a dispatch call so they may be invoked directly, will be merged into the component’s props. If a function is passed, it will be given dispatch. It’s up to you to return an object that somehow uses dispatch to bind action creators in your own way. (Tip: you may use the bindActionCreators() helper from Redux.) If you omit it, the default implementation just injects dispatch into your component’s props. If ownProps is specified as a second argument, its value will be the props passed to your component, and mapDispatchToProps will be re-invoked whenever the component receives new props.</p>
</li>
<li><p>[mergeProps(stateProps, dispatchProps, ownProps): props] (Function): If specified, it is passed the result of mapStateToProps(), mapDispatchToProps(), and the parent props. The plain object you return from it will be passed as props to the wrapped component. You may specify this function to select a slice of the state based on props, or to bind action creators to a particular variable from props. If you omit it, Object.assign({}, ownProps, stateProps, dispatchProps) is used by default.</p>
</li>
<li><p>[options] (Object) If specified, further customizes the behavior of the connector.</p>
<ul>
<li>[pure = true] (Boolean): If true, implements shouldComponentUpdate and shallowly compares the result of mergeProps, preventing unnecessary updates, assuming that the component is a “pure” component and does not rely on any input or state other than its props and the selected Redux store’s state. Defaults to true.</li>
<li>[withRef = false] (Boolean): If true, stores a ref to the wrapped component instance and makes it available via getWrappedInstance() method. Defaults to false.</li>
</ul>
</li>
</ul>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="//img.alicdn.com/tfs/TB1fYYeLpXXXXbtXFXXXXXXXXXX-900-500.jpg" alt="React 实践心得：react-redux 之 connect 方法详解"></p>
<p>Redux 是「React]]>
    </summary>
    
      <category term="React" scheme="http://taobaofed.org/tags/React/"/>
    
      <category term="Redux" scheme="http://taobaofed.org/tags/Redux/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[高性能 React 组件]]></title>
    <link href="http://taobaofed.org/blog/2016/08/12/optimized-react-components/"/>
    <id>http://taobaofed.org/blog/2016/08/12/optimized-react-components/</id>
    <published>2016-08-12T02:44:11.000Z</published>
    <updated>2016-10-12T02:02:15.000Z</updated>
    <content type="html"><![CDATA[<p><img src="//img.alicdn.com/tfs/TB1P4h_LpXXXXbGXpXXXXXXXXXX-900-500.jpg" alt="高性能 React 组件"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="组件的重新渲染"><a href="#组件的重新渲染" class="headerlink" title="组件的重新渲染"></a>组件的重新渲染</h2><p>说到 React 组件，肯定离不开组件的 props 和 state，我们可以在 props 和 state 存放任何类型的数据，通过改变 props 和 state，去控制整个组件的状态。当 props 和 state 发生变化时，React 会重新渲染整个组件，组件重新渲染的过程可简化如下图：</p>
<p><img src="http://img1.tbcdn.cn/L1/461/1/c3c7f7f478d86c40530967b5b0fc12037bc71d22" alt="1"></p>
<p>当组件的 props 或 state 变化，React 将会构建新的 virtual DOM，使用 diff 算法把新老的 virtual DOM 进行比较，如果新老 virtual DOM 树不相等则重新渲染，相等则不重新渲染。DOM 操作是非常耗时的，这导致重新渲染也非常的耗时，因此要提高组件的性能就应该尽一切可能的减少组件的重新渲染。</p>
<p>假设有一个渲染完成的组件，如下图：</p>
<p><img src="http://img3.tbcdn.cn/L1/461/1/c9a9e30223ef6188a4a498a8cfd92e346ba5c17d" alt="2"></p>
<p>接下来因为状态改变，需要重新渲染下图的绿色的节点，如下图：</p>
<p><img src="http://img4.tbcdn.cn/L1/461/1/7a8b26b7b14319ae4bfedf385fcb092ac33927a4" alt="3"></p>
<p>一般的想法是只需要更新下面的三个绿色节点就能够完成组件的更新，如下图：</p>
<p><img src="http://img4.tbcdn.cn/L1/461/1/5519a489525ef4b43ca636c2d05890f4cdbb8c94" alt="4"></p>
<p>事实上根据 React 的更新规则，只要组件的 props 或 state 发生了变化就会重新渲染整个组件，因此除了上述的三个绿色节点以外，还需要重新渲染所有的黄色的节点，如下图：</p>
<p><img src="http://img3.tbcdn.cn/L1/461/1/ca1f450b3816ce5fa3411be1710ecc76d7552765" alt="5"></p>
<p>除了必要渲染的三个节点外，还渲染了其他不必要渲染的节点，这对性能是一个很大的浪费。如果对于复杂的页面，这将导致页面的整体体验效果非常差。因此要提高组件的性能，就应该想尽一切方法减少不必要的渲染。</p>
<h1 id="组件优化"><a href="#组件优化" class="headerlink" title="组件优化"></a>组件优化</h1><h2 id="Pure-Component"><a href="#Pure-Component" class="headerlink" title="Pure Component"></a>Pure Component</h2><p>如果一个组件只和 props 和 state 有关系，给定相同的 props 和 state 就会渲染出相同的结果，那么这个组件就叫做纯组件，换一句话说纯组件只依赖于组件的 props 和 state，下面的代码表示的就是一个纯组件。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">render</span>() &#123;</span><br><span class="line">     <span class="selector-tag">return</span> (</span><br><span class="line">         &lt;div style=&#123;&#123;<span class="attribute">width</span>: this.props.width&#125;&#125;&gt;</span><br><span class="line">                  &#123;this<span class="selector-class">.state</span><span class="selector-class">.rows</span>&#125;</span><br><span class="line">         &lt;/div&gt;</span><br><span class="line">     );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h2><p><code>shouldComponentUpdate</code> 这个函数会在组件重新渲染之前调用，函数的返回值确定了组件是否需要重新渲染。函数默认的返回值是 <code>true</code>，意思就是只要组件的 props 或者 state 发生了变化，就会重新构建 virtual DOM，然后使用 diff 算法进行比较，再接着根据比较结果决定是否重新渲染整个组件。函数的返回值为 <code>false</code> 表示不需要重新渲染。 <code>shouldComponentUpdate</code> 在组件的重新渲染的过程中的位置如下图：</p>
<p><img src="http://img1.tbcdn.cn/L1/461/1/354dc8a5e804e06986dae35a92309ec7685499d9" alt="6"></p>
<p>函数默认返回为 <code>true</code>，表示在任何情况下都进行重新渲染的操作，要减少重新渲染，只需要在一些不必要重新渲染的时候，使得函数的返回结果为 <code>false</code>。如果使得函数的结果一直为 <code>false</code>，这样不管组件的状态怎么变化，组件都不会重新渲染，当然一般情况下没有人会这样干。</p>
<h2 id="PureRenderMixin"><a href="#PureRenderMixin" class="headerlink" title="PureRenderMixin"></a>PureRenderMixin</h2><p>React 官方提供了 PureRenderMixin 插件，插件的功能就是在不必要的情况下让函数 <code>shouldComponentUpdate</code> 返回 <code>false</code>, 使用这个插件就能够减少不必要的重新渲染，得到一定程度上的性能提升，其使用方法如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="type">PureRenderMixin</span> from <span class="symbol">'react</span>-addons-pure-render-mixin';</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.shouldComponentUpdate = <span class="type">PureRenderMixin</span>.shouldComponentUpdate.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;div className=&#123;<span class="keyword">this</span>.props.className&#125;&gt;foo&lt;/div&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看源码后发现这个插件其实就是重写了 <code>shouldComponentUpdate</code> 方法。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">	<span class="keyword">return</span> shallowCompare(<span class="keyword">this</span>, nextProps, nextState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重写的方法里面根据组件的目前的状态和组件接下来的状态进行<code>浅比较</code>，如果组件的状态发生变化则返回结果为 <code>false</code>，状态没有发生变化则返回结果为 <code>true</code>，把这个函数进行进一步的分解其实现如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">	<span class="keyword">return</span> !shallowEqual(<span class="keyword">this</span>.props, nextProps) ||</span><br><span class="line">			!shallowEqual(<span class="keyword">this</span>.state, nextState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是分别去比较了函数的 props 和 state 的变化情况。</p>
<p>在 React 的最新版本里面，提供了 <code>React.PureComponent</code> 的基础类，而不需要使用这个插件。</p>
<h2 id="状态比较"><a href="#状态比较" class="headerlink" title="状态比较"></a>状态比较</h2><p>假设在每一个组件中都使用 PureRenderMixin 这个插件，我们来看一下使用这个插件后的状态的比较过程。假设我们有一个组件如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Input</span> <span class="attr">size</span>=<span class="string">&#123;100&#125;</span> <span class="attr">color</span>=<span class="string">'red'</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们想要去改变这个组件的颜色，使其变为 <code>blue</code>，</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Input</span> <span class="attr">size</span>=<span class="string">&#123;100&#125;</span> <span class="attr">color</span>=<span class="string">'blue'</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>则状态的比较就是下面的对象的比较。</p>
<p><img src="http://img4.tbcdn.cn/L1/461/1/72ca4706b371e37deaa3d63a3427c992b6b6911d" alt="7"></p>
<p>上图的比较是简单对象的比较，比较过程非常简单而且快速。但是如果是比较复杂的对象的比较，比如日期、函数或者一些复杂的嵌套许多层的对象，这些会比较耗时，甚至没法进行比较。</p>
<p>其实我们自己可以重写 <code>shouldComponentUpdate</code> 这个函数，使得其能够对任何事物进行比较，也就是<code>深比较</code>（通过一层一层的递归进行比较），深比较是很耗时的，一般不推荐这么干，因为要保证比较所花的时间少于重新渲染的整个组件所花的时间，同时为了减少比较所花的时间我们应该保证 props 和 state 尽量简单，不要把不必要的属性放入 state，能够由其他属性计算出来的属性也不要放入 state 中。</p>
<h2 id="Immutable-js"><a href="#Immutable-js" class="headerlink" title="Immutable.js"></a>Immutable.js</h2><p>对于复杂的数据的比较是非常耗时的，而且可能无法比较，通过使用 Immutable.js  能够很好地解决这个问题，Immutable.js 的基本原则是对于不变的对象返回相同的引用，而对于变化的对象，返回新的引用。因此对于状态的比较只需要使用如下代码即可：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate() &#123;</span><br><span class="line">	<span class="keyword">return</span> ref1 !== ref2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这类比较是非常快速的。</p>
<h2 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h2><p>假设我们有一个下面这样的组件：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ScrollTable</span><br><span class="line">	<span class="attribute">width</span>=&#123;<span class="number">300</span>&#125;</span><br><span class="line">	<span class="attribute">color</span>=<span class="string">'blue'</span></span><br><span class="line">	scrollTop=&#123;this<span class="selector-class">.props</span><span class="selector-class">.offsetTop</span>&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>
<p>这是一个可以滚动的表格，<code>offsetTop</code> 代表着可视区距离浏览器的的上边界的距离，随着鼠标的滚动，这个值将会不断的发生变化，导致组件的 props 不断地发生变化，组件也将会不断的重新渲染。如果使用下面的这种写法：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">OuterScroll</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">InnerTable</span> <span class="attr">width</span>=<span class="string">&#123;300&#125;</span> <span class="attr">color</span>=<span class="string">'blue'</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">OuterScroll</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>因为 <code>InnerTable</code> 这个组件的 props 是固定的不会发生变化，在这个组件里面使用 <code>pureRenderMixin</code> 插件，能够保证 <code>shouldComponentUpdate</code> 的返回一直为 <code>false</code>， 因此不管组件的父组件也就是 <code>OuterScroll</code> 组件的状态是怎么变化，组件 <code>InnerTable</code> 都不会重新渲染。也就是子组件隔离了父组件的状态变化。</p>
<p>通过把变化的属性和不变的属性进行分离，减少了重新渲染，获得了性能的提升，同时这样做也能够让组件更容易进行分离，更好的被复用。</p>
<h2 id="Children"><a href="#Children" class="headerlink" title="Children"></a>Children</h2><p>对于嵌套多层、复杂的组件，组件的子节点很多，组件的更新的时间也将花费更多，并且难于维护，信息流从上往下由父组件传递到子组件单向流动，这可能会导致组件失去我们的控制。</p>
<h3 id="children-change-over-time"><a href="#children-change-over-time" class="headerlink" title="children change over time"></a>children change over time</h3><p>有如下的一个组件（现实中没人会这样写，这只是一个 demo），组件每 1 秒渲染一次。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    shouldComponentUpdate(nextProps) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.props.children != nextProps.children;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> &lt;div&gt;&#123;<span class="keyword">this</span>.props.children&#125;&lt;/div&gt;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setInterval(() =&gt; &#123;</span><br><span class="line">    <span class="type">ReactDOM</span>.render(</span><br><span class="line">        &lt;<span class="type">Parent</span>&gt;</span><br><span class="line">            &lt;div&gt;child&lt;/div&gt;</span><br><span class="line">        &lt;/<span class="type">Parent</span>&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>通过在 <code>shouldComponentUpdate</code> 函数里面判断组件的 children 是否相等决定是否重新进行渲染，由于 children 是 props 的一个属性，应该每次都是一样的，组件应该不会重新渲染，可是事实上组件每次都会重新渲染。</p>
<p>让我们来看一下，children 的具体结构，如下图：</p>
<p><img src="http://img4.tbcdn.cn/L1/461/1/63cb24b655ca5fd9cec7168d0716fd0be7a7f854" alt="8"></p>
<p>children 是一个比较复杂的对象，每次组件更新的时候都会重新构造，也就是说 children 是动态构建的，因此每次更新的时候都是不相等的。所以 <code>shouldComponentUpdate</code> 每次都会返回 <code>true</code>，因此组件每次都会重新渲染。可以用一个变量来代替 children，这样每次构造的也会是相同的对象。</p>
<h3 id="Independent-children"><a href="#Independent-children" class="headerlink" title="Independent children"></a>Independent children</h3><p>再来看一个比较费力的做法，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoColumnSplit</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    shouldComponentUpdate() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">FloatLeft</span>&gt;</span>&#123;this.props.children[0]&#125;<span class="tag">&lt;/<span class="name">FloatLeft</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">FloatRight</span>&gt;</span>&#123;this.props.children[1]&#125;<span class="tag">&lt;/<span class="name">FloatRight</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;TwoColumnSplit&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">TargetContainer</span>/&gt;</span></span></span><br><span class="line">    &lt;BudgetContainer/&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">TwoColumnSplit</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>通过在 <code>shouldComponentUpdate</code> 中返回 <code>false</code>，组件将不会因为外界的状态变化而发生改变，我们这样做是因为组件 <code>TargetContainer</code> 和 <code>BudgetContainer</code> 没有从它们的父元素获取任何信息，这样就不需要管外界的变化，把 children 和父组件进行了隔离，其实 <code>TwoColumnSplit</code> 就是起了隔离的作用。对于不需要从外界获取数据的组件，可以通过返回 <code>false</code> 来隔离外界的变化，减少重新渲染。</p>
<h2 id="Container-and-Component"><a href="#Container-and-Component" class="headerlink" title="Container and Component"></a>Container and Component</h2><p>我们也可以通过组件的容器来隔离外界的变化。容器就是一个数据层，而组件就是专门负责渲染，不进行任何数据交互，只根据得到的数据渲染相应的组件，下面就是一个容器以及他的组件。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BudgetContainer</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.shouldComponentUpdate = <span class="type">PureRenderMixin</span>.shouldComponentUpdate.bind(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    computeState() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">BudgetStore</span>.getStore()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> &lt;<span class="type">Budget</span> &#123;...<span class="keyword">this</span>.state&#125;/&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>容器不应该有 props 和 children，这样就能够把容器自己和父组件进行隔离，不会因为外界因素去重新渲染，也没有必要重新渲染。</p>
<p>设想一下，如果设计师觉得这个组件需要移动位置，你不需要做任何的更改只需要把组件放到对应的位置即可，我们可以把它移到任何地方，可以放在不同的应用中，同时也可以应用于测试，我们只需要关心容器的内部的数据的来源即可，在不同的环境中编写不同的容器。</p>
<p><img src="http://img1.tbcdn.cn/L1/461/1/c74de69b05661a277c6e9ad2ab12775b706af4d6" alt="9"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li><p>Purity =&gt; Use shouldComponentUpdate &amp; PureRenderMixin</p>
</li>
<li><p>Data Comparability =&gt; Use highly comparable data (immutability)</p>
</li>
<li><p>Loose coupling =&gt; Use for maintainability and performance</p>
</li>
<li><p>Children =&gt; Be careful of children, children create deep update,</p>
<pre><code>children are always change,  we should  insulate them from parent
</code></pre></li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><p><a href="https://www.youtube.com/watch?v=KYzlpRvWZ6c&amp;feature=youtu.be&amp;t=1372" target="_blank" rel="external">Making your app fast with high-performance components</a></p>
</li>
<li><p><a href="https://facebook.github.io/react/docs/advanced-performance.html" target="_blank" rel="external">React advanced-performance</a></p>
</li>
<li><a href="http://gold.xitu.io/entry/57621f7980dda4005f7332f3" target="_blank" rel="external">React 应用的性能优化</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="//img.alicdn.com/tfs/TB1P4h_LpXXXXbGXpXXXXXXXXXX-900-500.jpg" alt="高性能 React 组件"></p>
<h1 id="前言"><a href="#前言" class="headerli]]>
    </summary>
    
      <category term="React" scheme="http://taobaofed.org/tags/React/"/>
    
      <category term="性能优化" scheme="http://taobaofed.org/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[论版本号的正确打开方式]]></title>
    <link href="http://taobaofed.org/blog/2016/08/04/instructions-of-semver/"/>
    <id>http://taobaofed.org/blog/2016/08/04/instructions-of-semver/</id>
    <published>2016-08-04T09:48:27.000Z</published>
    <updated>2016-10-12T02:02:15.000Z</updated>
    <content type="html"><![CDATA[<p><img src="https://img.alicdn.com/tps/TB18IDkLXXXXXbeXpXXXXXXXXXX-900-500.png" alt="论版本号的正确打开方式"></p>
<p>版本号广泛运用于开发的各种场景：NPM 包的版本定义、对 NPM 包的特定版本的依赖指定、git 的 daily 版本号分支……</p>
<p>面对如此多的场景，版本号的命名却存在很大问题。举些例子：</p>
<ul>
<li>开始写一个新项目 / 模块时，不管三七二十一，都从 <code>0.0.1</code> 起版本，直到项目不再维护时，版本还停留在 <code>0.0.48</code>，前两位永远都是 0。</li>
<li>API 变化巨大，而版本号雷打不动一步一个脚印。一个二方包从 <code>0.0.8</code> 升级到 <code>0.0.9</code> 就引起了整个项目的崩溃。</li>
<li>依赖二方 / 三方包时，不知道该依赖哪个版本，有时随便指定了一个，有时则直接依赖了 <code>*</code>。</li>
</ul>
<hr>
<h2 id="版本号的命名"><a href="#版本号的命名" class="headerlink" title="版本号的命名"></a>版本号的命名</h2><h3 id="SemVer"><a href="#SemVer" class="headerlink" title="SemVer"></a>SemVer</h3><p>根据国际主流的惯例，我们使用「语义化版本（<a href="http://semver.org/" target="_blank" rel="external">Semantic Versioning</a>）」的命名方式，有时简称 SemVer。</p>
<p>语义化版本号（以下简称「版本号」）的格式是：<code>&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;</code>。即使用三位非负整数，以点号 <code>.</code> 连接。</p>
<p>如：<code>1.4.15</code>、<code>6.2.0</code>。</p>
<h3 id="每一位版本号的含义"><a href="#每一位版本号的含义" class="headerlink" title="每一位版本号的含义"></a>每一位版本号的含义</h3><ol>
<li><code>&lt;major&gt;</code> 即主版本号，俗称大版本升级。改动到主版本号时，标志着 API 发生了巨大变化，包括但不限于新增特性、修改机制、删除功能， <strong>一般不兼容上一个主版本号</strong>。</li>
<li><code>&lt;minor&gt;</code> 即次版本号，俗称小版本升级。当我们进行常规的新增或修改功能时，改动次版本号，但是 <strong>必须是向前兼容的</strong>。这也意味着我们 <strong>不能直接删除某个功能</strong>。如若必要，我们可以在 <a href="http://guide.taobao.net/6.changelog.php" target="_blank" rel="external">changelog</a> 中标记某项功能为「即将删除（Deprecated）」，然后在下一个大版本中将其彻底删除。</li>
<li><code>&lt;patch&gt;</code> 即修订号，俗称 bug 修复。顾名思义，如果仅仅为了修复或调整一些小问题，我们就只改动修订号。</li>
</ol>
<p>所以，当我们明确了每一位的含义和作用后，就不会陷入「每次只改最末位」的尴尬中了。</p>
<p>那如何判断一个修改应该是改动修订号还是次版本号呢？视情况而定。比如对于「修改了 app 图标」这件事来说，如果只是调整了图标的间距位置，那么可以认作问题修复；如果把整个图标换了，配上了不同的标语，那么这应该是一次功能改动。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>版本号前不要加 <code>v</code>。</li>
<li>不要在数字前补 <code>0</code>。错误示例：<code>01.12.03</code>。</li>
<li>每一位版本号按照 +1 的速度递增，不要在版本号之间跳跃。</li>
<li>主版本号停留在 <code>0</code> 的版本号，即 <code>0.x.x</code> 应当视作还在内部开发阶段的代码。如果代码有公共 API，此时不宜对外公开。</li>
<li><code>1.0.0</code> 的版本号用于界定公共 API 的形成。</li>
<li>当次版本号递增时，修订号归零；当主版本号递增时，次版本号、修订号归零。</li>
<li>进行新的开发时，版本号从 <code>0.1.0</code> 开始。</li>
<li>如果不小心把一个不兼容的改版当成了次版本号发行，应当发行一个新的次版本号来更正这个问题并且恢复向下兼容。注意 <strong>不能去修改已发行的版本</strong>。</li>
</ul>
<h3 id="一个典型的版本号发展示例"><a href="#一个典型的版本号发展示例" class="headerlink" title="一个典型的版本号发展示例"></a>一个典型的版本号发展示例</h3><ol>
<li><code>0.1.0</code></li>
<li><code>0.1.1</code></li>
<li><code>0.1.2</code></li>
<li><code>0.2.0</code></li>
<li><code>1.0.0</code></li>
<li><code>1.1.0</code></li>
<li><code>1.1.1</code></li>
<li>……</li>
</ol>
<h3 id="快速修改版本号"><a href="#快速修改版本号" class="headerlink" title="快速修改版本号"></a>快速修改版本号</h3><p>如果一个包发布在 NPM / TNPM 中，可以快速修改其版本号。会自动触发一个 git 提交。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 递增一个修订号</span><br><span class="line">npm version patch</span><br><span class="line"></span><br><span class="line"># 递增一个次版本号</span><br><span class="line">npm version minor</span><br><span class="line"></span><br><span class="line"># 递增一个主版本号</span><br><span class="line">npm version major</span><br></pre></td></tr></table></figure>
<h2 id="预发版本号"><a href="#预发版本号" class="headerlink" title="预发版本号"></a>预发版本号</h2><p>在常规的版本号命名之上还有一个特殊类别，叫做预发版本号（prerelease version）。它表示当前版本是一个不稳定的版本，使用它时需要注意风险。</p>
<p>预发版本号的格式是 <code>&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;-&lt;tag&gt;</code>，即前半部分和常规版本号相同，然后跟上连接符 <code>-</code>，后面再跟上字母数字点号连接符（[0-9A-Za-z-.]）。</p>
<p>一个典型的预发版本号形如 <code>1.0.0-beta.1</code>。建议使用这种 <code>&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;-&lt;stage&gt;.&lt;num&gt;</code> 的形式。其中 <code>&lt;stage&gt;</code> 一般选用：<code>alpha</code>、<code>beta</code>、<code>rc</code>。</p>
<p>预发版本号是常规版本号的附属，因此在版本的大小比较上，仍然先比较常规版本号部分；对于预发标记部分的比较，则是根据 ASCII 字母表中的顺序来进行。</p>
<h3 id="一个典型的预发版本号发展示例"><a href="#一个典型的预发版本号发展示例" class="headerlink" title="一个典型的预发版本号发展示例"></a>一个典型的预发版本号发展示例</h3><ol>
<li><code>0.9.0</code></li>
<li><code>1.0.0-alpha.1</code></li>
<li><code>1.0.0-alpha.2</code></li>
<li><code>1.0.0-beta.1</code></li>
<li><code>1.0.0-rc.1</code></li>
<li><code>1.0.0</code></li>
<li><code>1.0.1</code></li>
<li>……</li>
</ol>
<h2 id="依赖的版本号标记法"><a href="#依赖的版本号标记法" class="headerlink" title="依赖的版本号标记法"></a>依赖的版本号标记法</h2><p>我们广泛使用的 NPM 本身也遵从 SemVer 版本号命名，除了包版本本身的定义之外，最重要的是对三方包依赖的版本号的定义，不当的写法将导致一系列潜在的问题。</p>
<h3 id="指定可用的版本号范围"><a href="#指定可用的版本号范围" class="headerlink" title="指定可用的版本号范围"></a>指定可用的版本号范围</h3><p>在 NPM 包的 deps 系列字段中，经常出现形如 <code>~1.0.4</code>、<code>^2.1.1</code> 这样的标记法，这种标记法标记的是「版本号范围（version range）」，它表示依赖的三方包其版本号只要落在定义版本号范围内，即算合法。另外，当运行 <code>npm update</code> 时，依赖的包将升级到版本号范围支持的最高版本。</p>
<p>版本号范围的标记符号有很多种，诸如比较符号 <code>&gt;=</code>、<code>&lt;</code> 等；连接符 <code>-</code>；通配符 <code>x</code>、<code>*</code>；模糊符 <code>^</code>、<code>~</code>。具体的用法可参考 <a href="https://docs.npmjs.com/misc/semver" target="_blank" rel="external">NPM 官方文档</a>，这里仅给出常用的标记方式。</p>
<table>
<thead>
<tr>
<th>含义</th>
<th>最简写法</th>
<th>使用通配符的写法</th>
<th>使用模糊符的写法</th>
<th>表达的版本号范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>仅跟进修复版本</td>
<td><code>1.0</code></td>
<td><code>1.0.x</code></td>
<td><code>~1.0.4</code></td>
<td><code>&gt;=1.0.4 &lt;1.1.0</code></td>
</tr>
<tr>
<td>跟进每个小版本更新</td>
<td><code>1</code></td>
<td><code>1.x</code>、<code>1.x.x</code></td>
<td><code>^1.0.4</code></td>
<td><code>&gt;=1.0.4 &lt;2.0.0</code></td>
</tr>
<tr>
<td>始终升级到最新版</td>
<td><code>*</code></td>
<td><code>*</code></td>
<td><code>*</code></td>
<td><code>&gt;=0.0.0</code></td>
</tr>
</tbody>
</table>
<p>我们建议在写法上采用 <strong>「使用通配符的写法」</strong>，并且一般情况下 <strong>「跟进每个小版本更新」</strong>，但 <strong>不「始终升级到最新版」</strong>，即书写为 <code>1.x</code>。由于 <code>&lt;major&gt;</code> 位版本是不向下兼容的，所以在大版本的控制上，仍然采用人为干预以保证安全。</p>
<h3 id="不同的-deps-字段"><a href="#不同的-deps-字段" class="headerlink" title="不同的 deps 字段"></a>不同的 deps 字段</h3><p>NPM 包中的依赖有几种形式的字段：<code>dependencies</code>、<code>devDependencies</code>、<code>peerDependencies</code>。以下简要介绍下各字段的不同含义，以及使用场景。</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
<th>依赖被安装的时机</th>
<th>使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>dependencies</code></td>
<td>运行时依赖，包的调用者需要使用到的依赖</td>
<td>执行 <code>npm install</code> 后会把当前包的 <code>dependencies</code> 字段中的所有依赖项安装到 <code>./node_modules</code> 目录。<br> 执行 <code>npm install xxx</code> 后会把 xxx 安装到 <code>./node_modules</code> 下，同时会安装 xxx 的 <code>dependencies</code> 字段依赖项到 <code>./node_modules/xxx/node_modules</code> 目录。  <br> 执行 <code>npm install xxx --save</code> 后会额外把 xxx 作为依赖存到当前包的 <code>dependencies</code> 字段中。</td>
<td>所有程序运行需要用到的依赖代码，如 lodash 等。</td>
</tr>
<tr>
<td><code>devDependencies</code></td>
<td>开发时依赖，包的开发维护者需要使用到的依赖</td>
<td>执行 <code>npm install</code> 后也会把当前包的 <code>devDependencies</code> 字段中的所有依赖项安装到 <code>./node_modules</code> 目录。<br> 执行 <code>npm install xxx</code> 后会把 xxx 安装到 <code>./node_modules</code> 下，但不会安装 xxx 的 <code>devDependencies</code> 字段依赖项。 <br> 执行 <code>npm install xxx --save-dev</code> 后会额外把 xxx 作为开发时依赖存到当前包的 <code>devDependencies</code> 字段中。</td>
<td>一般是一些开发调试的辅助工具，如测试工具 mocha、构建工具 gulp 等。</td>
</tr>
<tr>
<td><code>peerDependencies</code></td>
<td>略</td>
<td>略</td>
<td>仅在 <a href="https://nodejs.org/en/blog/npm/peer-dependencies/" target="_blank" rel="external">特定场景</a> 下有用，默认不使用此字段。</td>
</tr>
</tbody>
</table>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol>
<li><a href="http://semver.org/" target="_blank" rel="external">Semantic Versioning</a></li>
<li><a href="https://docs.npmjs.com/misc/semver" target="_blank" rel="external">NPM SemVer</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="https://img.alicdn.com/tps/TB18IDkLXXXXXbeXpXXXXXXXXXX-900-500.png" alt="论版本号的正确打开方式"></p>
<p>版本号广泛运用于开发的各种场景：NPM 包的版本定义、对 NPM ]]>
    </summary>
    
      <category term="版本号" scheme="http://taobaofed.org/tags/%E7%89%88%E6%9C%AC%E5%8F%B7/"/>
    
      <category term="SemVer" scheme="http://taobaofed.org/tags/SemVer/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[纠结的链接：ln、ln -s、fs.symlink、require]]></title>
    <link href="http://taobaofed.org/blog/2016/07/29/puzzled-by-link/"/>
    <id>http://taobaofed.org/blog/2016/07/29/puzzled-by-link/</id>
    <published>2016-07-29T03:50:30.000Z</published>
    <updated>2016-10-12T02:02:15.000Z</updated>
    <content type="html"><![CDATA[<p><img src="//img.alicdn.com/tfs/TB1eKetLXXXXXalXVXXXXXXXXXX-900-500.jpg" alt="纠结的链接：ln、ln -s、fs.symlink、require"></p>
<p>最近在使用 <code>fs.symlink</code> 实现软链时，发现<a href="https://nodejs.org/api/fs.html#fs_fs_symlink_target_path_type_callback" target="_blank" rel="external">文档</a>里面写的是：<code>fs.symlink(target, path)</code>；然而 <code>man ln</code> 的时候显示的是：<code>ln source_file target_file</code>；而且，<code>require</code> 模块的时候其实还会处理软链但是处理的又不是想象中那样。于是，我彻底被相关东西绕晕。这篇文章算是我的学习笔记，希望对你有帮助。</p>
<a id="more"></a>
<h2 id="inode"><a href="#inode" class="headerlink" title="inode"></a>inode</h2><p>我们首先来看看 Linux 系统里面的一个重要概念：inode。</p>
<p>我们知道，文件存储在硬盘上，硬盘存储的最小单位是扇区（sector，每个扇区 512 B）。而操作系统读取文件时，按块读取（连续的多个扇区），也就是说文件存取的最小单位是块（block，块通常是 4 KB）。</p>
<p>除了文件数据，我们还必须存储文件的元信息（如：文件大小、文件创建者、文件数据的块位置、文件读/写/执行权限、文件时间戳等等），这种存储文件元信息的结构就称为 inode。我们可以使用 <code>stat</code> 命令查看文件的 inode 信息。在 Node.js 中，调用 <code>fs.stat</code> 后返回的结果中也有相关信息</p>
<p><img src="http://img.alicdn.com/tps/TB1IUOkKXXXXXX2aXXXXXXXXXXX-1126-980.png" alt="stat"></p>
<p>每个 inode 都有一个唯一的号码标志，Linux 系统内部使用 inode 的号码来识别文件，并不使用文件名。我们打开一个文件时，系统首先找到文件名对应的 inode 号码，然后通过 inode 号码获取 inode 信息，最后根据 inode 信息中的文件数据所在的 block 读出数据。</p>
<p>实际上，在 Linux 系统中，目录也是一种文件。目录文件包含一系列目录项，每个目录项由两部分组成：所包含文件的文件名，以及该文件名对应的 inode 号码。我们可以使用 <code>ls -i</code> 来列出目录中的文件以及它们的 inode 号码。这其实也解释了仅更改目录的读权限，并不能实现读取目录下所有文件内容的原因，通常需要 <code>chmod -R</code> 来进行递归更改。</p>
<p>总结下：</p>
<ul>
<li>硬盘存取的最小单位是扇区，文件存取的最小单位是块（连续的扇区）</li>
<li>存储文件元信息（文件大小、创建者、块位置、时间戳、权限等非数据信息）的结构称为 inode</li>
<li>每个 inode 拥有一个唯一号码，系统内部通过它来识别文件</li>
<li>目录也是一种文件，其内容包含一系列目录项（每个目录项由文件的文件名和文件对应的 inode 号码组成）</li>
</ul>
<h2 id="硬链接和软链接"><a href="#硬链接和软链接" class="headerlink" title="硬链接和软链接"></a>硬链接和软链接</h2><h3 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h3><p>一般情况，一个文件名“唯一”对应一个 inode。但是，Linux 允许多个文件名都指向同一个 inode。这表示我们可以使用不同的文件名访问同样的内容；对文件内容进行修改将“反映”到所有文件；删除一个文件不影响另一个文件的访问  。这种机制就被称为“硬链接”。</p>
<p>我们可以使用 <code>ln source target</code> 来建立硬链接（注意：<code>source</code> 是本身已存在的文件，<code>target</code> 是将要建立的链接）。</p>
<p><img src="http://img.alicdn.com/tps/TB1Q31gKXXXXXbLaXXXXXXXXXXX-912-438.png" alt="hard link"></p>
<p>形象化的表示为下图：</p>
<p><img src="http://img.alicdn.com/tps/TB1mYuqKXXXXXbGXVXXXXXXXXXX-300-361.png" alt="hard link graph"></p>
<p>需要注意的是，只能给文件建立硬链接，而不能给目录建立硬链接。另外，<code>source</code> 文件必须存在，否则将会报错。</p>
<p>删除一个文件为什么不影响另一个文件的访问呢？实际上，文件 inode 中还有一个链接数的信息，每多一个文件指向这个 inode，该数字就会加 1，每少一个文件指向这个 inode，该数字就会减 1，当值减到 0，系统就自动回收 inode 及其对应的 block 区域。很像是一种引用计数的垃圾回收机制。</p>
<p>当我们对某个文件建立了硬链接后，对应的 inode 的链接数会是 2（原文件本身已经有一个指向），当删除一个文件时，链接数变成 1，并没达到回收的条件，所以我们还是可以访问文件。</p>
<h3 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h3><p>软链接类似于 Windows 中的”快捷方式“。两个文件虽然 inode 号码不一样，但是文件 A 内部会指向文件 B 的 inode。当我们读取文件 A 时，系统就自动导向文件 B，文件 A 就是文件 B 的软链接（或者叫符号链接）。这表示我们同样可以使用不同的文件名访问同样的内容；对文件内容修改将”反映“到所有文件。但是当我们删除掉源文件 B 时，再访问文件 A 时会报错 “No such file or directory”。</p>
<p>我们可以使用 <code>ln -s source target</code> 来建立软链接（注意：表示让 <code>target</code> “指向” <code>source</code>）。</p>
<p><img src="http://img.alicdn.com/tps/TB1xOeTKXXXXXabXXXXXXXXXXXX-994-488.png" alt="soft link"></p>
<p>形象化的表示为下图：</p>
<p><img src="http://img.alicdn.com/tps/TB1PhakKXXXXXaSaXXXXXXXXXXX-300-366.png" alt="soft link graph"></p>
<p>和硬链接不同，我们可以给目录建立软链接，这带来许多便利。比如我们有一个模块有很多个版本，分别存放在 1.0.0、2.0.0 这样的目录下面，当更新模块时，只需要建立一个软链接指向最新版本号的目录就能很方便的切换版本。</p>
<p>另外，建立软链接时，<code>source</code> 是可以不存在的。这很像一种”运行时“机制，而不是“编译时”机制，建立的时候不报错，等执行的时候发现找不到就报错了。</p>
<p><img src="http://img.alicdn.com/tps/TB1UrifKXXXXXXjapXXXXXXXXXX-994-618.png" alt="danggling soft link"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>使用 <code>ln source target</code> 建立硬链接；使用 <code>ln -s source target</code> 建立软链接</li>
<li>硬链接不会创建额外 inode，和源文件共用同一个 inode；软链接会创建额外一个文件（额外 inode），指向源文件的 inode</li>
<li>建立硬链接时，<code>source</code> 必须存在且只能是文件；建立软链接时，<code>source</code> 可以不存在而且可以是目录</li>
<li>删除源文件不会影响硬链接文件的访问（因为 inode 还在）；删除源文件会影响软链接文件的访问（因为指向的 inode 已经不存在了）</li>
<li>对于已经建立的同名链接，不能再次建立，除非删掉或者使用 <code>-f</code> 参数</li>
</ul>
<h3 id="关于软链接的补充"><a href="#关于软链接的补充" class="headerlink" title="关于软链接的补充"></a>关于软链接的补充</h3><p>上面的例子 <code>ln -s file file-soft</code> 给我们的感觉像是 <code>file-soft</code> 是“凭空”出现的。当我们跨目录来创建软链接时，可能会“幻想”这样的命令也是可以生效的：<code>ln -s ~/development/mod ~/production/dir-not-exits/mod</code>。</p>
<p>这里并没有 <code>~/production/dir-not-exits/</code> 这个目录，而软链接本质上是一个新的“文件”，所以，我们不可能正确建立软链接（会报错说 “no such file or directory”）。</p>
<p>如果我们先通过 <code>mkdir</code> 建立好目录 <code>~/production/dir-not-exits/</code>，再进行软链接，即可达到预期效果。</p>
<h2 id="fs-symlink"><a href="#fs-symlink" class="headerlink" title="fs.symlink"></a>fs.symlink</h2><p>在 Node.js 中，我们可以使用方法 <code>fs.symink(target, path)</code> 建立软链接（符号链接），没有直接的方法建立硬链接（就算通过子进程的方式直接指向 shell 命令也不能跨平台）。</p>
<p>如果是对目录建立链接，请总是传递第三个参数 <code>dir</code>（虽然第三个参数只在 Windows 下生效，这可以保证代码跨平台）：<code>fs.symlink(target, path, &#39;dir&#39;)</code>。</p>
<p>为啥这个接口的参数会是 <code>target</code> 和 <code>path</code>。实际上这是一个 Linux 的 API，<a href="http://man7.org/linux/man-pages/man2/symlink.2.html" target="_blank" rel="external">symlink(target, linkpath)</a>。它是这样描述的：建立一个名为 <code>linkpath</code> 的符号链接并且含有内容 <code>target</code>。其实就是让 <code>linkpath</code> 指向 <code>target</code>，和 <code>ln -s source target</code> 功能一样，让 <code>target</code> 指向 <code>source</code>。</p>
<p>是不是有点晕？其实我们只需要明白 <code>ln -s</code> 和 <code>fs.symlink</code> 后面传递的两个参数顺序是一致的，只是叫法不一样，使用起来也就没那么纠结了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln <span class="_">-s</span> file file-soft <span class="comment"># file-soft -&gt; file</span></span><br><span class="line">ln <span class="_">-s</span> dir dir-soft <span class="comment"># dir-soft -&gt; dir</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fs.symlinkSync(<span class="string">'file'</span>, <span class="string">'file-soft'</span>); <span class="comment">// file-soft -&gt; file</span></span><br><span class="line">fs.symlinkSync(<span class="string">'dir'</span>, <span class="string">'dir-soft'</span>, <span class="string">'dir'</span>); <span class="comment">// dir-soft -&gt; dir</span></span><br></pre></td></tr></table></figure>
<h2 id="require"><a href="#require" class="headerlink" title="require"></a>require</h2><p>在 Node.js 中，我们经常通过 <code>require</code> 来引用模块。非常有趣的是，<code>require</code> 引用模块时，会“考虑”符号链接，但是却使用模块的真实路径作为 <code>__filename</code>、<code>__dirname</code>，而不是符号链接的路径。</p>
<p>考虑下面的目录结构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- app</span><br><span class="line">  - index.js // require(<span class="string">'dep1'</span>)</span><br><span class="line">  - node_modules</span><br><span class="line">    - dep1 -&gt; ../../mods/dep1 //符号链接</span><br><span class="line">- mods</span><br><span class="line">  - dep1</span><br><span class="line">    - index.js</span><br></pre></td></tr></table></figure>
<p>以及下面的文件内容：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'index.js'</span>, __dirname, __filename);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'dep1'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// dep1/index.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'dep1'</span>, __dirname, __filename);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">module</span>.paths);</span><br></pre></td></tr></table></figure>
<p>执行 <code>node index.js</code> 后输出是下面这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">index.js /Users/kohpoll/Workspace/<span class="built_in">test</span>/app /Users/kohpoll/Workspace/<span class="built_in">test</span>/app/index.js</span><br><span class="line"></span><br><span class="line">dep1 /Users/kohpoll/Workspace/<span class="built_in">test</span>/mods/dep1 /Users/kohpoll/Workspace/<span class="built_in">test</span>/mods/dep1/index.js</span><br><span class="line">[ <span class="string">'/Users/kohpoll/Workspace/test/mods/dep1/node_modules'</span>,</span><br><span class="line">  <span class="string">'/Users/kohpoll/Workspace/test/mods/node_modules'</span>,</span><br><span class="line">  <span class="string">'/Users/kohpoll/Workspace/test/node_modules'</span>,</span><br><span class="line">  <span class="string">'/Users/kohpoll/Workspace/node_modules'</span>,</span><br><span class="line">  <span class="string">'/Users/kohpoll/node_modules'</span>,</span><br><span class="line">  <span class="string">'/Users/node_modules'</span>,</span><br><span class="line">  <span class="string">'/node_modules'</span> ]</span><br></pre></td></tr></table></figure>
<p>我们发现，<code>index.js</code> 可以成功的 <code>require(&#39;dep1&#39;)</code>。这很好啊，这让我们调试本地开发中的 npm 模块很方便。我们只需要去 <code>require</code> 模块的文件所在的 <code>node_modules</code> 下面建立一个符号链接就行了。</p>
<p>但是在模块 <code>dep1</code> 中，<code>__dirname</code>、<code>__filename</code> 都变成了模块实际的路径，更要命的是模块查找路径 <code>module.paths</code> 也变成了从实际路径开始查找。</p>
<p>这会带来什么问题？</p>
<p>再考虑下面的目录结构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- app</span><br><span class="line">  - index.js // require(<span class="string">'dep1'</span>)</span><br><span class="line">  - node_modules</span><br><span class="line">    - dep1 -&gt; ../../mods/dep1 // require(<span class="string">'dep2'</span>)</span><br><span class="line">    - dep2 -&gt; ../../mods/dep2 // 符号连接</span><br><span class="line">- mods</span><br><span class="line">  - dep1</span><br><span class="line">    - index.js</span><br><span class="line">  - dep2</span><br><span class="line">    - index.js</span><br></pre></td></tr></table></figure>
<p>以及下面的文件内容：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'index.js'</span>, __dirname, __filename);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'dep1'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// dep1/index.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'dep1'</span>, __dirname, __filename);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">module</span>.paths);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'dep2'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// dep2/index.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'dep2'</span>, __dirname, __filename);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">module</span>.paths);</span><br></pre></td></tr></table></figure>
<p>当我们再执行 <code>node index.js</code> 时，输出是下面这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">index.js /Users/kohpoll/Workspace/<span class="built_in">test</span>/app /Users/kohpoll/Workspace/<span class="built_in">test</span>/app/index.js</span><br><span class="line"></span><br><span class="line">dep1 /Users/kohpoll/Workspace/<span class="built_in">test</span>/mods/dep1 /Users/kohpoll/Workspace/<span class="built_in">test</span>/mods/dep1/index.js</span><br><span class="line">[ <span class="string">'/Users/kohpoll/Workspace/test/mods/dep1/node_modules'</span>,</span><br><span class="line">  <span class="string">'/Users/kohpoll/Workspace/test/mods/node_modules'</span>,</span><br><span class="line">  <span class="string">'/Users/kohpoll/Workspace/test/node_modules'</span>,</span><br><span class="line">  <span class="string">'/Users/kohpoll/Workspace/node_modules'</span>,</span><br><span class="line">  <span class="string">'/Users/kohpoll/node_modules'</span>,</span><br><span class="line">  <span class="string">'/Users/node_modules'</span>,</span><br><span class="line">  <span class="string">'/node_modules'</span> ]</span><br><span class="line">  </span><br><span class="line">module.js:339</span><br><span class="line">    throw err;</span><br><span class="line">    ^</span><br><span class="line">Error: Cannot find module <span class="string">'dep2'</span></span><br><span class="line">    at Function.Module._resolveFilename (module.js:337:15)</span><br><span class="line">    at Function.Module._load (module.js:287:25)</span><br><span class="line">    at Module.require (module.js:366:17)</span><br><span class="line">    at require (module.js:385:17)</span><br><span class="line">    at Object.&lt;anonymous&gt; (/Users/kohpoll/Workspace/<span class="built_in">test</span>/mods/dep1/index.js:6:1)</span><br><span class="line">    at Module._compile (module.js:435:26)</span><br><span class="line">    at Object.Module._extensions..js (module.js:442:10)</span><br><span class="line">    at Module.load (module.js:356:32)</span><br><span class="line">    at Function.Module._load (module.js:311:12)</span><br><span class="line">    at Module.require (module.js:366:17)</span><br></pre></td></tr></table></figure>
<p>发现了吗？<code>dep1</code> 根本就 <code>require</code> 不到 <code>dep2</code>，因为 <code>dep2</code> 不在它的查找路径里面！</p>
<p>关于这个问题，github 上有一个冗长的 issue 在讨论。问题解决起来确实很麻烦，而且会 break 掉一大堆已有功能，所以，最终的结论是在找到更好的方法前给 Node.js v6 增加了一个 <code>--preserve-symlinks</code> 选项来禁止这种 <code>require</code> 的行为，而是使用全新的 <code>require</code> 逻辑。有兴趣和闲情的可以去围观：<a href="https://github.com/nodejs/node/issues/3402" target="_blank" rel="external">https://github.com/nodejs/node/issues/3402</a>（真的好长……）。</p>
<p>至于全新的 <code>require</code> 逻辑会不会有新的坑，在没有具体实践前，我也不知道。</p>
<p>那我们上面的情况有办法解决吗？其实也有，那就是将目录结构调整成下面这样，从而让 <code>dep2</code> 能在 <code>dep1</code> 的查找路径里面：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- app</span><br><span class="line">  - index.js // require(<span class="string">'dep1'</span>)</span><br><span class="line">  - node_modules</span><br><span class="line">    - dep1 -&gt; ../../mods/node_modules/dep1 // 软链接</span><br><span class="line">    - dep2 -&gt; ../../mods/node_modules/dep2 // 软连接</span><br><span class="line">- mods</span><br><span class="line">  - node_modules</span><br><span class="line">    - dep1</span><br><span class="line">      - index.js</span><br><span class="line">    - dep2</span><br><span class="line">      - index.js</span><br></pre></td></tr></table></figure>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://www.ruanyifeng.com/blog/2011/12/inode.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2011/12/inode.html</a></li>
<li><a href="http://www.geekride.com/hard-link-vs-soft-link/" target="_blank" rel="external">http://www.geekride.com/hard-link-vs-soft-link/</a></li>
<li><a href="http://man7.org/linux/man-pages/man2/symlink.2.html" target="_blank" rel="external">http://man7.org/linux/man-pages/man2/symlink.2.html</a></li>
<li><a href="https://nodejs.org/api/fs.html" target="_blank" rel="external">https://nodejs.org/api/fs.html</a></li>
<li><a href="https://github.com/nodejs/node/issues/3402" target="_blank" rel="external">https://github.com/nodejs/node/issues/3402</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="//img.alicdn.com/tfs/TB1eKetLXXXXXalXVXXXXXXXXXX-900-500.jpg" alt="纠结的链接：ln、ln -s、fs.symlink、require"></p>
<p>最近在使用 <code>fs.symlink</code> 实现软链时，发现<a href="https://nodejs.org/api/fs.html#fs_fs_symlink_target_path_type_callback">文档</a>里面写的是：<code>fs.symlink(target, path)</code>；然而 <code>man ln</code> 的时候显示的是：<code>ln source_file target_file</code>；而且，<code>require</code> 模块的时候其实还会处理软链但是处理的又不是想象中那样。于是，我彻底被相关东西绕晕。这篇文章算是我的学习笔记，希望对你有帮助。</p>]]>
    
    </summary>
    
      <category term="链接" scheme="http://taobaofed.org/tags/%E9%93%BE%E6%8E%A5/"/>
    
      <category term="require" scheme="http://taobaofed.org/tags/require/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ES6 你可能不知道的事 - 基础篇]]></title>
    <link href="http://taobaofed.org/blog/2016/07/22/es6-basics/"/>
    <id>http://taobaofed.org/blog/2016/07/22/es6-basics/</id>
    <published>2016-07-22T03:32:30.000Z</published>
    <updated>2016-10-12T02:02:15.000Z</updated>
    <content type="html"><![CDATA[<p><img src="//img.alicdn.com/tfs/TB1HPI1KVXXXXbBXpXXXXXXXXXX-900-500.jpg" alt="ES6 你可能不知道的事 - 基础篇"></p>
<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>ES6，或许应该叫 ES2015（2015 年 6 月正式发布），对于大多数前端同学都不陌生。</p>
<p>首先这篇文章不是工具书，不会去过多谈概念，而是想聊聊关于每个特性 <strong>你可能不知道的事</strong>，希望能为各位同学 <strong>正确使用</strong> ES6，提供一些指导。</p>
<p>对于 ES6，有些同学已经在项目中有过深入使用了，有些则刚刚开始认识他，但不论你是属于哪一类，相信这篇文章都有适合你的部分。针对文章中的问题或不同意见，欢迎随时拍砖、指正。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="Let-Const"><a href="#Let-Const" class="headerlink" title="Let + Const"></a>Let + Const</h3><p>这个大概是开始了解 ES6 后，我们第一个感觉自己完全明白并兴致勃勃的开始使用的特性。</p>
<p>以如下方式使用的同学请举下手？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义常量</span></span><br><span class="line"><span class="keyword">const</span> REG_GET_INPUT = <span class="regexp">/^\d&#123;1,3&#125;$/</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义配置项</span></span><br><span class="line"><span class="keyword">let</span> config = &#123;</span><br><span class="line">  isDev : <span class="literal">false</span>,</span><br><span class="line">  pubDir: <span class="string">'./admin/'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入 gulp</span></span><br><span class="line"><span class="keyword">let</span> gulp    = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入gulp相关插件</span></span><br><span class="line"><span class="keyword">let</span> concat  = <span class="built_in">require</span>(<span class="string">'gulp-concat'</span>);</span><br><span class="line"><span class="keyword">let</span> uglify  = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>);</span><br><span class="line"><span class="keyword">let</span> cssnano = <span class="built_in">require</span>(<span class="string">'gulp-cssnano'</span>);</span><br></pre></td></tr></table></figure>
<p>很多人看完概念之后，第一印象都是：“<code>const</code> 是表示不可变的值，而 <code>let</code> 则是用来替换原来的 <code>var</code> 的。”</p>
<p>所以就会出现上面代码中的样子；一段代码中出现大量的 <code>let</code>，只有部分常量用 <code>const</code> 去做定义，这样的使用方式是错误的。</p>
<h4 id="你可能不知道的事"><a href="#你可能不知道的事" class="headerlink" title="你可能不知道的事"></a>你可能不知道的事</h4><p><code>const</code> 的定义是<strong>不可重新赋值</strong>的值，与不可变的值(immutable value)不同；<code>const</code> 定义的 Object，在定义之后仍可以修改其属性。</p>
<p>所以其实他的使用场景很广，包括常量、配置项以及引用的组件、定义的 “大部分” 中间变量等，都应该以<code>const</code>做定义。反之就 <code>let</code> 而言，他的使用场景应该是相对较少的，我们只会在 loop(for，while 循环)及少量必须重定义的变量上用到他。</p>
<blockquote>
<p>猜想：就执行效率而言，<code>const</code> 由于不可以重新赋值的特性，所以可以做更多语法静态分析方面的优化，从而有更高的执行效率。</p>
</blockquote>
<p>所以上面代码中，所有使用 <code>let</code> 的部分，其实都应该是用 <code>const</code> 的。</p>
<h3 id="Template-Strings（字符串模板）"><a href="#Template-Strings（字符串模板）" class="headerlink" title="Template Strings（字符串模板）"></a>Template Strings（字符串模板）</h3><p>字符串模板是我刚接触ES6时最喜欢的特性之一，他语法简洁，语义明确，而且很好的解决了之前字符串拼接麻烦的问题。</p>
<p>因为他并不是 “必须” 的，而且原有的字符串拼接思维根深蒂固，导致我们很容易忽视掉他。</p>
<h4 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h4><p>我们先来看看他的一般使用场景：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> start = <span class="string">'hi all'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getName = () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'jelly'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> conf = &#123;</span><br><span class="line">  fav: <span class="string">'Coding'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板</span></span><br><span class="line"><span class="keyword">const</span> msg = <span class="string">`<span class="subst">$&#123;start&#125;</span>, my name is <span class="subst">$&#123;getName()&#125;</span>, <span class="subst">$&#123;conf.fav&#125;</span> is my favourite`</span>;</span><br></pre></td></tr></table></figure>
<h4 id="你可能不知道的事-1"><a href="#你可能不知道的事-1" class="headerlink" title="你可能不知道的事"></a>你可能不知道的事</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 与引号混用</span></span><br><span class="line"><span class="keyword">const</span> wantToSay = <span class="string">`I'm a "tbfed"`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 支持多行文本</span></span><br><span class="line"><span class="keyword">const</span> slogan = </span><br><span class="line"><span class="string">`</span><br><span class="line">I have a dream today!</span><br><span class="line">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较适合写HTML</span></span><br><span class="line"><span class="keyword">const</span> resultTpl = </span><br><span class="line"><span class="string">`</span><br><span class="line">  &lt;section&gt;</span><br><span class="line">    &lt;div&gt;...&lt;/div&gt;</span><br><span class="line">  &lt;/section&gt;</span><br><span class="line">`</span>;</span><br></pre></td></tr></table></figure>
<h3 id="Enhanced-Object-Literals（增强的对象字面量）"><a href="#Enhanced-Object-Literals（增强的对象字面量）" class="headerlink" title="Enhanced Object Literals（增强的对象字面量）"></a>Enhanced Object Literals（增强的对象字面量）</h3><p>增强的对象字面量是 ES6 中的升华功能，他设计了很多简写，这些简写不但保留了明确的语义，还减少了我们多余的代码量。</p>
<p>当他的使用成为一个习惯时，我们会看到自己代码变得更为优雅。</p>
<h4 id="你可能不知道的事-2"><a href="#你可能不知道的事-2" class="headerlink" title="你可能不知道的事"></a>你可能不知道的事</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> _bookNum = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> basicConfig = &#123;</span><br><span class="line">  level: <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="comment">// 直接指定原型对象</span></span><br><span class="line">  __proto__: basicConfig,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 属性简写</span></span><br><span class="line">  _bookNum,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 方法简写</span></span><br><span class="line">  getBookNum() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.bookNum;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Arrows-and-Lexical-This（箭头函数）"><a href="#Arrows-and-Lexical-This（箭头函数）" class="headerlink" title="Arrows and Lexical This（箭头函数）"></a>Arrows and Lexical This（箭头函数）</h3><p>箭头函数是ES6中的一个新的语法特性，他的用法简单，形态优雅，备受人们青睐。</p>
<p>大多数同学初识这个特性时，更多的仅仅用它作为函数定义的简写，这其实就有些屈才了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 未使用箭头函数的写法</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  addOptions: <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  </span><br><span class="line">    options.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">name, opts</span>)</span>&#123;</span><br><span class="line">      </span><br><span class="line">      self[name] = self.addChild(name, opts);</span><br><span class="line">      </span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用箭头函数后的写法</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  addOptions: <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">    options.forEach((name, opts) =&gt; &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">this</span>[name] = <span class="keyword">this</span>.addChild(name, opts);</span><br><span class="line">      </span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以注意到上下两段代码的区别。</p>
<p>在未使用箭头函数前，我们在过程函数中使用父级 <code>this</code>，需要将其显式缓存到另一个中间变量中，因为过程函数有独立的 <code>this</code> 变量，会覆盖父级；使用箭头函数后，不但简写了一个过程函数（ <code>forEach</code> 的参数），还省略掉了 <code>this</code> 的中间变量的定义。</p>
<p><em><strong>原因：箭头函数没有独立执行上下文（ <code>this</code> ），所以其内部引用 <code>this</code> 对象会直接访问父级。</strong></em></p>
<blockquote>
<p>插播：原来我们定义这个中间变量还有一个有趣的现象，就是明明千奇百怪，例如 <code>self, that, me, _that, _me, Self...</code>，快站出来说说你用过哪个，还是哪几个~</p>
</blockquote>
<p>当然，从这块我们也可以看出，箭头函数是无法替代全部 <code>function</code> 的使用场景的，例如我们需要有独立 <code>this</code> 的函数。</p>
<h4 id="你可能不知道的事-3"><a href="#你可能不知道的事-3" class="headerlink" title="你可能不知道的事"></a>你可能不知道的事</h4><ol>
<li>箭头函数不但没有独立 <code>this</code>，他也没有独立的 <code>arguments</code>，所以如果需要取不定参的时候，要么使用 <code>function</code>，要么用  ES6 的另一个新特性 <strong>rest</strong>（具体在 rest 中会有详解）。</li>
<li>箭头函数语法很灵活，在只有一个参数或者只有一句表达式做方法体时，可以省略相应括号。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完整写法</span></span><br><span class="line"><span class="keyword">const</span> getOptions = (name, key) =&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略参数括号</span></span><br><span class="line"><span class="keyword">const</span> getOptions = key =&gt; &#123;</span><br><span class="line">  ... </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略参数和方法体括号</span></span><br><span class="line"><span class="keyword">const</span> getOptions = key =&gt; <span class="built_in">console</span>.log(key);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参数或方法体，括号不能省略</span></span><br><span class="line"><span class="keyword">const</span> noop = () =&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>有个简单小栗子，这一灵活的语法在写连续的Promise链式调用时，可以使代码更加优雅</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gitPromise</span><br><span class="line">  .then(() =&gt; git.add())</span><br><span class="line">  .then(() =&gt; git.commit())</span><br><span class="line">  .then(() =&gt; git.log())</span><br><span class="line">  .then((msg) =&gt; &#123;</span><br><span class="line">      ...</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(() =&gt; git.push())</span><br><span class="line">  .catch((err) =&gt; &#123;</span><br><span class="line">      utils.error(err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Destructuring（解构）"><a href="#Destructuring（解构）" class="headerlink" title="Destructuring（解构）"></a>Destructuring（解构）</h3><p>解构这个特性可以简单解读为分别定义，用于一次定义多个变量，常常用于分解方法返回对象为多个变量，分别使用。<br>使用过ES6的同学应该或多或少接触过这个特性，但是你可能不知道它如下几个用法：</p>
<h4 id="你可能不知道的事-4"><a href="#你可能不知道的事-4" class="headerlink" title="你可能不知道的事"></a>你可能不知道的事</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bookSet = [<span class="string">'UED'</span>, <span class="string">'TB fed'</span>, <span class="string">'Not find'</span>];</span><br><span class="line"><span class="keyword">const</span> bookCollection = () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;book1: <span class="string">'UED'</span>, book2: <span class="string">'TB fed'</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 解构也可以设置默认值</span></span><br><span class="line"><span class="keyword">const</span> &#123;book1, book3 = <span class="string">'Not find'</span>&#125; = bookCollection();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 解构数组时候是可以跳过其中某几项的</span></span><br><span class="line"><span class="keyword">const</span> [book1,,book3] = bookSet;  <span class="comment">// book1 = 'UED', book3 = 'Not find'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 解构可以取到指定对象的任何属性，包括它包含的方法</span></span><br><span class="line"><span class="keyword">const</span> &#123;length: setLength&#125; = bookSet;  <span class="comment">// setLength = 3</span></span><br></pre></td></tr></table></figure>
<h3 id="Rest-Spread"><a href="#Rest-Spread" class="headerlink" title="Rest + Spread"></a>Rest + Spread</h3><p>Rest 和 Spread 主要是应用 <code>...</code> 运算符，完成值的聚合和分解。</p>
<h4 id="你可能不知道的事-5"><a href="#你可能不知道的事-5" class="headerlink" title="你可能不知道的事"></a>你可能不知道的事</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 1. rest 得到的是一个真正的数组而不是一个伪数组</span></span><br><span class="line"><span class="keyword">const</span> getOptions = <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(args.join); <span class="comment">// function</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. rest 可以配合箭头函数使用，达到取得所有参数的目的</span></span><br><span class="line"><span class="keyword">const</span> getOptions = (...args) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(args); <span class="comment">// array</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. spread 可以用于解构时，聚合所得的值</span></span><br><span class="line"><span class="keyword">const</span> [opt1, ...opts] = [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>, <span class="string">'four'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. spread 可以用于数组定义</span></span><br><span class="line"><span class="keyword">const</span> opts = [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>, <span class="string">'four'</span>];</span><br><span class="line"><span class="keyword">const</span> config = [<span class="string">'other'</span>, ...opts];</span><br></pre></td></tr></table></figure>
<h3 id="Classes"><a href="#Classes" class="headerlink" title="Classes"></a>Classes</h3><p>ES6 中实现的一个语法糖，用于简化基于原型集成实现类定义的场景。<br>虽然有很多人不太喜欢这个特性，认为它作为一个简单增强扩展，并没有其他语言 class 应有的特点。<br>但是就我自己观点来看，还是感觉这样一种写法确实比原有的原型继承的写法语义更清晰、明确，而且语法更简单。</p>
<p>同样，可能有些用法是你之前容易忽略掉的，在此做个补充。</p>
<h4 id="你可能不知道的事-6"><a href="#你可能不知道的事-6" class="headerlink" title="你可能不知道的事"></a>你可能不知道的事</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 1. 静态变量</span></span><br><span class="line"><span class="comment">// ES6 的类定义实现了静态方法的定义，但静态变量呢？</span></span><br><span class="line"><span class="comment">// 可以用如下方式实现: </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TbFedMembers</span></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> get HuaChen()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'jelly'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">TbFedMembers.HuaChen; <span class="comment">// "化辰"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 私有属性（私有属性有多种实现方式，只谈及其中一种）</span></span><br><span class="line"><span class="comment">// 闭包</span></span><br><span class="line"><span class="keyword">const</span> TbFedMembers = (() =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> HuaChen = <span class="string">'jelly'</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span></span>&#123;</span><br><span class="line">    getOneMemberName()&#123;</span><br><span class="line">      <span class="keyword">return</span> HuaChen;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<h3 id="Promises"><a href="#Promises" class="headerlink" title="Promises"></a>Promises</h3><p>Promise 不只是一个对象、一个语法，他更是一种异步编程方式的变化<br>相信使用过 ES6 的同学都已经开始尝试了 Promise，甚至在不支持ES6的时候，已经开始使用一些基于 Promise 思想的开源框架。</p>
<p>那么我们之前用 Promise 究竟用的对么？有什么需要注意的点呢？</p>
<h4 id="你可能不知道的事-7"><a href="#你可能不知道的事-7" class="headerlink" title="你可能不知道的事"></a>你可能不知道的事</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 1. 多个异步任务同时执行用 Promise.all，顺序执行使用链式调用</span></span><br><span class="line"><span class="comment">// Promise.all</span></span><br><span class="line"><span class="built_in">Promise</span></span><br><span class="line">  .all([jsBuildPromise, cssBuildPromise])</span><br><span class="line">  .then(() =&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// chain</span></span><br><span class="line">jsBuildPromise</span><br><span class="line">  .then(() =&gt; cssBuildPromise)</span><br><span class="line">  .then(() =&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Promise 的链式调用需要每一个过程返回一个 Promise 对象才能保证顺序执行</span></span><br><span class="line">gitPromise</span><br><span class="line">  .then(() =&gt; git.add())  <span class="comment">// 正确，箭头函数简写</span></span><br><span class="line">  .then(() =&gt; &#123;</span><br><span class="line">    git.commit(); <span class="comment">// 错误，函数返回 undefined，会立即执行下一过程</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(() =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> git.log(); <span class="comment">// 正确</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. Promise 需要调用 catch 方法来捕获错误，而且过程内的错误不会阻塞后续代码执行</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(() =&gt; &#123;</span><br><span class="line">  f;  <span class="comment">// not define error !</span></span><br><span class="line">&#125;)</span><br><span class="line">.catch((err) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err)  <span class="comment">// show 'f is not define'</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'error test'</span>);  <span class="comment">// 此行可以被正常执行</span></span><br></pre></td></tr></table></figure>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>基础篇主要是讲了我们最常用的一些特性，后续如果大家感兴趣，还可以再来个 “进阶篇”，最后，希望文章中的部分内容可以对大家理解和使用 ES6 有所帮助。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.stackoverflow.com" target="_blank" rel="external">https://www.stackoverflow.com</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/Web/JavaScript</a></li>
<li><a href="https://babeljs.io/docs/learn-es2015/" target="_blank" rel="external">https://babeljs.io/docs/learn-es2015/</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/Web/JavaScript</a></li>
<li><a href="https://ponyfoo.com/articles/es6-spread-and-butter-in-depth" target="_blank" rel="external">https://ponyfoo.com/articles/es6-spread-and-butter-in-depth</a></li>
<li><a href="http://12devs.co.uk/articles/promises-an-alternative-way-to-approach-asynchronous-javascript/" target="_blank" rel="external">http://12devs.co.uk/articles/promises-an-alternative-way-to-approach-asynchronous-javascript/</a></li>
<li><a href="http://www.2ality.com/2015/01/es6-destructuring.html" target="_blank" rel="external">http://www.2ality.com/2015/01/es6-destructuring.html</a></li>
<li><a href="http://www.datchley.name/es6-rest-spread-defaults-and-destructuring/" target="_blank" rel="external">http://www.datchley.name/es6-rest-spread-defaults-and-destructuring/</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="//img.alicdn.com/tfs/TB1HPI1KVXXXXbBXpXXXXXXXXXX-900-500.jpg" alt="ES6 你可能不知道的事 - 基础篇"></p>
<h2 id="序"><a href="#序" class="head]]>
    </summary>
    
      <category term="ES6" scheme="http://taobaofed.org/tags/ES6/"/>
    
      <category term="JavaScript" scheme="http://taobaofed.org/tags/JavaScript/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[性能优化：memoization]]></title>
    <link href="http://taobaofed.org/blog/2016/07/14/performance-optimization-memoization/"/>
    <id>http://taobaofed.org/blog/2016/07/14/performance-optimization-memoization/</id>
    <published>2016-07-14T04:01:25.000Z</published>
    <updated>2016-10-12T02:02:15.000Z</updated>
    <content type="html"><![CDATA[<p><img src="//img.alicdn.com/tfs/TB1wxWIKVXXXXXOapXXXXXXXXXX-900-500.jpg" alt="性能优化：memoization"></p>
<p><code>memoization</code>适用于递归计算场景，例如 <a href="http://en.wikipedia.org/wiki/Fibonacci_number" target="_blank" rel="external">fibonacci 数值</a> 的计算。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> n = process.env.N || <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'process $'</span>, process.pid);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'fibonacci recursive version with n = '</span>, n);</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  count++;</span><br><span class="line">  <span class="comment">//console.log(count);</span></span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">fibonacci(n);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'process memory usage'</span>, process.memoryUsage());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'final count'</span>, count);</span><br></pre></td></tr></table></figure>
<p>如果使用这种递归的写法去计算第 50 个 fibonacci 数值，需要执行 40730022147 次。随着执行次数的增加，执行所需时间成指数上涨：</p>
<p><img src="https://gtms04.alicdn.com/tps/i4/TB1d7ebKpXXXXXdXVXXue9FUVXX-1917-2180.png" alt=""></p>
<p><code>memoization</code>的技巧在于将计算过的结果『缓存』下来，避免重复计算带来的成本，例如将计算 fibonacci 的代码改写为如下形式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> N = process.env.N || <span class="number">50</span>;</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fibonacci = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> memo = &#123;&#125;;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">let</span> value;</span><br><span class="line">    <span class="keyword">if</span> (n <span class="keyword">in</span> memo) &#123;</span><br><span class="line">      value = memo[n];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) &#123;</span><br><span class="line">        value = n;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        value = f(n - <span class="number">1</span>) + f(n - <span class="number">2</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      memo[n] = value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">fibonacci(N);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'process memory usage'</span>, process.memoryUsage());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'final count'</span>, count);</span><br></pre></td></tr></table></figure>
<p>计算第 50 个 fibonacci 值只需要 99 次，执行时间为 0.06 秒，只有递归版本执行时间（546.41 秒）的万分之一，使用的内存（RSS 值 20111360）只有递归版本（RSS 值为 36757504）的 54%。</p>
<blockquote>
<p> 值得注意的是：这里闭包使用的<code>memo</code>对象有可能造成内存泄露。</p>
</blockquote>
<p><img src="https://gtms01.alicdn.com/tps/i1/TB1Q88ZKpXXXXcmaXXX9gOTNXXX-1922-768.png" alt=""></p>
<h3 id="处理多个参数"><a href="#处理多个参数" class="headerlink" title="处理多个参数"></a>处理多个参数</h3><p>如果需要处理多个参数，需要把缓存的内容变成多维数据结构，或者把多个参数结合起来作为一个索引。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> N = process.env.N || <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fibonacci = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> memo = &#123;&#125;;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> value;</span><br><span class="line">    memo[x] = memo[x] || &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (x <span class="keyword">in</span> memo &amp;&amp; n <span class="keyword">in</span> memo[x]) &#123;</span><br><span class="line">      value = memo[x][n];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) &#123;</span><br><span class="line">        value = n;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        value = f(n - <span class="number">1</span>) + f(n - <span class="number">2</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      memo[x][n] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">fibonacci(<span class="string">'a'</span>, N);</span><br><span class="line">fibonacci(<span class="string">'b'</span>, N);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'process memory usage'</span>, process.memoryUsage());</span><br></pre></td></tr></table></figure>
<p>上面执行了两次<code>fibonacci</code>函数，假设执行多次：</p>
<p><img src="https://gtms01.alicdn.com/tps/i1/TB1hgewKpXXXXXLXpXXASkp1VXX-1954-918.png" alt=""></p>
<p>可以看到内存的增长也是有限的，并且最终控制在了<code>22097920</code>这个值。下面是另一种处理多个参数的情况（将多个参数组成一个索引）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> N = process.env.N || <span class="number">50</span>;</span><br><span class="line"><span class="keyword">let</span> count;</span><br><span class="line"><span class="keyword">let</span> memo = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> slice = <span class="built_in">Array</span>.prototype.slice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fibonacci = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  count = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, n</span>) </span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">let</span> args = slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">let</span> value;</span><br><span class="line">    memo[x] = memo[x] || &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (args <span class="keyword">in</span> memo) &#123;</span><br><span class="line">      value = memo[args];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(n == <span class="number">0</span> || n == <span class="number">1</span>) &#123;</span><br><span class="line">        value = n;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        value = f(x, n - <span class="number">1</span>) + f(x, n - <span class="number">2</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      memo[args] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">  count = <span class="number">0</span>;</span><br><span class="line">  result = fibonacci(<span class="string">'#'</span> + i, i);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'process memory usage'</span>, process.memoryUsage());</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'final count'</span>, count);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'result of #'</span> + i, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与上面版本相比，内存有所增加，速度有所下降：</p>
<p><img src="https://gtms02.alicdn.com/tps/i2/TB1x71oKpXXXXcEXpXXj7Qt5VXX-3824-2270.png" alt="50 次对比" title="50 次对比"></p>
<p><img src="https://gtms03.alicdn.com/tps/i3/TB1TTt8KpXXXXc9XVXX4nXcUXXX-3832-2300.png" alt="100 次对比" title="100 次对比"></p>
<p><img src="https://gtms04.alicdn.com/tps/i4/TB18uugKpXXXXb9XFXXX9u8OXXX-3820-2304.png" alt="1000 次对比" title="1000 次对比"></p>
<h3 id="自动memoization"><a href="#自动memoization" class="headerlink" title="自动memoization"></a>自动<code>memoization</code></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">memoize</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> memo = &#123;&#125;;</span><br><span class="line">  <span class="keyword">let</span> slice = <span class="built_in">Array</span>.prototype.slice;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> args = slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">if</span> (args <span class="keyword">in</span> memo) &#123;</span><br><span class="line">      <span class="keyword">return</span> memo[args];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> memo[args] = func.apply(<span class="keyword">this</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是需要注意的是，并不是所有函数都可以自动<code>memoization</code>，只有<code>referential transparency</code>（引用透明）的函数可以。所谓<code>referential transparency</code>的函数是指：函数的输出完全由其输入决定，且不会有副作用的函数。下面的函数就是一个反例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo 函数的结果还受到全局变量 bar 的影响</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">baz</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> baz + bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>);</span><br><span class="line">bar++;</span><br><span class="line">foo(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>对比自动<code>memoization</code>前后的两个版本：</p>
<p><img src="https://gtms02.alicdn.com/tps/i2/TB1soOyKpXXXXaPXVXX28mEJXXX-3814-420.png" alt=""></p>
<p>自动<code>memoization</code>处理后的版本有所提高，但相比手动完全<code>memoization</code>的版本效率还是差了很多。</p>
<p>其实<code>memoization</code>这个词来自人工智能研究领域，其词源为拉丁语<code>memorandum</code>，这个词的创造者为<a href="http://www.aiai.ed.ac.uk/~dm/dm.html" target="_blank" rel="external">Donald Michie</a>，这种函数的设计初衷是为了提升机器学习的性能。随着函数式编程语言（Functional Programming，简称 FP）的兴起，例如 JavaScript、Haskell 以及 Erlang，这种用法才变得越来越流行。在前端编程中，可以使用<code>memoization</code>去处理各种需要递归计算的场景，例如缓存 canvas 动画的计算结果。</p>
<p>上面自动<code>memoization</code>的结果并不理想，可以参考<code>underscore</code>和<code>lodash</code>的<code>memoize</code>来做优化。</p>
<p>使用<a href="https://github.com/lodash/lodash/blob/145c3abb34ae327679d90d18804c7b955398c390/vendor/underscore/underscore.js#L777" target="_blank" rel="external"><code>lodash</code>的<code>memoize</code></a>方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * @filename: fibonacci-memoization-with-lodash.js</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> n = process.env.N || <span class="number">50</span>;</span><br><span class="line"><span class="keyword">let</span> _ = <span class="built_in">require</span>(<span class="string">'lodash'</span>);</span><br><span class="line"><span class="keyword">let</span> memoize = _.memoize;</span><br><span class="line"><span class="keyword">let</span> fibonacci = <span class="built_in">require</span>(<span class="string">'./fibonacci-recursive.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newFibonacci = memoize(fibonacci);</span><br><span class="line"><span class="keyword">let</span> result = newFibonacci(n);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'process memory usage'</span>, process.memoryUsage());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'result'</span>, result);</span><br></pre></td></tr></table></figure>
<p>对比结果：</p>
<p><img src="http://gtms01.alicdn.com/tps/i1/TB1pHCxKpXXXXcsXVXXT7Jp5pXX-3760-400.png" alt=""></p>
<p>可以看到<code>lodash</code>的<code>memoize</code>方法减少了一半执行时间。进一步优化：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">memoize</span>(<span class="params">func, context</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">memoizeArg</span>(<span class="params">argPos</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cache = &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (argPos == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(<span class="built_in">arguments</span>[argPos] <span class="keyword">in</span> cache)) &#123;</span><br><span class="line">          cache[<span class="built_in">arguments</span>[argPos]] = func.apply(context, <span class="built_in">arguments</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cache[<span class="built_in">arguments</span>[argPos]];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(<span class="built_in">arguments</span>[argPos] <span class="keyword">in</span> cache)) &#123;</span><br><span class="line">          cache[<span class="built_in">arguments</span>[argPos]] = memoizeArg(argPos - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cache[<span class="built_in">arguments</span>[argPos]].apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> arity = func.arity || func.length;</span><br><span class="line">  <span class="keyword">return</span> memoizeArg(arity - <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="http://gtms01.alicdn.com/tps/i1/TB1q4SZKpXXXXcRXXXXusZkMpXX-1918-320.png" alt=""></p>
<blockquote>
<p> 科普下：<code>function arity</code>指的是一个函数接受的参数个数，这是一个被废弃的属性，现在应使用<code>Function.prototype.length</code>。<br> <a href="https://stackoverflow.com/questions/4848149/get-a-functions-arity" target="_blank" rel="external">https://stackoverflow.com/questions/4848149/get-a-functions-arity</a></p>
</blockquote>
<p>zakas 的版本更加快，甚至比我们将<code>fibonacci</code>手动<code>memoization</code>的版本还快：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">let</span> n = process.env.N || <span class="number">50</span>;</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">memoizer</span>(<span class="params">fundamental, cache</span>) </span>&#123;</span><br><span class="line">  cache = cache || &#123;&#125;;</span><br><span class="line">  <span class="keyword">let</span> shell = <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cache.hasOwnProperty(arg)) &#123;</span><br><span class="line">      cache[arg] = fundamental(shell, arg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cache[arg];</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> shell;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fibonacci = memoizer(<span class="function"><span class="keyword">function</span>(<span class="params">recur, n</span>) </span>&#123;</span><br><span class="line">  count++;</span><br><span class="line">  <span class="keyword">return</span> recur(n - <span class="number">1</span>) + recur(n - <span class="number">2</span>);</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="number">1</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = fibonacci(n);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'process memory usage'</span>, process.memoryUsage());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'count'</span>, count);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'result'</span>, result);</span><br></pre></td></tr></table></figure>
<p><img src="http://gtms02.alicdn.com/tps/i2/TB1taHXKpXXXXXqXXXXHSJCLpXX-1916-570.png" alt=""></p>
<p>但是上面这些函数都存在问题，如果输入数目过大，会引发调用栈超过限制异常：<code>RangeError: Maximum call stack size exceeded</code>。</p>
<p>一种解决的方法就是将递归（<code>recursion</code>）修改为迭代（<code>iteration</code>）。例如下面这样的归并排序算法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> n = process.env.N || <span class="number">100</span>;</span><br><span class="line"><span class="keyword">let</span> isMemoized = process.env.M;</span><br><span class="line"><span class="keyword">let</span> test = [];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (left.length &gt; <span class="number">0</span> &amp;&amp; right.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left[<span class="number">0</span>] &lt; right[<span class="number">0</span>]) &#123;</span><br><span class="line">      result.push(left.shift());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.push(right.shift());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result.concat(left).concat(right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">items</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (items.length == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> items;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> middle = <span class="built_in">Math</span>.floor(items.length / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">let</span> left = items.slice(<span class="number">0</span>, middle);</span><br><span class="line">    <span class="keyword">let</span> right = items.slice(middle);</span><br><span class="line">    <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">  test.push(<span class="built_in">Math</span>.random() * <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result;</span><br><span class="line"><span class="keyword">if</span> (isMemoized) &#123;</span><br><span class="line">  <span class="keyword">let</span> memoize = <span class="built_in">require</span>(<span class="string">'./zakas-memo.js'</span>);</span><br><span class="line">  mergeSort = memoize(mergeSort);</span><br><span class="line">  result = mergeSort(test);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  result = mergeSort(test);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'process memory usage'</span>, process.memoryUsage());</span><br></pre></td></tr></table></figure>
<p><img src="http://gtms01.alicdn.com/tps/i1/TB1L8uRKpXXXXbkXFXXDHvXMXXX-3822-622.png" alt=""></p>
<p>而上面的排序函数在经过<code>memoization</code>后虽然不会抛出<code>RangeError: Maximum call stack size exceeded</code>的异常，但是在极端情况下也会因为内存不够分配导致失败：</p>
<p><img src="https://gtms02.alicdn.com/tps/i2/TB1XrjXKpXXXXaxXXXXrdqLOXXX-1926-1882.png" alt=""></p>
<p>解决<code>RangeError: Maximum call stack size exceeded</code>异常的一种方法是将递归的代码改写为迭代的代码，例如<code>fibonacci</code>的递归式写法为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  n = <span class="built_in">parseInt</span>(n);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'n = '</span>, n);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isNaN</span>(n)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> first = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> prev = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> sum;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">      sum = n;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        sum = first + prev;</span><br><span class="line">        first = prev;</span><br><span class="line">        prev = sum;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'i = '</span> + i + <span class="string">':'</span> + <span class="string">' sum = '</span> + sum);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="他山之石"><a href="#他山之石" class="headerlink" title="他山之石"></a>他山之石</h3><p>在 JavaScript 中我们是通过函数的形式来是实现函数的<code>memoization</code>，在 Python 中还可以用另一种被称为<code>decorator</code>的形式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">memoize</span><span class="params">(f)</span>:</span></span><br><span class="line">    memo = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> memo:</span><br><span class="line">            memo[x] = f(x)</span><br><span class="line">        <span class="keyword">return</span> memo[x]</span><br><span class="line">    <span class="keyword">return</span> helper</span><br><span class="line"></span><br><span class="line"><span class="meta">@memoize</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">print(fib(<span class="number">100</span>))</span><br></pre></td></tr></table></figure>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://www.sitepoint.com/implementing-memoization-in-javascript/" target="_blank" rel="external">https://www.sitepoint.com/implementing-memoization-in-javascript/</a></li>
<li><a href="http://en.wikipedia.org/wiki/Referential_transparency_(computer_science" target="_blank" rel="external">Referential transparency</a>)</li>
<li><a href="https://addyosmani.com/blog/faster-javascript-memoization/" target="_blank" rel="external">https://addyosmani.com/blog/faster-javascript-memoization/</a></li>
<li><a href="http://unscriptable.com/index.php/2009/05/01/a-better-javascript-memoizer/" target="_blank" rel="external">http://unscriptable.com/index.php/2009/05/01/a-better-javascript-memoizer/</a></li>
<li><a href="http://www.nczonline.net/blog/2009/01/27/speed-up-your-javascript-part-3/" target="_blank" rel="external">http://www.nczonline.net/blog/2009/01/27/speed-up-your-javascript-part-3/</a></li>
<li><a href="http://books.google.co.uk/books?id=PXa2bby0oQ0C&amp;pg=PA44&amp;lpg=PA44&amp;dq=crockford+memoization&amp;source=bl&amp;ots=HImnm6r1iH&amp;sig=lrdT9Sk4F4yQ-xQ-TLTx4SpLkuk&amp;hl=en&amp;ei=C-hyTvaIEofB8QO21Nn_DQ&amp;sa=X&amp;oi=book_result&amp;ct=result&amp;resnum=4&amp;ved=0CDMQ6AEwAw#v=onepage&amp;q&amp;f=false" target="_blank" rel="external">http://books.google.co.uk/books?id=PXa2bby0oQ0C&amp;pg=PA44&amp;lpg=PA44&amp;dq=crockford+memoization&amp;source=bl&amp;ots=HImnm6r1iH&amp;sig=lrdT9Sk4F4yQ-xQ-TLTx4SpLkuk&amp;hl=en&amp;ei=C-hyTvaIEofB8QO21Nn_DQ&amp;sa=X&amp;oi=book_result&amp;ct=result&amp;resnum=4&amp;ved=0CDMQ6AEwAw#v=onepage&amp;q&amp;f=false</a></li>
<li><a href="http://my.safaribooksonline.com/book/programming/javascript/9781449399115/functions/function_propertiesma_memoization_patter#X2ludGVybmFsX0ZsYXNoUmVhZGVyP3htbGlkPTk3ODE0NDkzOTkxMTUvNzY=" target="_blank" rel="external">http://my.safaribooksonline.com/book/programming/javascript/9781449399115/functions/function_propertiesma_memoization_patter#X2ludGVybmFsX0ZsYXNoUmVhZGVyP3htbGlkPTk3ODE0NDkzOTkxMTUvNzY=</a></li>
<li>memoize function javascript | npm memoize | lodash memoize | underscore memoize</li>
<li><a href="http://unscriptable.com/2009/05/01/a-better-javascript-memoizer/" target="_blank" rel="external">http://unscriptable.com/2009/05/01/a-better-javascript-memoizer/</a></li>
<li>programming optimization techniques</li>
<li><a href="http://blog.stevenlevithan.com/archives/timed-memoization" target="_blank" rel="external">http://blog.stevenlevithan.com/archives/timed-memoization</a></li>
<li><a href="https://github.com/addyosmani/memoize.js" target="_blank" rel="external">https://github.com/addyosmani/memoize.js</a></li>
<li><a href="https://en.wikipedia.org/wiki/Arity" target="_blank" rel="external">function arity</a></li>
<li><a href="https://philogb.github.io/blog/2008/09/05/memoization-in-javascript/" target="_blank" rel="external">https://philogb.github.io/blog/2008/09/05/memoization-in-javascript/</a></li>
<li><a href="https://stackoverflow.com/questions/6184869/what-is-difference-between-memoization-and-dynamic-programming" target="_blank" rel="external">https://stackoverflow.com/questions/6184869/what-is-difference-between-memoization-and-dynamic-programming</a></li>
<li><a href="http://www.python-course.eu/python3_memoization.php" target="_blank" rel="external">http://www.python-course.eu/python3_memoization.php</a></li>
<li><a href="https://en.wikipedia.org/wiki/Iteration" target="_blank" rel="external">https://en.wikipedia.org/wiki/Iteration</a></li>
<li><a href="https://en.wikipedia.org/wiki/Iterated_function" target="_blank" rel="external">https://en.wikipedia.org/wiki/Iterated_function</a></li>
<li><a href="https://www.ics.uci.edu/~eppstein/161/960109.html" target="_blank" rel="external">https://www.ics.uci.edu/~eppstein/161/960109.html</a></li>
<li><a href="https://classes.soe.ucsc.edu/cmpe012/Summer09/labs/lab8-Recursion-vs-Iteration/" target="_blank" rel="external">https://classes.soe.ucsc.edu/cmpe012/Summer09/labs/lab8-Recursion-vs-Iteration/</a></li>
<li>google: iterative merge sort</li>
<li>google: maximum call stack size exceeded | avoid maximum recursive</li>
<li><a href="http://www.python-course.eu/python3_decorators.php" target="_blank" rel="external">http://www.python-course.eu/python3_decorators.php</a></li>
<li><a href="https://www.cs.cornell.edu/courses/cs3110/2011sp/lectures/lec22-memoization/memo.htm" target="_blank" rel="external">https://www.cs.cornell.edu/courses/cs3110/2011sp/lectures/lec22-memoization/memo.htm</a></li>
<li>dynamic programming</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="//img.alicdn.com/tfs/TB1wxWIKVXXXXXOapXXXXXXXXXX-900-500.jpg" alt="性能优化：memoization"></p>
<p><code>memoization</code>适用于递归计算场景，]]>
    </summary>
    
      <category term="性能优化" scheme="http://taobaofed.org/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="javascript" scheme="http://taobaofed.org/tags/javascript/"/>
    
      <category term="memoization" scheme="http://taobaofed.org/tags/memoization/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[聊一聊淘宝首页和它背后的一套]]></title>
    <link href="http://taobaofed.org/blog/2016/06/02/thing-about-taobao-homepage/"/>
    <id>http://taobaofed.org/blog/2016/06/02/thing-about-taobao-homepage/</id>
    <published>2016-06-02T06:45:32.000Z</published>
    <updated>2016-10-12T02:02:15.000Z</updated>
    <content type="html"><![CDATA[<p><img src="//img.alicdn.com/tfs/TB1dcfNKXXXXXXcXVXXXXXXXXXX-900-500.png" alt="聊一聊淘宝首页和它背后的一套"></p>
<p>从 14 年双十二结束开始接手淘宝首页，到如今差不多 1 年半时间了，不久前完成了首页相关工作的交接。经历了两次改版和一次从 PHP 到 Node 的迁移，还是颇有感受，下面给大家分享下。</p>
<h3 id="一、相关背景介绍"><a href="#一、相关背景介绍" class="headerlink" title="一、相关背景介绍"></a>一、相关背景介绍</h3><p>淘宝首页是淘宝的门面，承载着几乎淘系所有业务的入口，流量很大，量级单位为亿。近几年无线端崛起，业务重点开始向无线终端偏移（目前不能叫偏移，基本以无线为主了），所以淘宝 PC 端首页的流量也有削减，不过即便如此，它的日均 PV 依然相当高。</p>
<p>淘宝首页一向是内部平台和技术的试验田，它一直在变化着。最新的框架和系统都会找淘宝首页试点，可以试想下，如果某一项需要推动的升级或者优化措施在淘宝首页已经上线，并且拿到了良好的数据和稳定性，其他业务还有什么理由不去尝试和更迭呢？同时，去年一年身在淘宝前端的技术架构组，自然而然也会主动去 push 一些实验性的内容到业务上。</p>
<p>淘系的站点页面包括首页、其他频道页和活动页等，这些页面并不都由淘宝前端一行一行的代码码出来，业务如此之多，这种玩法即便人数 double 也忙不过来。事实上，大多数页面都是依托内部的搭建平台——运营或者前端通过模块搭建的方式——构建的，而前端 focus 的重点在于搭建平台的建设自身以及模块的通用性和复用率的保障，当然，还有一些工程化的东西。</p>
<p>使用搭建平台搭建的页面，前端只需要考虑组成页面的原子模块的开发，整体的渲染由搭建平台提供的统一脚本全权负责。而在淘宝首页上，考虑到页面模块数量巨多，加上还有少量跨部门、跨团队的沟通，渲染模型略微不同。</p>
<h3 id="二、淘宝首页的整体变迁"><a href="#二、淘宝首页的整体变迁" class="headerlink" title="二、淘宝首页的整体变迁"></a>二、淘宝首页的整体变迁</h3><p>背景中提到，淘宝首页依托于内部搭建平台，它的变迁自然也是跟着搭建系统的变化而变化的。</p>
<h4 id="1-PHP-下的淘宝首页"><a href="#1-PHP-下的淘宝首页" class="headerlink" title="1. PHP 下的淘宝首页"></a>1. PHP 下的淘宝首页</h4><p>接手淘宝首页不久，便遇到了一年一度的改版，那时它还运行在 PHP 环境中。这里需要说明的是，淘宝首页的所有代码完全由前端掌控，前端不会直接跟数据库打交道，其数据来源分为两部分。</p>
<p><strong>数据来源</strong></p>
<p>一是 <em>运营填写的数据。</em> 采用前端挖坑的形式，预留坑位让运营获取填写数据，如（伪代码）：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> $info = Person(<span class="string">'name:String:姓名,age:Number:年龄'</span>, <span class="string">'个人信息坑位填写'</span>);<span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;div&gt;</span><br><span class="line"><span class="meta">&lt;?php</span> $info.<span class="keyword">forEach</span>(index) &#123; <span class="meta">?&gt;</span></span><br><span class="line">  Name: <span class="meta">&lt;?</span>= info[index].name <span class="meta">?&gt;</span>, Age: <span class="meta">&lt;?</span>= info[index].age <span class="meta">?&gt;</span></span><br><span class="line"><span class="meta">&lt;?php</span> &#125; <span class="meta">?&gt;</span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>上面的代码会产生一份 PHP 的模板和 info 字段对应的表单坑位，这个过程简称「挖坑」。</p>
<p><img src="http://ww4.sinaimg.cn/large/6c0378f8gw1f4g54zdicej20do09cdfy.jpg" alt="挖坑"></p>
<p>运营填写这些坑位就会产生这份 PHP 模板对应的数据，最后渲染出来就是一个完整的 HTML 片段（实时性渲染）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── data.json   <span class="comment"># 运营数据的来源</span></span><br><span class="line">└── index.php   <span class="comment"># 装载运营数据的 PHP 模板</span></span><br></pre></td></tr></table></figure>
<p>旧版搭建系统中就是通过这种方式构造一个子模块。我描述得十分简单，但作为一个平台它需要考虑的东西还有很多很多的，比如数据顺序的控制、定时发布、回滚机制、过滤机制、筛选机制、数据的同步、数据的更新、版本控制、权限控制、其他系统的引用等等。</p>
<p>二是 <em>后端或者个性化平台提供的数据。</em> 不同的业务有不同的诉求。一些业务有自己的后端，他们要求使用自己业务产出的数据；有的业务希望用户看到的内容不一样，千人千面，期望接入算法；一些业务跟卖家直接打交道，期望使用招商数据；而有些业务期望采用运营从数据池筛选出来的数据…总之，淘宝首页需要对接形形色色的系统，接口繁多。后面会提到对动态数据源的整合。</p>
<p>并且这些系统对应的域名是不一样的，JSONP 格式自然也就成了首选。但一些特殊的系统，比如广告，它的渲染并不是一个简单的 JSONP 请求，可能它还要干预整个广告的渲染流程，比如加载他们的 JS，把渲染的控制权交过去。</p>
<p><strong>页面的架构</strong></p>
<p>上面介绍了数据的来源和子模块的结构，那么整个页面又是如何构成的呢？模块的搭建分为两种，一种是可视化搭建，运营或者前端可以将开发好的模块（或者模块库中选取的模块）拖拽到容器内，形成一个页面，</p>
<p><img src="http://ww2.sinaimg.cn/large/6c0378f8gw1f4g51ddlmzj21ao0x4dij.jpg" alt="模块搭建"></p>
<p>当然，上图也只是一个模型，作为一个系统需要考虑的问题还有很多很多，如页面的布局、多终端适配、模块的临时隐藏、位置调整、皮肤选择、模块的复制等等。</p>
<p>也可以通过如下源码搭建的方式（伪代码）：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  <span class="meta">&lt;?</span>= loadModule(Mod1ID) <span class="meta">?&gt;</span></span><br><span class="line">  <span class="meta">&lt;?</span>= loadModule(Mod2ID) <span class="meta">?&gt;</span></span><br><span class="line">  <span class="meta">&lt;?</span>= loadModule(Mod3ID, <span class="string">'lazyload'</span>) <span class="meta">?&gt;</span></span><br><span class="line">  <span class="meta">&lt;?</span>= loadModule(Mod4ID, <span class="string">'lazyload'</span>) <span class="meta">?&gt;</span></span><br><span class="line">  <span class="meta">&lt;?</span>= loadModule(Mod5ID, <span class="string">'lazyload'</span>) <span class="meta">?&gt;</span></span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<p>通过模块 id 将模块引入，并且添加一些类似 <code>lazyload</code> 的标记，方便控制渲染节奏和数据入口。源码搭建和模块搭建的区别在于，前者更易于控制模块的结构以及模块的渲染顺序。</p>
<p><strong>动态数据源</strong></p>
<p>首页面对一大堆接口和平台，对接几十个业务方，接口是个很大的问题，由于后台系统的差异，基本没有办法统一数据源的格式，一旦运营哪天心血来潮要换一个他自己觉得用的更爽的或者数据更好的系统，前后端估计又得沟通和对接几次。所以出现了下面这张图：</p>
<p><img src="http://ww2.sinaimg.cn/large/6c0378f8gw1f4g5mwl5jzj218w0psdia.jpg" alt="动态数据源"></p>
<p>平台具备数据源接入的能力，也就是说我们挖的坑不仅仅可以让运营填数据，还可以从各种数据源中直接导入数据，当然，这里需要进行一次数据字段的映射转换。后端提供的接口是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"data"</span>: [&#123;</span><br><span class="line">    <span class="string">"item_name"</span>: <span class="string">"name"</span>,</span><br><span class="line">    <span class="string">"item_url"</span>: <span class="string">"http://xxx"</span>,</span><br><span class="line">    <span class="string">"item_pic"</span>: <span class="string">"http://xxx"</span></span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前端约定的接口形式是: </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"info"</span>: [&#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"name"</span>,</span><br><span class="line">    <span class="string">"url"</span>: <span class="string">"http://xxx"</span></span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么系统必须提供这种映射的绑定策略：</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">info</span>/<span class="keyword">name</span> -&gt;</span> <span class="keyword">data</span>/item_name</span><br><span class="line"><span class="function"><span class="title">info</span>/url -&gt;</span> <span class="keyword">data</span>/item_url</span><br></pre></td></tr></table></figure>
<p>绑定之后，数据既可以同步输出，也可以异步输出，这些都是平台提供的能力。这个方案基本上解决了后端系统/接口变化的问题，并且减少了前后端之间的沟通成本。</p>
<p>不过这里需要注意的是，虽然页面上的接口都通过平台统一梳理了一次，这也意味着，页面所有的请求会先流经平台，然后分发到各个后端，平台的抗压能力要求很高。</p>
<h4 id="2-PHP-到-Node-的变迁"><a href="#2-PHP-到-Node-的变迁" class="headerlink" title="2. PHP 到 Node 的变迁"></a>2. PHP 到 Node 的变迁</h4><p>淘宝首页日均请求的这个量级，不可能是十几二十台台服务器抗得住的，支撑它必须有一个服务集群。</p>
<p><img src="http://ww4.sinaimg.cn/large/6c0378f8gw1f4g6rdqpd0j212o0s076f.jpg" alt="集群"></p>
<p>每一个 CDN 节点上都具备 PHP 渲染的能力，当页面发布时，我们把该页面所有的模块和数据同步到全部 CDN 节点上，基本模式大概就是如此了。看起来还挺不错，但是经过一段时间的运维，很多安全、性能问题都慢慢浮现出来了：</p>
<p><em>性能问题。</em> 每个 PHP 页面包含多个子模块，而子模块也有可能引用了其他的子模块，PHP 的 <code>include</code> 操作是存在消耗的，每一次引用都是一次磁盘 IO，一个渲染节点上跑了成千上万个类似淘宝首页的 PHP 页面，并发一高其效率可想而知。</p>
<p><em>推送机制问题。</em> 文件同步（图中的 <code>sync</code> 动作）是一种比较恶心的机制，首先，时间上没法控制，一个文件同步到所有的节点，快则几秒钟，慢的话耗时会超过一两分钟；并且同步过程还有可能失败，健康检测的成本也是相当高的。发布比较紧凑时，需要同步的文件也很多，很容易造成队列堆积，加剧同步差的体验。</p>
<p><em>实时性强需求问题。</em> 文件在推送之前，还可能经过一些前置系统，发布链路越长，线上生效时间越慢，慢的时候大约五分钟才生效，这样的延时对于实时性要求很高（如秒杀）的需求来说是完全不能接受的。</p>
<p>当然，还有很多其他问题，如运维成本增高、安全风险增高、PHP 资深人才储备不足等等。所以 PHP 渲染容器的命运，就是，被干掉。</p>
<p><img src="http://ww4.sinaimg.cn/large/6c0378f8gw1f4g7eogvy9j21840tatb1.jpg" alt="回源"></p>
<p>上图改变了下玩法，服务集群为 Cache CDN，它只有静态文件处理能力，没有 PHP/Node 的渲染能力，所以处理效率高，性能也好，抗压能力相当强，并且扛不住的时候还可以花钱买服务，拓展 Cache 集群。</p>
<p>用户访问时，Nginx 转到 Cache CDN，如果命中缓存则直接返回，没有命中便回源到源站服务器。源站服务器是具备模块渲染能力的 Node 服务，它可以做很多事情：</p>
<ul>
<li>控制 Cache 响应头，通过 <code>max-age</code> 和 <code>s-maxage</code> 控制页面在客户端的缓存时间以及在 Cache 上的缓存时间，这个缓存时间可以根据需求随时做调整，比如大促的时候调长一些</li>
<li>控制内外网环境，和 AB 测试状态</li>
<li>融合前端相关的工具链，比如检测、压缩、过滤等等</li>
</ul>
<p>它的优势有很多，这里不一一列举了。这个模式中还添加了一层容灾，源站服务器每隔一段时间将数据推送到于 Cache 同机房的备份服务器，一点源站挂了，还能够自动容灾到备份数据上。</p>
<p>模式的变化不仅在运维上有了突破，CDN 被攻击时的安全风险也低了很多，同时也省却了 sync 所需的各种检测机制，每年节约成本也是百万以上，优势还是相当明显。</p>
<h4 id="3-Node，不一样的模式"><a href="#3-Node，不一样的模式" class="headerlink" title="3. Node，不一样的模式"></a>3. Node，不一样的模式</h4><p>上面 PHP 模块中，我们只说了 HTML 和数据部分，用心的读者应该已经发现，CSS 和 JS 这些静态资源都没提到，那页面是如何渲染的呢？</p>
<p>旧版 PHP 页面中，我们是直接引入了一个 CSS 和一个 JS，淘宝这边采用的是 git 版本迭代发布，这些静态资源都是直接放在一个 git 仓库中。也就是这样：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"//cdn/@VERSION@/index.css"</span>&gt;</span><br><span class="line">  &lt;script src=<span class="string">"//cdn/@VERSION@/index.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  <span class="meta">&lt;?</span>= loadModule(Mod1ID) <span class="meta">?&gt;</span></span><br><span class="line">  <span class="meta">&lt;?</span>= loadModule(Mod2ID) <span class="meta">?&gt;</span></span><br><span class="line">  <span class="meta">&lt;?</span>= loadModule(Mod3ID, <span class="string">'lazyload'</span>) <span class="meta">?&gt;</span></span><br><span class="line">  <span class="meta">&lt;?</span>= loadModule(Mod4ID, <span class="string">'lazyload'</span>) <span class="meta">?&gt;</span></span><br><span class="line">  <span class="meta">&lt;?</span>= loadModule(Mod5ID, <span class="string">'lazyload'</span>) <span class="meta">?&gt;</span></span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<p>每次发布完 git 文件，再修改 PHP 的版本号，然后发布 PHP 代码。当然，也做了相关的优化，比如发布 git 时自动更新版本号等。</p>
<p>而新版搭建平台的页面渲染模式与 PHP 的模式不太一样。</p>
<p><img src="http://ww1.sinaimg.cn/large/6c0378f8gw1f4g8566uz3j21kw0yt79h.jpg" alt="Node渲染模型"></p>
<p>一个模块的 CSS/JS 和模板放在一起，CSS/JS 与页面其他模块的静态资源是相互独立的，目的就是希望单个模块也能够完整的跑起来，更加利于模块的复用。</p>
<p>而模块的挖坑，也从模板中独立了出来，采用 JSON Schema 的形式定义数据格式，</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── <span class="keyword">index</span>.css    <span class="meta"># 模块样式</span></span><br><span class="line">├── <span class="keyword">index</span>.js     <span class="meta"># 模块渲染脚本</span></span><br><span class="line">├── schema.json  <span class="meta"># schema 配置</span></span><br><span class="line">└── <span class="keyword">index</span>.xtpl   <span class="meta"># 模块的模板</span></span><br></pre></td></tr></table></figure>
<p>搭建平台通过这个 JSON Schema 解析成 <a href="http://ww4.sinaimg.cn/large/6c0378f8gw1f4g54zdicej20do09cdfy.jpg" target="_blank" rel="external">图一</a> 的坑位。那么一个模块的渲染就变成了 <code>index.xtpl</code> 和挖坑数据之间的拼装了。</p>
<p>模块之间相互独立隔离，所以会存在一定程度的冗余，不过模块解偶带来的收益要比这点冗余要多得多。事实上，我们是通过一个仓库去管理单个模块的。页面的渲染就比较简单了，源站 Node 容器会将所有的 <code>index.xtpl</code> 合并成一个 <code>page.xtpl</code>，为减少页面请求，css 和 js 也会 combo 成一个文件，如上图所示的 <code>http://cdn/??mod1.css,mod2.css,mod3.css</code>。</p>
<p>任何模块的更新，页面都会有感知，下次进入系统时，就会提示是否需要升级模块和页面。</p>
<h3 id="三、淘宝首页的性能优化"><a href="#三、淘宝首页的性能优化" class="headerlink" title="三、淘宝首页的性能优化"></a>三、淘宝首页的性能优化</h3><p>首页模块众多，如果一口气吐出来，DOM 数量必然超过 4k 个，其结果就是首屏时间极长。按照 TMS 的开发规范，每个 TMS 模块都包含一个 <code>index.js</code> 和 <code>index.css</code>，最后展示出来两个 combo 的 js 和 css。首页加载的时候也不会一口气执行所有 <code>index.js</code>，否则刚开始页面阻塞会十分严重。</p>
<p><strong>页面的渲染逻辑</strong></p>
<p><img src="http://ww2.sinaimg.cn/large/6c0378f8gw1f4gse45ss8j20fn0jr0v3.jpg" alt="页面的渲染逻辑"></p>
<p>首页框架的加载逻辑，大致上图所示：</p>
<ul>
<li>遍历所有 TMS 模块（包含一个 <code>J_Module</code> 的钩子）</li>
<li>部分 TMS 模块无 JS 内容，但是加载了一个 <code>index.js</code>，为模块添加 <code>tb-pass</code> 的 class，用于跳过该模块 JS 的执行</li>
<li>将页面分为两块，首屏为一块，非首屏整体为第二块，先将首屏模块加入到懒加载监控</li>
<li>待首屏模块加载完成，或者用户处理了页面交互时（滚动、鼠标移动等），将非首屏模块加入到懒加载监控</li>
<li>处理一些特殊模块，它们会在进入视窗之前几百像素就开始加载</li>
<li>监控滚动，按照以上逻辑，渲染模块</li>
</ul>
<p>部分模块即便是被执行了，也不一定渲染出来，因为它的优先级不高，在模块内部加了事件监听，比如等到 <code>mouseover/onload</code> 事件触发的时候再渲染这些内容。</p>
<p>之前写过性能优化相关的文章，复制就没必要了，直接贴地址：</p>
<ul>
<li><a href="http://taobaofed.org/blog/2016/04/05/optimize-in-tbhome/">《淘宝首页性能优化实践》</a></li>
</ul>
<p>代码的性能优化是一个精细活，如果你要在一个庞大的未经优化的页面上做性能优化，可能会面临一次重构代码。</p>
<p>上面的文章提到的是页面内部的细节优化，但是在开发流程中做的规范化、标准化，以及线上访问通路中的各个环节优化还没有提及。</p>
<h3 id="四、淘宝首页的稳定性保障"><a href="#四、淘宝首页的稳定性保障" class="headerlink" title="四、淘宝首页的稳定性保障"></a>四、淘宝首页的稳定性保障</h3><p>在大流量下，任何小问题都会被放大成大问题，所以开发环节遇到的任何偶发性问题都需要引起重视。不过很多偶发性问题在我们的测试环境中是找不到的，比如与地域相关的问题（如上海的某个 CDN 节点挂了），用户属性问题（如 nickname 最后一个为字母 s 的用户页面天窗），浏览器插件问题，运营商广告注入问题等等。</p>
<p>难以在上线之前把所有问题考虑周全，但是有两点是必须做好的：<strong>兜底容灾 + 监控预警。</strong></p>
<h4 id="1-兜底容灾机制"><a href="#1-兜底容灾机制" class="headerlink" title="1. 兜底容灾机制"></a>1. 兜底容灾机制</h4><p>兜底容灾有两个层面的考虑：</p>
<ul>
<li>异步接口请求错误，包括接口数据格式错误，接口请求超时等</li>
<li>同步渲染，源站页面渲染出错</li>
</ul>
<p>异步接口请求，主要涉及到的是后台系统，对接系统较多，各个系统的稳定性和抗压能力各不相同，这方面的保障有多种方案，下面是最常见的：</p>
<p><img src="http://ww4.sinaimg.cn/large/6c0378f8gw1f4go51ui9zj20kh0h7n0b.jpg" alt="请求缓存"></p>
<p>每次数据请求都缓存到本地，并且为每个接口都提供一个硬兜底。还有一种方案是「重试」，请求一次不成功那就请求第二次。这方面的讨论具体可以看看之前写的这篇文章：<a href="http://taobaofed.org/blog/2015/10/28/disaster-recovery-at-taobao-home-page/">《淘宝首页兜底容灾方案》</a>。</p>
<p>对于同步渲染，它只需要页面模板和同步数据，两者中任一种存在错误，源站都会报错，此时回源返回的内容就是一个 error 页面，状态码为 <code>5xx</code>。这个错误不一定是开发者造成的，有可能是系统链路出现同步异常或者断路问题。针对这种问题，我给淘宝首页做了一个镜像页：</p>
<p><img src="http://ww1.sinaimg.cn/large/6c0378f8gw1f4gonwmraoj21ce0rq0vr.jpg" alt="镜像"></p>
<p>一旦源站任何异常，Nginx 都会转到与 Cache CDN 同机房的首页镜像上去，这个镜像内容就是淘宝首页的 HTML 备份源码。</p>
<h4 id="2-监控预警机制"><a href="#2-监控预警机制" class="headerlink" title="2. 监控预警机制"></a>2. 监控预警机制</h4><p>监控也有两个层面：</p>
<ul>
<li>模块级别的监控，接口请求布点、模块天窗检测等</li>
<li>页面的监控，在页面上添加特殊标记，定时回归所有 CDN 节点，查看特殊标记是否存在</li>
</ul>
<p>模块层面的监控，内容还是相当多的，监控的点越多越详细，到最后定位问题的效率就会越高，比如在一个稍微复杂的模块上，我会埋下这些监控：</p>
<ul>
<li>接口请求格式错误、请求失败、请求超时，至少三个埋点</li>
<li>硬兜底数据请求失败埋点</li>
<li>模块 5s 内没有渲染完成统计埋点</li>
<li>模块内链接和图片黑白名单匹配埋点</li>
</ul>
<p><img src="http://ww3.sinaimg.cn/large/6c0378f8gw1f4gtw0jjxxj20w50akace.jpg" alt="监控"></p>
<p>其中部分监控还会自动处理明确的错误，比如 https 页面下出现了 http 的图片，会立即自动处理掉这些问题。</p>
<h4 id="3-上线前的自动化检测"><a href="#3-上线前的自动化检测" class="headerlink" title="3. 上线前的自动化检测"></a>3. 上线前的自动化检测</h4><p>这属于淘宝整个工程化环境的一部分，前端自动化测试。一般会在上线之前处理这些问题：</p>
<ul>
<li>检测 HTML 是否符合规范</li>
<li>检测 https 升级情况</li>
<li>检测链接合法性</li>
<li>检测静态资源合法性</li>
<li>检测 JavaScript 报错</li>
<li>检测页面加载时是否有弹出框</li>
<li>检测页面是否调用 <code>console.*</code></li>
<li>页面 JS 内存记录</li>
</ul>
<p>当然，也可以自己添加测试用例，比如检测接口数据格式、模块天窗问题等。自动化检测也可以设定定时回归，还是比较有保障的。</p>
<h3 id="五、淘宝首页的敏捷措施"><a href="#五、淘宝首页的敏捷措施" class="headerlink" title="五、淘宝首页的敏捷措施"></a>五、淘宝首页的敏捷措施</h3><h4 id="1-健康检查"><a href="#1-健康检查" class="headerlink" title="1. 健康检查"></a>1. 健康检查</h4><p>页面模块众多，为了能够追踪页面上每一个小点的变化，我在请求、渲染的每一个环节都做了详细的统计，如下图所示：</p>
<p><img src="http://ww3.sinaimg.cn/large/6c0378f8gw1f4gt6p2lsfj20la0gmjwg.jpg" alt="Console"></p>
<p>一旦接口请求失败，或者接口走了容灾逻辑，或者模块渲染超过 5s，控制台都会有黄色警报，当然此时，也已经向服务器发送了警报统计。</p>
<h4 id="2-接口-Hub"><a href="#2-接口-Hub" class="headerlink" title="2. 接口 Hub"></a>2. 接口 Hub</h4><p>接口 Hub 是对数据请求的管理工具，如下图所示：</p>
<p><img src="http://ww1.sinaimg.cn/large/6c0378f8gw1f4gt7e0p74j20j70cvtbv.jpg" alt="HubCache"></p>
<p>页面很多模块的渲染都需要一个以上的数据源，一旦运营反馈页面渲染数据异常，可以直接通过 Hub 找到数据，加速 Bug 定位效率。同时 Hub 也可以用来切换环境，将一个接口的请求切换到日常或者预发环境的接口之中，它是调试的利器。</p>
<h4 id="3-快捷通道"><a href="#3-快捷通道" class="headerlink" title="3. 快捷通道"></a>3. 快捷通道</h4><p>我在页面脚本执行前后都放了一个快捷操作通道，一旦遇到紧急线上问题，比如样式错乱溢出、接口报错导致天窗等，可以通过快捷通道直接修改页面的 CSS 和 JS，两分钟内上线。</p>
<p>不过这类通道只适合紧急问题的修复，毕竟随意插入 JS 代码是存在很大风险的。</p>
<h3 id="六、小结"><a href="#六、小结" class="headerlink" title="六、小结"></a>六、小结</h3><p>写的好像有点虎头蛇尾（码字和画图都太累），还有很多方面没有延伸拓展开。希望以上可以让你对淘宝首页有一个基本的认识。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="//img.alicdn.com/tfs/TB1dcfNKXXXXXXcXVXXXXXXXXXX-900-500.png" alt="聊一聊淘宝首页和它背后的一套"></p>
<p>从 14 年双十二结束开始接手淘宝首页，到如今差不多 1 年半时间了，不]]>
    </summary>
    
      <category term="淘宝首页" scheme="http://taobaofed.org/tags/%E6%B7%98%E5%AE%9D%E9%A6%96%E9%A1%B5/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[视频播放的那些事]]></title>
    <link href="http://taobaofed.org/blog/2016/05/23/video-player/"/>
    <id>http://taobaofed.org/blog/2016/05/23/video-player/</id>
    <published>2016-05-23T03:26:29.000Z</published>
    <updated>2016-10-12T02:02:15.000Z</updated>
    <content type="html"><![CDATA[<p><img src="//img.alicdn.com/tfs/TB1YyshJVXXXXaEXVXXXXXXXXXX-900-500.jpg" alt="视频播放的那些事"></p>
<ul>
<li>视频作为淘宝教育业务的基础服务，本文根据自身在手淘中视频播放的实践，谈谈在手淘中视频播放遇到的问题及其解决方案。 </li>
</ul>
<h3 id="播放器"><a href="#播放器" class="headerlink" title="播放器"></a>播放器</h3><ul>
<li><p>在手淘过去一年多的历史长河中存在五种类型的播放器。</p>
<ul>
<li>原生 HTML5 video 标签</li>
<li>Android 5.3.2 版本之后的 UC 内核增强 SAC 播放器</li>
<li>Android 5.4.9 版本之后的 UC HAC 播放器</li>
<li>Android 5.3.2 版本之前的 Glue native 播放器</li>
<li>Android 5.3.2 版本及其之后的 PlayBuddy 播放器</li>
</ul>
</li>
<li><p>下面从支持平台，loading 动画，全屏，模拟全屏和兼容性五个方面对各个播放器做个横向对比。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>video IOS</th>
<th>video Android</th>
<th>UC SAC</th>
<th>UC HAC</th>
<th>PlayBuddy</th>
<th>Glue</th>
</tr>
</thead>
<tbody>
<tr>
<td>平台</td>
<td>IOS手淘</td>
<td>android手淘</td>
<td>android手淘&gt;=5.3.2</td>
<td>android手淘&gt;=5.4.9</td>
<td>android手淘&gt;=5.3.2</td>
<td>android手淘&lt;5.3.2</td>
</tr>
<tr>
<td>loading</td>
<td>可定制</td>
<td>可定制</td>
<td>无</td>
<td>可定制</td>
<td>不可定制，丑陋</td>
<td>有</td>
</tr>
<tr>
<td>控件可定制性</td>
<td>可以</td>
<td>可以</td>
<td>不可以</td>
<td>可以</td>
<td>不可以</td>
<td>不可以</td>
</tr>
<tr>
<td>全屏</td>
<td>支持竖全屏</td>
<td>不支持</td>
<td>支持竖全屏</td>
<td>可以</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>模拟全屏</td>
<td>支持</td>
<td>支持</td>
<td>不支持</td>
<td>有bug</td>
<td>–</td>
<td>–</td>
</tr>
<tr>
<td>兼容性</td>
<td>好</td>
<td>较好</td>
<td>较好</td>
<td>好</td>
<td>较好</td>
<td>一般，不兼容 android 5.0及以上</td>
</tr>
</tbody>
</table>
<h3 id="接口与事件封装"><a href="#接口与事件封装" class="headerlink" title="接口与事件封装"></a>接口与事件封装</h3><p>上面介绍了手淘中可供 WebView 选择的播放器，对于业务方而言迫切需要一个解决方，无需关心底层差异。为此，我们屏蔽移动端不同系统平台、宿主环境、播放器的实现细节和兼容性问题，提供统一的接口和事件，具体如下：</p>
<ul>
<li>方法<ul>
<li>play 播放</li>
<li>pause 暂停</li>
<li>stop 停止</li>
<li>show 显示</li>
<li>hide 隐藏</li>
<li>requestFullscreen 全屏</li>
<li>exitFullScreen 退出全屏</li>
<li>getCurrentTime 获取当前播放时间</li>
<li>setCurrentTime 设置播放时间</li>
<li>getDuration 获取视频时长</li>
<li>setPoster 设置背景图</li>
<li>destory 销毁</li>
<li>reset 重置视频</li>
</ul>
</li>
<li><p>事件</p>
<ul>
<li>timeupdate 进度更新</li>
<li>ended 停止</li>
<li>error 错误</li>
<li>play （专指video）</li>
<li>pause 停止（专指video）</li>
<li>firstpaint 视频真正开始播放（专指video）</li>
</ul>
</li>
<li><p>controls 播放控件（专指video）</p>
<ul>
<li>播放</li>
<li>暂停</li>
<li>进度更新</li>
<li>全屏</li>
<li>loading</li>
</ul>
</li>
</ul>
<h3 id="兼容性处理"><a href="#兼容性处理" class="headerlink" title="兼容性处理"></a>兼容性处理</h3><p>接下来谈谈在开发过程中遇到的各种小问题及其解决办法。</p>
<h4 id="video"><a href="#video" class="headerlink" title="video"></a>video</h4><ul>
<li><p><strong>内联播放</strong>。iPhone 在视频播放时默认全屏播放，<a href="https://developer.apple.com/library/iad/documentation/UserExperience/Conceptual/iAdJSProgGuide/PlayingVideosinAds/PlayingVideosinAds.html" target="_blank" rel="external">参考</a>。</p>
<ul>
<li><p>WebView 中，可以对 UIWebView 做如下配置，并且在 video 中配置 webkit-playsinline 属性即可：</p>
<figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">webview.allowsInlineMediaPlayback </span>=<span class="string"> YES;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>iPhone Safari 在 IOS &gt;= 8 的系统中，有人也提出了一个<a href="https://link.zhihu.com/?target=https%3A//github.com/bfred-it/iphone-inline-video" target="_blank" rel="external">方案</a></p>
</li>
</ul>
</li>
<li><p><strong>自定义播放控件</strong></p>
<ul>
<li>部分 Android 机型不支持内置控件，或者说内置控件无法正常使用；各个产品都有特定的视觉规范，默认控件的交互和视觉无法满足需求。因此，我们推荐默认不启用默认控件，采用自定义控件。</li>
<li>IOS 下播放时还可能还展示系统自带播放按钮，可以配置如下 CSS。</li>
</ul>
</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">video</span><span class="selector-pseudo">::-webkit-media-controls-start-playback-button</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>poster 视频底图</strong></p>
<ul>
<li>在 iPhone 中视频加载完第一帧数据后会覆盖 Poster 底图展示第一帧画面，这时可以使用 DIV 覆盖在视频上方模拟，监听 timeupdate 事件做隐藏操作。</li>
<li>在 UC WebView 中动态设置 poster 可能会导致手淘 crash，方案跟上方一样。</li>
<li>在使用 Native 播放器时，在播放器未初始化时使用 DIV 替换 video 标签，并设置底图为背景图。</li>
</ul>
</li>
<li><p><strong>播放首屏</strong>：IOS 通过监听 playing 事件可以准确获取视频播放的时间点；Android 中在该事件触发时，还没真正开始播放。我们通过监听 timeupdate 的事件做模拟处理。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">_timeUpdate(e) &#123;</span><br><span class="line"> <span class="keyword">var</span> currentTime = <span class="keyword">this</span>.getCurrentTime();</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 判断是否为首帧</span></span><br><span class="line"> <span class="keyword">if</span> (currentTime !== <span class="literal">undefined</span> &amp;&amp; currentTime !== <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="keyword">this</span>.fire(<span class="string">'firstpaint'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_playing() &#123;</span><br><span class="line">  <span class="keyword">if</span> (Env.os.ios) &#123;</span><br><span class="line">     <span class="keyword">this</span>.fire(<span class="string">'firstpaint'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>视频切换</strong>：在android 4.4 以下版本，在视频切换时存在第一次切换不能正常播放，第二次才能正常播放情况。通过调试人肉分析，发现切换视频的 video 存在以下两个特征：readyState 值为 0，videoWidth 为 0。因此我们判断当两个属性为0时，则切换失败，再次调用播放逻辑。存在误判的可能，但是能保证正常工作。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">isWork() &#123;</span><br><span class="line">    <span class="keyword">if</span> (videoEl.readyState === <span class="number">0</span> &amp;&amp; videoEl.videoWidth === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>全屏</strong>：手淘 IOS 支持竖全屏效果，Android 虽然具有全屏方法，但是被手淘限制，调用全屏方法无效。</p>
<ul>
<li><p><code>方案一</code>：为了支持横全屏，我们使用 css3 的 rotate 对视频区域进行90度旋转，并且调用 bridge 接口隐藏 native 顶部的 navibar，并对自定义控件进行响应优化调整。基本到达 native全屏效果。当然顶部状态栏不能隐藏还是有些小瑕疵。同时旋转之后元素的 z-index失效，导致视频覆盖控件问题，可以通过设置 -webkit-transform: translate3d(0,0,0) 来修复</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">requestFullscreen() &#123;</span><br><span class="line">    <span class="keyword">var</span> element = <span class="keyword">this</span>.el[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">var</span> method = FullscreenApi.requestFullscreen;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (method) &#123;</span><br><span class="line">        element[method]();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.webkitEnterFullscreen || element.enterFullScreen) &#123;</span><br><span class="line">        element.webkitEnterFullscreen &amp;&amp; element.webkitEnterFullscreen();</span><br><span class="line">        element.enterFullScreen &amp;&amp; element.enterFullScreen();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟全屏</span></span><br><span class="line">        <span class="comment">// enterFullWindow();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟全屏js核心代码</span></span><br><span class="line">_mockFullscreen() &#123;</span><br><span class="line">    <span class="keyword">if</span> (curEl.hasClass(<span class="string">'normal'</span>)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.fullscreen = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        playerEl.css(&#123;</span><br><span class="line">            width: <span class="keyword">this</span>.originWidth,</span><br><span class="line">            height: <span class="keyword">this</span>.originHeight,</span><br><span class="line">            left: <span class="number">0</span></span><br><span class="line">        &#125;).removeClass(<span class="string">'fullscreen'</span>);</span><br><span class="line"></span><br><span class="line">        wrapperEl.css(&#123;</span><br><span class="line">            width: <span class="keyword">this</span>.wrapperOriginWidth,</span><br><span class="line">            height: <span class="keyword">this</span>.wrapperOriginHeight</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        videoEl.css(<span class="string">'height'</span>, <span class="string">'100%'</span>);</span><br><span class="line"></span><br><span class="line">        curEl.removeClass(<span class="string">'normal'</span>);</span><br><span class="line">        contentEl.removeClass(<span class="string">'fullscreen'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.fullscreen = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.originWidth = playerEl.width();</span><br><span class="line">        <span class="keyword">this</span>.originHeight = playerEl.height();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.wrapperOriginWidth = wrapperEl.width();</span><br><span class="line">        <span class="keyword">this</span>.wrapperOriginHeight = wrapperEl.height();</span><br><span class="line"></span><br><span class="line">        playerEl.css(&#123;</span><br><span class="line">            width: $(<span class="built_in">window</span>).height(),</span><br><span class="line">            height: $(<span class="built_in">window</span>).width(),</span><br><span class="line">            left: $(<span class="built_in">window</span>).width()</span><br><span class="line">        &#125;).addClass(<span class="string">'fullscreen'</span>);</span><br><span class="line"></span><br><span class="line">        wrapperEl.css(&#123;</span><br><span class="line">            width: $(<span class="built_in">window</span>).height(),</span><br><span class="line">            height: $(<span class="built_in">window</span>).width()</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        videoEl.css(<span class="string">'height'</span>, videoEl.height() - controlsHeight);</span><br><span class="line"></span><br><span class="line">        curEl.addClass(<span class="string">'normal'</span>);</span><br><span class="line">        contentEl.addClass(<span class="string">'fullscreen'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>效果图:<br><img src="https://img.alicdn.com/tps/TB1vRHkJpXXXXXAXFXXXXXXXXXX-1280-719.jpg" alt="IOS全屏"></p>
</li>
<li>预览地址（请用手淘扫码）：<br><img src="https://img.alicdn.com/tps/TB1VrUrJFXXXXctXVXXXXXXXXXX-178-175.jpg" alt="demo"></li>
</ul>
<ul>
<li><code>方案二</code>。方案一只是模拟了横全屏效果，对于追求完美的处女座不能忍。还有其他方案吗？有时候只需要转换下思维，问题即可迎刃而解。既然是横屏播放，只需要让 WebView 横屏即可，同时在横屏之后重新调整控件即可，关键手淘提供了打开应用横全屏的接口。注意点：横屏之后需要禁止页面滚动，要不然全屏就露馅了，因为本质还是个 WebView。</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.transverseFullScreen) &#123;</span><br><span class="line">  <span class="keyword">if</span> (curEl.hasClass(<span class="string">'normal'</span>)) &#123;</span><br><span class="line">    curEl.removeClass(<span class="string">'normal'</span>);</span><br><span class="line">    <span class="keyword">this</span>._transverseFullScreen(<span class="literal">false</span>).then(() =&gt; &#123;</span><br><span class="line">      $(<span class="string">'body'</span>).removeClass(<span class="string">'co-fullscreen'</span>).attr(&#123; height: <span class="string">'auto'</span> &#125;);</span><br><span class="line">      <span class="keyword">this</span>.videoWrapperEl.height(<span class="keyword">this</span>.videoOriginHeight).removeClass(<span class="string">'fullscreen'</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.player.fire(<span class="string">'transversefullscreen'</span>, &#123; fullscreen: <span class="literal">false</span> &#125;);</span><br><span class="line">      <span class="keyword">this</span>.resize();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    curEl.addClass(<span class="string">'normal'</span>);</span><br><span class="line">    <span class="keyword">this</span>._transverseFullScreen(<span class="literal">true</span>).then(() =&gt; &#123;</span><br><span class="line">      $(<span class="string">'body'</span>).addClass(<span class="string">'co-fullscreen'</span>).attr(&#123; height: win.height() &#125;);</span><br><span class="line">      <span class="keyword">this</span>.videoWrapperEl.height(win.height()).addClass(<span class="string">'fullscreen'</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.player.fire(<span class="string">'transversefullscreen'</span>, &#123; fullscreen: <span class="literal">true</span> &#125;);</span><br><span class="line">      <span class="keyword">this</span>.resize();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Demo：<br><img src="http://img3.tbcdn.cn/L1/461/1/2d8cead70e721088b82892514ef210b7150df716.gif" alt="fullscreen"></li>
<li>手淘 IOS 扫码：<br><img src="https://img.alicdn.com/tps/TB1bu2KJVXXXXcfXXXXXXXXXXXX-181-178.jpg" alt=""><ul>
<li><code>方案3</code>。在 UC HAC 方案视频提供全屏接口 UCSettings.setVideoViewFullscreenByDefault（true），开启后，视频全屏默认为横屏  </li>
</ul>
</li>
<li><strong>自动播放</strong><ul>
<li>出于用户节省用户流量考虑，iPhone 下播放视频需要用户手动触发，即使配置了 autoplay 属性也是无效的。在业务中，特定场景还是需要视频能够自动播放，对此我们可以监听页面的 touchstart 事件，做如下处理：</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.auoplay &amp;&amp; env.app.TB &amp;&amp; env.network.wifi) &#123;</span><br><span class="line"><span class="keyword">if</span> (player.getCurrentTime() &gt; <span class="number">0</span> &amp;&amp; !player.isPause()) &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.hasAutoPlay) &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.hasAutoPlay = <span class="literal">true</span>;</span><br><span class="line">startEl.trigger(<span class="string">'click'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">autoplay</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    doc.detach(<span class="string">'touchstart'</span>, autoplay);</span><br><span class="line">    <span class="keyword">if</span> (player.getCurrentTime() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  startEl.trigger(<span class="string">'click'</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> doc.on(<span class="string">'touchstart'</span>, autoplay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>其他<ul>
<li>部分机型手淘低版本使用 video 播放时，会出现有声音没画面的问题，升级手淘后即恢复。例如，小米4 手淘 4.2.0</li>
<li>IOS 5.1 和部分 android 手机暂停和开始按钮不触发点击事件(元素的 :after 为iconfont)。通过父元素添加background即可</li>
<li>Android UC 内核的播放器，在未设置 source 资源时，设置 poster 无效</li>
<li>Android UC 内核的播放器无法自定义控件和样式操作，但是可以正常的监听事件。</li>
<li>直接替换 source 不会改变当前正在播放的视频，需要调用 load 方法。</li>
<li>UC 浏览器中 video 标签会被 UC 的播放器插件替换</li>
<li>使用 m3u8 和 mp4 基本可以兼容所有机型 </li>
<li>在 IOS 视频初始化后设置 currrentTime 无效，在 loadedmetadata 事件触发后，设置 currentTime 即可。</li>
</ul>
</li>
</ul>
<h3 id="native播放器"><a href="#native播放器" class="headerlink" title="native播放器"></a>native播放器</h3><ul>
<li><p>destroy：</p>
<ul>
<li>Glue：Glue native 播放器在页面跳转，WebView 后退等操作时，不会自动析构，好的情况是视频依然在背后播放，有时候会直接导致手淘 crash。</li>
<li><p>PlayBuddy：在页面跳转时依然会继续播放</p>
<p>处理方式：页面跳转时需要手动的销毁native播放器。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'WV.Event.Page.Refresh'</span>, $.proxy(<span class="keyword">this</span>.destory, <span class="keyword">this</span>), <span class="literal">false</span>);</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'WV.Event.Key.Back'</span>, $.proxy(<span class="keyword">this</span>.destory, <span class="keyword">this</span>), <span class="literal">false</span>);</span><br><span class="line">win.on(<span class="string">'unload'</span>, $.proxy(<span class="keyword">this</span>.destory, <span class="keyword">this</span>));</span><br><span class="line">win.on(<span class="string">'beforeunload'</span>, $.proxy(<span class="keyword">this</span>.destory, <span class="keyword">this</span>));</span><br></pre></td></tr></table></figure>
<ul>
<li>定位<ul>
<li>Glue 播放器使用 dip 作为播放器的定位单位，rem 布局会对页面进行缩放，导致定位位置和视频大小错误。同时定位时参数有小数点会导致播放器错误。</li>
</ul>
</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/__</span><br><span class="line"> * 返回值需要是整数，否则会有异常</span><br><span class="line"> */</span><br><span class="line">_getVedioPos(isDpr) &#123;</span><br><span class="line">    var el = this.el,</span><br><span class="line">        offset = el.offset(),</span><br><span class="line">        dpr = 1;</span><br><span class="line"></span><br><span class="line">    if (isDpr) &#123;</span><br><span class="line">        dpr = this._getDpr();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">        x: parseInt(offset.left / dpr),</span><br><span class="line">        y: parseInt(offset.top / dpr),</span><br><span class="line">        w: parseInt(el.width() / dpr),</span><br><span class="line">        h: parseInt(el.height() / dpr)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>视频源地址：Glue 播放器不支持以 // 开始的视频资源，例如 //video.xxx</li>
<li>PlayBuddy 播放器不会随着页面滚动而滚动。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>如果业务中需要在手淘中播放视频，IOS 直接使用原生 video 即可。在 Android 中较为复杂，没有完全兼容的方案。建议使用 video，对于 Android 低版本建议使用native 播放器。随着uc内核接入，未来完全抛弃 native 方案也是可行的。</li>
<li>本文基于过去一年在手淘视频播放过程中遇到问题的小结，后续会整理视频监控和视频娱乐化相关内容。</li>
</ul>
<h2 id="附：手淘同学播放器兼容性表"><a href="#附：手淘同学播放器兼容性表" class="headerlink" title="附：手淘同学播放器兼容性表"></a>附：手淘同学播放器兼容性表</h2><table>
<thead>
<tr>
<th>品牌</th>
<th>机型</th>
<th>手淘版本</th>
<th>操作系统版本</th>
<th>播放器控件</th>
<th>视频列表切换</th>
<th>试看控制</th>
<th>观看进度同步</th>
<th>切换模式</th>
<th>问题</th>
</tr>
</thead>
<tbody>
<tr>
<td>苹果</td>
<td>6 plus</td>
<td>5.2.7</td>
<td>8.11</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>*</td>
</tr>
<tr>
<td>苹果</td>
<td>6</td>
<td>5.2.7</td>
<td>8.11</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>*</td>
</tr>
<tr>
<td>苹果</td>
<td>5s</td>
<td>5.2.7</td>
<td>8.11</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>*</td>
</tr>
<tr>
<td>苹果</td>
<td>5</td>
<td>5.2.7</td>
<td>8.11</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>*</td>
</tr>
<tr>
<td>苹果</td>
<td>4s</td>
<td>5.2.7</td>
<td>8.11</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>*</td>
</tr>
<tr>
<td>苹果</td>
<td>4</td>
<td>*</td>
<td>*</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>*</td>
</tr>
<tr>
<td>google</td>
<td>nexus 5</td>
<td>*</td>
<td>yun os 3</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>*</td>
</tr>
<tr>
<td>google</td>
<td>nexus 5</td>
<td>*</td>
<td>安卓 5</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>*</td>
</tr>
<tr>
<td>三星</td>
<td>N7100</td>
<td>4.9</td>
<td>*</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>*</td>
</tr>
<tr>
<td>三星</td>
<td>NOTE4</td>
<td>4.9</td>
<td>*</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>模式二点最大化crash</td>
</tr>
<tr>
<td>三星</td>
<td>NOTE3</td>
<td>4.9</td>
<td>*</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>*</td>
</tr>
<tr>
<td>三星</td>
<td>S4</td>
<td>5.2.7.3</td>
<td>*</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>模式二，播放有问题 </td>
</tr>
<tr>
<td>三星</td>
<td>I9300</td>
<td>4.3</td>
<td>*</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>*</td>
</tr>
<tr>
<td>三星</td>
<td>S3</td>
<td>5.2.8.2</td>
<td>*</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>*</td>
</tr>
<tr>
<td>三星</td>
<td>S5</td>
<td>5.2.7.3</td>
<td>*</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>*</td>
</tr>
<tr>
<td>魅族</td>
<td>MX2</td>
<td>*</td>
<td>*</td>
<td>√</td>
<td>*</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>*</td>
</tr>
<tr>
<td>魅族</td>
<td>MX4 PRO</td>
<td>*</td>
<td>*</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>*</td>
</tr>
<tr>
<td>魅族</td>
<td>魅蓝Note</td>
<td>*</td>
<td>*</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>*</td>
</tr>
<tr>
<td>魅族</td>
<td>MX3（安装不上）</td>
<td>*</td>
<td>*</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>*</td>
</tr>
<tr>
<td>华为</td>
<td>荣耀6</td>
<td>*</td>
<td>*</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>模式二可能播放不了</td>
</tr>
<tr>
<td>华为</td>
<td>mate7</td>
<td>*</td>
<td>*</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>模式二可能播放不了 </td>
</tr>
<tr>
<td>华为</td>
<td>c8816</td>
<td>*</td>
<td>*</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>进度条拖动会跳</td>
</tr>
<tr>
<td>华为</td>
<td>荣耀3c</td>
<td>*</td>
<td>4.4.2</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×一直展示loading的图片</td>
<td>模式二播放不了</td>
</tr>
<tr>
<td>华为</td>
<td>C8813</td>
<td>*</td>
<td>4.1.1</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>高清视频不能播放</td>
</tr>
<tr>
<td>HTC</td>
<td>MAX</td>
<td>*</td>
<td>*</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>*</td>
<td>*</td>
</tr>
<tr>
<td>HTC</td>
<td>816w</td>
<td>*</td>
<td>*</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>*</td>
</tr>
<tr>
<td>VIVO</td>
<td>Find5</td>
<td>*</td>
<td>4.1.1</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>*</td>
</tr>
<tr>
<td>VIVO</td>
<td>X3</td>
<td>*</td>
<td>4.2.2</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>*</td>
</tr>
<tr>
<td>小米</td>
<td>2S</td>
<td>*</td>
<td>4.3</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>*</td>
<td>高清的播放不了</td>
</tr>
<tr>
<td>小米</td>
<td>3</td>
<td>*</td>
<td>*</td>
<td>*</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>*</td>
<td>*</td>
</tr>
<tr>
<td>小米</td>
<td>4</td>
<td>*</td>
<td>4.4.4</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>*</td>
<td>*</td>
</tr>
<tr>
<td>索尼</td>
<td>M512</td>
<td>*</td>
<td>4.4.2</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>*</td>
</tr>
<tr>
<td>索尼</td>
<td>xperia 36l</td>
<td>*</td>
<td>4.1.2</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>*</td>
<td>*</td>
</tr>
<tr>
<td>nubia</td>
<td>nx403</td>
<td>*</td>
<td>4.2.2</td>
<td>√</td>
<td>×</td>
<td>√</td>
<td>√</td>
<td>*</td>
<td>模式一，模式二播放均有问题</td>
</tr>
<tr>
<td>锤子</td>
<td>*</td>
<td>*</td>
<td>*</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>*</td>
<td></td>
</tr>
<tr>
<td>oppo</td>
<td>x907</td>
<td>*</td>
<td>4.0.3</td>
<td>很难点到</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>*</td>
</tr>
<tr>
<td>nexus5</td>
<td>*</td>
<td>*</td>
<td>*</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>第二种模式crash</td>
</tr>
</tbody>
</table>
<p>注：模式1为video，模式2为glue native播放器</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="//img.alicdn.com/tfs/TB1YyshJVXXXXaEXVXXXXXXXXXX-900-500.jpg" alt="视频播放的那些事"></p>
<ul>
<li>视频作为淘宝教育业务的基础服务，本文根据自身在手淘中视频播放的实践，谈谈]]>
    </summary>
    
      <category term="视频" scheme="http://taobaofed.org/tags/%E8%A7%86%E9%A2%91/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[无线端的弹幕实现方案]]></title>
    <link href="http://taobaofed.org/blog/2016/05/13/barrage-in-mobile/"/>
    <id>http://taobaofed.org/blog/2016/05/13/barrage-in-mobile/</id>
    <published>2016-05-13T07:59:50.000Z</published>
    <updated>2016-10-12T02:02:15.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img.alicdn.com/tfs/TB1zithJVXXXXabXVXXXXXXXXXX-900-500.jpg" alt="无线端的弹幕实现方案"></p>
<p>前段时间做了游戏的相关业务，其中弹幕相关的内容自成一块。弹幕已经不只是最初的视频弹幕了，战火已经烧到了评论区，烧到了手机淘宝的首页搜索结果。作为一种近几年迅速燃起的内容呈现形式，有必要适时引入，对于休闲化、娱乐化的业务更是如此。那么，要做出一个较为完整的弹幕效果来，需要哪几个部分呢？尤其是，在集团内部，怎么快速地搭建起一个可用的弹幕框架来？本文分3块来阐述。</p>
<ol>
<li><a href="#client_rendering_module">弹幕渲染层</a></li>
<li><a href="#data_pipeline_module">弹幕数据通道</a></li>
<li><a href="#server_business_module">弹幕服务逻辑</a></li>
</ol>
<h2 id="弹幕渲染层"><a href="#弹幕渲染层" class="headerlink" title="弹幕渲染层"></a><a name="client_rendering_module"></a>弹幕渲染层</h2><p>目前弹幕的呈现载体主要是Web、无线客户端。因为我们的工作主要针对无线端，所以本文主要以无线端为例——包括iOS，Android两类系统。</p>
<h4 id="碰撞检测"><a href="#碰撞检测" class="headerlink" title="碰撞检测"></a>碰撞检测</h4><p>弹幕无非是动画，是分布在时间轴上图像的连续运动。自然可以用Native的动画来实现。不过弹幕动画有一个重要的特征，即保持动画元素(sprites)尽可能少地碰撞，以使弹幕承载的信息能够清晰地传达，执行碰撞检测是必须的。但弹幕里的碰撞检测相对简单，因为弹幕的运动轨迹相对简单并且容易预测，所以只需要在一条弹幕将要显示之前，根据已经显示的弹幕(位置、速度、活跃的时间等)来确定他的运动轨迹。以尽最大可能地在其生命周期内不与已有弹幕冲突。</p>
<p><img src="http://img.alicdn.com/tfs/TB1tSxyJVXXXXarXpXXXXXXXXXX-900-507.png" alt="弹幕碰撞检测范例"></p>
<h4 id="弹幕的同步问题"><a href="#弹幕的同步问题" class="headerlink" title="弹幕的同步问题"></a>弹幕的同步问题</h4><p>弹幕不是超然而独立的，往往相伴业务场景而生，目前可见最多的场景是视频，直播或者录播皆有。到此时则涉及到一个时间同步的问题。比如，一位用户在看一段时间第314s的时候突然有感而发，发出了一条弹幕，自然希望其他观众能够在看到视频此刻看到他的弹幕。所以一条弹幕上屏的时间是需要明确的，想想那些年文不对题的字幕君吧。那么，如何实现呢？一般，可以为一条弹幕提供一个时间点delay，当到了这个时刻，由控制器把这条弹幕播放出去。但仅仅这些是不够的，因为视频还存在暂停，存在快进快退，所以你必须也为弹幕组件提供类似的接口，以期能和视频内容同步。其他的应用场景也是类似的。比如下面的样子(弹幕在向左运动)：</p>
<h4 id="弹幕的样式"><a href="#弹幕的样式" class="headerlink" title="弹幕的样式"></a>弹幕的样式</h4><p>弹幕的运动样式主要有两种，一种是横向的过场弹幕，一种是纵向的浮动弹幕。弹幕的内容形式不外乎一段文字或者图片，其中以文字为主。对于文字，则有文字的颜色、背景、字体、边框等属性，这一切必须是灵活可配的。当然实际应用中一个APP需要的是风格统一的、优雅美观的弹幕动画。所以弹幕的方向不要太混乱，不要有太多不一样的主题配置。你可以定义几类色调协调但样式不同的弹幕，然后由业务代码决定使用哪一种风格的弹幕。</p>
<h4 id="渲染效率"><a href="#渲染效率" class="headerlink" title="渲染效率"></a>渲染效率</h4><p>性能直接关系到用户体验。在绝大多数场景中，锦上添花的弹幕往往伴随着具体的业务逻辑，业务逻辑会占用CPU——甚至很高的CPU，比如视频解码———所以弹幕动画应该尽可能地使用GPU渲染。为应对线上可能的大规模弹幕的情况，本地最好也能测试到大量弹幕的情况。可以使用一个定时器，模拟客户端频繁接受渲染弹幕的情况，看看实际中弹幕的性能究竟如何。</p>
<h4 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h4><p>弹幕稀稀疏疏地铺满半屏窗口，朦胧中犹抱琵琶半遮面的感觉，自然是最好的。但万一遇到弹幕决堤，内容疯狂涌来，那当如何应对？渲染内容层层堆叠，既看不清，又降低了系统应用性能，为此可以在业务或者组件中选择限流。</p>
<h2 id="弹幕数据层"><a href="#弹幕数据层" class="headerlink" title="弹幕数据层"></a><a name="data_pipeline_module"></a>弹幕数据层</h2><p>若不考虑弹幕在用户间共享，只需下图左侧的模块即可；若需引入弹幕共享、存储功能，则如下图右侧所示。</p>
<p><img src="http://img.alicdn.com/tfs/TB1omxtJVXXXXcAXpXXXXXXXXXX-616-236.png" alt="简要结构图"></p>
<p>但实际情况往往比这复杂。弹幕很多时候是实时的，最好使用长连接来传输数据。业务导向的项目，很少从零开始开发专门的弹幕服务通道，而是尽可能地应用已有的服务组件。淘宝在长连通道上有多个选择，但其功能又是不尽相同的。这种不同也会带来弹幕实现方案的不同。比如通道A支持订阅功能，消息会根据订阅关系分发；而通道B是单纯的通道，订阅关系由业务方维护，凡是发送到客户端的消息都会接收，所以流量需要业务服务端来控制。</p>
<h4 id="经过服务端的必要性"><a href="#经过服务端的必要性" class="headerlink" title="经过服务端的必要性"></a>经过服务端的必要性</h4><p>仅仅使用长连接通道是不够的，还需引入业务服务器，其原因如下：</p>
<ul>
<li>如果长连通道不支持客户端发送消息，那么弹幕的发送要走其它的接口</li>
<li>因业务原因，需要统一多个长连接通道，以便更好地做 多端同步，故引入中间服务器做协调</li>
<li>一些业务相关的需求，不适合在长连接服务器上做，比如内容过滤、弹幕存储、服务端限流等</li>
</ul>
<p>整体的数据流如下图所示：</p>
<p><img src="http://img.alicdn.com/tfs/TB1PEVtJVXXXXcHXpXXXXXXXXXX-920-335.png" alt="详细结构图"></p>
<h4 id="消息格式制定"><a href="#消息格式制定" class="headerlink" title="消息格式制定"></a>消息格式制定</h4><p>通过长连接传输的弹幕消息会有一些附加数据需要考虑，比如弹幕的样式、出现的时间，随着业务的扩展，可能需要更多的辅助字段。所以弹幕消息必须能够向后兼容，一般可设置为message，version两个字段，message为纯粹的json字符串，version表示消息的版本号。先解析version，根据判断得到的version选择响应的解析样式。太多的附加信息会降低数据的利用率，此是需要权衡的地方。当然，如果针对的是在线视频业务，弹幕的流量相比于视频流而言，就显得不那么重要了。</p>
<h4 id="自发的弹幕消息"><a href="#自发的弹幕消息" class="headerlink" title="自发的弹幕消息"></a>自发的弹幕消息</h4><p>主要有两种：</p>
<ol>
<li>用户发送了弹幕消息后，通过网络发送消息的同时直接将弹幕数据上屏，以提升用户所见即所得的体验；当收到相同的弹幕消息后，将消息抛弃。</li>
<li>用户发送了弹幕消息后，通过正常的网络接收消息然后渲染呈现，这样会因延时损失一定的用户体验，但逻辑简单，并且可以控制所有弹幕数据。</li>
</ol>
<h2 id="弹幕服务层"><a href="#弹幕服务层" class="headerlink" title="弹幕服务层"></a><a name="server_business_module"></a>弹幕服务层</h2><h4 id="主题维护"><a href="#主题维护" class="headerlink" title="主题维护"></a>主题维护</h4><p>主题代表弹幕消息围绕的中心。在不同的业务场景中，主题的呈现方式可能是不同的。在视频直播业务中，主题代表了一个个直播房间，弹幕围绕着视频展开；在新闻咨询业务中，主题代表了一则则新闻，弹幕围绕着新闻展开。客户端与主题存在多对一的关系，如下图所示：</p>
<p><img src="http://img.alicdn.com/tfs/TB1sVg7JFXXXXcraXXXXXXXXXXX-984-284.png" alt="主题房间维护"></p>
<p>用户U1、U2订阅了主题T1，用户U3、U4订阅了主题T2。由于处于不同的语境中，U1、U2发送的弹幕U3、U4应该是不能接收到的，反之亦然。很自然服务端需要维护一个用户到主题的映射表简单的实现是，客户端监测到用户进入特定主题之后，发送一条网络请求登记这样一条订阅；用户离开特定主题时发送网络请求注销登记。但由于实际客户端运行场景复杂，离开特定主题不一定来得及发送网络请求。补充方案是，由客户端每隔特定时间心跳一次，用以告知服务端维护映射表。一旦服务端一段时间没有监听到心跳信息，就取消映射表中的一条订阅。这里需要注意的是，服务端需要防止心跳的伪造，否则可能映射表可能会因攻击而混乱掉。一旦映射表正确建立，用户发送的弹幕消息就可以准确传达到相同主题的用户客户端了。</p>
<h4 id="弹幕存储"><a href="#弹幕存储" class="headerlink" title="弹幕存储"></a>弹幕存储</h4><p>对于直播等即时性业务，弹幕数据一般没有重播的必要；但是对于录播，则需要持久化弹幕，如是方能在其他用户看视频的时候看到其他人发出过的弹幕消息。持久化这类弹幕数据，必须在存储弹幕的时候带上弹幕对应的时间点。在用户进入了某一主题之后，批量返回给客户端对应的弹幕数据，由客户端将弹幕数据对应到视频业务响应的时间点上；如果此主题对应的弹幕数据很多，服务端可能实现做一定的筛选；对于录播同时新发送的弹幕，则由服务端记录并添加到对应的弹幕数据列表中。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img.alicdn.com/tfs/TB1zithJVXXXXabXVXXXXXXXXXX-900-500.jpg" alt="无线端的弹幕实现方案"></p>
<p>前段时间做了游戏的相关业务，其中弹幕相关的内容自成一块。弹幕已经不只是]]>
    </summary>
    
      <category term="无线" scheme="http://taobaofed.org/tags/%E6%97%A0%E7%BA%BF/"/>
    
      <category term="弹幕" scheme="http://taobaofed.org/tags/%E5%BC%B9%E5%B9%95/"/>
    
      <category term="无线开发" scheme="http://taobaofed.org/categories/%E6%97%A0%E7%BA%BF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android 新一代编译 toolchain Jack & Jill 简介]]></title>
    <link href="http://taobaofed.org/blog/2016/05/05/new-compiler-for-android/"/>
    <id>http://taobaofed.org/blog/2016/05/05/new-compiler-for-android/</id>
    <published>2016-05-05T07:03:37.000Z</published>
    <updated>2016-10-12T02:02:15.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img.alicdn.com/tfs/TB1brqAJFXXXXaGXVXXXXXXXXXX-900-500.jpg" alt="Android 新一代编译 toolchain Jack &amp; Jill 简介"></p>
<p>2016 年 3 月 10 日， Google 向外界发布了 Android N 的预览版，并宣布了 Android N 的 <a href="https://developer.android.com/intl/zh-cn/preview/overview.html" target="_blank" rel="external">Roadmap</a>，Android N 的最终版源代码将于今年 8 或 9 月份释出到 AOSP 项目。</p>
<p>在众多的 Android N 新特性中，有一项新工具链的出现与 Android 生态圈的所有开发者息息相关，即 Jack &amp; Jill 编译器的引入。</p>
<p>在依赖了 Sun/Oracle 的 Java 编译器十年之后，Android 终于有了自己的 Java 编译器。</p>
<p>本文试图对市面上非常有限的资料进行总结，向大家介绍 Jack &amp; Jill 的缘起，工作方式和原理。</p>
<p>Jack 是 Java Android Compiler Kit 的缩写，它可以将 Java 代码直接编译为 Dalvik 字节码，并负责 Minification, Obfuscation, Repackaging, Multidexing, Incremental compilation。它试图取代 javac/dx/proguard/jarjar/multidex 库等工具。</p>
<ul>
<li>git 源代码地址是 <a href="https://android.googlesource.com/toolchain/jack" target="_blank" rel="external">https://android.googlesource.com/toolchain/jack</a>。</li>
</ul>
<p>Jill 是 Jack Intermediate Library Linker 的缩写，它负责 “Shielding JACK from Java byte code”；实际上辅助 Jack 对.class 做预处理，生成 <code>.jack</code> 文件</p>
<ul>
<li>git 源代码地址是 <a href="https://android.googlesource.com/toolchain/jill" target="_blank" rel="external">https://android.googlesource.com/toolchain/jill</a>。</li>
</ul>
<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>虽然 Google 是在宣布 Android N 预览版时隆重介绍了Jack &amp; Jill。但是，早在 2014 年 Google 就对外宣布了新编译器 Jack 的存在 <a href="http://android-developers.blogspot.jp/2014/12/hello-world-meet-our-new-experimental.html?utm_source=feedburner&amp;utm_medium=feed&amp;utm_campaign=Feed:+blogspot/hsDu+\(Android+Developers+Blog" target="_blank" rel="external">meet our new experimental toolchain</a>, 它的开发启动时间更是远远早于 2014 年。</p>
<p>下面是我总结的 Jack 的缘起</p>
<ul>
<li>一家名叫 FlexyCore 的小公司基于 GCC toolchain 开发了 Android 平台上的 AOT 编译器，被 Google 看中并于 2013 年被收购</li>
<li>FlexyCore team 基于 LLVM toolchain 开发了 ART，并成为 Android 5.0 之后的缺省 Java Runtime</li>
<li>FlexyCore team 基于 Eclipse ecj 编译器开始开发 Jack，基于 ASM4 开发 Jill。 他们早在 2014 年 2 月就开始提交 Jill 的代码了 <a href="https://android.googlesource.com/toolchain/jill/+/e991948d20515a04e46524dbe1bf17222e872889" target="_blank" rel="external">Jill initial commit</a>； 3 月份开始提交 Jack的代码 <a href="https://android.googlesource.com/toolchain/jack/+/4eceb95409e844fdc33c9c706e1dc307bfd40303" target="_blank" rel="external">Jack initial commit</a></li>
<li>自 Android build-tools 21.1 开始，里面已经内置 jack.jar 和 jill.jar</li>
<li>Android Gradle plugin 自 0.14 开始支持 Jack &amp; Jill <a href="https://android.googlesource.com/platform/tools/base/+/3bdd23d7583603ea0839d49c25d56bff83115533" target="_blank" rel="external">initial commit</a></li>
<li>自 Android 6.0 开始，Jack &amp; Jill 成为 AOSP 的官方编译器, 也就是说所有的 Android 6.0 ROM 都是 Jack 编译出来的 <a href="https://source.android.com/source/jack.html" target="_blank" rel="external">link</a>，也代表 Google 认为 Jack 达到了一定的成熟度</li>
<li>预计等 Android 7.0 正式发布时，Jack 可能会成为官方推荐的编译器</li>
</ul>
<h3 id="为什么要抛弃-Javac-dx-开发-Jack-和-Jill"><a href="#为什么要抛弃-Javac-dx-开发-Jack-和-Jill" class="headerlink" title="为什么要抛弃 Javac/dx,开发 Jack 和 Jill"></a>为什么要抛弃 Javac/dx,开发 Jack 和 Jill</h3><p>据个人推测主要有三个目的</p>
<ul>
<li>提高编译速度</li>
<li>应对 Oracle 的法律诉讼 </li>
<li>将编译器掌控权拿在自己手中，不再受制于 Oracle，可以做一些 Android only 的优化</li>
</ul>
<p>下面比较一下旧的 javac/dx/ProGuard/jarjar toolchain 和新的 Jack 编译器的工作流程</p>
<h2 id="旧编译流程"><a href="#旧编译流程" class="headerlink" title="旧编译流程"></a>旧编译流程</h2><p>简单的说，将 Java 代码和依赖库编译为 dex 有两个大的阶段</p>
<blockquote>
<p>javac (.java –&gt; .class) –&gt; dx (.class –&gt; .dex)</p>
</blockquote>
<p>下面是用流程图表示的旧编译过程</p>
<p><img src="http://img.alicdn.com/tfs/TB10AmzJFXXXXaDXVXXXXXXXXXX-672-307.png" alt="dx"></p>
<ol>
<li>javac 将 java 代码编译为 java bytecode, 以 <code>.class</code> 的形式存在; 以 jar 和 aar 形式存在的依赖库，代码在里面以一堆.class 的形式存在</li>
<li>Proguard 工具读取 Proguard 配置，对 <code>.class</code> 做 shrinking, obfuscation，输出 Proguard mapping</li>
<li>dx 将多个 <code>.class</code> 转化为单一的 classes.dex ; 如果 dex 方法数超过 65k, 就生成 classes.dex, classes1.dex…classesN.dex</li>
</ol>
<h2 id="新编译流程"><a href="#新编译流程" class="headerlink" title="新编译流程"></a>新编译流程</h2><p>新的编译过程只有一个阶段了，它完全抛弃了 javac, ProGuard, jarjar 等工具，一个工具搞定一切</p>
<blockquote>
<p>Jack (.java –&gt; .jack –&gt; .dex)</p>
</blockquote>
<p>下面是用流程图表示的 Jill 预处理过程</p>
<p><img src="http://img.alicdn.com/tfs/TB1zUGAJFXXXXX8XVXXXXXXXXXX-943-396.png" alt="jill"></p>
<p>下面是用流程图表示的 Jack 编译过程</p>
<p><img src="http://img.alicdn.com/tfs/TB1p_53JFXXXXaiXXXXXXXXXXXX-676-617.png" alt="jack"></p>
<ol>
<li>各种依赖库仍然以 jar/aar 的形式存在</li>
<li>辅助工具 Jill 将根据依赖库中的 <code>.class</code> 生成 Jayce 格式的 IL，并调用 Jack 做 pre-dex 并生成 <code>.jack</code>，此过程只在编译 app 时发生一次</li>
<li>Jack 将 java 源代码也编译为 <code>.jack</code>，然后将多个 <code>.jack</code> 转化为单一的 <code>.dex</code>; 如果 dex 方法数超过 65k, 就生成 classes.dex, classes1.dex…classesN.dex</li>
</ol>
<p>pre-dex 的详细解释可以参阅此链接 <a href="https://sites.google.com/a/android.com/tools/tech-docs/new-build-system/tips" target="_blank" rel="external">new-build-system</a></p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Improving Build Server performance.</span><br><span class="line">The Gradle based build system has a strong focus <span class="keyword">on</span> incremental builds. One way <span class="keyword">it</span> <span class="keyword">is</span> doing this <span class="keyword">in</span> doing pre-dexing <span class="keyword">on</span> <span class="keyword">the</span> dependencies <span class="keyword">of</span> each modules, so <span class="keyword">that</span> each gets turned <span class="keyword">into</span> <span class="keyword">its</span> own dex <span class="built_in">file</span> (ie converting <span class="keyword">its</span> Java bytecode <span class="keyword">into</span> Android bytecode). This allows <span class="keyword">the</span> dex task <span class="keyword">to</span> do less work <span class="keyword">and</span> <span class="keyword">to</span> only re-dex what changed <span class="keyword">and</span> merge all <span class="keyword">the</span> dex files.</span><br></pre></td></tr></table></figure>
<h3 id="Jack中间文件"><a href="#Jack中间文件" class="headerlink" title=".Jack中间文件"></a>.Jack中间文件</h3><p><code>.Jack</code> 的具体格式如下图所示</p>
<p><img src="http://img.alicdn.com/tfs/TB1a91AJFXXXXXXXVXXXXXXXXXX-1000-539.png" alt=".jack"></p>
<p>可见里面包含了 Jayce 格式的 IL ，pre-dex，原始 aar 中的资源文件，以及 Jack 会用到的一些 meta 信息</p>
<p>下图简单比较了 java 代码转化的 <code>.class</code>, Jayce IL 和 dex 的内容异同</p>
<p><img src="http://img.alicdn.com/tfs/TB1XqKBJFXXXXacXVXXXXXXXXXX-1041-611.png" alt="compare"></p>
<p>简单比较下三种 IL 的区别：</p>
<p>Sun/Oracle Hotspot VM 是基于栈式的，所以 <code>.class</code> 文件的内容就是不断地压操作数到栈顶，从栈顶读取操作数，比较或做运算，将结果再压回栈顶</p>
<p>Dalvik VM 是基于寄存器的，所以 <code>.dex</code> 的内容就是不断地 move 操作数到寄存器，比较或做运算，将结果写回寄存器或内存地址</p>
<p>Jayce 则是 Jack&amp;Jill 专有的 IL, 目前没有查阅到更多的官方资料。只能参阅 Jill 源代码中 com.android.jill.backend.jayce 包的代码了，比如其中的 Token 类就定义了 Jayce 的 Token 定义。</p>
<p>个人推测 Jayce 存在的意义是:</p>
<ul>
<li>为了在整合多个 jack 文件，生成单一的 dex 时，方便 Jack 做一些全局性的后端编译优化。</li>
<li>从 Android 生态圈中完全去除 Oracle 的 Java Bytecode 格式</li>
</ul>
<h3 id="使用Jack编译器的优势"><a href="#使用Jack编译器的优势" class="headerlink" title="使用Jack编译器的优势"></a>使用Jack编译器的优势</h3><ul>
<li>对依赖库做 pre dex，且成果会被保存到 build/intermediates/jill/debug 目录。</li>
</ul>
<p>之后的编译过程中，只要依赖库的数目和版本不变，之前的 pre dex 成果会被复用；Jack 只需要编译变化的源代码，然后对多个 dex 进行 merge 即可，能够加速整个编译过程。</p>
<ul>
<li>编译时会启动一个 Jack compilation server，并开启并行编译</li>
</ul>
<p>Jack 文档是这么介绍的</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This server brings <span class="keyword">an</span> intrinsic speedup, because <span class="keyword">it</span> avoids launching <span class="keyword">a</span> <span class="built_in">new</span> host JRE JVM, loading Jack code, initializing Jack <span class="keyword">and</span> warming up <span class="keyword">the</span> JIT <span class="keyword">at</span> <span class="keyword">each</span> compilation. It also provides very good compilation times during small compilations (e.g. <span class="keyword">in</span> incremental mode).</span><br><span class="line">The server is also <span class="keyword">a</span> <span class="keyword">short</span>-term solution <span class="built_in">to</span> control <span class="keyword">the</span> <span class="built_in">number</span> <span class="keyword">of</span> parallel Jack compilations, <span class="keyword">and</span> so <span class="built_in">to</span> avoid overloading your computer (memory <span class="keyword">or</span> disk issue), because <span class="keyword">it</span> limits <span class="keyword">the</span> <span class="built_in">number</span> <span class="keyword">of</span> parallel compilations.</span><br></pre></td></tr></table></figure>
<ul>
<li>支持 Java 8 的一部分特性</li>
<li>Jack 由 Google 完全掌控，未来可能成为 Android sdk 的默认编译器</li>
<li>向后兼容到 Android 2.3</li>
</ul>
<h3 id="采用-Jack-对打包流程的影响"><a href="#采用-Jack-对打包流程的影响" class="headerlink" title="采用 Jack 对打包流程的影响"></a>采用 Jack 对打包流程的影响</h3><ol>
<li>不再需要独立的 ProGuard。Jack 支持读取旧的 ProGuard 配置，完成 shrinking, obfuscation 的工作</li>
<li>不再需要独立的 jarjar。Jack 支持读取旧的 jarjar 配置，完成 repackaging 的工作</li>
<li>没有 <code>.class</code> 文件了，直接操纵或读取 Java 字节码的各种工具如 JaCoCo/Lint/Mokito/Retrolambda 没有了用武之地。但是仍然可以在 Android Library 上使用这些工具，编译为 aar/jar 后作为 Jill 的输入</li>
<li>annotation processors 如 Dagger, ButterKife 仍可以使用</li>
<li>Scala/Kotlin 等第三方 JVM 语言编写的内容必须先被 Jill 处理，再作为 Jack 的输入</li>
</ol>
<h3 id="Jack-当前的局限-截止到2016-03-15"><a href="#Jack-当前的局限-截止到2016-03-15" class="headerlink" title="Jack 当前的局限(截止到2016/03/15)"></a>Jack 当前的局限(截止到2016/03/15)</h3><ol>
<li>暂时还不支持 Android Studio 2.0 的 Instant Run 特性</li>
<li>暂时还不支持 data binding</li>
</ol>
<h2 id="65k-方法数目问题"><a href="#65k-方法数目问题" class="headerlink" title="65k 方法数目问题"></a>65k 方法数目问题</h2><h3 id="为什么会有-65k-问题"><a href="#为什么会有-65k-问题" class="headerlink" title="为什么会有 65k 问题?"></a>为什么会有 65k 问题?</h3><p>当你的 app 足够复杂之后，在打包时常常会遇到这种错误提示</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unable to execute dex: method ID not in [0, 0xffff]: 65536</span><br></pre></td></tr></table></figure>
<p>为什么方法数目不能超过 65k 呢？有人说是 dexopt 的问题，有人说是 dex 格式的限制，下面我们看看这个 log 到底是哪里吐出来的，然后分析下具体原因。</p>
<ul>
<li>dex 格式的限制？</li>
</ul>
<p>首先我们看一下 dex 的结构定义</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Direct-mapped "header_item" struct.</span></span><br><span class="line"><span class="keyword">struct</span> DexHeader &#123;</span><br><span class="line">	...</span><br><span class="line">  u4  methodIdsSize;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//These match the definitions in the VM specification.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span>            u4;</span><br></pre></td></tr></table></figure>
<p>可见 dex 文件结构是用 32 位来存储 method id 的，最大支持 2 的 32 次方，因此 65k 的原因不在于此。</p>
<ul>
<li>dexopt 的原因?</li>
</ul>
<p>dexopt 是 app 已经打包成功，安装到手机之后才会发生的过程。但是 65k 问题是在打包时发生的，所以问题原因也不在此</p>
<p>一般提到的 dexopt 错误，其实是 Android 2.3 及其以下在 dexopt 执行时只分配 5M 内存，导致方法数目过多(数量不一定到 65k)时在 odex 过程中崩溃，官方称之为 Dalvik linearAlloc bug(Issue 22586) 。</p>
<p>另：这个 linearAlloc 的限制不仅存在于 dexopt 里，还在 dalvik rumtime 中存在……</p>
<p>以下链接详细解释了此问题：<a href="https://github.com/simpleton/dalvik_patch" target="_blank" rel="external">https://github.com/simpleton/dalvik_patch</a></p>
<ul>
<li>错误 log 是哪里吐出来的?</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MemberIdsSection.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (items().size() &gt; DexFormat.MAX_MEMBER_IDX + <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> DexIndexOverflowException(getTooManyMembersMessage());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line">Maximum addressable field or method index.</span><br><span class="line">The largest addressable member is 0xffff, in the "instruction formats" spec as field@CCCC or meth@CCCC.</span><br><span class="line">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_MEMBER_IDX = <span class="number">0xFFFF</span>;</span><br></pre></td></tr></table></figure>
<p>通过查阅 <a href="https://source.android.com/devices/tech/dalvik/dalvik-bytecode.html" target="_blank" rel="external">dalvik-bytecode</a> 可知，@CCCC 的范围必须在 0～65535 之间。</p>
<p>所以归根结底，65k 问题是因为 dalvik bytecode 中的指令格式使用了 16 位来放 @CCCC 导致的；所以，不仅 Method 数目不能超过 65k, Field 和 Class 数目也不能超过 65k。</p>
<h3 id="为什么-jack-没有-65k-问题"><a href="#为什么-jack-没有-65k-问题" class="headerlink" title="为什么 jack 没有 65k 问题"></a>为什么 jack 没有 65k 问题</h3><p>前文已经很清楚地解释了 65k 问题的由来，可见只要 dalvik bytecode 指令格式不升级，65k 问题是逃不掉的。</p>
<p>Jack 官网对 65k 问题是这么说的：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Multidex support</span><br><span class="line"></span><br><span class="line">Since dex <span class="built_in">files</span> are limited <span class="built_in">to</span> <span class="number">65</span>K methods, apps <span class="keyword">with</span> over <span class="number">65</span>K methods must be <span class="built_in">split</span> <span class="keyword">into</span> multiple dex <span class="built_in">files</span>. (See ‘Building Apps <span class="keyword">with</span> Over <span class="number">65</span>K Methods’ <span class="keyword">for</span> more information about multidex.)</span><br><span class="line"></span><br><span class="line">Jack offers native <span class="keyword">and</span> legacy multidex support.</span><br></pre></td></tr></table></figure>
<p>所以，Jack 和旧工具链对 multidex 的支持方式是相同的</p>
<p>被 Jack 编译出来的 app 执行时也和以前一样</p>
<ol>
<li>若是 dalvik 虚拟机，它只支持读取一个 classes.dex。而 multidex 解决方案会读取多个 <code>.dex</code>，帮我们做 dex 数组合并</li>
<li>若是 art 虚拟机，它会扫描 classes.dex, classes1.dex…classesN.dex，调用 dex2oat 转化为单一的 oat</li>
</ol>
<h2 id="Jack-是怎么支持-Java-8-的？"><a href="#Jack-是怎么支持-Java-8-的？" class="headerlink" title="Jack 是怎么支持 Java 8 的？"></a>Jack 是怎么支持 Java 8 的？</h2><p>以 lambda 表达式为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Interface lambda = i -&gt; i + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>会被转化为 anonymous classes</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Interface lambda = <span class="keyword">new</span> Interface() &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">m</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Jack当前支持的 Java 8 特性可参见 <a href="https://developer.android.com/intl/zh-cn/preview/j8-jack.html" target="_blank" rel="external">j8-jack</a>。</p>
<h2 id="如何在-Gradle-脚本中使用-Jack-编译器编译-app"><a href="#如何在-Gradle-脚本中使用-Jack-编译器编译-app" class="headerlink" title="如何在 Gradle 脚本中使用 Jack 编译器编译 app"></a>如何在 Gradle 脚本中使用 Jack 编译器编译 app</h2><p>想使用 Jack 和 Jill 需要指定你的 Build Tools version 是 21.1.0+, Gradle plugin version 是1.0.0+。</p>
<p>以下的配置是我个人测试通过的配置</p>
<ul>
<li>使用 Android Gradle 插件 2.1.0-alpha2<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  classpath <span class="string">'com.android.tools.build:gradle:2.1.0-alpha2'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>使用以下版本的 sdk 和 build-tool</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">compileSdkVersion <span class="string">'android-N'</span></span><br><span class="line">buildToolsVersion <span class="string">'24.0.0 rc1'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在 defaultConfig 中指定用 Jack</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">defaultConfig &#123;</span><br><span class="line">  jackOptions &#123;</span><br><span class="line">    enabled <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 gradle 2.10 以上</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">distributionUrl=http\<span class="symbol">://mirrors</span>.taobao.net/mirror/gradle/gradle-<span class="number">2.10</span>-bin.zip</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 Android Studio 2.1 (preview) 或者命令行编译</p>
</li>
<li><p>可能需要提升 javaMaxHeapSize</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dexOptions&#123;</span><br><span class="line">  javaMaxHeapSize <span class="string">"2g"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h2><p>经过测试，当前版本(2016/03/15)的 Jack 编译器比起 Javac+dx 在编译时间，编译出的 apk 体积，编译出的 apk 的性能上暂时并没有优势。</p>
<p>但是，可以期待 Google 将在 Jack 编译器上做大量的智力投资，Jack 的未来是光明的。</p>
<p>下图是 guardsquare 公司对 Javac+dx 和 Jack 做的对比测试</p>
<p><img src="http://img.alicdn.com/tfs/TB1odirJFXXXXaYaXXXXXXXXXXX-979-726.png" alt="buildtime"></p>
<p>对于不 proguard 的 clean build，javac/dx 耗时 56s， jack 耗时 1 m 48 s；之所以 jack 这么慢是因为它要做大量的 pre-dex。</p>
<p><img src="http://img.alicdn.com/tfs/TB1vV9LJFXXXXaXXFXXXXXXXXXX-946-673.png" alt="performance"></p>
<p>对于不 proguard 的 clean build，javac/dx 和 jack 编译出来的 app 性能相差无几。</p>
<p><img src="http://img.alicdn.com/tfs/TB1E3GnJFXXXXcmaXXXXXXXXXXX-956-640.png" alt="size"></p>
<p>对于共用 proguard 配置文件情况，javac/dx 和jack 编译出来的 app 体积也差不多。</p>
<p>我个人测试的编译速度 / apk 体积等对比也大致如此，在此不再赘述.</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>虽然 Jack 编译器的现状并不出彩，但是它终究有一天会成为 Android app 的官方推荐编译器。</p>
<p>期待 Google Android team 加倍努力，让这一天早日到来。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://www.guardsquare.com/blog/the_upcoming_jack_and_jill_compilers_in_android" target="_blank" rel="external">https://www.guardsquare.com/blog/the_upcoming_jack_and_jill_compilers_in_android</a></li>
<li><a href="http://source.android.com/devices/tech/dalvik/dex-format.html" target="_blank" rel="external">http://source.android.com/devices/tech/dalvik/dex-format.html</a></li>
<li><a href="http://tools.android.com/tech-docs/jackandjill" target="_blank" rel="external">http://tools.android.com/tech-docs/jackandjill</a></li>
<li><a href="https://developer.android.com/intl/zh-cn/tools/building/multidex.html" target="_blank" rel="external">https://developer.android.com/intl/zh-cn/tools/building/multidex.html</a></li>
<li><a href="https://www.guardsquare.com/blog/DroidconLondon2015" target="_blank" rel="external">https://www.guardsquare.com/blog/DroidconLondon2015</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img.alicdn.com/tfs/TB1brqAJFXXXXaGXVXXXXXXXXXX-900-500.jpg" alt="Android 新一代编译 toolchain Jack &amp; Jill 简介"></p>
<p>201]]>
    </summary>
    
      <category term="toolchain Jack&amp;Jill" scheme="http://taobaofed.org/tags/toolchain-Jack-Jill/"/>
    
      <category term="无线开发" scheme="http://taobaofed.org/categories/%E6%97%A0%E7%BA%BF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Promise 反模式]]></title>
    <link href="http://taobaofed.org/blog/2016/05/03/promise-anti-patterns/"/>
    <id>http://taobaofed.org/blog/2016/05/03/promise-anti-patterns/</id>
    <published>2016-05-03T08:59:13.000Z</published>
    <updated>2016-10-12T02:02:15.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://gtms02.alicdn.com/tps/i2/TB1d9xhJFXXXXa8XFXX2AXZ8pXX-900-500.png" alt="Promise 反模式"></p>
<p>Promises are about making asynchronous code retain most of the lost properties of synchronous code such as flat indentation and one exception channel. – Bluebird Wiki: Promise Anti Patterns</p>
<p>Promises 是为了让异步代码也能保持这些同步代码的属性：扁平缩进和单异常管道。</p>
<h3 id="Deferred-反模式"><a href="#Deferred-反模式" class="headerlink" title="Deferred 反模式"></a>Deferred 反模式</h3><p>这种反模式中，<code>deferred</code> 对象的创建是没有意义的，反而会增加代码的复杂度。</p>
<p>例如：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Code copyright by Twisternha http://stackoverflow.com/a/19486699/995876 CC BY-SA 2.5</span></span><br><span class="line">myApp.factory(<span class="string">'Configurations'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(Restangular, MotorRestangular, $q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> getConfigurations = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> deferred = $q.defer();</span><br><span class="line"></span><br><span class="line">        MotorRestangular.all(<span class="string">'Motors'</span>).getList().then(<span class="function"><span class="keyword">function</span> <span class="params">(Motors)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//Group by Config</span></span><br><span class="line">            <span class="keyword">var</span> g = _.groupBy(Motors, <span class="string">'configuration'</span>);</span><br><span class="line">            <span class="comment">//Map values</span></span><br><span class="line">            <span class="keyword">var</span> mapped = _.map(g, <span class="function"><span class="keyword">function</span> <span class="params">(m)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    id: m[<span class="number">0</span>].configuration,</span><br><span class="line">                    configuration: m[<span class="number">0</span>].configuration,</span><br><span class="line">                    sizes: _.map(m, <span class="function"><span class="keyword">function</span> <span class="params">(a)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> a.sizeMm</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            deferred.resolve(mapped);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> deferred.promise;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        config: getConfigurations()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这里的 <code>deferred</code> 对象并没有什么意义，而且可能在出错的情况下无法捕获。</p>
<p>正确的写法应该为：</p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">myApp.factory(<span class="string">'Configurations'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">Restangular, MotorRestangular, $q</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">var</span> getConfigurations = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//Just return the promise we already have!</span></span><br><span class="line">        <span class="keyword">return</span> MotorRestangular.all(<span class="string">'Motors'</span>).getList().then(<span class="function"><span class="keyword">function</span> (<span class="params">Motors</span>) </span>&#123;</span><br><span class="line">            <span class="comment">//Group by Cofig</span></span><br><span class="line">            <span class="built_in">var</span> g = _.groupBy(Motors, <span class="string">'configuration'</span>);</span><br><span class="line">            <span class="comment">//Return the mapped array as the value of this promise</span></span><br><span class="line">            <span class="keyword">return</span> _.map(g, <span class="function"><span class="keyword">function</span> (<span class="params">m</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    <span class="attribute">id:</span><span class="string"> m</span>[<span class="number">0</span>].configuration,</span><br><span class="line">                    <span class="attribute">configuration</span>: m[<span class="number">0</span>].configuration,</span><br><span class="line">                    <span class="attribute">sizes</span>: _.map(m, <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> a.sizeMm</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attribute">config</span>: getConfigurations()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>再举一个例子：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span></span> applicationFunction(arg1) &#123;</span><br><span class="line">  var <span class="keyword">deferred</span> = Promise.pending(); // 获取 Q.defer()</span><br><span class="line">  libraryFunction(arg1, <span class="function"><span class="keyword">function</span><span class="params">(err, value)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">deferred</span>.reject(err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">deferred</span>.resolve(<span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">deferred</span>.promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就像重复造轮子，因为回调 API 的封装应该使用 promise 库的 promisification（promise 化）方法实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> applicationFunction = <span class="built_in">Promise</span>.promisify(libraryFunction);</span><br></pre></td></tr></table></figure>
<p>通用 promise 化可能更快，因为可以借助 Promise 的内部操作，还能处理一些极端情况：例如 <code>libraryFunction</code> 同步抛异常或者用到了多个成功值。</p>
<h4 id="什么时候使用-deferred？"><a href="#什么时候使用-deferred？" class="headerlink" title="什么时候使用 deferred？"></a>什么时候使用 deferred？</h4><p>必须用的时候。</p>
<p>当要封装的回调 API 和规范不一致时，例如 <code>setTimeout</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 setTimeout 返回 promise</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delay</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> deferred = <span class="built_in">Promise</span>.pending();</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    deferred.resolve();</span><br><span class="line">  &#125;, ms);</span><br><span class="line">  <span class="keyword">return</span> deferred.promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="then-success-fail-反模式"><a href="#then-success-fail-反模式" class="headerlink" title=".then(success, fail) 反模式"></a><code>.then(success, fail)</code> 反模式</h3><p>这样使用 <code>.then</code> 就像下面这段代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t0;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  t0 = doThat();</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样报错发生时会 catch 不到</span></span><br><span class="line"><span class="keyword">var</span> staff = <span class="built_in">JSON</span>.parse(t0);</span><br></pre></td></tr></table></figure>
<p>正常的同步写法是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> stuff = <span class="built_in">JSON</span>.parse(doThat());</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以正确的 <code>.then</code> 用法应该是：</p>
<figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">doThat()</span><br><span class="line">.<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(v)</span> &#123;</span></span><br><span class="line">  <span class="keyword">return</span> JSON.parse(v);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="keyword">catch</span>(<span class="function"><span class="keyword">function</span><span class="params">(e)</span> &#123;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="嵌套-Promise"><a href="#嵌套-Promise" class="headerlink" title="嵌套 Promise"></a>嵌套 Promise</h3><p>例如：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">loadSomething().<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(something)</span></span> &#123;</span><br><span class="line">  loadAnothering().<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(another)</span></span> &#123;</span><br><span class="line">    DoSomethingOnThem(something, another);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果只是想对两个 promise 的结果做处理，可以使用 Promise.all 方法：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Promise.<span class="built_in">all</span>([loadSomething, loadAnothering]).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(something, another)</span></span> &#123;</span><br><span class="line">  DoSomethingOnThem(something, another);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="断链"><a href="#断链" class="headerlink" title="断链"></a>断链</h3><p>例如：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">anAsyncCall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> promise = doSomethingAsync();</span><br><span class="line">  promise.then(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    somethingComplicated();</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的问题在于加入 <code>somethingComplicated()</code> 出错的话不会被捕获。promise 应该链式调用。也就是说所有的 <code>then</code> 方法都应该返回一个新的 <code>promise</code>。所以上面代码的正确写法为：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">anAsyncCall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> promise = doSomethingAsync();</span><br><span class="line">  <span class="keyword">return</span> promise.then(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    somethingComplicated();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>例如需要对一个集合中的每个元素执行异步操作：</p>
<figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workMyCollection</span><span class="params">(arr)</span> &#123;</span></span><br><span class="line">  var resultArr = [];</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">_recursive</span><span class="params">(idx)</span> &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (idx &gt;= resultArr.<span class="built_in">length</span>) <span class="keyword">return</span> resultArr;</span><br><span class="line">    <span class="keyword">return</span> doSomethingAsync(arr[idx]).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(res)</span> &#123;</span></span><br><span class="line">      resultArr.push(res);</span><br><span class="line">      <span class="keyword">return</span> _recursive(idx + <span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> _recursive(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的问题在于需要遍历数组，其实可以用 <code>promise.all</code> 解决：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workMyCollection</span><span class="params">(arr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> q.all(</span><br><span class="line">    arr.map(<span class="function"><span class="keyword">function</span><span class="params">(item)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> doSomethingAsync(item);</span><br><span class="line">    &#125;)</span><br><span class="line">  );    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最容易犯的错误，没有使用 <code>catch</code> 去捕获 <code>then</code> 里抛出的报错：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// snippet1</span></span><br><span class="line">somePromise().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'oh noes'</span>);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// I caught your error! :)</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// snippet2</span></span><br><span class="line">somePromise().then(<span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'oh noes'</span>);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// I didn't catch your error! :(</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这里的问题在于 snippet2 在 function resolve 中出错时无法捕获。而 catch 则可以。</p>
<p>下面的两个示例返回结果是不一样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example1</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'foo'</span>).then(<span class="built_in">Promise</span>.resolve(<span class="string">'bar'</span>)).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);  <span class="comment">// foo</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// example2</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'foo'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">'bar'</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result); <span class="comment">// bar</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>example2 改变了返回值，因而 result 发生了变化。</p>
<h3 id="更多关键词"><a href="#更多关键词" class="headerlink" title="更多关键词"></a>更多关键词</h3><p><code>async flow control, event loop, callback, promises, generators, async/wait, coroutines</code></p>
<p>Promises 所做的承诺是保证异步代码顺序执行，并能够链式管理异常和错误。相比使用 <code>event loop</code> 和回调（callback）来控制异步代码的顺序执行，Promises 能够让代码更加清晰易懂。generator 更是从语言级别上提供了更好的支持。</p>
<h3 id="V8-优化"><a href="#V8-优化" class="headerlink" title="V8 优化"></a>V8 优化</h3><p>V8 有两个编译器：通用编译器和优化编译器。也就是V8 中的 JavaScript 代码总是被编译成机器码后才执行的。</p>
<p>例如 <code>a + b</code> 编译成汇编代码为：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, a</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ebx</span>, b</span><br><span class="line"><span class="keyword">call</span> RuntimeAdd</span><br></pre></td></tr></table></figure>
<p>但如果 <code>a</code> 和 <code>b</code> 都是整数的话，则会被编译成：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, a</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ebx</span>, b</span><br><span class="line"><span class="keyword">add</span> <span class="built_in">eax</span>, <span class="built_in">ebx</span></span><br></pre></td></tr></table></figure>
<p>这样编译后的代码性能会快很多，因为跳过了 JavaScript 对不同类型数据相加的处理。</p>
<p>通用编译器会得到前一种汇编码，优化编译器会得到后一种汇编码。两种汇编代码性能很容易产生 100 倍的差异。但是存在一些模式，这些模式下的代码优化编译器不会去处理（称为<code>bail out</code>）。Promises 属于一种被 bail out 的模式。</p>
<h3 id="他山之石"><a href="#他山之石" class="headerlink" title="他山之石"></a>他山之石</h3><p>Python greenlets（基于gevent）</p>
<p>go coroutine</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://github.com/petkaantonov/bluebird/wiki/Promise-anti-patterns#the-thensuccess-fail-anti-pattern" target="_blank" rel="external">bluebird wiki</a></li>
<li><a href="http://taoofcode.net/promise-anti-patterns/" target="_blank" rel="external">tao of code</a></li>
<li><a href="https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html" target="_blank" rel="external">https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html</a></li>
<li><a href="https://www.promisejs.org/patterns/" target="_blank" rel="external">https://www.promisejs.org/patterns/</a></li>
<li><a href="http://www.slideshare.net/domenicdenicola/callbacks-promises-and-coroutines-oh-my-the-evolution-of-asynchronicity-in-javascript" target="_blank" rel="external">http://www.slideshare.net/domenicdenicola/callbacks-promises-and-coroutines-oh-my-the-evolution-of-asynchronicity-in-javascript</a></li>
<li><a href="https://github.com/nodejs/node/wiki/Async-Exception-Handling" target="_blank" rel="external">Node.js async exception handling</a></li>
<li><a href="https://promise-nuggets.github.io/" target="_blank" rel="external">promise nuggets</a></li>
<li><a href="https://github.com/petkaantonov/bluebird/wiki/Optimization-killers" target="_blank" rel="external">Optimization Killers</a></li>
<li><a href="https://github.com/vhf/v8-bailout-reasons" target="_blank" rel="external">v8 bailout reasons</a></li>
<li><a href="https://sdiehl.github.io/gevent-tutorial/" target="_blank" rel="external">Python greenlets</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://gtms02.alicdn.com/tps/i2/TB1d9xhJFXXXXa8XFXX2AXZ8pXX-900-500.png" alt="Promise 反模式"></p>
<p>Promises are about making as]]>
    </summary>
    
      <category term="nodejs" scheme="http://taobaofed.org/tags/nodejs/"/>
    
      <category term="promise" scheme="http://taobaofed.org/tags/promise/"/>
    
      <category term="generator" scheme="http://taobaofed.org/tags/generator/"/>
    
      <category term="async" scheme="http://taobaofed.org/tags/async/"/>
    
      <category term="flow_control" scheme="http://taobaofed.org/tags/flow-control/"/>
    
      <category term="Node.js" scheme="http://taobaofed.org/categories/Node-js/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[无线性能优化：Composite]]></title>
    <link href="http://taobaofed.org/blog/2016/04/25/performance-composite/"/>
    <id>http://taobaofed.org/blog/2016/04/25/performance-composite/</id>
    <published>2016-04-25T02:21:18.000Z</published>
    <updated>2016-10-12T02:02:15.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img.alicdn.com/tfs/TB1XT4kMFXXXXaBXXXXXXXXXXXX-900-500.png" alt="无线性能优化：Composite"></p>
<p>一个 Web 页面的展示，简单来说可以认为经历了以下下几个步骤。</p>
<p><img src="https://img.alicdn.com/tps/TB1eabOLpXXXXX3XFXXXXXXXXXX-1093-167.jpg_720x720.jpg" alt=""></p>
<ul>
<li>JavaScript：一般来说，我们会使用 JavaScript 来实现一些视觉变化的效果。比如做一个动画或者往页面里添加一些 DOM 元素等。</li>
<li>Style：计算样式，这个过程是根据 CSS 选择器，对每个 DOM 元素匹配对应的 CSS 样式。这一步结束之后，就确定了每个 DOM 元素上该应用什么 CSS 样式规则。</li>
<li>Layout：布局，上一步确定了每个 DOM 元素的样式规则，这一步就是具体计算每个 DOM 元素最终在屏幕上显示的大小和位置。web 页面中元素的布局是相对的，因此一个元素的布局发生变化，会联动地引发其他元素的布局发生变化。比如，<code>&lt;body&gt;</code> 元素的宽度的变化会影响其子元素的宽度，其子元素宽度的变化也会继续对其孙子元素产生影响。因此对于浏览器来说，布局过程是经常发生的。</li>
<li>Paint：绘制，本质上就是填充像素的过程。包括绘制文字、颜色、图像、边框和阴影等，也就是一个 DOM 元素所有的可视效果。一般来说，这个绘制过程是在多个层上完成的。</li>
<li>Composite：渲染层合并，由上一步可知，对页面中 DOM 元素的绘制是在多个层上进行的。在每个层上完成绘制过程之后，浏览器会将所有层按照合理的顺序合并成一个图层，然后显示在屏幕上。对于有位置重叠的元素的页面，这个过程尤其重要，因为一旦图层的合并顺序出错，将会导致元素显示异常。</li>
</ul>
<p>当然，本文我们只来关注 Composite 部分。</p>
<h2 id="浏览器渲染原理"><a href="#浏览器渲染原理" class="headerlink" title="浏览器渲染原理"></a>浏览器渲染原理</h2><p>在讨论 Composite 之前，有必要先简单了解下一些浏览器（本文只是针对 Chrome 来说）的渲染原理，方便对之后一些概念的理解。更多详细的内容可以参阅 <a href="http://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome" target="_blank" rel="external">GPU Accelerated Compositing in Chrome</a></p>
<p>注：由于 Chrome 对 Blank 引擎某些实现的修改，某些我们之前熟知的类名有了变化，比如 RenderObject 变成了 LayoutObject，RenderLayer 变成了 PaintLayer。感兴趣的看以参阅 <a href="https://www.chromium.org/blink/slimming-paint" target="_blank" rel="external">Slimming Paint</a>。</p>
<p>在浏览器中，页面内容是存储为由 Node 对象组成的树状结构，也就是 DOM 树。每一个 HTML element 元素都有一个 Node 对象与之对应，DOM 树的根节点永远都是 Document Node。这一点相信大家都很熟悉了，但其实，从 DOM 树到最后的渲染，需要进行一些转换映射。</p>
<p><img src="https://img.alicdn.com/tps/TB1VFRDMXXXXXahXpXXXXXXXXXX-814-320.png_720x720.jpg" alt=""></p>
<h3 id="从-Nodes-到-LayoutObjects"><a href="#从-Nodes-到-LayoutObjects" class="headerlink" title="从 Nodes 到 LayoutObjects"></a>从 Nodes 到 LayoutObjects</h3><p>DOM 树中得每个 Node 节点都有一个对应的 LayoutObject 。LayoutObject 知道如何在屏幕上 paint Node 的内容。</p>
<h3 id="从-LayoutObjects-到-PaintLayers"><a href="#从-LayoutObjects-到-PaintLayers" class="headerlink" title="从 LayoutObjects 到 PaintLayers"></a>从 LayoutObjects 到 PaintLayers</h3><p>一般来说，拥有相同的坐标空间的 LayoutObjects，属于同一个渲染层（PaintLayer）。PaintLayer 最初是用来实现 <a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context" target="_blank" rel="external">stacking contest（层叠上下文）</a>，以此来保证页面元素以正确的顺序合成（composite），这样才能正确的展示元素的重叠以及半透明元素等等。因此满足形成层叠上下文条件的 LayoutObject 一定会为其创建新的渲染层，当然还有其他的一些特殊情况，为一些特殊的 LayoutObjects 创建一个新的渲染层，比如 <code>overflow != visible</code> 的元素。根据创建 PaintLayer 的原因不同，可以将其分为常见的 3 类：</p>
<ul>
<li><p>NormalPaintLayer</p>
<ul>
<li>根元素（HTML）</li>
<li>有明确的定位属性（relative、fixed、sticky、absolute）</li>
<li>透明的（opacity 小于 1）</li>
<li>有 CSS 滤镜（fliter）</li>
<li>有 CSS mask 属性</li>
<li>有 CSS mix-blend-mode 属性（不为 normal）</li>
<li>有 CSS transform 属性（不为 none）</li>
<li>backface-visibility 属性为 hidden</li>
<li>有 CSS reflection 属性</li>
<li>有 CSS column-count 属性（不为 auto）或者 有 CSS column-width 属性（不为 auto）</li>
<li>当前有对于 opacity、transform、fliter、backdrop-filter 应用动画</li>
</ul>
</li>
<li><p>OverflowClipPaintLayer</p>
<ul>
<li>overflow 不为 visible</li>
</ul>
</li>
<li><p>NoPaintLayer</p>
<ul>
<li>不需要 paint 的 PaintLayer，比如一个没有视觉属性（背景、颜色、阴影等）的空 div。</li>
</ul>
</li>
</ul>
<p>满足以上条件的 LayoutObject 会拥有独立的渲染层，而其他的 LayoutObject 则和其第一个拥有渲染层的父元素共用一个。</p>
<h3 id="从-PaintLayers-到-GraphicsLayers"><a href="#从-PaintLayers-到-GraphicsLayers" class="headerlink" title="从 PaintLayers 到 GraphicsLayers"></a>从 PaintLayers 到 GraphicsLayers</h3><p>某些特殊的渲染层会被认为是合成层（Compositing Layers），合成层拥有单独的 GraphicsLayer，而其他不是合成层的渲染层，则和其第一个拥有 GraphicsLayer 父层公用一个。</p>
<p>每个 GraphicsLayer 都有一个 GraphicsContext，GraphicsContext 会负责输出该层的位图，位图是存储在共享内存中，作为纹理上传到 GPU 中，最后由 GPU 将多个位图进行合成，然后 draw 到屏幕上，此时，我们的页面也就展现到了屏幕上。</p>
<p>渲染层提升为合成层的原因有一下几种：</p>
<p>注：渲染层提升为合成层有一个先决条件，该渲染层必须是 SelfPaintingLayer（基本可认为是上文介绍的 NormalPaintLayer）。以下所讨论的渲染层提升为合成层的情况都是在该渲染层为 SelfPaintingLayer 前提下的。</p>
<ul>
<li><p>直接原因（direct reason）</p>
<ul>
<li>硬件加速的 iframe 元素（比如 iframe 嵌入的页面中有合成层）<a href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/direct/iframe.html" target="_blank" rel="external">demo</a></li>
<li>video 元素</li>
<li>覆盖在 video 元素上的视频控制栏</li>
<li><p>3D 或者 硬件加速的 2D Canvas 元素</p>
<ul>
<li><a href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/direct/canvas.html" target="_blank" rel="external">demo：普通 2D Canvas 不会提升为合成层</a></li>
<li><a href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/direct/webgl.html" target="_blank" rel="external">demo：3D Canvas 提升为合成层</a></li>
</ul>
</li>
<li><p>硬件加速的插件，比如 flash 等等</p>
</li>
<li>在 DPI 较高的屏幕上，fix 定位的元素会自动地被提升到合成层中。但在 DPI 较低的设备上却并非如此，因为这个渲染层的提升会使得字体渲染方式由子像素变为灰阶（详细内容请参考：<a href="http://www.html5rocks.com/en/tutorials/internals/antialiasing-101/?redirect_from_locale=zh#toc-text-rendering" target="_blank" rel="external">Text Rendering</a>）</li>
<li>有 3D transform</li>
<li>backface-visibility 为 hidden</li>
<li><p>对 opacity、transform、fliter、backdropfilter 应用了 animation 或者 transition（需要是 active 的 animation 或者 transition，当 animation 或者 transition 效果未开始或结束后，提升合成层也会失效）</p>
<ul>
<li><a href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/direct/animation.html" target="_blank" rel="external">demo：animation</a></li>
<li><p><a href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/direct/transition.html" target="_blank" rel="external">demo：transition</a></p>
<p><img src="https://img.alicdn.com/tps/TB1XMzqMXXXXXXsXFXXXXXXXXXX-959-370.jpg" alt=""></p>
</li>
</ul>
</li>
<li><p>will-change 设置为 opacity、transform、top、left、bottom、right（其中 top、left 等需要设置明确的定位属性，如 relative 等）<a href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/direct/will-change.html" target="_blank" rel="external">demo</a></p>
</li>
</ul>
</li>
<li><p>后代元素原因</p>
<ul>
<li>有合成层后代同时本身有 transform、opactiy（小于 1）、mask、fliter、reflection 属性 <a href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/descendant/combo.html" target="_blank" rel="external">demo</a></li>
<li>有合成层后代同时本身 overflow 不为 visible（如果本身是因为明确的定位因素产生的 SelfPaintingLayer，则需要 z-index 不为 auto） <a href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/descendant/overflow.html" target="_blank" rel="external">demo</a></li>
<li>有合成层后代同时本身 fixed 定位 <a href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/descendant/fixed.html" target="_blank" rel="external">demo</a></li>
<li>有 3D transfrom 的合成层后代同时本身有 preserves-3d 属性 <a href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/descendant/preserves-3d.html" target="_blank" rel="external">demo</a></li>
<li>有 3D transfrom 的合成层后代同时本身有 perspective 属性 <a href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/descendant/perspective.html" target="_blank" rel="external">demo</a></li>
</ul>
</li>
<li><p>overlap 重叠原因</p>
<p>  为什么会因为重叠原因而产生合成层呢？举个简单的栗子。</p>
<p>  <img src="https://img.alicdn.com/tps/TB1sZbvMXXXXXXlXXXXXXXXXXXX-491-300.jpg" alt=""></p>
<p>  蓝色的矩形重叠在绿色矩形之上，同时它们的父元素是一个 GraphicsLayer。此时假设绿色矩形为一个 GraphicsLayer，如果 overlap 无法提升合成层的话，那么蓝色矩形不会提升为合成层，也就会和父元素公用一个 GraphicsLayer。</p>
<p>  <img src="https://img.alicdn.com/tps/TB1qzzmMXXXXXX1XpXXXXXXXXXX-491-300.jpg" alt=""></p>
<p>  此时，渲染顺序就会发生错误，因此为保证渲染顺序，overlap 也成为了合成层产生的原因，也就是如下的正常情形。</p>
<p>  <img src="https://img.alicdn.com/tps/TB13cYmMXXXXXaXXpXXXXXXXXXX-491-300.jpg" alt=""></p>
<p>  当然 overlap 的原因也会细分为几类，接下来我们会详细看下。</p>
<ul>
<li><p>重叠或者说部分重叠在一个合成层之上。</p>
<p>  那如何算是重叠呢，最常见和容易理解的就是元素的 border box（content + padding + border） 和合成层的有重叠，比如：<a href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/overlap/normal.html" target="_blank" rel="external">demo</a>，当然 margin area 的重叠是无效的（<a href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/overlap/margin.html" target="_blank" rel="external">demo</a>）。其他的还有一些不常见的情况，也算是同合成层重叠的条件，如下：</p>
<ul>
<li>filter 效果同合成层重叠 <a href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/overlap/filter.html" target="_blank" rel="external">demo</a></li>
<li>transform 变换后同合成层重叠 <a href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/overlap/transform.html" target="_blank" rel="external">demo</a></li>
<li>overflow scroll 情况下同合成层重叠。即如果一个 overflow scroll（不管 <code>overflow:auto</code> 还是 <code>overflow:scrill</code>，只要是能 scroll 即可） 的元素同一个合成层重叠，则其可视子元素也同该合成层重叠 <a href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/overlap/overflow.html" target="_blank" rel="external">demo</a></li>
</ul>
</li>
<li><p>假设重叠在一个合成层之上（assumedOverlap）。</p>
<p>  这个原因听上去有点虚，什么叫假设重叠？其实也比较好理解，比如一个元素的 CSS 动画效果，动画运行期间，元素是有可能和其他元素有重叠的。针对于这种情况，于是就有了 assumedOverlap 的合成层产生原因，示例可见：<a href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/overlap/animation.html" target="_blank" rel="external">demo</a>。在本 demo 中，动画元素视觉上并没有和其兄弟元素重叠，但因为 assumedOverlap 的原因，其兄弟元素依然提升为了合成层。</p>
<p>  需要注意的是该原因下，有一个很特殊的情况：</p>
<p>  如果合成层有内联的 transform 属性，会导致其兄弟渲染层 assume overlap，从而提升为合成层。比如：<a href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/overlap/inline.html" target="_blank" rel="external">demo</a>。</p>
</li>
</ul>
</li>
</ul>
<h4 id="层压缩"><a href="#层压缩" class="headerlink" title="层压缩"></a>层压缩</h4><p>基本上常见的一些合成层的提升原因如上所说，你会发现，由于重叠的原因，可能随随便便就会产生出大量合成层来，而每个合成层都要消耗 CPU 和内存资源，岂不是严重影响页面性能。这一点浏览器也考虑到了，因此就有了层压缩（Layer Squashing）的处理。如果多个渲染层同一个合成层重叠时，这些渲染层会被压缩到一个 GraphicsLayer 中，以防止由于重叠原因导致可能出现的“层爆炸”。具体可以看如下 <a href="http://taobaofed.github.io/demo/performance-composite-demo/squash/squash-hover.html" target="_blank" rel="external">demo</a>。一开始，蓝色方块由于<br><code>translateZ</code> 提升为了合成层，其他的方块元素因为重叠的原因，被压缩了一起，大小就是包含这 3 个方块的矩形大小。</p>
<p><img src="https://img.alicdn.com/tps/TB1yslCMXXXXXahaXXXXXXXXXXX-755-406.png_720x720.jpg" alt=""></p>
<p>当我们 hover 绿色方块时，会给其设置 <code>translateZ</code> 属性，导致绿色方块也被提升为合成层，则剩下的两个被压缩到了一起，大小就缩小为包含这 2 个方块的矩形大小。</p>
<p><img src="https://img.alicdn.com/tps/TB1xxh1MXXXXXX_XXXXXXXXXXXX-755-406.png_720x720.jpg" alt=""></p>
<p>当然，浏览器的自动的层压缩也不是万能的，有很多特定情况下，浏览器是无法进行层压缩的，如下所示，而这些情况也是我们应该尽量避免的。（注：以下情况都是基于重叠原因而言）</p>
<ul>
<li><p>无法进行会打破渲染顺序的压缩（squashingWouldBreakPaintOrder）</p>
<p>  示例如下：<a href="http://taobaofed.github.io/demo/performance-composite-demo/squash/squashingWouldBreakPaintOrder-mask.html" target="_blank" rel="external">demo</a></p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span><br><span class="line">  <span class="selector-id">#ancestor</span> &#123;</span><br><span class="line">    <span class="attribute">-webkit-mask-image</span>: <span class="built_in">-webkit-linear-gradient</span>(rgba(0,0,0,1), <span class="built_in">rgba</span>(0,0,0,0));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="selector-id">#composited</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateZ</span>(0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-id">#container</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">60px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-id">#overlap-child</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span> ;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">60px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: orange;</span><br><span class="line">  &#125;</span><br><span class="line"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"composited"</span>&gt;</span>Text behind the orange box.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"ancestor"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"overlap-child"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>  在本例中，<code>#overlap-child</code> 同合成层重叠，如果进行压缩，会导致渲染顺序的改变，其父元素 <code>#ancestor</code> 的 mask 属性将失效，因此类似这种情况下，是无法进行层压缩的。目前常见的产生这种原因的情况有两种，一种是上述的祖先元素使用 mask 属性的情况，另一种是祖先元素使用 filter 属性的情况（<a href="http://taobaofed.github.io/demo/performance-composite-demo/squash/squashingWouldBreakPaintOrder-filter.html" target="_blank" rel="external">demo</a>）。</p>
</li>
<li><p>video 元素的渲染层无法被压缩同时也无法将别的渲染层压缩到 video 所在的合成层上（squashingVideoIsDisallowed）<a href="http://taobaofed.github.io/demo/performance-composite-demo/squash/video.html" target="_blank" rel="external">demo</a></p>
</li>
<li><p>iframe、plugin 的渲染层无法被压缩同时也无法将别的渲染层压缩到其所在的合成层上（squashingLayoutPartIsDisallowed）<a href="http://taobaofed.github.io/demo/performance-composite-demo/squash/layoutpart.html" target="_blank" rel="external">demo</a></p>
</li>
<li><p>无法压缩有 reflection 属性的渲染层（squashingReflectionDisallowed）<a href="http://taobaofed.github.io/demo/performance-composite-demo/squash/reflection.html" target="_blank" rel="external">demo</a></p>
</li>
<li><p>无法压缩有 blend mode 属性的渲染层（squashingBlendingDisallowed）<a href="http://taobaofed.github.io/demo/performance-composite-demo/squash/blend-mode.html" target="_blank" rel="external">demo</a></p>
</li>
<li><p>当渲染层同合成层有不同的裁剪容器（clipping container）时，该渲染层无法压缩（squashingClippingContainerMismatch）。</p>
<p>  示例如下：<a href="http://taobaofed.github.io/demo/performance-composite-demo/squash/squashingClippingContainerMismatch.html" target="_blank" rel="external">demo</a></p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span><br><span class="line">  <span class="selector-class">.clipping-container</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">10px</span>; </span><br><span class="line">    <span class="attribute">background-color</span>: blue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.composited</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateZ</span>(0); </span><br><span class="line">    <span class="attribute">height</span>: <span class="number">10px</span>; </span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.target</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">position</span>:absolute; </span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0px</span>; </span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100px</span>; </span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100px</span>; </span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"clipping-container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"composited"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"target"</span>&gt;</span>不会被压缩到 composited div 上<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>  本例中 <code>.target</code> 同 合成层 <code>.composited</code> 重叠，但是由于 <code>.composited</code> 在一个 <code>overflow: hidden</code> 的容器中，导致 <code>.target</code> 和合成层有不同的裁剪容器，从而 <code>.target</code> 无法被压缩。</p>
</li>
<li><p>相对于合成层滚动的渲染层无法被压缩（scrollsWithRespectToSquashingLayer）</p>
<p>  示例如下：<a href="http://taobaofed.github.io/demo/performance-composite-demo/squash/scrollsWithRespectToSquashingLayer.html" target="_blank" rel="external">demo</a></p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">1500px</span>;</span><br><span class="line">    <span class="attribute">overflow-x</span>: hidden;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.composited</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateZ</span>(0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.overlap</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">    <span class="attribute">position</span>: fixed;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0px</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"composited"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"overlap"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>  本例中，红色的 <code>.composited</code> 提升为了合成层，绿色的 <code>.overlap</code> fix 在页面顶部，一开始只有 <code>.composited</code> 合成层。</p>
<p>  <img src="https://img.alicdn.com/tps/TB1SHBOMXXXXXbnXFXXXXXXXXXX-690-484.jpg_640x640.jpg" alt=""></p>
<p>  当滑动页面，<code>.overlap</code> 重叠到 <code>.composited</code> 上时，<code>.overlap</code> 会因重叠原因提升为合成层，同时，因为相对于合成层滚动，因此无法被压缩。</p>
<p>  <img src="https://img.alicdn.com/tps/TB1IrRGMXXXXXXxaXXXXXXXXXXX-690-484.jpg_640x640.jpg" alt=""></p>
</li>
<li><p>当渲染层同合成层有不同的具有 opacity 的祖先层（一个设置了 opacity 且小于 1，一个没有设置 opacity，也算是不同）时，该渲染层无法压缩（squashingOpacityAncestorMismatch，同 squashingClippingContainerMismatch）<a href="http://taobaofed.github.io/demo/performance-composite-demo/squash/squashingOpacityAncestorMismatch.html" target="_blank" rel="external">demo</a></p>
</li>
<li><p>当渲染层同合成层有不同的具有 transform 的祖先层时，该渲染层无法压缩（squashingTransformAncestorMismatch，同上） <a href="http://taobaofed.github.io/demo/performance-composite-demo/squash/squashingTransformAncestorMismatch.html" target="_blank" rel="external">demo</a></p>
</li>
<li><p>当渲染层同合成层有不同的具有 filter 的祖先层时，该渲染层无法压缩（squashingFilterAncestorMismatch，同上）<a href="http://taobaofed.github.io/demo/performance-composite-demo/squash/squashingFilterAncestorMismatch.html" target="_blank" rel="external">demo</a></p>
</li>
<li><p>当覆盖的合成层正在运行动画时，该渲染层无法压缩（squashingLayerIsAnimating），当动画未开始或者运行完毕以后，该渲染层才可以被压缩 <a href="http://taobaofed.github.io/demo/performance-composite-demo/squash/animating.html" target="_blank" rel="external">demo</a></p>
<p>  <img src="https://img.alicdn.com/tps/TB1mJjwMXXXXXajXpXXXXXXXXXX-960-391.jpg" alt=""></p>
</li>
</ul>
<h2 id="如何查看合成层"><a href="#如何查看合成层" class="headerlink" title="如何查看合成层"></a>如何查看合成层</h2><p>使用 Chrome DevTools 工具来查看页面中合成层的情况。</p>
<p>比较简单的方法是打开 DevTools，勾选上 <code>Show layer borders</code></p>
<p><img src="https://img.alicdn.com/tps/TB1dZG.MXXXXXX2XVXXXXXXXXXX-276-164.png" alt=""></p>
<p>其中，页面上的合成层会用黄色边框框出来。</p>
<p><img src="https://img.alicdn.com/tps/TB1EQu4MXXXXXXiaXXXXXXXXXXX-709-717.png_600x600.jpg" alt=""></p>
<p>当然，更加详细的信息可以通过 Timeline 来查看。</p>
<p>每一个单独的帧，看到每个帧的渲染细节：</p>
<p><img src="https://img.alicdn.com/tps/TB1.uznMXXXXXbcXFXXXXXXXXXX-325-195.jpg" alt=""></p>
<p>点击之后，你就会在视图中看到一个新的选项卡：Layers。</p>
<p><img src="https://img.alicdn.com/tps/TB1uCgsLpXXXXXNXFXXXXXXXXXX-333-260.jpg" alt=""></p>
<p>点击这个 Layers 选项卡，你会看到一个新的视图。在这个视图中，你可以对这一帧中的所有合成层进行扫描、缩放等操作，同时还能看到每个渲染层被创建的原因。</p>
<p><img src="https://img.alicdn.com/tps/TB163nGMXXXXXatXXXXXXXXXXXX-1440-756.jpg_720x720.jpg" alt=""></p>
<p>有了这个视图，你就能知道页面中到底有多少个合成层。如果你在对页面滚动或渐变效果的性能分析中发现 Composite 过程耗费了太多时间，那么你可以从这个视图里看到页面中有多少个渲染层，它们为何被创建，从而对合成层的数量进行优化。</p>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>提升为合成层简单说来有以下几点好处：</p>
<ul>
<li>合成层的位图，会交由 GPU 合成，比 CPU 处理要快</li>
<li>当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层</li>
<li>对于 transform 和 opacity 效果，不会触发 layout 和 paint</li>
</ul>
<p>利用合成层对于提升页面性能方面有很大的作用，因此我们也总结了一下几点优化建议。</p>
<h3 id="提升动画效果的元素"><a href="#提升动画效果的元素" class="headerlink" title="提升动画效果的元素"></a>提升动画效果的元素</h3><p>合成层的好处是不会影响到其他元素的绘制，因此，为了减少动画元素对其他元素的影响，从而减少 paint，我们需要把动画效果中的元素提升为合成层。</p>
<p>提升合成层的最好方式是使用 CSS 的 will-change 属性。从上一节合成层产生原因中，可以知道 will-change 设置为 opacity、transform、top、left、bottom、right 可以将元素提升为合成层。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#target</span> &#123;</span><br><span class="line">  <span class="attribute">will-change</span>: transform;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其兼容如下所示：</p>
<p><img src="https://img.alicdn.com/tps/TB1_6P9LpXXXXblXXXXXXXXXXXX-1252-284.png_720x720.jpg" alt=""></p>
<p>对于那些目前还不支持 will-change 属性的浏览器，目前常用的是使用一个 3D transform 属性来强制提升为合成层：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#target</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateZ</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但需要注意的是，不要创建太多的渲染层。因为每创建一个新的渲染层，就意味着新的内存分配和更复杂的层的管理。之后我们会详细讨论。</p>
<p>如果你已经把一个元素放到一个新的合成层里，那么可以使用 Timeline 来确认这么做是否真的改进了渲染性能。别盲目提升合成层，一定要分析其实际性能表现。</p>
<h3 id="使用-transform-或者-opacity-来实现动画效果"><a href="#使用-transform-或者-opacity-来实现动画效果" class="headerlink" title="使用 transform 或者 opacity 来实现动画效果"></a>使用 transform 或者 opacity 来实现动画效果</h3><p>文章最开始，我们讲到了页面呈现出来所经历的渲染流水线，其实从性能方面考虑，最理想的渲染流水线是没有布局和绘制环节的，只需要做合成层的合并即可：</p>
<p><img src="https://img.alicdn.com/tps/TB14YwvLpXXXXXGXFXXXXXXXXXX-1093-167.jpg_720x720.jpg" alt=""></p>
<p>为了实现上述效果，就需要只使用那些仅触发 Composite 的属性。目前，只有两个属性是满足这个条件的：transforms 和 opacity。更详细的信息可以查看 <a href="http://csstriggers.com/" target="_blank" rel="external">CSS Triggers</a>。</p>
<p>注意：元素提升为合成层后，transform 和 opacity 才不会触发 paint，如果不是合成层，则其依然会触发 paint。具体见如下两个 demo。</p>
<ul>
<li><p><a href="http://taobaofed.github.io/demo/performance-composite-demo/paint/promote-element/no-promote-transform.html" target="_blank" rel="external">demo 1：transform</a></p>
<p>  <img src="https://img.alicdn.com/tps/TB1XsAVLpXXXXbzXpXXXXXXXXXX-712-411.png_640x640.jpg" alt="no-promote-transform"></p>
</li>
<li><p><a href="http://taobaofed.github.io/demo/performance-composite-demo/paint/promote-element/no-promote-opacity.html" target="_blank" rel="external">demo 2：opacity</a></p>
<p>  <img src="https://img.alicdn.com/tps/TB1j9M7LpXXXXaiXXXXXXXXXXXX-713-424.png_640x640.jpg" alt="no-promote-opacity"></p>
</li>
</ul>
<p>可以看到未提升 target element 为合成层，transform 和 opacity 依然会触发 paint。</p>
<h3 id="减少绘制区域"><a href="#减少绘制区域" class="headerlink" title="减少绘制区域"></a>减少绘制区域</h3><p>对于不需要重新绘制的区域应尽量避免绘制，以减少绘制区域，比如一个 fix 在页面顶部的固定不变的导航 header，在页面内容某个区域 repaint 时，整个屏幕包括 fix 的 header 也会被重绘，见 <a href="http://taobaofed.github.io/demo/performance-composite-demo/paint/reduce/no-reduce.html" target="_blank" rel="external">demo</a>，结果如下：</p>
<p><img src="https://img.alicdn.com/tps/TB1SK_9LpXXXXcaaXXXXXXXXXXX-699-304.png" alt="no-reduce"></p>
<p>而对于固定不变的区域，我们期望其并不会被重绘，因此可以通过之前的方法，将其提升为独立的合成层。</p>
<p>减少绘制区域，需要仔细分析页面，区分绘制区域，减少重绘区域甚至避免重绘。</p>
<h3 id="合理管理合成层"><a href="#合理管理合成层" class="headerlink" title="合理管理合成层"></a>合理管理合成层</h3><p>看完上面的文章，你会发现提升合成层会达到更好的性能。这看上去非常诱人，但是问题是，创建一个新的合成层并不是免费的，它得消耗额外的内存和管理资源。实际上，在内存资源有限的设备上，合成层带来的性能改善，可能远远赶不上过多合成层开销给页面性能带来的负面影响。同时，由于每个渲染层的纹理都需要上传到 GPU 处理，因此我们还需要考虑 CPU 和 GPU 之间的带宽问题、以及有多大内存供 GPU 处理这些纹理的问题。</p>
<p>对于合成层占用内存的问题，我们简单做了几个 demo 进行了验证。</p>
<p><a href="http://taobaofed.github.io/demo/performance-composite-demo/memory/multi-layers-expect.html" target="_blank" rel="external">demo 1</a> 和 <a href="http://taobaofed.github.io/demo/performance-composite-demo/memory/multi-layers.html" target="_blank" rel="external">demo 2</a> 中，会创建 2000 个同样的 div 元素，不同的是 <a href="http://taobaofed.github.io/demo/performance-composite-demo/memory/multi-layers.html" target="_blank" rel="external">demo 2</a> 中的元素通过 will-change 都提升为了合成层，而两个 demo 页面的内存消耗却有很明显的差别。</p>
<p><img src="https://img.alicdn.com/tps/TB1EMYKMXXXXXcUXXXXXXXXXXXX-972-480.jpg" alt=""></p>
<h4 id="防止层爆炸"><a href="#防止层爆炸" class="headerlink" title="防止层爆炸"></a>防止层爆炸</h4><p>通过之前的介绍，我们知道同合成层重叠也会使元素提升为合成层，虽然有浏览器的层压缩机制，但是也有很多无法进行压缩的情况。也就是说除了我们显式的声明的合成层，还可能由于重叠原因不经意间产生一些不在预期的合成层，极端一点可能会产生大量的额外合成层，出现层爆炸的现象。我们简单写了一个极端点但其实在我们的页面中比较常见的 <a href="http://taobaofed.github.io/demo/performance-composite-demo/memory/layer-explode.html" target="_blank" rel="external">demo</a>。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span><br><span class="line">  @-<span class="keyword">webkit</span>-<span class="keyword">keyframes</span> slide &#123;</span><br><span class="line">    <span class="selector-tag">from</span> &#123; <span class="attribute">transform</span>: none; &#125;</span><br><span class="line">    <span class="selector-tag">to</span> &#123; <span class="attribute">transform</span>: <span class="built_in">translateX</span>(100px); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.animating</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: orange;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">      <span class="attribute">-webkit-animation</span>: slide <span class="number">5s</span> alternate linear infinite;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">ul</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.box</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: blue;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="comment">/* 会导致无法压缩：squashingClippingContainerMismatch */</span></span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.inner</span> &#123;</span><br><span class="line">      <span class="attribute">position</span>: absolute;</span><br><span class="line">      <span class="attribute">top</span>: <span class="number">2px</span>;</span><br><span class="line">      <span class="attribute">left</span>: <span class="number">2px</span>;</span><br><span class="line">      <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">      <span class="attribute">line-height</span>: <span class="number">16px</span>;</span><br><span class="line">      <span class="attribute">padding</span>: <span class="number">2px</span>;</span><br><span class="line">      <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">      <span class="attribute">background-color</span>: green;</span><br><span class="line">    &#125;</span><br><span class="line"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 动画合成层 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"animating"</span>&gt;</span>composited animating<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- assume overlap --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- assume overlap --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"inner"</span>&gt;</span>asume overlap, 因为 squashingClippingContainerMismatch 无法压缩<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><a href="http://taobaofed.github.io/demo/performance-composite-demo/memory/layer-explode.html" target="_blank" rel="external">demo</a> 中，<code>.animating</code> 的合成层在运行动画，会导致 <code>.inner</code> 元素因为上文介绍过的 assumedOverlap 的原因，而被提升为合成层，同时，<code>.inner</code> 的父元素 <code>.box</code> 设置了 <code>overflow: hidden</code>，导致 <code>.inner</code> 的合成层因为 squashingClippingContainerMismatch 的原因，无法压缩，就出现了层爆炸的问题。</p>
<p><img src="https://img.alicdn.com/tps/TB1E7PEMXXXXXbAXpXXXXXXXXXX-1390-778.jpg_720x720.jpg" alt=""></p>
<p>这种情况平时在我们的业务中还是很常见的，比如 slider + list 的结构，一旦满足了无法进行层压缩的情况，就很容易出现层爆炸的问题。</p>
<p>解决层爆炸的问题，最佳方案是打破 overlap 的条件，也就是说让其他元素不要和合成层元素重叠。对于上述的示例，我们可以将 <code>.animation</code> 的 z-index 提高。修改后 <a href="http://taobaofed.github.io/demo/performance-composite-demo/memory/layer-explode-zIndex.html" target="_blank" rel="external">demo</a></p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.animating</span> &#123;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">/* 让其他元素不和合成层重叠 */</span></span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，就只有 <code>.animating</code> 提升为合成层，如下：</p>
<p><img src="https://img.alicdn.com/tps/TB1LxrnMXXXXXcIXVXXXXXXXXXX-1366-777.jpg_720x720.jpg" alt=""></p>
<p>同时，内存占用比起之前也降低了很多。</p>
<p><img src="https://img.alicdn.com/tps/TB1FoDwMXXXXXc2XFXXXXXXXXXX-947-485.jpg" alt=""></p>
<p>如果受限于视觉需要等因素，其他元素必须要覆盖在合成层之上，那应该尽量避免无法层压缩情况的出现。针对上述示例中，无法层压缩的情况（squashingClippingContainerMismatch），我们可以将 <code>.box</code> 的 <code>overflow: hidden</code> 去掉，这样就可以利用浏览器的层压缩了。修改后 <a href="http://taobaofed.github.io/demo/performance-composite-demo/memory/layer-explode-squash.html" target="_blank" rel="external">demo</a></p>
<p>此时，由于第一个 <code>.box</code> 因为 squashingLayerIsAnimating 的原因无法压缩，其他的都被压缩到了一起。</p>
<p><img src="https://img.alicdn.com/tps/TB1OE6uMXXXXXc8XFXXXXXXXXXX-1368-774.jpg_720x720.jpg" alt=""></p>
<p>同时，内存占用比起之前也降低了很多。</p>
<p><img src="https://img.alicdn.com/tps/TB1eYvqMXXXXXbJXVXXXXXXXXXX-936-480.jpg" alt=""></p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>之前无线开发时，大多数人都很喜欢使用 <code>translateZ(0)</code> 来进行所谓的硬件加速，以提升性能，但是性能优化并没有所谓的“银弹”，<code>translateZ(0)</code> 不是，本文列出的优化建议也不是。抛开了对页面的具体分析，任何的性能优化都是站不住脚的，盲目的使用一些优化措施，结果可能会适得其反。因此切实的去分析页面的实际性能表现，不断的改进测试，才是正确的优化途径。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://code.google.com/p/chromium/codesearch#chromium/src/third_party/WebKit/Source/core/paint/PaintLayer.h" target="_blank" rel="external">PaintLayer.h</a></li>
<li><a href="https://code.google.com/p/chromium/codesearch#chromium/src/third_party/WebKit/Source/core/paint/PaintLayer.cpp" target="_blank" rel="external">PaintLayer.cpp</a></li>
<li><a href="https://code.google.com/p/chromium/codesearch#chromium/src/third_party/WebKit/Source/platform/graphics/CompositingReasons.cpp" target="_blank" rel="external">CompositingReasons.cpp</a></li>
<li><a href="https://code.google.com/p/chromium/codesearch#chromium/src/third_party/WebKit/Source/platform/graphics/CompositingReasons.h" target="_blank" rel="external">CompositingReasons.h</a></li>
<li><a href="https://code.google.com/p/chromium/codesearch#chromium/src/third_party/WebKit/Source/core/layout/compositing/CompositingRequirementsUpdater.cpp&amp;q=CompositingRequirementsUpdater&amp;sq=package:chromium&amp;type=cs&amp;l=212" target="_blank" rel="external">CompositingRequirementsUpdater.cpp</a></li>
<li><a href="https://www.chromium.org/developers/testing/webkit-layout-tests" target="_blank" rel="external">chrome layout test</a></li>
<li><a href="https://www.chromium.org/blink/slimming-paint" target="_blank" rel="external">Slimming Paint</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context" target="_blank" rel="external">The stacking contest</a></li>
<li><a href="https://docs.google.com/presentation/d/1WOhbWLkhMyo4vZUaHq-FO-mt0B2sejXw-lMwohD5iUo/edit?pref=2&amp;pli=1#slide=id.g2a949df15_00" target="_blank" rel="external">Blink Compositing Update: Recap and Squashing</a></li>
<li><a href="http://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome" target="_blank" rel="external">GPU Accelerated Compositing in Chrome</a></li>
<li><a href="http://csstriggers.com/" target="_blank" rel="external">CSS Triggers</a></li>
<li><a href="https://developers.google.com/web/fundamentals/performance/rendering/?hl=zh-cn" target="_blank" rel="external">google render performance</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img.alicdn.com/tfs/TB1XT4kMFXXXXaBXXXXXXXXXXXX-900-500.png" alt="无线性能优化：Composite"></p>
<p>一个 Web 页面的展示，简单来说可以认为经历了以下下几个]]>
    </summary>
    
      <category term="性能" scheme="http://taobaofed.org/tags/%E6%80%A7%E8%83%BD/"/>
    
      <category term="无线开发" scheme="http://taobaofed.org/categories/%E6%97%A0%E7%BA%BF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何定位 Node.js 的内存泄漏]]></title>
    <link href="http://taobaofed.org/blog/2016/04/15/how-to-find-memory-leak/"/>
    <id>http://taobaofed.org/blog/2016/04/15/how-to-find-memory-leak/</id>
    <published>2016-04-15T09:58:18.000Z</published>
    <updated>2016-10-12T02:02:15.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img.alicdn.com/tps/TB1Fs7jMpXXXXabXXXXXXXXXXXX-900-500.jpg" alt="如何定位 Node.js 的内存泄漏"></p>
<p>在 <a href="http://taobaofed.org/blog/2016/01/14/nodejs-memory-leak-analyze/">《一次 Node.js 应用内存暴涨分析》</a>中，我们处理了一个 Node.js vm 引发的内存泄漏问题，处理过程也是比较艰辛。而在我们实际开发中，可能经常会碰到内存泄漏的问题，但很多情况下，我们对于这种问题的处理是有些迷茫的，没有一定的操作流程，效率比较低。虽然这种问题对于经验的要求比较高，但如果有一个简单的排查流程，还是会有一定帮助的。</p>
<p>这里简单整理一个流程，欢迎一起探讨，补充。</p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>Node.js 进程的内存管理，都是有 V8 自动处理的，包括内存分配和释放。那么 V8 什么时候会将内存释放呢？</p>
<p>在 V8 内部，会为程序中的所有变量构建一个图，来表示变量间的关联关系，当变量从根节点无法触达时，就意味着这个变量不会再被使用了，就是可以回收的了。<br>而这个回收是一个过程性的，从快速 GC 到 最后的 Full GC，是需要一段时间的。<br>另外，Full GC 是有触发阈值的，所以可能会出现内存长期占用在一个高值，也可以算是一种内存泄漏，可以从《一次 Node.js 应用内存暴涨分析》中找到例子。还有一种就是引用不释放，导致无法进入 GC 环节，并且一直产生新的占用，这一般会发生在 Javascript 层面。</p>
<p>所以，定位内存泄漏问题，一般方案就是找那些不被使用又不会被释放的变量，处理了这些变量，问题一般就可以解决了。如果是 Node.js 底层变量不释放，除了提交 issue 等待解决外，只能通过优化启动参数来解决。</p>
<h2 id="如何找出并解决问题"><a href="#如何找出并解决问题" class="headerlink" title="如何找出并解决问题"></a>如何找出并解决问题</h2><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>工欲善其事必先利其器，在排查时，我们还是需要一些工具来帮忙的。</p>
<h4 id="devTool"><a href="#devTool" class="headerlink" title="devTool"></a>devTool</h4><p>这个是今年初出的 Node.js 调试工具，基于 Electron 将 Node.js 和 Chromium 的功能融合在了一起。操作起来比 node-inspector 方便，开放的 Timeline 功能还是比较实用的，虽然不是实时显示。<br>仅需要 <code>devtool xxx.js</code>，还可以通过 .devtoolrc 来进行参数定制，具体见 <a href="https://github.com/Jam3/devtool" target="_blank" rel="external">GitHub</a></p>
<h4 id="heapdump-chrome-devTool"><a href="#heapdump-chrome-devTool" class="headerlink" title="heapdump + chrome devTool"></a>heapdump + chrome devTool</h4><p>这个是比较传统的定位内存泄漏的组合。heapdump 可以直接在代码中调用生成内存快照，然后将快照文件导入到 chrome devTool 进行分析，之后操作其实和前者就差不多了。不过，这个方案和前者有一点区别就是，前者实际还是在浏览器环境中，所以生成的内存快照会有一些 DOM 对象的存在，会有一定的干扰。而这个方案，是直接调用底层 V8 的方法，生成的快照只有 Node.js 环境中的对象。</p>
<h4 id="memwatch"><a href="#memwatch" class="headerlink" title="memwatch"></a>memwatch</h4><p>这个可以在代码里直接使用，实时检测内存动态，当发生内存泄漏的时候，会触发 ‘leak’ 事件，会传递当前的堆状态，配合 heapdump 有奇效。详见 <a href="https://www.npmjs.com/package/memwatch" target="_blank" rel="external">memwatch</a>。</p>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><h4 id="一、重现问题"><a href="#一、重现问题" class="headerlink" title="一、重现问题"></a>一、重现问题</h4><p>对于垃圾回收，V8 引擎有很复杂的逻辑来决定什么时候进行回收。很多时候，当我们发现 Node.js 进程所使用的内存快速增长的时候，并不能确定是否是内存泄漏导致的，很有可能是程序设计问题，导致内存的不合理利用。只有当垃圾回收触发，未使用内存被释放后，内存增长还在持续，我们才能确定是发生了内存泄漏。</p>
<p>隐藏的内存泄漏问题，大多是有触发条件的，重现问题是需要这些条件的，所以我们在平时写代码的时候，可以将一些重要环节的参数细节打印在 log 中，这样我们在重现问题是就不会摸不着头脑，乱试一气。</p>
<p>有了参数可以用来重现问题，接下来要确定问题。我们要确定，这部分内存是否没有被 GC 正确释放。那么问题来了，我们如何知道程序进行了垃圾回收呢？很显然，等待并不是办法，我们要主动。</p>
<p>在 Node.js 的启动参数中，提供了暴露手动调用 GC 方法的参数，即 <code>--expose-gc</code>。我们用这个参数来启动应用后，就可以在代码中调用 <code>global.gc()</code> 手动触发垃圾回收操作。同时，使用 <code>process.memoryUsage().heapUsed</code> 获取进程运行时所占用的内存。如果 GC 之后，内存依然没有下降，就可以确定是内存泄露了。</p>
<h4 id="二、生成内存快照"><a href="#二、生成内存快照" class="headerlink" title="二、生成内存快照"></a>二、生成内存快照</h4><p>既然内存是问题，我们就需要获取程序运行的内存快照来帮助定位问题。但内存快照并不是随便打得，是有一定技巧的。</p>
<p>我们<strong>至少要生成三次内存快照</strong>，才能更好的定位问题。这三次中又一次要在问题出现前生成，之后可以在问题持续的过程中生成两次或更多。</p>
<p>为什么要这样做呢？理解起来很简单。第一次是为了获取正常情况下的堆栈信息，而在问题出现后，堆栈信息一定会发生变化，有了第一次的信息，我们才好进行后面的比对，过滤一些无用的信息。而后两次的快照，用来比对某一对象的堆栈变化，来确定是否是有问题的对象。下面会详细应用到。</p>
<h4 id="三、定位问题"><a href="#三、定位问题" class="headerlink" title="三、定位问题"></a>三、定位问题</h4><p>用 devTool 的可以忽略下面的过程：</p>
<blockquote>
<p>打开 Chrome Devtools ，进入到 Profiles 选项卡，点 Load 按钮，加载之前生成的快照。</p>
</blockquote>
<p>对于内存快照，有四个视图，Summary，Comparison，Containment，Statistics，这里面常用的是前三个。</p>
<p>在 Summary 视图中，我们可以看到当前快照的全部信息，以及多个快照之间的信息。在列表里显示的都是对象的构造函数名字，可以先忽略被括号包裹的对象，优先观察其他的对象，最后再来看他们。后面的 <code>shallow size</code> 表示的是对象自身的大小，<code>retained size</code> 表示的是对象和它依赖对象的大小，一般是 GC 不可达的。</p>
<p>在 Comparison 视图中，我们可以进行多个快照之间的对比，这个用处比较大，如果我们将前两次快照进行对比，可能比较快速的定位出问题的对象。注意观察 New、Deleted、Delta，如果是内存泄漏的对象，可能是一直在 New，而没有 Deleted。</p>
<p>在 Containment 视图中，我们可以查看整个 GC 路径，当然一般不会用到。因为展开在 Summary 和 Comparison 列举的每一项，都可以看到从 GC roots 到这个对象的路径。通过这些路径，你可以看到这个对象的句柄被什么持有，从而定位问题产生的原因。值的注意的是，其中背景色黄色的，表示这个对象在 Javascript 中还存在引用，所以可能没有被清除。如果是红色的，表示的是这个对象在 Javascript 中不存在引用，但是依然存活在内存中，一般常见于 DOM 对象，它们存放的位置和 Javascript 中对象还是有不同的，在 Node.js 中很少遇见。</p>
<p>更多的操作方法，可以看这个视频 <a href="https://youtu.be/L3ugr9BJqIs" target="_blank" rel="external">Memory Profiling with Chrome DevTools</a> 和 <a href="https://youtu.be/LaxbdIyBkL0" target="_blank" rel="external">Memory Management Masterclass</a>。还有 Chrome 的文档 <a href="https://developer.chrome.com/devtools/docs/javascript-memory-profiling" target="_blank" rel="external">Memory Profiling</a>（旧） 和 <a href="https://developers.google.com/web/tools/chrome-devtools/profile/memory-problems/memory-diagnosis" target="_blank" rel="external">Memory Diagnosis</a>（新）。讲的还是很详细的。（请自备梯子）</p>
<h4 id="四、解决问题"><a href="#四、解决问题" class="headerlink" title="四、解决问题"></a>四、解决问题</h4><p>一般在 Javascript 中存在引用而导致内存泄漏的情况，是比较好处理的，只需要在使用后及时的将引用释放掉即可。</p>
<p>但像 <a href="http://taobaofed.org/blog/2016/01/14/nodejs-memory-leak-analyze/">《一次 Node.js 应用内存暴涨分析》</a> 所存在的那种内存问题，是属于底层机制的问题，如果等不了 bugfix，就只能先通过一些启动参数来优化内存管理。常用的参数：</p>
<ul>
<li><code>--max-old-space-size</code> 限制老生区大小，可以控制内存占用的最大值，即使发生泄漏，也不会让内存占用保持很高。可以根据开启进程数以及是否同机部署来优化。</li>
<li><code>--gc_global</code> 这其实是个 V8 的 debug flag，让 GC 永远都是 Full GC，使用上会有一定的性能损耗，根据应用复杂度不同，损耗不同。</li>
</ul>
<p>当我们找到问题，进行修复后，重复上面的步骤，确认问题已经被解决。有时可能一次并不能解决问题，所以耐心还是很重要的。</p>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>可以在这里下载使用到的代码， <a href="https://github.com/taobaofed/demo" target="_blank" rel="external">GitHub</a>，进入 memory-leak 文件夹。<br>我们来举个例子，应用上面的步骤排查问题，使用 leak-memory 的例子，代码还有另外一个例子，可以自己实践。</p>
<p>这里我们为了方便，我们使用了 devTool。</p>
<p><code>devTool leak-memory.js</code></p>
<p>然后在打开的界面中进入内存快照界面，生成第一次快照。当控制台有输出后，间隔的生成两次快照，结果如下。</p>
<p><img src="http://img.alicdn.com/tps/TB1ejYNMpXXXXcsXVXXXXXXXXXX-2880-1708.jpg" alt="screenshot"></p>
<p>我们切换视图，对比下三次快照间的区别，可以看到 <code>Foo</code> 这个对象一直在创建而没有被删除。</p>
<p><img src="http://img.alicdn.com/tps/TB1utodMpXXXXcWXXXXXXXXXXXX-2876-660.jpg" alt="screenshot"></p>
<p><img src="http://img.alicdn.com/tps/TB1FYDUMpXXXXc1XFXXXXXXXXXX-2880-474.jpg" alt="screenshot"></p>
<p>我们展开 <code>Foo</code>，选择下面的一个实例，查看它的 GC path，可以看到它一直被 neverRelease 持有引用（黄色），所以没有被释放，之后就可以进行问题的处理了。</p>
<p><img src="http://img.alicdn.com/tps/TB1DUz4MpXXXXXLXFXXXXXXXXXX-2876-852.jpg" alt="screenshot"></p>
<p>去掉 <code>// neverRelease.splice(index, 1);</code>  前的注释，然后在重复上面的步骤，你会发现内存的变化已经正常了。</p>
<blockquote>
<p>在使用 devTool 时，可以查看运行时的 memory timeline，如果图像呈现阶梯式增长，一般就是存在内存泄漏问题了。正常的应用曲线会类似于锯齿，如图：</p>
</blockquote>
<p><img src="http://img.alicdn.com/tps/TB17UkfMpXXXXbEXXXXXXXXXXXX-2358-500.jpg" alt="screenshot"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><p>内存泄漏问题的定位，经验很重要，但有了良好工具的辅助，可以节省很多时间。如果懒得自己一步步的操作，可以接入 <a href="http://alinode.aliyun.com/" target="_blank" rel="external">alinode</a>，这个可以帮助你很方便的生成快照等运行时数据，并有一定的分析辅助，还是方便的。</p>
</li>
<li><p>你可能看到很多内存分析的文章会有一些图来表示内存的增长，可以使用 python 来快速生成相关的图片，使用 <code>matplotlib.pyplot</code> 这个包。</p>
</li>
</ol>
<p><img src="http://img.alicdn.com/tps/TB1J8gkMpXXXXXuXXXXXXXXXXXX-1194-914.jpg" alt="screenshot"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://developers.google.com/web/tools/chrome-devtools/profile/memory-problems/memory-diagnosis" target="_blank" rel="external">memory-diagnosis</a></li>
<li><a href="https://www.youtube.com/watch?v=L3ugr9BJqIs&amp;feature=youtu.be" target="_blank" rel="external">Memory Profiling with Chrome DevTools</a></li>
<li><a href="http://www.alexkras.com/simple-guide-to-finding-a-javascript-memory-leak-in-node-js/" target="_blank" rel="external">Simple Guide to Finding a JavaScript Memory Leak in Node.js</a></li>
<li><a href="http://jayconrod.com/posts/55/a-tour-of-v8-garbage-collection" target="_blank" rel="external">A tour of V8: Garbage Collection</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img.alicdn.com/tps/TB1Fs7jMpXXXXabXXXXXXXXXXXX-900-500.jpg" alt="如何定位 Node.js 的内存泄漏"></p>
<p>在 <a href="http://taobaofed]]>
    </summary>
    
      <category term="Node.js" scheme="http://taobaofed.org/tags/Node-js/"/>
    
      <category term="memory leak" scheme="http://taobaofed.org/tags/memory-leak/"/>
    
      <category term="Node.js" scheme="http://taobaofed.org/categories/Node-js/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[H5 页面高级字体应用实践]]></title>
    <link href="http://taobaofed.org/blog/2016/04/12/webfont-practice/"/>
    <id>http://taobaofed.org/blog/2016/04/12/webfont-practice/</id>
    <published>2016-04-12T01:11:03.000Z</published>
    <updated>2016-10-12T02:02:15.000Z</updated>
    <content type="html"><![CDATA[<p><img src="//img.alicdn.com/tps/TB1kaazMpXXXXacXFXXXXXXXXXX-900-500.jpg" alt="H5 页面高级字体应用实践"></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ul>
<li>最近在开发一个 H5 活动页快速搭建平台，可以通过拖拽编辑图片，文字等元素组件，快速搭建出一个移动端的活动页面，基本交互和成品效果类似 PPT 软件。这类活动大量在微信等平台上传播，其中会包含各种动画和特效，而各类高级艺术字体（如：方正兰亭黑，方正彩云，方正大草，方正剑体等）的应用也非常广泛。</li>
<li>之前用户只能通过 ps 等软件将文字转化为图片再贴到平台上使用。使用成本很高，修改，调试都非常不便，而且图片占用的资源也比较多，为了降低用户的使用成本，基于一站式搭建的理念，我们需要将高级字体的使用透明化，使用户和使用 PPT 一样直接选择字体使用即可。</li>
</ul>
<h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><ul>
<li>第一种方案是通过用户输入的文字，和选择的字体，通过服务器生成对应的图片来使用。这种方案的优点是逻辑简单，缺点是搭建/修改时增加了复杂度，调试时无法实时预览文字在活动中的效果。而且容易出现大量冗余图片，最终页面的图片请求也会增加。</li>
<li>第二种方案是调用 iconfont.cn 的服务接口，通过传递字体和文字内容来获取字体文件。这种方案的优点是可以直接利用现有成熟平台，开发成本低，可靠。缺点是增加了外部依赖，不但面临合作方配合的限制，而且无法自行控制可供的选择字体等。</li>
<li>最终采用的的第三种方案是直接使用 iconfont.cn 的 Node.js 模块 （font-carrier） ，自行解析/生成字体，将生成的字体放在我们自己申请的 OSS 中存储使用。这种方法的开发量最大，且要消耗额外的 OSS 资源，但是整个流程独立自主，可以不断定制优化，自行添加字体等，由于我们的服务只面向移动端，所以只需要生成 ttf 或者 woff 一种文件类型即可兼容。</li>
</ul>
<h2 id="字体文件解析的基本原理"><a href="#字体文件解析的基本原理" class="headerlink" title="字体文件解析的基本原理"></a>字体文件解析的基本原理</h2><h3 id="字体文件的核心结构"><a href="#字体文件的核心结构" class="headerlink" title="字体文件的核心结构"></a>字体文件的核心结构</h3><p>以 ttf 文件为例，字体文件中主要包含了字体头表，位置索引表和图元数据表等等，其中最核心的部分就是图元数据表，也就是字形描述表，它可以包含可变数目的图元，每个图元可以有不同数目的控制点，甚至还可以有数量可变的图元指令，通过位置索引表对应到每个字符上，通过图元数据表，使其只包含需要使用的字符的图元描述。即可最小化字体，使其可用于生产环境的页面中，其他类型的字体文件（如 woff， eot， svg 等）原理也是大同小异，仅仅是压缩方式和字形描述规范不同，也可以互相转化。</p>
<h3 id="font-carrier-模块基本原理"><a href="#font-carrier-模块基本原理" class="headerlink" title="font-carrier 模块基本原理"></a>font-carrier 模块基本原理</h3><p>font-carrier 模块使用 OpenType 模块分析 ttf 文件，可以文件的内容脚本化，使其成为一个字符 unicode 编码和其字形描述的键值对象。通过对这个对象的 min 方法，可以使其最小化，并且再逆向生成文件 Buffer 供用户使用。</p>
<h2 id="一期实现流程"><a href="#一期实现流程" class="headerlink" title="一期实现流程"></a>一期实现流程</h2><ul>
<li>在程序启动后通过 font-carrier 模块将本地的字体文件包装成字体对象，保存在服务器内存中。</li>
<li>用户保存页面时，记录下此活动所有使用的高级字体和相应的文字内容</li>
<li>通过 font-carrier 模块找到字体对应的字体对象，使用 min 命令生成最小化的字体对象</li>
<li>使用 min 命令生成缩小后的字体文件，保存到 OSS，并以活动的 id 为路径，字体的名字为文件名。</li>
<li>最终渲染时通过记录的活动使用的字体名拼出 OSS 路径来引用文件</li>
</ul>
<h4 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h4><ul>
<li>由于字体数量较多，启动时将本地字体文件包装成字体对象的时间非常长，可达到数十分钟。</li>
<li>字体对象常驻内存，占用巨大，甚至可能直接吃光内存</li>
</ul>
<h4 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h4><p>因为 font-carrier 模块生成的字体对象无法通过文件来持久化保存，只能生成后常驻内存中，而字体的数量多，大小也大，所以不管是生成的时间，生成时消耗的性能，生成后占用的内存都非常巨大。所以问题的关键在于如何把字体的分析结果持久化保存在服务器中。</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>在咨询了 font-carrier 模块的开发者后，了解到 font-carrier 模块还有生成字体的 svg 片段的方法，可以将字体的图元数据转变为 svg 输出，并可以将 svg 逆向导入到空字体文件中来生成最终字体文件。<br>通过将字体分析转译后的 svg 片段结果保存在数据库中，即可持久化分析结果。使用的时候通过创建空字体-&gt;配置字符-svg 的对应关系-&gt;提取字体-&gt;上传到 OSS 的流程来使用最小化后的字体即可。</p>
<h2 id="二期实现流程"><a href="#二期实现流程" class="headerlink" title="二期实现流程"></a>二期实现流程</h2><ul>
<li>建立提取字体任务，运行时遍历字体文件，提取其中的 svg 片段存入数据库</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> transFont = fontCarrier.transfer(__dirname + <span class="string">'/../../www/fonts/'</span> + fontInfo.font_name + <span class="string">'.ttf'</span>);</span><br><span class="line"><span class="keyword">var</span> words = [];</span><br><span class="line">	_.each(transFont.__glyphs， <span class="function"><span class="keyword">function</span>(<span class="params">n, word</span>) </span>&#123;</span><br><span class="line">	words.push(&#123;</span><br><span class="line">	  word: word,</span><br><span class="line">	  fontId: fontInfo.id,</span><br><span class="line">	  svg: transFont.getSvg(word, &#123;</span><br><span class="line">	    skipViewport: <span class="literal">true</span></span><br><span class="line">	  &#125;)</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>以下是一段方正喵呜体中的“我”字提取的 svg 片段<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line">  <span class="meta">&lt;!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">svg</span> <span class="attr">version</span>=<span class="string">"1.1"</span> <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/2000/svg"</span> <span class="attr">xmlns:xlink</span>=<span class="string">"http://www.w3.org/1999/xlink"</span> <span class="attr">x</span>=<span class="string">"0"</span> <span class="attr">y</span>=<span class="string">"0"</span> <span class="attr">width</span>=<span class="string">"100px"</span> <span class="attr">height</span>=<span class="string">"100px"</span> <span class="attr">viewBox</span>=<span class="string">"0 0 1000 1000"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">"M324 857Q324 837 332 819 340 801 340 775 317 775 296.5 776.5 276 778 253 778 237 778 224.5 769.5 212 761 212 742 212 731 221 722 230 713 242 712L333 703Q348 703 353 691 357 662 357.5 643 358 624 358 596L358 559Q357 554 353 554 351 554 349 554 313 554 278 558.5 243 563 208 563 193 563 182 557 171 551 171 533.5 171 516 184 507 197 498 217.5 494 238 490 261 489 286 489 306.5 488.5 327 488 342 487 357 486 358 479L358 461Q358 458 356.5 434.5 355 411 352 384 349 357 344.5 335 340 313 333 313 332 313 329 315 326 317 325 318L270 372Q265 377 259 378 255 381 248 381 217 381 217 348 217 340 218 334 219 328 225 322L420 132Q426 125 432 124 438 123 446 123 460 123 469.5 130.5 479 138 479 152 479 160 474 168 471 176 465 181 462 185 452.5 194.5 443 204 432 214.5 421 225 411.5 234.5 402 244 399 247 398 249 397 252 396 255 395 256L395 259 395 260Q402 290 408 315 414 340 417.5 364.5 421 389 423.5 414.5 426 440 428 471L433 479Q433 480 442 480 451 480 456 480 475 480 492 479.5 509 479 528 476L528 449Q528 399 523.5 348.5 519 298 519 247 519 228 523 215 529 201 550 201 565 201 573 209.5 581 218 584 231 587 244 587.5 257.5 588 271 589 281 589 287 591 310 593 335 594 362 595 389 596 412 598 437 598 442 598 447 598 451 598 457 600 462L602 476 611 479 723 479Q742 480 759.5 486.5 777 493 777 515 777 526 770.5 536 764 546 752 546L628 546 615 550Q614 551 614 553 614 557 614 559 614 564 619 583 623 604 629 625 635 646 642.5 663 650 680 656 680 666 680 673 667 682 655 691 639 701 625 714 611 726 599 743 599 756 599 766.5 606.5 777 614 777 629 777 642 764.5 658.5 752 675 736 692 722 709 709 723 697 739 697 747L697 748Q697 749 698 749 704 756 710 764 718 773 726.5 780.5 735 788 745 794 755 800 764.5 800 774 800 782 796 790 794 799 794 812 794 821 805 830 816 830 829 830 851 812 862 796 873 777 873 755 873 736.5 866 718 859 701.5 847 685 835 669.5 821 654 807 640 795 631 800 623.5 806.5 616 813 609 818.5 602 824 593.5 828.5 585 833 575 833 544 833 544 803 544 798 544.5 794.5 545 791 548 786L598 737 598 725Q576 688 562.5 642 549 596 540 554 538 550 532.5 548 527 546 522 546L519 546Q514 546 503 546 493 548 481.5 548.5 470 549 459.5 549.5 449 550 445 550 442 552 438.5 553.5 435 555 433.5 558.5 432 562 429 574 428 588 428 591 428 596 427.5 607.5 427 619 426 632.5 425 646 424 657 424 670 424 674 424 681 426 682 428 683 432 683 444 683 454.5 681 465 679 477.5 679 490 679 500.5 686.5 511 694 511 708 511 727 499 733 486 741 470 744 454 747 439.5 749 425 751 420 761 419 763 417.5 767.5 416 772 416 774 415 779 411.5 791.5 408 804 404.5 817.5 401 831 398 843 396 857 395 861 385 886 357 886 343 886 333.5 878.5 324 871 324 857M668 269Q668 254 677 246 687 240 699 240 716 240 726 251 736 262 743 277 745 281 750 292 755 303 760 316 765 329 769.5 339.5 774 350 777 355L777 369Q777 385 770.5 393.5 764 402 746 402 735 402 721.5 385 708 368 696.5 346 685 324 676 301 668 280 668 269Z"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>保存活动时创建空字体，导入需要的字符和其对应的 svg，并将这个字体保存到 OSS</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建空白字体，使用 svg 生成字体</span></span><br><span class="line"><span class="keyword">var</span> font = fontCarrier.create();</span><br><span class="line">values.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  font.setSvg(v.word，v.svg);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">return</span> font.output(&#123;</span><br><span class="line">  types:[<span class="string">'woff'</span>]</span><br><span class="line">&#125;)[<span class="string">'woff'</span>];</span><br></pre></td></tr></table></figure>
<ul>
<li>最终渲染时通过的记录的活动使用的字体名拼出 OSS 路径来引用文件</li>
</ul>
<h4 id="新的问题"><a href="#新的问题" class="headerlink" title="新的问题"></a>新的问题</h4><p>在正常运行了一段时间后，用户反馈了新的问题，编辑和预览时的字宽度不匹配，现象为所有的字符都变为了全角模式，数字，字母和符号，都占用了一个汉字的位置。如图：</p>
<p><img src="http://img4.tbcdn.cn/L1/461/1/bf9de797cecf959b7becc43476a85c32f49b6ea3.png" alt="新的问题"></p>
<h4 id="分析问题-1"><a href="#分析问题-1" class="headerlink" title="分析问题"></a>分析问题</h4><p>经过排查和测试，最后发现原因在于生成 svg 片段时，模块给这个 svg 加上了宽和高，这是不必要的，在显示汉字等全角字符时，一切正常，而在显示半角字符时，则会导致两边出现空隙。</p>
<h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><p>在无法改变 font-carrier 模块的前提下，只能在我们自己的流程中加补丁，我在读取 svg 使用前，额外增加了替换代码将宽高删除，证明可以解决该问题。另外我也知会了模块开发者，在未来的版本中修复此问题。修复后效果如图：</p>
<p><img src="http://img1.tbcdn.cn/L1/461/1/f61a003304e10548610be4c933c13b6a83a06c5d.png" alt="修复问题"></p>
<h2 id="未来展望"><a href="#未来展望" class="headerlink" title="未来展望"></a>未来展望</h2><ul>
<li>目前我们采用引用字体文件的方式来定义高级字体，而最近团队的无线端最佳实践的要求，无线端使用的字体将字体文件 base 64 化，以减少请求数，未来我们也将改造成这种方式，不但符合最佳实践的要求，同时还可以节省 OSS 存储的资源。</li>
<li>下一阶段我们将调研 svg 在移动端的兼容性和性能，未来开发的插入几何形状功能将考虑使用这一技术，同是我们也会尝试直接用 svg 绘制字体，产生更多的可能性（比如 svg 动画等），需要考虑兼容性和渐进方案。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="//img.alicdn.com/tps/TB1kaazMpXXXXacXFXXXXXXXXXX-900-500.jpg" alt="H5 页面高级字体应用实践"></p>
<h2 id="背景"><a href="#背景" class="headerl]]>
    </summary>
    
      <category term="webfont" scheme="http://taobaofed.org/tags/webfont/"/>
    
      <category term="艺术字" scheme="http://taobaofed.org/tags/%E8%89%BA%E6%9C%AF%E5%AD%97/"/>
    
      <category term="字体" scheme="http://taobaofed.org/tags/%E5%AD%97%E4%BD%93/"/>
    
      <category term="TTF" scheme="http://taobaofed.org/tags/TTF/"/>
    
      <category term="无线开发" scheme="http://taobaofed.org/categories/%E6%97%A0%E7%BA%BF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[企业级 Node.js Web 应用解决方案设计的零零总总]]></title>
    <link href="http://taobaofed.org/blog/2016/04/08/node-web-framework-design/"/>
    <id>http://taobaofed.org/blog/2016/04/08/node-web-framework-design/</id>
    <published>2016-04-08T08:28:29.000Z</published>
    <updated>2016-10-12T02:02:15.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://gtms01.alicdn.com/tps/i1/TB146VMMpXXXXXqXXXXWPiOLXXX-900-500.jpeg" alt="企业级 Node.js Web 应用解决方案设计的零零总总"></p>
<p>年前一直在忙着做新版 Midway 升级的事情，不少同学都知道 Midway 是淘宝的 Node.js Web 应用解决方案，目的是为了更好的做前后端分离，让前端同学开发更简单，生活更幸福（笑）。</p>
<p>如今 Midway 5 正式发布了，横跨了几个月的开发个工作，期间带来的感慨，也算是史上最多。</p>
<p>Midway 的诞生也有 2 年多的时间，我个人参与维护也有 1 年多，经历了从 v3 到 v5 的变化，最大的感慨莫过于，<strong>分分合合</strong>，以前总想着灵活性，要做分离，后来就想着统一升级，又合并回去， 折腾的是自己，也是用户，不管怎么说，之前欠着的债总是要还的，历史包袱总是框架开发者的胸口大石，不破不立才是最终的方案。</p>
<h2 id="代码风格选型"><a href="#代码风格选型" class="headerlink" title="代码风格选型"></a>代码风格选型</h2><p>随着 ES6 乃至 ES2015 的出现，<code>generator</code> 和 <code>promise</code> 配合的开发方式渐渐的趋于稳定和标准化，再结合未来 <code>async/await</code> 的方式，使用 <code>Koa 1.0</code> 是比较中和的选择，在 2.0 推出之前，可以使用  <code>yield</code> 的写法来简化异步操作，将大部分的异步代码扁平化，同时也可以对未来的 <code>Koa 2.0</code> 代码进行一个很好的兼容和补充。</p>
<p>有人不禁会问，为什么不用 <code>babel</code> ，当然这是一种选择，在 <code>Node.js</code> 没有原生支持这些语法特性，乃至 <code>--harmony</code> 也无法启用的新特性的时候，我们不会考虑使用，这是在做企业级框架的一些基本原则，在面对数千万用户的期待的时候，我们不能拿稳定性来试错。</p>
<h2 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h2><p>框架的稳定性和业务的稳定性是两个不同的方向，业务需要的是容错，而框架需要的是兜底。很多时候业务代码只需要 <code>try/catch</code> 就能解决，再不然 <code>promise.catch</code> 也好，然后 <code>logger.error</code> 就可以了，但是框架不行。</p>
<p>Midway 使用的是 <code>Master/Agent/Worker</code> 进程方案，同时会启动 N+2 的进程，每个 Worker 进程可能会和 <code>Master/Agent</code> 进程进行通信，一旦有进程错误甚至挂掉，都是一个复杂的情况，所以要处理所有类型的错误就变得非常重要。</p>
<p>进程本身有着一些简单的处理，比如在接受到正常的信息消息的时候正常退出流程，并且杀死其他子进程（碰到过其他子进程杀不死的，所以要强制再杀一下）:</p>
<pre><code>// SIGTERM AND SIGINT will trigger the exit event.
process.once(&apos;SIGQUIT&apos;, function() {
  process.exit(0);
});

process.once(&apos;SIGTERM&apos;, function() {
  process.exit(0);
});

process.once(&apos;SIGINT&apos;, function() {
  process.exit(0);
});

process.on(&apos;exit&apos;, function(code) {
  killAgentWorker();
});
</code></pre><p>当然，进程也有一些奇奇怪怪的异常，这些异常必须通过日志记录，然后才能进行安全的退出或者其他自定义行为。</p>
<pre><code>process.on(&apos;unhandledRejection&apos;, function(err, p) {
     //logger
});
</code></pre><p>除了以上标准流程之外，就得考虑非主进程出错退出时的情况并做相应的处理，比如 Agent 进程属于非常重要的业务进程，假如第一次启动就出问题，那必然需要强制退出，如果进程在某些情况下意外挂掉，必须有一些自重启机制来保证稳定运行，同时需要处理一些事件（之前出现过事件绑定过多内存泄露的事故）。</p>
<pre><code>agentWorker.once(&apos;exit&apos;, function(code, signal) {
  coreLogger.error(err);
  // 防止事件泄漏
  agentWorker.removeAllListeners(&apos;message&apos;);
  agentWorker = null;

  if (allWorkerStartSuccess) {
    // restart agent
    setTimeout(startAgent.bind(null, opts), 1000);
  } else {
    // AgentWorker 初始化过程发生异常，主进程直接退出
    // coreLogger.error(&apos;Agent worker init exception occurs. Master exits therefor.&apos;);
    process.exit(1);
  }
});
</code></pre><p>Worker 进程虽然使用 cluster 机制来启动，但是处理方式和 Agent 差不太多，除了挂掉自启之外，还需要有一些不一样的地方，比如进程的数量，原本默认的是 CPU 的核数，但是可能会根据当前的运行环境稍稍进行一些降低以保证内存的可用。此外，进程重启次数过多可能也是一大问题，需要进行额外的计数和报警，当然代码很简单，这边就不再赘述。</p>
<p>当然框架稳定性不仅仅只有这些，进程的处理只是最重要的一环，整个架构的设计中都必须考虑。</p>
<h2 id="框架设计"><a href="#框架设计" class="headerlink" title="框架设计"></a>框架设计</h2><p>Midway 新的设计理念是 <code>Everything is a plugin</code>，即所有的都是插件，包括框架和普通应用，这样的设计可以最大化的复用代码，简化使用。</p>
<p>一个简单的应用的结构和插件的结构，乃至框架的结构大致是一样的，经过集团 Node 小组的讨论形成了一套规范，也算是一次大统一。</p>
<pre><code>app_name/
├─app/   
|  ├─extends/
|  │  └─application.js      
│  ├─controllers/         
│  │  └─home.js            
│  ├─router.js             
│  └─views/               
│     └─home.xtpl 
├─bin/                     
│  ├─build.sh
│  └─server.js 
├─config/
│  ├─config.js 
│  ├─config.local.conf 
│  ├─config.prod.conf 
├─node_modules/
├─package.json              
└─README.md
</code></pre><p>看起来非常简单，除了常见的 node_modules 之外，还有一些淘宝特有的 <code>bin/app</code> 目录和一些 <code>xtpl</code> 模板文件。_bin 是启动目录，这边暂且不谈。</p>
<p>所有的插件的目录结构除了没有 <code>controllers</code> 和 <code>routers</code> 之外，和应用的目录结构是一样的，这其中最重要的一环就是加载方式。</p>
<p>Midway 的加载思路非常清晰简单：</p>
<ul>
<li>顺序加载插件</li>
<li>把应用作为最后一个插件加载进来</li>
<li>后边的插件覆盖之前的插件</li>
</ul>
<p>作为一个需要满足大部分场景的框架（插件、应用），需要加载东西有几样，配置文件、Koa 扩展、中间件，控制器，路由，这个时候需要一个通用的加载方法，这个方法可能是长这个样子。</p>
<pre><code>_loadFiles(files, opts) {
  //...

  loadDirs.forEach((dir)=&gt; {
    let fileResults = globby.sync(files, {cwd: dir});

    fileResults.forEach((f)=&gt; {
      let m = util.tryRequire(path.join(dir, f), opts.required);
      let result = (is.function(m) &amp;&amp; !is.class(m) &amp;&amp; needCall) ? m.apply(this, opts.inject ? [].concat(opts.inject) : [this.app]) : m;

      results.push(opts.resultHandler ? opts.resultHandler.call(this, result, f, dir, m) : result);

      if (opts.target) {
        extend(true, opts.target, result);
      }
    });
  });

  return results;
}
</code></pre><p>整个方法核心的思路就是加载(<code>tryRequire</code>)，除此之外，就是对加载之后的内容进行判断，处理，合并，返回。所有的加载都通过这一方法来做，就目前来看，大部分场景都已经满足了（笑）。</p>
<p>至此，一个框架的主线已经比较明确，核心功能也可用，剩下的就是插件的开发和补充，以及一些细节的修补。</p>
<h2 id="细节和纠结"><a href="#细节和纠结" class="headerlink" title="细节和纠结"></a>细节和纠结</h2><p>一个企业级框架的开发肯定没那么简单，主线设计相对容易一些，更麻烦的是细节，往往细节才是区别不同的框架最重要的地方。</p>
<h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><p>框架的历史包袱很大一部分体现在升级和兼容性上，但是框架的大版本更新往往是很多的不兼容，要让旧版本用户升级是一件非常头疼的事情。</p>
<p>Midway 也一样。</p>
<p>以前的 Midway 使用的是 <code>Proxy</code> 方式，所有暴露的外部接口都从 <code>midway.getXXXX</code> 中体现，而现有的进程加载方式使得 Midway 从 Worker 进程变为了 Master 进程，导致无法使用原本的方式了。</p>
<p>经历了多次讨论，最后还是为了用户妥协，将入口的文件(require 的部分) 变为 Worker ，而真正用户启动的 <code>server.js</code> 变为了 <code>midway/server</code>，也算是一个圆满的解决方案。</p>
<h3 id="测试和调试"><a href="#测试和调试" class="headerlink" title="测试和调试"></a>测试和调试</h3><p>由于将 Worker 机制内置到了 Midway 框架中，本来用户通过 app.js 的调试方式就行不通了，现在必须通过 <code>bin/server.js</code> 的方式来调试，略显繁琐。</p>
<p>根据新升级的 <a href="http://taobaofed.org/blog/2016/01/26/nodejs-ipc/">IPC 通信方式</a>，我们想到了可以通过只启动一个进程的方式来调试代码。所以在测试用例中也可以不用启动多个进程来测试代码了。</p>
<p>在大部分情况下测试代码使用 <code>mocha + supertest</code> 已经可以完美的完成了，但是偶尔会在运行多个的时候抽个风，这个问题属于 Agent 进程通信在本地无法判断出相同目录下是否是同一个实例的问题，除此之外，其他还没发现问题（笑:)）。</p>
<h3 id="更新机制"><a href="#更新机制" class="headerlink" title="更新机制"></a>更新机制</h3><p>新 Midway 的设计理念是简化开发，以往的经历告诉我们，推动用户升级是不现实的，花了许多的时间在给用户升级脚本，升级 Node.js 上，不仅给自己带来了很多不必要的工作量，也给用户带来了很多麻烦和隐患。</p>
<p>在新的设计中，把插件都内置到了自身的依赖中，由框架统一来处理版本，同时，把打包脚本和启动脚本也固化到了框架中，随着框架一起升级，至少在框架使用到现在，已经非常明显的减少客服量。</p>
<p>Midway 本身的升级由 <code>npm tag</code> 版本来控制，这个是由脚手架来处理的，用户每次部署 <code>install</code>，都使用的是该版本最新的框架。</p>
<pre><code>&quot;publishConfig&quot;: {
   &quot;tag&quot;: &quot;release-5.1&quot;
 },
</code></pre><p>当然这样的行为也是有隐患的，比如某个插件升级导致框架出错，不过作为一个内部的框架，我们尽可能保证插件的兼容性和稳定性，必须符合 <a href="http://semver.org/" target="_blank" rel="external">semver</a> 的版本规范，必须有一定的测试覆盖率，如果有不兼容的情况，整个框架都会一起升级 tag，尽可能减少给用户带来问题的机会。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>一个解决方案、一个框架的诞生背后总有一群抓耳挠腮的开发者，经常为了一些小的地方，团队会讨论许久，不光是为用户负责，也对自己负责，Midway 不会走 102 年，只是希望在能做的事情上，稍微多做一点罢了。</p>
<p>想来随着 Midway 5 的发布，有一阵子可以不用考虑该如何权衡和取舍了，可以更加把事情专注在服务用户，提升效率这些事情上了（笑）。</p>
<p>最后，铭记，不忘初心，奋勇前行。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://gtms01.alicdn.com/tps/i1/TB146VMMpXXXXXqXXXXWPiOLXXX-900-500.jpeg" alt="企业级 Node.js Web 应用解决方案设计的零零总总"></p>
<p>年前一直在忙着做新]]>
    </summary>
    
      <category term="node.js" scheme="http://taobaofed.org/tags/node-js/"/>
    
      <category term="midway" scheme="http://taobaofed.org/tags/midway/"/>
    
      <category term="Node.js" scheme="http://taobaofed.org/categories/Node-js/"/>
    
  </entry>
  
</feed>
