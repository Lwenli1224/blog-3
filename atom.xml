<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Taobao FED | 淘宝前端团队]]></title>
  <subtitle><![CDATA[淘宝前端团队（FED）]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://taobaofed.org/"/>
  <updated>2016-07-22T05:20:24.000Z</updated>
  <id>http://taobaofed.org/</id>
  
  <author>
    <name><![CDATA[Taobao FED]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[ES6 你可能不知道的事 - 基础篇]]></title>
    <link href="http://taobaofed.org/blog/2016/07/22/es6-basics/"/>
    <id>http://taobaofed.org/blog/2016/07/22/es6-basics/</id>
    <published>2016-07-22T03:32:30.000Z</published>
    <updated>2016-07-22T05:20:24.000Z</updated>
    <content type="html"><![CDATA[<p><img src="//img.alicdn.com/tfs/TB1HPI1KVXXXXbBXpXXXXXXXXXX-900-500.jpg" alt="ES6 你可能不知道的事 - 基础篇"></p>
<h1 id="ES6-你可能不知道的事-基础篇"><a href="#ES6-你可能不知道的事-基础篇" class="headerlink" title="ES6 你可能不知道的事 - 基础篇"></a>ES6 你可能不知道的事 - 基础篇</h1><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>ES6，或许应该叫 ES2015（2015 年 6 月正式发布），对于大多数前端同学都不陌生。</p>
<p>首先这篇文章不是工具书，不会去过多谈概念，而是想聊聊关于每个特性 <strong>你可能不知道的事</strong>，希望能为各位同学 <strong>正确使用</strong> ES6，提供一些指导。</p>
<p>对于 ES6，有些同学已经在项目中有过深入使用了，有些则刚刚开始认识他，但不论你是属于哪一类，相信这篇文章都有适合你的部分。针对文章中的问题或不同意见，欢迎随时拍砖、指正。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="Let-Const"><a href="#Let-Const" class="headerlink" title="Let + Const"></a>Let + Const</h3><p>这个大概是开始了解 ES6 后，我们第一个感觉自己完全明白并兴致勃勃的开始使用的特性。</p>
<p>以如下方式使用的同学请举下手？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义常量</span></span><br><span class="line"><span class="keyword">const</span> REG_GET_INPUT = <span class="regexp">/^\d&#123;1,3&#125;$/</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义配置项</span></span><br><span class="line"><span class="keyword">let</span> config = &#123;</span><br><span class="line">  isDev : <span class="literal">false</span>,</span><br><span class="line">  pubDir: <span class="string">'./admin/'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入 gulp</span></span><br><span class="line"><span class="keyword">let</span> gulp    = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入gulp相关插件</span></span><br><span class="line"><span class="keyword">let</span> concat  = <span class="built_in">require</span>(<span class="string">'gulp-concat'</span>);</span><br><span class="line"><span class="keyword">let</span> uglify  = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>);</span><br><span class="line"><span class="keyword">let</span> cssnano = <span class="built_in">require</span>(<span class="string">'gulp-cssnano'</span>);</span><br></pre></td></tr></table></figure>
<p>很多人看完概念之后，第一印象都是：“<code>const</code> 是表示不可变的值，而 <code>let</code> 则是用来替换原来的 <code>var</code> 的。”</p>
<p>所以就会出现上面代码中的样子；一段代码中出现大量的 <code>let</code>，只有部分常量用 <code>const</code> 去做定义，这样的使用方式是错误的。</p>
<h4 id="你可能不知道的事"><a href="#你可能不知道的事" class="headerlink" title="你可能不知道的事"></a>你可能不知道的事</h4><p><code>const</code> 的定义是<strong>不可重新赋值</strong>的值，与不可变的值(immutable value)不同；<code>const</code> 定义的 Object，在定义之后仍可以修改其属性。</p>
<p>所以其实他的使用场景很广，包括常量、配置项以及引用的组件、定义的 “大部分” 中间变量等，都应该以<code>const</code>做定义。反之就 <code>let</code> 而言，他的使用场景应该是相对较少的，我们只会在 loop(for，while 循环)及少量必须重定义的变量上用到他。</p>
<blockquote>
<p>猜想：就执行效率而言，<code>const</code> 由于不可以重新赋值的特性，所以可以做更多语法静态分析方面的优化，从而有更高的执行效率。</p>
</blockquote>
<p>所以上面代码中，所有使用 <code>let</code> 的部分，其实都应该是用 <code>const</code> 的。</p>
<h3 id="Template-Strings（字符串模板）"><a href="#Template-Strings（字符串模板）" class="headerlink" title="Template Strings（字符串模板）"></a>Template Strings（字符串模板）</h3><p>字符串模板是我刚接触ES6时最喜欢的特性之一，他语法简洁，语义明确，而且很好的解决了之前字符串拼接麻烦的问题。</p>
<p>因为他并不是 “必须” 的，而且原有的字符串拼接思维根深蒂固，导致我们很容易忽视掉他。</p>
<h4 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h4><p>我们先来看看他的一般使用场景：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> start = <span class="string">'hi all'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getName = () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'jelly'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> conf = &#123;</span><br><span class="line">  fav: <span class="string">'Coding'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板</span></span><br><span class="line"><span class="keyword">const</span> msg = <span class="string">`<span class="subst">$&#123;start&#125;</span>, my name is <span class="subst">$&#123;getName()&#125;</span>, <span class="subst">$&#123;conf.fav&#125;</span> is my favourite`</span>;</span><br></pre></td></tr></table></figure>
<h4 id="你可能不知道的事-1"><a href="#你可能不知道的事-1" class="headerlink" title="你可能不知道的事"></a>你可能不知道的事</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 与引号混用</span></span><br><span class="line"><span class="keyword">const</span> wantToSay = <span class="string">`I'm a "tbfed"`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 支持多行文本</span></span><br><span class="line"><span class="keyword">const</span> slogan = </span><br><span class="line"><span class="string">`</span><br><span class="line">I have a dream today!</span><br><span class="line">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较适合写HTML</span></span><br><span class="line"><span class="keyword">const</span> resultTpl = </span><br><span class="line"><span class="string">`</span><br><span class="line">  &lt;section&gt;</span><br><span class="line">    &lt;div&gt;...&lt;/div&gt;</span><br><span class="line">  &lt;/section&gt;</span><br><span class="line">`</span>;</span><br></pre></td></tr></table></figure>
<h3 id="Enhanced-Object-Literals（增强的对象字面量）"><a href="#Enhanced-Object-Literals（增强的对象字面量）" class="headerlink" title="Enhanced Object Literals（增强的对象字面量）"></a>Enhanced Object Literals（增强的对象字面量）</h3><p>增强的对象字面量是 ES6 中的升华功能，他设计了很多简写，这些简写不但保留了明确的语义，还减少了我们多余的代码量。</p>
<p>当他的使用成为一个习惯时，我们会看到自己代码变得更为优雅。</p>
<h4 id="你可能不知道的事-2"><a href="#你可能不知道的事-2" class="headerlink" title="你可能不知道的事"></a>你可能不知道的事</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> _bookNum = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> basicConfig = &#123;</span><br><span class="line">  level: <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="comment">// 直接指定原型对象</span></span><br><span class="line">  __proto__: basicConfig,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 属性简写</span></span><br><span class="line">  _bookNum,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 方法简写</span></span><br><span class="line">  getBookNum() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.bookNum;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Arrows-and-Lexical-This（箭头函数）"><a href="#Arrows-and-Lexical-This（箭头函数）" class="headerlink" title="Arrows and Lexical This（箭头函数）"></a>Arrows and Lexical This（箭头函数）</h3><p>箭头函数是ES6中的一个新的语法特性，他的用法简单，形态优雅，备受人们青睐。</p>
<p>大多数同学初识这个特性时，更多的仅仅用它作为函数定义的简写，这其实就有些屈才了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 未使用箭头函数的写法</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  addOptions: <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  </span><br><span class="line">    options.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">name, opts</span>)</span>&#123;</span><br><span class="line">      </span><br><span class="line">      self[name] = self.addChild(name, opts);</span><br><span class="line">      </span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用箭头函数后的写法</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  addOptions: <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">    options.forEach((name, opts) =&gt; &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">this</span>[name] = <span class="keyword">this</span>.addChild(name, opts);</span><br><span class="line">      </span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以注意到上下两段代码的区别。</p>
<p>在未使用箭头函数前，我们在过程函数中使用父级 <code>this</code>，需要将其显式缓存到另一个中间变量中，因为过程函数有独立的 <code>this</code> 变量，会覆盖父级；使用箭头函数后，不但简写了一个过程函数（ <code>forEach</code> 的参数），还省略掉了 <code>this</code> 的中间变量的定义。</p>
<p><em><strong>原因：箭头函数没有独立执行上下文（ <code>this</code> ），所以其内部引用 <code>this</code> 对象会直接访问父级。</strong></em></p>
<blockquote>
<p>插播：原来我们定义这个中间变量还有一个有趣的现象，就是明明千奇百怪，例如 <code>self, that, me, _that, _me, Self...</code>，快站出来说说你用过哪个，还是哪几个~</p>
</blockquote>
<p>当然，从这块我们也可以看出，箭头函数是无法替代全部 <code>function</code> 的使用场景的，例如我们需要有独立 <code>this</code> 的函数。</p>
<h4 id="你可能不知道的事-3"><a href="#你可能不知道的事-3" class="headerlink" title="你可能不知道的事"></a>你可能不知道的事</h4><ol>
<li>箭头函数不但没有独立 <code>this</code>，他也没有独立的 <code>arguments</code>，所以如果需要取不定参的时候，要么使用 <code>function</code>，要么用  ES6 的另一个新特性 <strong>rest</strong>（具体在 rest 中会有详解）。</li>
<li>箭头函数语法很灵活，在只有一个参数或者只有一句表达式做方法体时，可以省略相应括号。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完整写法</span></span><br><span class="line"><span class="keyword">const</span> getOptions = (name, key) =&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略参数括号</span></span><br><span class="line"><span class="keyword">const</span> getOptions = key =&gt; &#123;</span><br><span class="line">  ... </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略参数和方法体括号</span></span><br><span class="line"><span class="keyword">const</span> getOptions = key =&gt; <span class="built_in">console</span>.log(key);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参数或方法体，括号不能省略</span></span><br><span class="line"><span class="keyword">const</span> noop = () =&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>有个简单小栗子，这一灵活的语法在写连续的Promise链式调用时，可以使代码更加优雅</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gitPromise</span><br><span class="line">  .then(() =&gt; git.add())</span><br><span class="line">  .then(() =&gt; git.commit())</span><br><span class="line">  .then(() =&gt; git.log())</span><br><span class="line">  .then((msg) =&gt; &#123;</span><br><span class="line">      ...</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(() =&gt; git.push())</span><br><span class="line">  .catch((err) =&gt; &#123;</span><br><span class="line">      utils.error(err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Destructuring（解构）"><a href="#Destructuring（解构）" class="headerlink" title="Destructuring（解构）"></a>Destructuring（解构）</h3><p>解构这个特性可以简单解读为分别定义，用于一次定义多个变量，常常用于分解方法返回对象为多个变量，分别使用。<br>使用过ES6的同学应该或多或少接触过这个特性，但是你可能不知道它如下几个用法：</p>
<h4 id="你可能不知道的事-4"><a href="#你可能不知道的事-4" class="headerlink" title="你可能不知道的事"></a>你可能不知道的事</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bookSet = [<span class="string">'UED'</span>, <span class="string">'TB fed'</span>, <span class="string">'Not find'</span>];</span><br><span class="line"><span class="keyword">const</span> bookCollection = () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;book1: <span class="string">'UED'</span>, book2: <span class="string">'TB fed'</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 解构也可以设置默认值</span></span><br><span class="line"><span class="keyword">const</span> &#123;book1, book3 = <span class="string">'Not find'</span>&#125; = bookCollection();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 解构数组时候是可以跳过其中某几项的</span></span><br><span class="line"><span class="keyword">const</span> [book1,,book3] = bookSet;  <span class="comment">// book1 = 'UED', book3 = 'Not find'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 解构可以取到指定对象的任何属性，包括它包含的方法</span></span><br><span class="line"><span class="keyword">const</span> &#123;length: setLength&#125; = bookSet;  <span class="comment">// setLength = 3</span></span><br></pre></td></tr></table></figure>
<h3 id="Rest-Spread"><a href="#Rest-Spread" class="headerlink" title="Rest + Spread"></a>Rest + Spread</h3><p>Rest 和 Spread 主要是应用 <code>...</code> 运算符，完成值的聚合和分解。</p>
<h4 id="你可能不知道的事-5"><a href="#你可能不知道的事-5" class="headerlink" title="你可能不知道的事"></a>你可能不知道的事</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 1. rest 得到的是一个真正的数组而不是一个伪数组</span></span><br><span class="line"><span class="keyword">const</span> getOptions = <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(args.join); <span class="comment">// function</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. rest 可以配合箭头函数使用，达到取得所有参数的目的</span></span><br><span class="line"><span class="keyword">const</span> getOptions = (...args) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(args); <span class="comment">// array</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. spread 可以用于解构时，聚合所得的值</span></span><br><span class="line"><span class="keyword">const</span> [opt1, ...opts] = [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>, <span class="string">'four'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. spread 可以用于数组定义</span></span><br><span class="line"><span class="keyword">const</span> opts = [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>, <span class="string">'four'</span>];</span><br><span class="line"><span class="keyword">const</span> config = [<span class="string">'other'</span>, ...opts];</span><br></pre></td></tr></table></figure>
<h3 id="Classes"><a href="#Classes" class="headerlink" title="Classes"></a>Classes</h3><p>ES6 中实现的一个语法糖，用于简化基于原型集成实现类定义的场景。<br>虽然有很多人不太喜欢这个特性，认为它作为一个简单增强扩展，并没有其他语言 class 应有的特点。<br>但是就我自己观点来看，还是感觉这样一种写法确实比原有的原型继承的写法语义更清晰、明确，而且语法更简单。</p>
<p>同样，可能有些用法是你之前容易忽略掉的，在此做个补充。</p>
<h4 id="你可能不知道的事-6"><a href="#你可能不知道的事-6" class="headerlink" title="你可能不知道的事"></a>你可能不知道的事</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 1. 静态变量</span></span><br><span class="line"><span class="comment">// ES6 的类定义实现了静态方法的定义，但静态变量呢？</span></span><br><span class="line"><span class="comment">// 可以用如下方式实现: </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TbFedMembers</span></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> get HuaChen()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'jelly'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">TbFedMembers.HuaChen; <span class="comment">// "化辰"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 私有属性（私有属性有多种实现方式，只谈及其中一种）</span></span><br><span class="line"><span class="comment">// 闭包</span></span><br><span class="line"><span class="keyword">const</span> TbFedMembers = (() =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> HuaChen = <span class="string">'jelly'</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span></span>&#123;</span><br><span class="line">    getOneMemberName()&#123;</span><br><span class="line">      <span class="keyword">return</span> HuaChen;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<h3 id="Promises"><a href="#Promises" class="headerlink" title="Promises"></a>Promises</h3><p>Promise 不只是一个对象、一个语法，他更是一种异步编程方式的变化<br>相信使用过 ES6 的同学都已经开始尝试了 Promise，甚至在不支持ES6的时候，已经开始使用一些基于 Promise 思想的开源框架。</p>
<p>那么我们之前用 Promise 究竟用的对么？有什么需要注意的点呢？</p>
<h4 id="你可能不知道的事-7"><a href="#你可能不知道的事-7" class="headerlink" title="你可能不知道的事"></a>你可能不知道的事</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 1. 多个异步任务同时执行用 Promise.all，顺序执行使用链式调用</span></span><br><span class="line"><span class="comment">// Promise.all</span></span><br><span class="line"><span class="built_in">Promise</span></span><br><span class="line">  .all([jsBuildPromise, cssBuildPromise])</span><br><span class="line">  .then(() =&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// chain</span></span><br><span class="line">jsBuildPromise</span><br><span class="line">  .then(() =&gt; cssBuildPromise)</span><br><span class="line">  .then(() =&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Promise 的链式调用需要每一个过程返回一个 Promise 对象才能保证顺序执行</span></span><br><span class="line">gitPromise</span><br><span class="line">  .then(() =&gt; git.add())  <span class="comment">// 正确，箭头函数简写</span></span><br><span class="line">  .then(() =&gt; &#123;</span><br><span class="line">    git.commit(); <span class="comment">// 错误，函数返回 undefined，会立即执行下一过程</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(() =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> git.log(); <span class="comment">// 正确</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. Promise 需要调用 catch 方法来捕获错误，而且过程内的错误不会阻塞后续代码执行</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(() =&gt; &#123;</span><br><span class="line">  f;  <span class="comment">// not define error !</span></span><br><span class="line">&#125;)</span><br><span class="line">.catch((err) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err)  <span class="comment">// show 'f is not define'</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'error test'</span>);  <span class="comment">// 此行可以被正常执行</span></span><br></pre></td></tr></table></figure>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>基础篇主要是讲了我们最常用的一些特性，后续如果大家感兴趣，还可以再来个 “进阶篇”，最后，希望文章中的部分内容可以对大家理解和使用 ES6 有所帮助。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.stackoverflow.com" target="_blank" rel="external">https://www.stackoverflow.com</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/Web/JavaScript</a></li>
<li><a href="https://babeljs.io/docs/learn-es2015/" target="_blank" rel="external">https://babeljs.io/docs/learn-es2015/</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/Web/JavaScript</a></li>
<li><a href="https://ponyfoo.com/articles/es6-spread-and-butter-in-depth" target="_blank" rel="external">https://ponyfoo.com/articles/es6-spread-and-butter-in-depth</a></li>
<li><a href="http://12devs.co.uk/articles/promises-an-alternative-way-to-approach-asynchronous-javascript/" target="_blank" rel="external">http://12devs.co.uk/articles/promises-an-alternative-way-to-approach-asynchronous-javascript/</a></li>
<li><a href="http://www.2ality.com/2015/01/es6-destructuring.html" target="_blank" rel="external">http://www.2ality.com/2015/01/es6-destructuring.html</a></li>
<li><a href="http://www.datchley.name/es6-rest-spread-defaults-and-destructuring/" target="_blank" rel="external">http://www.datchley.name/es6-rest-spread-defaults-and-destructuring/</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="//img.alicdn.com/tfs/TB1HPI1KVXXXXbBXpXXXXXXXXXX-900-500.jpg" alt="ES6 你可能不知道的事 - 基础篇"></p>
<h1 id="ES6-你可能不知道的事-基础篇"><a href="]]>
    </summary>
    
      <category term="ES6" scheme="http://taobaofed.org/tags/ES6/"/>
    
      <category term="JavaScript" scheme="http://taobaofed.org/tags/JavaScript/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[性能优化：memoization]]></title>
    <link href="http://taobaofed.org/blog/2016/07/14/performance-optimization-memoization/"/>
    <id>http://taobaofed.org/blog/2016/07/14/performance-optimization-memoization/</id>
    <published>2016-07-14T04:01:25.000Z</published>
    <updated>2016-07-22T05:20:24.000Z</updated>
    <content type="html"><![CDATA[<p><img src="//img.alicdn.com/tfs/TB1wxWIKVXXXXXOapXXXXXXXXXX-900-500.jpg" alt="性能优化：memoization"></p>
<p><code>memoization</code>适用于递归计算场景，例如 <a href="http://en.wikipedia.org/wiki/Fibonacci_number" target="_blank" rel="external">fibonacci 数值</a> 的计算。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> n = process.env.N || <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'process $'</span>, process.pid);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'fibonacci recursive version with n = '</span>, n);</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  count++;</span><br><span class="line">  <span class="comment">//console.log(count);</span></span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">fibonacci(n);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'process memory usage'</span>, process.memoryUsage());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'final count'</span>, count);</span><br></pre></td></tr></table></figure>
<p>如果使用这种递归的写法去计算第 50 个 fibonacci 数值，需要执行 40730022147 次。随着执行次数的增加，执行所需时间成指数上涨：</p>
<p><img src="https://gtms04.alicdn.com/tps/i4/TB1d7ebKpXXXXXdXVXXue9FUVXX-1917-2180.png" alt=""></p>
<p><code>memoization</code>的技巧在于将计算过的结果『缓存』下来，避免重复计算带来的成本，例如将计算 fibonacci 的代码改写为如下形式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> N = process.env.N || <span class="number">50</span>;</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fibonacci = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> memo = &#123;&#125;;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">let</span> value;</span><br><span class="line">    <span class="keyword">if</span> (n <span class="keyword">in</span> memo) &#123;</span><br><span class="line">      value = memo[n];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) &#123;</span><br><span class="line">        value = n;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        value = f(n - <span class="number">1</span>) + f(n - <span class="number">2</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      memo[n] = value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">fibonacci(N);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'process memory usage'</span>, process.memoryUsage());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'final count'</span>, count);</span><br></pre></td></tr></table></figure>
<p>计算第 50 个 fibonacci 值只需要 99 次，执行时间为 0.06 秒，只有递归版本执行时间（546.41 秒）的万分之一，使用的内存（RSS 值 20111360）只有递归版本（RSS 值为 36757504）的 54%。</p>
<blockquote>
<p> 值得注意的是：这里闭包使用的<code>memo</code>对象有可能造成内存泄露。</p>
</blockquote>
<p><img src="https://gtms01.alicdn.com/tps/i1/TB1Q88ZKpXXXXcmaXXX9gOTNXXX-1922-768.png" alt=""></p>
<h3 id="处理多个参数"><a href="#处理多个参数" class="headerlink" title="处理多个参数"></a>处理多个参数</h3><p>如果需要处理多个参数，需要把缓存的内容变成多维数据结构，或者把多个参数结合起来作为一个索引。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> N = process.env.N || <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fibonacci = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> memo = &#123;&#125;;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> value;</span><br><span class="line">    memo[x] = memo[x] || &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (x <span class="keyword">in</span> memo &amp;&amp; n <span class="keyword">in</span> memo[x]) &#123;</span><br><span class="line">      value = memo[x][n];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) &#123;</span><br><span class="line">        value = n;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        value = f(n - <span class="number">1</span>) + f(n - <span class="number">2</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      memo[x][n] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">fibonacci(<span class="string">'a'</span>, N);</span><br><span class="line">fibonacci(<span class="string">'b'</span>, N);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'process memory usage'</span>, process.memoryUsage());</span><br></pre></td></tr></table></figure>
<p>上面执行了两次<code>fibonacci</code>函数，假设执行多次：</p>
<p><img src="https://gtms01.alicdn.com/tps/i1/TB1hgewKpXXXXXLXpXXASkp1VXX-1954-918.png" alt=""></p>
<p>可以看到内存的增长也是有限的，并且最终控制在了<code>22097920</code>这个值。下面是另一种处理多个参数的情况（将多个参数组成一个索引）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> N = process.env.N || <span class="number">50</span>;</span><br><span class="line"><span class="keyword">let</span> count;</span><br><span class="line"><span class="keyword">let</span> memo = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> slice = <span class="built_in">Array</span>.prototype.slice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fibonacci = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  count = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, n</span>) </span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">let</span> args = slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">let</span> value;</span><br><span class="line">    memo[x] = memo[x] || &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (args <span class="keyword">in</span> memo) &#123;</span><br><span class="line">      value = memo[args];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(n == <span class="number">0</span> || n == <span class="number">1</span>) &#123;</span><br><span class="line">        value = n;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        value = f(x, n - <span class="number">1</span>) + f(x, n - <span class="number">2</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      memo[args] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">  count = <span class="number">0</span>;</span><br><span class="line">  result = fibonacci(<span class="string">'#'</span> + i, i);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'process memory usage'</span>, process.memoryUsage());</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'final count'</span>, count);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'result of #'</span> + i, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与上面版本相比，内存有所增加，速度有所下降：</p>
<p><img src="https://gtms02.alicdn.com/tps/i2/TB1x71oKpXXXXcEXpXXj7Qt5VXX-3824-2270.png" alt="50 次对比" title="50 次对比"></p>
<p><img src="https://gtms03.alicdn.com/tps/i3/TB1TTt8KpXXXXc9XVXX4nXcUXXX-3832-2300.png" alt="100 次对比" title="100 次对比"></p>
<p><img src="https://gtms04.alicdn.com/tps/i4/TB18uugKpXXXXb9XFXXX9u8OXXX-3820-2304.png" alt="1000 次对比" title="1000 次对比"></p>
<h3 id="自动memoization"><a href="#自动memoization" class="headerlink" title="自动memoization"></a>自动<code>memoization</code></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">memoize</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> memo = &#123;&#125;;</span><br><span class="line">  <span class="keyword">let</span> slice = <span class="built_in">Array</span>.prototype.slice;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> args = slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">if</span> (args <span class="keyword">in</span> memo) &#123;</span><br><span class="line">      <span class="keyword">return</span> memo[args];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> memo[args] = func.apply(<span class="keyword">this</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是需要注意的是，并不是所有函数都可以自动<code>memoization</code>，只有<code>referential transparency</code>（引用透明）的函数可以。所谓<code>referential transparency</code>的函数是指：函数的输出完全由其输入决定，且不会有副作用的函数。下面的函数就是一个反例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo 函数的结果还受到全局变量 bar 的影响</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">baz</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> baz + bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>);</span><br><span class="line">bar++;</span><br><span class="line">foo(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>对比自动<code>memoization</code>前后的两个版本：</p>
<p><img src="https://gtms02.alicdn.com/tps/i2/TB1soOyKpXXXXaPXVXX28mEJXXX-3814-420.png" alt=""></p>
<p>自动<code>memoization</code>处理后的版本有所提高，但相比手动完全<code>memoization</code>的版本效率还是差了很多。</p>
<p>其实<code>memoization</code>这个词来自人工智能研究领域，其词源为拉丁语<code>memorandum</code>，这个词的创造者为<a href="http://www.aiai.ed.ac.uk/~dm/dm.html" target="_blank" rel="external">Donald Michie</a>，这种函数的设计初衷是为了提升机器学习的性能。随着函数式编程语言（Functional Programming，简称 FP）的兴起，例如 JavaScript、Haskell 以及 Erlang，这种用法才变得越来越流行。在前端编程中，可以使用<code>memoization</code>去处理各种需要递归计算的场景，例如缓存 canvas 动画的计算结果。</p>
<p>上面自动<code>memoization</code>的结果并不理想，可以参考<code>underscore</code>和<code>lodash</code>的<code>memoize</code>来做优化。</p>
<p>使用<a href="https://github.com/lodash/lodash/blob/145c3abb34ae327679d90d18804c7b955398c390/vendor/underscore/underscore.js#L777" target="_blank" rel="external"><code>lodash</code>的<code>memoize</code></a>方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * @filename: fibonacci-memoization-with-lodash.js</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> n = process.env.N || <span class="number">50</span>;</span><br><span class="line"><span class="keyword">let</span> _ = <span class="built_in">require</span>(<span class="string">'lodash'</span>);</span><br><span class="line"><span class="keyword">let</span> memoize = _.memoize;</span><br><span class="line"><span class="keyword">let</span> fibonacci = <span class="built_in">require</span>(<span class="string">'./fibonacci-recursive.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newFibonacci = memoize(fibonacci);</span><br><span class="line"><span class="keyword">let</span> result = newFibonacci(n);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'process memory usage'</span>, process.memoryUsage());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'result'</span>, result);</span><br></pre></td></tr></table></figure>
<p>对比结果：</p>
<p><img src="http://gtms01.alicdn.com/tps/i1/TB1pHCxKpXXXXcsXVXXT7Jp5pXX-3760-400.png" alt=""></p>
<p>可以看到<code>lodash</code>的<code>memoize</code>方法减少了一半执行时间。进一步优化：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">memoize</span>(<span class="params">func, context</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">memoizeArg</span>(<span class="params">argPos</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cache = &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (argPos == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(<span class="built_in">arguments</span>[argPos] <span class="keyword">in</span> cache)) &#123;</span><br><span class="line">          cache[<span class="built_in">arguments</span>[argPos]] = func.apply(context, <span class="built_in">arguments</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cache[<span class="built_in">arguments</span>[argPos]];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(<span class="built_in">arguments</span>[argPos] <span class="keyword">in</span> cache)) &#123;</span><br><span class="line">          cache[<span class="built_in">arguments</span>[argPos]] = memoizeArg(argPos - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cache[<span class="built_in">arguments</span>[argPos]].apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> arity = func.arity || func.length;</span><br><span class="line">  <span class="keyword">return</span> memoizeArg(arity - <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="http://gtms01.alicdn.com/tps/i1/TB1q4SZKpXXXXcRXXXXusZkMpXX-1918-320.png" alt=""></p>
<blockquote>
<p> 科普下：<code>function arity</code>指的是一个函数接受的参数个数，这是一个被废弃的属性，现在应使用<code>Function.prototype.length</code>。<br> <a href="https://stackoverflow.com/questions/4848149/get-a-functions-arity" target="_blank" rel="external">https://stackoverflow.com/questions/4848149/get-a-functions-arity</a></p>
</blockquote>
<p>zakas 的版本更加快，甚至比我们将<code>fibonacci</code>手动<code>memoization</code>的版本还快：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">let</span> n = process.env.N || <span class="number">50</span>;</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">memoizer</span>(<span class="params">fundamental, cache</span>) </span>&#123;</span><br><span class="line">  cache = cache || &#123;&#125;;</span><br><span class="line">  <span class="keyword">let</span> shell = <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cache.hasOwnProperty(arg)) &#123;</span><br><span class="line">      cache[arg] = fundamental(shell, arg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cache[arg];</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> shell;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fibonacci = memoizer(<span class="function"><span class="keyword">function</span>(<span class="params">recur, n</span>) </span>&#123;</span><br><span class="line">  count++;</span><br><span class="line">  <span class="keyword">return</span> recur(n - <span class="number">1</span>) + recur(n - <span class="number">2</span>);</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="number">1</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = fibonacci(n);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'process memory usage'</span>, process.memoryUsage());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'count'</span>, count);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'result'</span>, result);</span><br></pre></td></tr></table></figure>
<p><img src="http://gtms02.alicdn.com/tps/i2/TB1taHXKpXXXXXqXXXXHSJCLpXX-1916-570.png" alt=""></p>
<p>但是上面这些函数都存在问题，如果输入数目过大，会引发调用栈超过限制异常：<code>RangeError: Maximum call stack size exceeded</code>。</p>
<p>一种解决的方法就是将递归（<code>recursion</code>）修改为迭代（<code>iteration</code>）。例如下面这样的归并排序算法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> n = process.env.N || <span class="number">100</span>;</span><br><span class="line"><span class="keyword">let</span> isMemoized = process.env.M;</span><br><span class="line"><span class="keyword">let</span> test = [];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (left.length &gt; <span class="number">0</span> &amp;&amp; right.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left[<span class="number">0</span>] &lt; right[<span class="number">0</span>]) &#123;</span><br><span class="line">      result.push(left.shift());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.push(right.shift());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result.concat(left).concat(right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">items</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (items.length == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> items;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> middle = <span class="built_in">Math</span>.floor(items.length / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">let</span> left = items.slice(<span class="number">0</span>, middle);</span><br><span class="line">    <span class="keyword">let</span> right = items.slice(middle);</span><br><span class="line">    <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">  test.push(<span class="built_in">Math</span>.random() * <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result;</span><br><span class="line"><span class="keyword">if</span> (isMemoized) &#123;</span><br><span class="line">  <span class="keyword">let</span> memoize = <span class="built_in">require</span>(<span class="string">'./zakas-memo.js'</span>);</span><br><span class="line">  mergeSort = memoize(mergeSort);</span><br><span class="line">  result = mergeSort(test);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  result = mergeSort(test);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'process memory usage'</span>, process.memoryUsage());</span><br></pre></td></tr></table></figure>
<p><img src="http://gtms01.alicdn.com/tps/i1/TB1L8uRKpXXXXbkXFXXDHvXMXXX-3822-622.png" alt=""></p>
<p>而上面的排序函数在经过<code>memoization</code>后虽然不会抛出<code>RangeError: Maximum call stack size exceeded</code>的异常，但是在极端情况下也会因为内存不够分配导致失败：</p>
<p><img src="https://gtms02.alicdn.com/tps/i2/TB1XrjXKpXXXXaxXXXXrdqLOXXX-1926-1882.png" alt=""></p>
<p>解决<code>RangeError: Maximum call stack size exceeded</code>异常的一种方法是将递归的代码改写为迭代的代码，例如<code>fibonacci</code>的递归式写法为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  n = <span class="built_in">parseInt</span>(n);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'n = '</span>, n);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isNaN</span>(n)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> first = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> prev = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> sum;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">      sum = n;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        sum = first + prev;</span><br><span class="line">        first = prev;</span><br><span class="line">        prev = sum;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'i = '</span> + i + <span class="string">':'</span> + <span class="string">' sum = '</span> + sum);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="他山之石"><a href="#他山之石" class="headerlink" title="他山之石"></a>他山之石</h3><p>在 JavaScript 中我们是通过函数的形式来是实现函数的<code>memoization</code>，在 Python 中还可以用另一种被称为<code>decorator</code>的形式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">memoize</span><span class="params">(f)</span>:</span></span><br><span class="line">    memo = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> memo:</span><br><span class="line">            memo[x] = f(x)</span><br><span class="line">        <span class="keyword">return</span> memo[x]</span><br><span class="line">    <span class="keyword">return</span> helper</span><br><span class="line"></span><br><span class="line"><span class="meta">@memoize</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">print(fib(<span class="number">100</span>))</span><br></pre></td></tr></table></figure>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://www.sitepoint.com/implementing-memoization-in-javascript/" target="_blank" rel="external">https://www.sitepoint.com/implementing-memoization-in-javascript/</a></li>
<li><a href="http://en.wikipedia.org/wiki/Referential_transparency_(computer_science" target="_blank" rel="external">Referential transparency</a>)</li>
<li><a href="https://addyosmani.com/blog/faster-javascript-memoization/" target="_blank" rel="external">https://addyosmani.com/blog/faster-javascript-memoization/</a></li>
<li><a href="http://unscriptable.com/index.php/2009/05/01/a-better-javascript-memoizer/" target="_blank" rel="external">http://unscriptable.com/index.php/2009/05/01/a-better-javascript-memoizer/</a></li>
<li><a href="http://www.nczonline.net/blog/2009/01/27/speed-up-your-javascript-part-3/" target="_blank" rel="external">http://www.nczonline.net/blog/2009/01/27/speed-up-your-javascript-part-3/</a></li>
<li><a href="http://books.google.co.uk/books?id=PXa2bby0oQ0C&amp;pg=PA44&amp;lpg=PA44&amp;dq=crockford+memoization&amp;source=bl&amp;ots=HImnm6r1iH&amp;sig=lrdT9Sk4F4yQ-xQ-TLTx4SpLkuk&amp;hl=en&amp;ei=C-hyTvaIEofB8QO21Nn_DQ&amp;sa=X&amp;oi=book_result&amp;ct=result&amp;resnum=4&amp;ved=0CDMQ6AEwAw#v=onepage&amp;q&amp;f=false" target="_blank" rel="external">http://books.google.co.uk/books?id=PXa2bby0oQ0C&amp;pg=PA44&amp;lpg=PA44&amp;dq=crockford+memoization&amp;source=bl&amp;ots=HImnm6r1iH&amp;sig=lrdT9Sk4F4yQ-xQ-TLTx4SpLkuk&amp;hl=en&amp;ei=C-hyTvaIEofB8QO21Nn_DQ&amp;sa=X&amp;oi=book_result&amp;ct=result&amp;resnum=4&amp;ved=0CDMQ6AEwAw#v=onepage&amp;q&amp;f=false</a></li>
<li><a href="http://my.safaribooksonline.com/book/programming/javascript/9781449399115/functions/function_propertiesma_memoization_patter#X2ludGVybmFsX0ZsYXNoUmVhZGVyP3htbGlkPTk3ODE0NDkzOTkxMTUvNzY=" target="_blank" rel="external">http://my.safaribooksonline.com/book/programming/javascript/9781449399115/functions/function_propertiesma_memoization_patter#X2ludGVybmFsX0ZsYXNoUmVhZGVyP3htbGlkPTk3ODE0NDkzOTkxMTUvNzY=</a></li>
<li>memoize function javascript | npm memoize | lodash memoize | underscore memoize</li>
<li><a href="http://unscriptable.com/2009/05/01/a-better-javascript-memoizer/" target="_blank" rel="external">http://unscriptable.com/2009/05/01/a-better-javascript-memoizer/</a></li>
<li>programming optimization techniques</li>
<li><a href="http://blog.stevenlevithan.com/archives/timed-memoization" target="_blank" rel="external">http://blog.stevenlevithan.com/archives/timed-memoization</a></li>
<li><a href="https://github.com/addyosmani/memoize.js" target="_blank" rel="external">https://github.com/addyosmani/memoize.js</a></li>
<li><a href="https://en.wikipedia.org/wiki/Arity" target="_blank" rel="external">function arity</a></li>
<li><a href="https://philogb.github.io/blog/2008/09/05/memoization-in-javascript/" target="_blank" rel="external">https://philogb.github.io/blog/2008/09/05/memoization-in-javascript/</a></li>
<li><a href="https://stackoverflow.com/questions/6184869/what-is-difference-between-memoization-and-dynamic-programming" target="_blank" rel="external">https://stackoverflow.com/questions/6184869/what-is-difference-between-memoization-and-dynamic-programming</a></li>
<li><a href="http://www.python-course.eu/python3_memoization.php" target="_blank" rel="external">http://www.python-course.eu/python3_memoization.php</a></li>
<li><a href="https://en.wikipedia.org/wiki/Iteration" target="_blank" rel="external">https://en.wikipedia.org/wiki/Iteration</a></li>
<li><a href="https://en.wikipedia.org/wiki/Iterated_function" target="_blank" rel="external">https://en.wikipedia.org/wiki/Iterated_function</a></li>
<li><a href="https://www.ics.uci.edu/~eppstein/161/960109.html" target="_blank" rel="external">https://www.ics.uci.edu/~eppstein/161/960109.html</a></li>
<li><a href="https://classes.soe.ucsc.edu/cmpe012/Summer09/labs/lab8-Recursion-vs-Iteration/" target="_blank" rel="external">https://classes.soe.ucsc.edu/cmpe012/Summer09/labs/lab8-Recursion-vs-Iteration/</a></li>
<li>google: iterative merge sort</li>
<li>google: maximum call stack size exceeded | avoid maximum recursive</li>
<li><a href="http://www.python-course.eu/python3_decorators.php" target="_blank" rel="external">http://www.python-course.eu/python3_decorators.php</a></li>
<li><a href="https://www.cs.cornell.edu/courses/cs3110/2011sp/lectures/lec22-memoization/memo.htm" target="_blank" rel="external">https://www.cs.cornell.edu/courses/cs3110/2011sp/lectures/lec22-memoization/memo.htm</a></li>
<li>dynamic programming</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="//img.alicdn.com/tfs/TB1wxWIKVXXXXXOapXXXXXXXXXX-900-500.jpg" alt="性能优化：memoization"></p>
<p><code>memoization</code>适用于递归计算场景，]]>
    </summary>
    
      <category term="性能优化" scheme="http://taobaofed.org/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="javascript" scheme="http://taobaofed.org/tags/javascript/"/>
    
      <category term="memoization" scheme="http://taobaofed.org/tags/memoization/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[聊一聊淘宝首页和它背后的一套]]></title>
    <link href="http://taobaofed.org/blog/2016/06/02/thing-about-taobao-homepage/"/>
    <id>http://taobaofed.org/blog/2016/06/02/thing-about-taobao-homepage/</id>
    <published>2016-06-02T06:45:32.000Z</published>
    <updated>2016-07-22T05:20:24.000Z</updated>
    <content type="html"><![CDATA[<p><img src="//img.alicdn.com/tfs/TB1dcfNKXXXXXXcXVXXXXXXXXXX-900-500.png" alt="聊一聊淘宝首页和它背后的一套"></p>
<p>从 14 年双十二结束开始接手淘宝首页，到如今差不多 1 年半时间了，不久前完成了首页相关工作的交接。经历了两次改版和一次从 PHP 到 Node 的迁移，还是颇有感受，下面给大家分享下。</p>
<h3 id="一、相关背景介绍"><a href="#一、相关背景介绍" class="headerlink" title="一、相关背景介绍"></a>一、相关背景介绍</h3><p>淘宝首页是淘宝的门面，承载着几乎淘系所有业务的入口，流量很大，量级单位为亿。近几年无线端崛起，业务重点开始向无线终端偏移（目前不能叫偏移，基本以无线为主了），所以淘宝 PC 端首页的流量也有削减，不过即便如此，它的日均 PV 依然相当高。</p>
<p>淘宝首页一向是内部平台和技术的试验田，它一直在变化着。最新的框架和系统都会找淘宝首页试点，可以试想下，如果某一项需要推动的升级或者优化措施在淘宝首页已经上线，并且拿到了良好的数据和稳定性，其他业务还有什么理由不去尝试和更迭呢？同时，去年一年身在淘宝前端的技术架构组，自然而然也会主动去 push 一些实验性的内容到业务上。</p>
<p>淘系的站点页面包括首页、其他频道页和活动页等，这些页面并不都由淘宝前端一行一行的代码码出来，业务如此之多，这种玩法即便人数 double 也忙不过来。事实上，大多数页面都是依托内部的搭建平台——运营或者前端通过模块搭建的方式——构建的，而前端 focus 的重点在于搭建平台的建设自身以及模块的通用性和复用率的保障，当然，还有一些工程化的东西。</p>
<p>使用搭建平台搭建的页面，前端只需要考虑组成页面的原子模块的开发，整体的渲染由搭建平台提供的统一脚本全权负责。而在淘宝首页上，考虑到页面模块数量巨多，加上还有少量跨部门、跨团队的沟通，渲染模型略微不同。</p>
<h3 id="二、淘宝首页的整体变迁"><a href="#二、淘宝首页的整体变迁" class="headerlink" title="二、淘宝首页的整体变迁"></a>二、淘宝首页的整体变迁</h3><p>背景中提到，淘宝首页依托于内部搭建平台，它的变迁自然也是跟着搭建系统的变化而变化的。</p>
<h4 id="1-PHP-下的淘宝首页"><a href="#1-PHP-下的淘宝首页" class="headerlink" title="1. PHP 下的淘宝首页"></a>1. PHP 下的淘宝首页</h4><p>接手淘宝首页不久，便遇到了一年一度的改版，那时它还运行在 PHP 环境中。这里需要说明的是，淘宝首页的所有代码完全由前端掌控，前端不会直接跟数据库打交道，其数据来源分为两部分。</p>
<p><strong>数据来源</strong></p>
<p>一是 <em>运营填写的数据。</em> 采用前端挖坑的形式，预留坑位让运营获取填写数据，如（伪代码）：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> $info = Person(<span class="string">'name:String:姓名,age:Number:年龄'</span>, <span class="string">'个人信息坑位填写'</span>);<span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;div&gt;</span><br><span class="line"><span class="meta">&lt;?php</span> $info.<span class="keyword">forEach</span>(index) &#123; <span class="meta">?&gt;</span></span><br><span class="line">  Name: <span class="meta">&lt;?</span>= info[index].name <span class="meta">?&gt;</span>, Age: <span class="meta">&lt;?</span>= info[index].age <span class="meta">?&gt;</span></span><br><span class="line"><span class="meta">&lt;?php</span> &#125; <span class="meta">?&gt;</span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>上面的代码会产生一份 PHP 的模板和 info 字段对应的表单坑位，这个过程简称「挖坑」。</p>
<p><img src="http://ww4.sinaimg.cn/large/6c0378f8gw1f4g54zdicej20do09cdfy.jpg" alt="挖坑"></p>
<p>运营填写这些坑位就会产生这份 PHP 模板对应的数据，最后渲染出来就是一个完整的 HTML 片段（实时性渲染）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── data.json   <span class="comment"># 运营数据的来源</span></span><br><span class="line">└── index.php   <span class="comment"># 装载运营数据的 PHP 模板</span></span><br></pre></td></tr></table></figure>
<p>旧版搭建系统中就是通过这种方式构造一个子模块。我描述得十分简单，但作为一个平台它需要考虑的东西还有很多很多的，比如数据顺序的控制、定时发布、回滚机制、过滤机制、筛选机制、数据的同步、数据的更新、版本控制、权限控制、其他系统的引用等等。</p>
<p>二是 <em>后端或者个性化平台提供的数据。</em> 不同的业务有不同的诉求。一些业务有自己的后端，他们要求使用自己业务产出的数据；有的业务希望用户看到的内容不一样，千人千面，期望接入算法；一些业务跟卖家直接打交道，期望使用招商数据；而有些业务期望采用运营从数据池筛选出来的数据…总之，淘宝首页需要对接形形色色的系统，接口繁多。后面会提到对动态数据源的整合。</p>
<p>并且这些系统对应的域名是不一样的，JSONP 格式自然也就成了首选。但一些特殊的系统，比如广告，它的渲染并不是一个简单的 JSONP 请求，可能它还要干预整个广告的渲染流程，比如加载他们的 JS，把渲染的控制权交过去。</p>
<p><strong>页面的架构</strong></p>
<p>上面介绍了数据的来源和子模块的结构，那么整个页面又是如何构成的呢？模块的搭建分为两种，一种是可视化搭建，运营或者前端可以将开发好的模块（或者模块库中选取的模块）拖拽到容器内，形成一个页面，</p>
<p><img src="http://ww2.sinaimg.cn/large/6c0378f8gw1f4g51ddlmzj21ao0x4dij.jpg" alt="模块搭建"></p>
<p>当然，上图也只是一个模型，作为一个系统需要考虑的问题还有很多很多，如页面的布局、多终端适配、模块的临时隐藏、位置调整、皮肤选择、模块的复制等等。</p>
<p>也可以通过如下源码搭建的方式（伪代码）：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  <span class="meta">&lt;?</span>= loadModule(Mod1ID) <span class="meta">?&gt;</span></span><br><span class="line">  <span class="meta">&lt;?</span>= loadModule(Mod2ID) <span class="meta">?&gt;</span></span><br><span class="line">  <span class="meta">&lt;?</span>= loadModule(Mod3ID, <span class="string">'lazyload'</span>) <span class="meta">?&gt;</span></span><br><span class="line">  <span class="meta">&lt;?</span>= loadModule(Mod4ID, <span class="string">'lazyload'</span>) <span class="meta">?&gt;</span></span><br><span class="line">  <span class="meta">&lt;?</span>= loadModule(Mod5ID, <span class="string">'lazyload'</span>) <span class="meta">?&gt;</span></span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<p>通过模块 id 将模块引入，并且添加一些类似 <code>lazyload</code> 的标记，方便控制渲染节奏和数据入口。源码搭建和模块搭建的区别在于，前者更易于控制模块的结构以及模块的渲染顺序。</p>
<p><strong>动态数据源</strong></p>
<p>首页面对一大堆接口和平台，对接几十个业务方，接口是个很大的问题，由于后台系统的差异，基本没有办法统一数据源的格式，一旦运营哪天心血来潮要换一个他自己觉得用的更爽的或者数据更好的系统，前后端估计又得沟通和对接几次。所以出现了下面这张图：</p>
<p><img src="http://ww2.sinaimg.cn/large/6c0378f8gw1f4g5mwl5jzj218w0psdia.jpg" alt="动态数据源"></p>
<p>平台具备数据源接入的能力，也就是说我们挖的坑不仅仅可以让运营填数据，还可以从各种数据源中直接导入数据，当然，这里需要进行一次数据字段的映射转换。后端提供的接口是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"data"</span>: [&#123;</span><br><span class="line">    <span class="string">"item_name"</span>: <span class="string">"name"</span>,</span><br><span class="line">    <span class="string">"item_url"</span>: <span class="string">"http://xxx"</span>,</span><br><span class="line">    <span class="string">"item_pic"</span>: <span class="string">"http://xxx"</span></span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前端约定的接口形式是: </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"info"</span>: [&#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"name"</span>,</span><br><span class="line">    <span class="string">"url"</span>: <span class="string">"http://xxx"</span></span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么系统必须提供这种映射的绑定策略：</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">info</span>/<span class="keyword">name</span> -&gt;</span> <span class="keyword">data</span>/item_name</span><br><span class="line"><span class="function"><span class="title">info</span>/url -&gt;</span> <span class="keyword">data</span>/item_url</span><br></pre></td></tr></table></figure>
<p>绑定之后，数据既可以同步输出，也可以异步输出，这些都是平台提供的能力。这个方案基本上解决了后端系统/接口变化的问题，并且减少了前后端之间的沟通成本。</p>
<p>不过这里需要注意的是，虽然页面上的接口都通过平台统一梳理了一次，这也意味着，页面所有的请求会先流经平台，然后分发到各个后端，平台的抗压能力要求很高。</p>
<h4 id="2-PHP-到-Node-的变迁"><a href="#2-PHP-到-Node-的变迁" class="headerlink" title="2. PHP 到 Node 的变迁"></a>2. PHP 到 Node 的变迁</h4><p>淘宝首页日均请求的这个量级，不可能是十几二十台台服务器抗得住的，支撑它必须有一个服务集群。</p>
<p><img src="http://ww4.sinaimg.cn/large/6c0378f8gw1f4g6rdqpd0j212o0s076f.jpg" alt="集群"></p>
<p>每一个 CDN 节点上都具备 PHP 渲染的能力，当页面发布时，我们把该页面所有的模块和数据同步到全部 CDN 节点上，基本模式大概就是如此了。看起来还挺不错，但是经过一段时间的运维，很多安全、性能问题都慢慢浮现出来了：</p>
<p><em>性能问题。</em> 每个 PHP 页面包含多个子模块，而子模块也有可能引用了其他的子模块，PHP 的 <code>include</code> 操作是存在消耗的，每一次引用都是一次磁盘 IO，一个渲染节点上跑了成千上万个类似淘宝首页的 PHP 页面，并发一高其效率可想而知。</p>
<p><em>推送机制问题。</em> 文件同步（图中的 <code>sync</code> 动作）是一种比较恶心的机制，首先，时间上没法控制，一个文件同步到所有的节点，快则几秒钟，慢的话耗时会超过一两分钟；并且同步过程还有可能失败，健康检测的成本也是相当高的。发布比较紧凑时，需要同步的文件也很多，很容易造成队列堆积，加剧同步差的体验。</p>
<p><em>实时性强需求问题。</em> 文件在推送之前，还可能经过一些前置系统，发布链路越长，线上生效时间越慢，慢的时候大约五分钟才生效，这样的延时对于实时性要求很高（如秒杀）的需求来说是完全不能接受的。</p>
<p>当然，还有很多其他问题，如运维成本增高、安全风险增高、PHP 资深人才储备不足等等。所以 PHP 渲染容器的命运，就是，被干掉。</p>
<p><img src="http://ww4.sinaimg.cn/large/6c0378f8gw1f4g7eogvy9j21840tatb1.jpg" alt="回源"></p>
<p>上图改变了下玩法，服务集群为 Cache CDN，它只有静态文件处理能力，没有 PHP/Node 的渲染能力，所以处理效率高，性能也好，抗压能力相当强，并且扛不住的时候还可以花钱买服务，拓展 Cache 集群。</p>
<p>用户访问时，Nginx 转到 Cache CDN，如果命中缓存则直接返回，没有命中便回源到源站服务器。源站服务器是具备模块渲染能力的 Node 服务，它可以做很多事情：</p>
<ul>
<li>控制 Cache 响应头，通过 <code>max-age</code> 和 <code>s-maxage</code> 控制页面在客户端的缓存时间以及在 Cache 上的缓存时间，这个缓存时间可以根据需求随时做调整，比如大促的时候调长一些</li>
<li>控制内外网环境，和 AB 测试状态</li>
<li>融合前端相关的工具链，比如检测、压缩、过滤等等</li>
</ul>
<p>它的优势有很多，这里不一一列举了。这个模式中还添加了一层容灾，源站服务器每隔一段时间将数据推送到于 Cache 同机房的备份服务器，一点源站挂了，还能够自动容灾到备份数据上。</p>
<p>模式的变化不仅在运维上有了突破，CDN 被攻击时的安全风险也低了很多，同时也省却了 sync 所需的各种检测机制，每年节约成本也是百万以上，优势还是相当明显。</p>
<h4 id="3-Node，不一样的模式"><a href="#3-Node，不一样的模式" class="headerlink" title="3. Node，不一样的模式"></a>3. Node，不一样的模式</h4><p>上面 PHP 模块中，我们只说了 HTML 和数据部分，用心的读者应该已经发现，CSS 和 JS 这些静态资源都没提到，那页面是如何渲染的呢？</p>
<p>旧版 PHP 页面中，我们是直接引入了一个 CSS 和一个 JS，淘宝这边采用的是 git 版本迭代发布，这些静态资源都是直接放在一个 git 仓库中。也就是这样：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"//cdn/@VERSION@/index.css"</span>&gt;</span><br><span class="line">  &lt;script src=<span class="string">"//cdn/@VERSION@/index.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  <span class="meta">&lt;?</span>= loadModule(Mod1ID) <span class="meta">?&gt;</span></span><br><span class="line">  <span class="meta">&lt;?</span>= loadModule(Mod2ID) <span class="meta">?&gt;</span></span><br><span class="line">  <span class="meta">&lt;?</span>= loadModule(Mod3ID, <span class="string">'lazyload'</span>) <span class="meta">?&gt;</span></span><br><span class="line">  <span class="meta">&lt;?</span>= loadModule(Mod4ID, <span class="string">'lazyload'</span>) <span class="meta">?&gt;</span></span><br><span class="line">  <span class="meta">&lt;?</span>= loadModule(Mod5ID, <span class="string">'lazyload'</span>) <span class="meta">?&gt;</span></span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<p>每次发布完 git 文件，再修改 PHP 的版本号，然后发布 PHP 代码。当然，也做了相关的优化，比如发布 git 时自动更新版本号等。</p>
<p>而新版搭建平台的页面渲染模式与 PHP 的模式不太一样。</p>
<p><img src="http://ww1.sinaimg.cn/large/6c0378f8gw1f4g8566uz3j21kw0yt79h.jpg" alt="Node渲染模型"></p>
<p>一个模块的 CSS/JS 和模板放在一起，CSS/JS 与页面其他模块的静态资源是相互独立的，目的就是希望单个模块也能够完整的跑起来，更加利于模块的复用。</p>
<p>而模块的挖坑，也从模板中独立了出来，采用 JSON Schema 的形式定义数据格式，</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── <span class="keyword">index</span>.css    <span class="meta"># 模块样式</span></span><br><span class="line">├── <span class="keyword">index</span>.js     <span class="meta"># 模块渲染脚本</span></span><br><span class="line">├── schema.json  <span class="meta"># schema 配置</span></span><br><span class="line">└── <span class="keyword">index</span>.xtpl   <span class="meta"># 模块的模板</span></span><br></pre></td></tr></table></figure>
<p>搭建平台通过这个 JSON Schema 解析成 <a href="http://ww4.sinaimg.cn/large/6c0378f8gw1f4g54zdicej20do09cdfy.jpg" target="_blank" rel="external">图一</a> 的坑位。那么一个模块的渲染就变成了 <code>index.xtpl</code> 和挖坑数据之间的拼装了。</p>
<p>模块之间相互独立隔离，所以会存在一定程度的冗余，不过模块解偶带来的收益要比这点冗余要多得多。事实上，我们是通过一个仓库去管理单个模块的。页面的渲染就比较简单了，源站 Node 容器会将所有的 <code>index.xtpl</code> 合并成一个 <code>page.xtpl</code>，为减少页面请求，css 和 js 也会 combo 成一个文件，如上图所示的 <code>http://cdn/??mod1.css,mod2.css,mod3.css</code>。</p>
<p>任何模块的更新，页面都会有感知，下次进入系统时，就会提示是否需要升级模块和页面。</p>
<h3 id="三、淘宝首页的性能优化"><a href="#三、淘宝首页的性能优化" class="headerlink" title="三、淘宝首页的性能优化"></a>三、淘宝首页的性能优化</h3><p>首页模块众多，如果一口气吐出来，DOM 数量必然超过 4k 个，其结果就是首屏时间极长。按照 TMS 的开发规范，每个 TMS 模块都包含一个 <code>index.js</code> 和 <code>index.css</code>，最后展示出来两个 combo 的 js 和 css。首页加载的时候也不会一口气执行所有 <code>index.js</code>，否则刚开始页面阻塞会十分严重。</p>
<p><strong>页面的渲染逻辑</strong></p>
<p><img src="http://ww2.sinaimg.cn/large/6c0378f8gw1f4gse45ss8j20fn0jr0v3.jpg" alt="页面的渲染逻辑"></p>
<p>首页框架的加载逻辑，大致上图所示：</p>
<ul>
<li>遍历所有 TMS 模块（包含一个 <code>J_Module</code> 的钩子）</li>
<li>部分 TMS 模块无 JS 内容，但是加载了一个 <code>index.js</code>，为模块添加 <code>tb-pass</code> 的 class，用于跳过该模块 JS 的执行</li>
<li>将页面分为两块，首屏为一块，非首屏整体为第二块，先将首屏模块加入到懒加载监控</li>
<li>待首屏模块加载完成，或者用户处理了页面交互时（滚动、鼠标移动等），将非首屏模块加入到懒加载监控</li>
<li>处理一些特殊模块，它们会在进入视窗之前几百像素就开始加载</li>
<li>监控滚动，按照以上逻辑，渲染模块</li>
</ul>
<p>部分模块即便是被执行了，也不一定渲染出来，因为它的优先级不高，在模块内部加了事件监听，比如等到 <code>mouseover/onload</code> 事件触发的时候再渲染这些内容。</p>
<p>之前写过性能优化相关的文章，复制就没必要了，直接贴地址：</p>
<ul>
<li><a href="http://taobaofed.org/blog/2016/04/05/optimize-in-tbhome/">《淘宝首页性能优化实践》</a></li>
</ul>
<p>代码的性能优化是一个精细活，如果你要在一个庞大的未经优化的页面上做性能优化，可能会面临一次重构代码。</p>
<p>上面的文章提到的是页面内部的细节优化，但是在开发流程中做的规范化、标准化，以及线上访问通路中的各个环节优化还没有提及。</p>
<h3 id="四、淘宝首页的稳定性保障"><a href="#四、淘宝首页的稳定性保障" class="headerlink" title="四、淘宝首页的稳定性保障"></a>四、淘宝首页的稳定性保障</h3><p>在大流量下，任何小问题都会被放大成大问题，所以开发环节遇到的任何偶发性问题都需要引起重视。不过很多偶发性问题在我们的测试环境中是找不到的，比如与地域相关的问题（如上海的某个 CDN 节点挂了），用户属性问题（如 nickname 最后一个为字母 s 的用户页面天窗），浏览器插件问题，运营商广告注入问题等等。</p>
<p>难以在上线之前把所有问题考虑周全，但是有两点是必须做好的：<strong>兜底容灾 + 监控预警。</strong></p>
<h4 id="1-兜底容灾机制"><a href="#1-兜底容灾机制" class="headerlink" title="1. 兜底容灾机制"></a>1. 兜底容灾机制</h4><p>兜底容灾有两个层面的考虑：</p>
<ul>
<li>异步接口请求错误，包括接口数据格式错误，接口请求超时等</li>
<li>同步渲染，源站页面渲染出错</li>
</ul>
<p>异步接口请求，主要涉及到的是后台系统，对接系统较多，各个系统的稳定性和抗压能力各不相同，这方面的保障有多种方案，下面是最常见的：</p>
<p><img src="http://ww4.sinaimg.cn/large/6c0378f8gw1f4go51ui9zj20kh0h7n0b.jpg" alt="请求缓存"></p>
<p>每次数据请求都缓存到本地，并且为每个接口都提供一个硬兜底。还有一种方案是「重试」，请求一次不成功那就请求第二次。这方面的讨论具体可以看看之前写的这篇文章：<a href="http://taobaofed.org/blog/2015/10/28/disaster-recovery-at-taobao-home-page/">《淘宝首页兜底容灾方案》</a>。</p>
<p>对于同步渲染，它只需要页面模板和同步数据，两者中任一种存在错误，源站都会报错，此时回源返回的内容就是一个 error 页面，状态码为 <code>5xx</code>。这个错误不一定是开发者造成的，有可能是系统链路出现同步异常或者断路问题。针对这种问题，我给淘宝首页做了一个镜像页：</p>
<p><img src="http://ww1.sinaimg.cn/large/6c0378f8gw1f4gonwmraoj21ce0rq0vr.jpg" alt="镜像"></p>
<p>一旦源站任何异常，Nginx 都会转到与 Cache CDN 同机房的首页镜像上去，这个镜像内容就是淘宝首页的 HTML 备份源码。</p>
<h4 id="2-监控预警机制"><a href="#2-监控预警机制" class="headerlink" title="2. 监控预警机制"></a>2. 监控预警机制</h4><p>监控也有两个层面：</p>
<ul>
<li>模块级别的监控，接口请求布点、模块天窗检测等</li>
<li>页面的监控，在页面上添加特殊标记，定时回归所有 CDN 节点，查看特殊标记是否存在</li>
</ul>
<p>模块层面的监控，内容还是相当多的，监控的点越多越详细，到最后定位问题的效率就会越高，比如在一个稍微复杂的模块上，我会埋下这些监控：</p>
<ul>
<li>接口请求格式错误、请求失败、请求超时，至少三个埋点</li>
<li>硬兜底数据请求失败埋点</li>
<li>模块 5s 内没有渲染完成统计埋点</li>
<li>模块内链接和图片黑白名单匹配埋点</li>
</ul>
<p><img src="http://ww3.sinaimg.cn/large/6c0378f8gw1f4gtw0jjxxj20w50akace.jpg" alt="监控"></p>
<p>其中部分监控还会自动处理明确的错误，比如 https 页面下出现了 http 的图片，会立即自动处理掉这些问题。</p>
<h4 id="3-上线前的自动化检测"><a href="#3-上线前的自动化检测" class="headerlink" title="3. 上线前的自动化检测"></a>3. 上线前的自动化检测</h4><p>这属于淘宝整个工程化环境的一部分，前端自动化测试。一般会在上线之前处理这些问题：</p>
<ul>
<li>检测 HTML 是否符合规范</li>
<li>检测 https 升级情况</li>
<li>检测链接合法性</li>
<li>检测静态资源合法性</li>
<li>检测 JavaScript 报错</li>
<li>检测页面加载时是否有弹出框</li>
<li>检测页面是否调用 <code>console.*</code></li>
<li>页面 JS 内存记录</li>
</ul>
<p>当然，也可以自己添加测试用例，比如检测接口数据格式、模块天窗问题等。自动化检测也可以设定定时回归，还是比较有保障的。</p>
<h3 id="五、淘宝首页的敏捷措施"><a href="#五、淘宝首页的敏捷措施" class="headerlink" title="五、淘宝首页的敏捷措施"></a>五、淘宝首页的敏捷措施</h3><h4 id="1-健康检查"><a href="#1-健康检查" class="headerlink" title="1. 健康检查"></a>1. 健康检查</h4><p>页面模块众多，为了能够追踪页面上每一个小点的变化，我在请求、渲染的每一个环节都做了详细的统计，如下图所示：</p>
<p><img src="http://ww3.sinaimg.cn/large/6c0378f8gw1f4gt6p2lsfj20la0gmjwg.jpg" alt="Console"></p>
<p>一旦接口请求失败，或者接口走了容灾逻辑，或者模块渲染超过 5s，控制台都会有黄色警报，当然此时，也已经向服务器发送了警报统计。</p>
<h4 id="2-接口-Hub"><a href="#2-接口-Hub" class="headerlink" title="2. 接口 Hub"></a>2. 接口 Hub</h4><p>接口 Hub 是对数据请求的管理工具，如下图所示：</p>
<p><img src="http://ww1.sinaimg.cn/large/6c0378f8gw1f4gt7e0p74j20j70cvtbv.jpg" alt="HubCache"></p>
<p>页面很多模块的渲染都需要一个以上的数据源，一旦运营反馈页面渲染数据异常，可以直接通过 Hub 找到数据，加速 Bug 定位效率。同时 Hub 也可以用来切换环境，将一个接口的请求切换到日常或者预发环境的接口之中，它是调试的利器。</p>
<h4 id="3-快捷通道"><a href="#3-快捷通道" class="headerlink" title="3. 快捷通道"></a>3. 快捷通道</h4><p>我在页面脚本执行前后都放了一个快捷操作通道，一旦遇到紧急线上问题，比如样式错乱溢出、接口报错导致天窗等，可以通过快捷通道直接修改页面的 CSS 和 JS，两分钟内上线。</p>
<p>不过这类通道只适合紧急问题的修复，毕竟随意插入 JS 代码是存在很大风险的。</p>
<h3 id="六、小结"><a href="#六、小结" class="headerlink" title="六、小结"></a>六、小结</h3><p>写的好像有点虎头蛇尾（码字和画图都太累），还有很多方面没有延伸拓展开。希望以上可以让你对淘宝首页有一个基本的认识。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="//img.alicdn.com/tfs/TB1dcfNKXXXXXXcXVXXXXXXXXXX-900-500.png" alt="聊一聊淘宝首页和它背后的一套"></p>
<p>从 14 年双十二结束开始接手淘宝首页，到如今差不多 1 年半时间了，不]]>
    </summary>
    
      <category term="淘宝首页" scheme="http://taobaofed.org/tags/%E6%B7%98%E5%AE%9D%E9%A6%96%E9%A1%B5/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[视频播放的那些事]]></title>
    <link href="http://taobaofed.org/blog/2016/05/23/video-player/"/>
    <id>http://taobaofed.org/blog/2016/05/23/video-player/</id>
    <published>2016-05-23T03:26:29.000Z</published>
    <updated>2016-07-22T05:20:24.000Z</updated>
    <content type="html"><![CDATA[<p><img src="//img.alicdn.com/tfs/TB1YyshJVXXXXaEXVXXXXXXXXXX-900-500.jpg" alt="视频播放的那些事"></p>
<ul>
<li>视频作为淘宝教育业务的基础服务，本文根据自身在手淘中视频播放的实践，谈谈在手淘中视频播放遇到的问题及其解决方案。 </li>
</ul>
<h3 id="播放器"><a href="#播放器" class="headerlink" title="播放器"></a>播放器</h3><ul>
<li><p>在手淘过去一年多的历史长河中存在五种类型的播放器。</p>
<ul>
<li>原生 HTML5 video 标签</li>
<li>Android 5.3.2 版本之后的 UC 内核增强 SAC 播放器</li>
<li>Android 5.4.9 版本之后的 UC HAC 播放器</li>
<li>Android 5.3.2 版本之前的 Glue native 播放器</li>
<li>Android 5.3.2 版本及其之后的 PlayBuddy 播放器</li>
</ul>
</li>
<li><p>下面从支持平台，loading 动画，全屏，模拟全屏和兼容性五个方面对各个播放器做个横向对比。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>video IOS</th>
<th>video Android</th>
<th>UC SAC</th>
<th>UC HAC</th>
<th>PlayBuddy</th>
<th>Glue</th>
</tr>
</thead>
<tbody>
<tr>
<td>平台</td>
<td>IOS手淘</td>
<td>android手淘</td>
<td>android手淘&gt;=5.3.2</td>
<td>android手淘&gt;=5.4.9</td>
<td>android手淘&gt;=5.3.2</td>
<td>android手淘&lt;5.3.2</td>
</tr>
<tr>
<td>loading</td>
<td>可定制</td>
<td>可定制</td>
<td>无</td>
<td>可定制</td>
<td>不可定制，丑陋</td>
<td>有</td>
</tr>
<tr>
<td>控件可定制性</td>
<td>可以</td>
<td>可以</td>
<td>不可以</td>
<td>可以</td>
<td>不可以</td>
<td>不可以</td>
</tr>
<tr>
<td>全屏</td>
<td>支持竖全屏</td>
<td>不支持</td>
<td>支持竖全屏</td>
<td>可以</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>模拟全屏</td>
<td>支持</td>
<td>支持</td>
<td>不支持</td>
<td>有bug</td>
<td>–</td>
<td>–</td>
</tr>
<tr>
<td>兼容性</td>
<td>好</td>
<td>较好</td>
<td>较好</td>
<td>好</td>
<td>较好</td>
<td>一般，不兼容 android 5.0及以上</td>
</tr>
</tbody>
</table>
<h3 id="接口与事件封装"><a href="#接口与事件封装" class="headerlink" title="接口与事件封装"></a>接口与事件封装</h3><p>上面介绍了手淘中可供 WebView 选择的播放器，对于业务方而言迫切需要一个解决方，无需关心底层差异。为此，我们屏蔽移动端不同系统平台、宿主环境、播放器的实现细节和兼容性问题，提供统一的接口和事件，具体如下：</p>
<ul>
<li>方法<ul>
<li>play 播放</li>
<li>pause 暂停</li>
<li>stop 停止</li>
<li>show 显示</li>
<li>hide 隐藏</li>
<li>requestFullscreen 全屏</li>
<li>exitFullScreen 退出全屏</li>
<li>getCurrentTime 获取当前播放时间</li>
<li>setCurrentTime 设置播放时间</li>
<li>getDuration 获取视频时长</li>
<li>setPoster 设置背景图</li>
<li>destory 销毁</li>
<li>reset 重置视频</li>
</ul>
</li>
<li><p>事件</p>
<ul>
<li>timeupdate 进度更新</li>
<li>ended 停止</li>
<li>error 错误</li>
<li>play （专指video）</li>
<li>pause 停止（专指video）</li>
<li>firstpaint 视频真正开始播放（专指video）</li>
</ul>
</li>
<li><p>controls 播放控件（专指video）</p>
<ul>
<li>播放</li>
<li>暂停</li>
<li>进度更新</li>
<li>全屏</li>
<li>loading</li>
</ul>
</li>
</ul>
<h3 id="兼容性处理"><a href="#兼容性处理" class="headerlink" title="兼容性处理"></a>兼容性处理</h3><p>接下来谈谈在开发过程中遇到的各种小问题及其解决办法。</p>
<h4 id="video"><a href="#video" class="headerlink" title="video"></a>video</h4><ul>
<li><p><strong>内联播放</strong>。iPhone 在视频播放时默认全屏播放，<a href="https://developer.apple.com/library/iad/documentation/UserExperience/Conceptual/iAdJSProgGuide/PlayingVideosinAds/PlayingVideosinAds.html" target="_blank" rel="external">参考</a>。</p>
<ul>
<li><p>WebView 中，可以对 UIWebView 做如下配置，并且在 video 中配置 webkit-playsinline 属性即可：</p>
<figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">webview.allowsInlineMediaPlayback </span>=<span class="string"> YES;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>iPhone Safari 在 IOS &gt;= 8 的系统中，有人也提出了一个<a href="https://link.zhihu.com/?target=https%3A//github.com/bfred-it/iphone-inline-video" target="_blank" rel="external">方案</a></p>
</li>
</ul>
</li>
<li><p><strong>自定义播放控件</strong></p>
<ul>
<li>部分 Android 机型不支持内置控件，或者说内置控件无法正常使用；各个产品都有特定的视觉规范，默认控件的交互和视觉无法满足需求。因此，我们推荐默认不启用默认控件，采用自定义控件。</li>
<li>IOS 下播放时还可能还展示系统自带播放按钮，可以配置如下 CSS。</li>
</ul>
</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">video</span><span class="selector-pseudo">::-webkit-media-controls-start-playback-button</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>poster 视频底图</strong></p>
<ul>
<li>在 iPhone 中视频加载完第一帧数据后会覆盖 Poster 底图展示第一帧画面，这时可以使用 DIV 覆盖在视频上方模拟，监听 timeupdate 事件做隐藏操作。</li>
<li>在 UC WebView 中动态设置 poster 可能会导致手淘 crash，方案跟上方一样。</li>
<li>在使用 Native 播放器时，在播放器未初始化时使用 DIV 替换 video 标签，并设置底图为背景图。</li>
</ul>
</li>
<li><p><strong>播放首屏</strong>：IOS 通过监听 playing 事件可以准确获取视频播放的时间点；Android 中在该事件触发时，还没真正开始播放。我们通过监听 timeupdate 的事件做模拟处理。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">_timeUpdate(e) &#123;</span><br><span class="line"> <span class="keyword">var</span> currentTime = <span class="keyword">this</span>.getCurrentTime();</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 判断是否为首帧</span></span><br><span class="line"> <span class="keyword">if</span> (currentTime !== <span class="literal">undefined</span> &amp;&amp; currentTime !== <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="keyword">this</span>.fire(<span class="string">'firstpaint'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_playing() &#123;</span><br><span class="line">  <span class="keyword">if</span> (Env.os.ios) &#123;</span><br><span class="line">     <span class="keyword">this</span>.fire(<span class="string">'firstpaint'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>视频切换</strong>：在android 4.4 以下版本，在视频切换时存在第一次切换不能正常播放，第二次才能正常播放情况。通过调试人肉分析，发现切换视频的 video 存在以下两个特征：readyState 值为 0，videoWidth 为 0。因此我们判断当两个属性为0时，则切换失败，再次调用播放逻辑。存在误判的可能，但是能保证正常工作。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">isWork() &#123;</span><br><span class="line">    <span class="keyword">if</span> (videoEl.readyState === <span class="number">0</span> &amp;&amp; videoEl.videoWidth === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>全屏</strong>：手淘 IOS 支持竖全屏效果，Android 虽然具有全屏方法，但是被手淘限制，调用全屏方法无效。</p>
<ul>
<li><p><code>方案一</code>：为了支持横全屏，我们使用 css3 的 rotate 对视频区域进行90度旋转，并且调用 bridge 接口隐藏 native 顶部的 navibar，并对自定义控件进行响应优化调整。基本到达 native全屏效果。当然顶部状态栏不能隐藏还是有些小瑕疵。同时旋转之后元素的 z-index失效，导致视频覆盖控件问题，可以通过设置 -webkit-transform: translate3d(0,0,0) 来修复</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">requestFullscreen() &#123;</span><br><span class="line">    <span class="keyword">var</span> element = <span class="keyword">this</span>.el[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">var</span> method = FullscreenApi.requestFullscreen;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (method) &#123;</span><br><span class="line">        element[method]();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.webkitEnterFullscreen || element.enterFullScreen) &#123;</span><br><span class="line">        element.webkitEnterFullscreen &amp;&amp; element.webkitEnterFullscreen();</span><br><span class="line">        element.enterFullScreen &amp;&amp; element.enterFullScreen();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟全屏</span></span><br><span class="line">        <span class="comment">// enterFullWindow();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟全屏js核心代码</span></span><br><span class="line">_mockFullscreen() &#123;</span><br><span class="line">    <span class="keyword">if</span> (curEl.hasClass(<span class="string">'normal'</span>)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.fullscreen = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        playerEl.css(&#123;</span><br><span class="line">            width: <span class="keyword">this</span>.originWidth,</span><br><span class="line">            height: <span class="keyword">this</span>.originHeight,</span><br><span class="line">            left: <span class="number">0</span></span><br><span class="line">        &#125;).removeClass(<span class="string">'fullscreen'</span>);</span><br><span class="line"></span><br><span class="line">        wrapperEl.css(&#123;</span><br><span class="line">            width: <span class="keyword">this</span>.wrapperOriginWidth,</span><br><span class="line">            height: <span class="keyword">this</span>.wrapperOriginHeight</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        videoEl.css(<span class="string">'height'</span>, <span class="string">'100%'</span>);</span><br><span class="line"></span><br><span class="line">        curEl.removeClass(<span class="string">'normal'</span>);</span><br><span class="line">        contentEl.removeClass(<span class="string">'fullscreen'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.fullscreen = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.originWidth = playerEl.width();</span><br><span class="line">        <span class="keyword">this</span>.originHeight = playerEl.height();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.wrapperOriginWidth = wrapperEl.width();</span><br><span class="line">        <span class="keyword">this</span>.wrapperOriginHeight = wrapperEl.height();</span><br><span class="line"></span><br><span class="line">        playerEl.css(&#123;</span><br><span class="line">            width: $(<span class="built_in">window</span>).height(),</span><br><span class="line">            height: $(<span class="built_in">window</span>).width(),</span><br><span class="line">            left: $(<span class="built_in">window</span>).width()</span><br><span class="line">        &#125;).addClass(<span class="string">'fullscreen'</span>);</span><br><span class="line"></span><br><span class="line">        wrapperEl.css(&#123;</span><br><span class="line">            width: $(<span class="built_in">window</span>).height(),</span><br><span class="line">            height: $(<span class="built_in">window</span>).width()</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        videoEl.css(<span class="string">'height'</span>, videoEl.height() - controlsHeight);</span><br><span class="line"></span><br><span class="line">        curEl.addClass(<span class="string">'normal'</span>);</span><br><span class="line">        contentEl.addClass(<span class="string">'fullscreen'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>效果图:<br><img src="https://img.alicdn.com/tps/TB1vRHkJpXXXXXAXFXXXXXXXXXX-1280-719.jpg" alt="IOS全屏"></p>
</li>
<li>预览地址（请用手淘扫码）：<br><img src="https://img.alicdn.com/tps/TB1VrUrJFXXXXctXVXXXXXXXXXX-178-175.jpg" alt="demo"></li>
</ul>
<ul>
<li><code>方案二</code>。方案一只是模拟了横全屏效果，对于追求完美的处女座不能忍。还有其他方案吗？有时候只需要转换下思维，问题即可迎刃而解。既然是横屏播放，只需要让 WebView 横屏即可，同时在横屏之后重新调整控件即可，关键手淘提供了打开应用横全屏的接口。注意点：横屏之后需要禁止页面滚动，要不然全屏就露馅了，因为本质还是个 WebView。</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.transverseFullScreen) &#123;</span><br><span class="line">  <span class="keyword">if</span> (curEl.hasClass(<span class="string">'normal'</span>)) &#123;</span><br><span class="line">    curEl.removeClass(<span class="string">'normal'</span>);</span><br><span class="line">    <span class="keyword">this</span>._transverseFullScreen(<span class="literal">false</span>).then(() =&gt; &#123;</span><br><span class="line">      $(<span class="string">'body'</span>).removeClass(<span class="string">'co-fullscreen'</span>).attr(&#123; height: <span class="string">'auto'</span> &#125;);</span><br><span class="line">      <span class="keyword">this</span>.videoWrapperEl.height(<span class="keyword">this</span>.videoOriginHeight).removeClass(<span class="string">'fullscreen'</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.player.fire(<span class="string">'transversefullscreen'</span>, &#123; fullscreen: <span class="literal">false</span> &#125;);</span><br><span class="line">      <span class="keyword">this</span>.resize();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    curEl.addClass(<span class="string">'normal'</span>);</span><br><span class="line">    <span class="keyword">this</span>._transverseFullScreen(<span class="literal">true</span>).then(() =&gt; &#123;</span><br><span class="line">      $(<span class="string">'body'</span>).addClass(<span class="string">'co-fullscreen'</span>).attr(&#123; height: win.height() &#125;);</span><br><span class="line">      <span class="keyword">this</span>.videoWrapperEl.height(win.height()).addClass(<span class="string">'fullscreen'</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.player.fire(<span class="string">'transversefullscreen'</span>, &#123; fullscreen: <span class="literal">true</span> &#125;);</span><br><span class="line">      <span class="keyword">this</span>.resize();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Demo：<br><img src="http://img3.tbcdn.cn/L1/461/1/2d8cead70e721088b82892514ef210b7150df716.gif" alt="fullscreen"></li>
<li>手淘 IOS 扫码：<br><img src="https://img.alicdn.com/tps/TB1bu2KJVXXXXcfXXXXXXXXXXXX-181-178.jpg" alt=""><ul>
<li><code>方案3</code>。在 UC HAC 方案视频提供全屏接口 UCSettings.setVideoViewFullscreenByDefault（true），开启后，视频全屏默认为横屏  </li>
</ul>
</li>
<li><strong>自动播放</strong><ul>
<li>出于用户节省用户流量考虑，iPhone 下播放视频需要用户手动触发，即使配置了 autoplay 属性也是无效的。在业务中，特定场景还是需要视频能够自动播放，对此我们可以监听页面的 touchstart 事件，做如下处理：</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.auoplay &amp;&amp; env.app.TB &amp;&amp; env.network.wifi) &#123;</span><br><span class="line"><span class="keyword">if</span> (player.getCurrentTime() &gt; <span class="number">0</span> &amp;&amp; !player.isPause()) &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.hasAutoPlay) &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.hasAutoPlay = <span class="literal">true</span>;</span><br><span class="line">startEl.trigger(<span class="string">'click'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">autoplay</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    doc.detach(<span class="string">'touchstart'</span>, autoplay);</span><br><span class="line">    <span class="keyword">if</span> (player.getCurrentTime() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  startEl.trigger(<span class="string">'click'</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> doc.on(<span class="string">'touchstart'</span>, autoplay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>其他<ul>
<li>部分机型手淘低版本使用 video 播放时，会出现有声音没画面的问题，升级手淘后即恢复。例如，小米4 手淘 4.2.0</li>
<li>IOS 5.1 和部分 android 手机暂停和开始按钮不触发点击事件(元素的 :after 为iconfont)。通过父元素添加background即可</li>
<li>Android UC 内核的播放器，在未设置 source 资源时，设置 poster 无效</li>
<li>Android UC 内核的播放器无法自定义控件和样式操作，但是可以正常的监听事件。</li>
<li>直接替换 source 不会改变当前正在播放的视频，需要调用 load 方法。</li>
<li>UC 浏览器中 video 标签会被 UC 的播放器插件替换</li>
<li>使用 m3u8 和 mp4 基本可以兼容所有机型 </li>
<li>在 IOS 视频初始化后设置 currrentTime 无效，在 loadedmetadata 事件触发后，设置 currentTime 即可。</li>
</ul>
</li>
</ul>
<h3 id="native播放器"><a href="#native播放器" class="headerlink" title="native播放器"></a>native播放器</h3><ul>
<li><p>destroy：</p>
<ul>
<li>Glue：Glue native 播放器在页面跳转，WebView 后退等操作时，不会自动析构，好的情况是视频依然在背后播放，有时候会直接导致手淘 crash。</li>
<li><p>PlayBuddy：在页面跳转时依然会继续播放</p>
<p>处理方式：页面跳转时需要手动的销毁native播放器。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'WV.Event.Page.Refresh'</span>, $.proxy(<span class="keyword">this</span>.destory, <span class="keyword">this</span>), <span class="literal">false</span>);</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'WV.Event.Key.Back'</span>, $.proxy(<span class="keyword">this</span>.destory, <span class="keyword">this</span>), <span class="literal">false</span>);</span><br><span class="line">win.on(<span class="string">'unload'</span>, $.proxy(<span class="keyword">this</span>.destory, <span class="keyword">this</span>));</span><br><span class="line">win.on(<span class="string">'beforeunload'</span>, $.proxy(<span class="keyword">this</span>.destory, <span class="keyword">this</span>));</span><br></pre></td></tr></table></figure>
<ul>
<li>定位<ul>
<li>Glue 播放器使用 dip 作为播放器的定位单位，rem 布局会对页面进行缩放，导致定位位置和视频大小错误。同时定位时参数有小数点会导致播放器错误。</li>
</ul>
</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/__</span><br><span class="line"> * 返回值需要是整数，否则会有异常</span><br><span class="line"> */</span><br><span class="line">_getVedioPos(isDpr) &#123;</span><br><span class="line">    var el = this.el,</span><br><span class="line">        offset = el.offset(),</span><br><span class="line">        dpr = 1;</span><br><span class="line"></span><br><span class="line">    if (isDpr) &#123;</span><br><span class="line">        dpr = this._getDpr();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">        x: parseInt(offset.left / dpr),</span><br><span class="line">        y: parseInt(offset.top / dpr),</span><br><span class="line">        w: parseInt(el.width() / dpr),</span><br><span class="line">        h: parseInt(el.height() / dpr)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>视频源地址：Glue 播放器不支持以 // 开始的视频资源，例如 //video.xxx</li>
<li>PlayBuddy 播放器不会随着页面滚动而滚动。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>如果业务中需要在手淘中播放视频，IOS 直接使用原生 video 即可。在 Android 中较为复杂，没有完全兼容的方案。建议使用 video，对于 Android 低版本建议使用native 播放器。随着uc内核接入，未来完全抛弃 native 方案也是可行的。</li>
<li>本文基于过去一年在手淘视频播放过程中遇到问题的小结，后续会整理视频监控和视频娱乐化相关内容。</li>
</ul>
<h2 id="附：手淘同学播放器兼容性表"><a href="#附：手淘同学播放器兼容性表" class="headerlink" title="附：手淘同学播放器兼容性表"></a>附：手淘同学播放器兼容性表</h2><table>
<thead>
<tr>
<th>品牌</th>
<th>机型</th>
<th>手淘版本</th>
<th>操作系统版本</th>
<th>播放器控件</th>
<th>视频列表切换</th>
<th>试看控制</th>
<th>观看进度同步</th>
<th>切换模式</th>
<th>问题</th>
</tr>
</thead>
<tbody>
<tr>
<td>苹果</td>
<td>6 plus</td>
<td>5.2.7</td>
<td>8.11</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>*</td>
</tr>
<tr>
<td>苹果</td>
<td>6</td>
<td>5.2.7</td>
<td>8.11</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>*</td>
</tr>
<tr>
<td>苹果</td>
<td>5s</td>
<td>5.2.7</td>
<td>8.11</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>*</td>
</tr>
<tr>
<td>苹果</td>
<td>5</td>
<td>5.2.7</td>
<td>8.11</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>*</td>
</tr>
<tr>
<td>苹果</td>
<td>4s</td>
<td>5.2.7</td>
<td>8.11</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>*</td>
</tr>
<tr>
<td>苹果</td>
<td>4</td>
<td>*</td>
<td>*</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>*</td>
</tr>
<tr>
<td>google</td>
<td>nexus 5</td>
<td>*</td>
<td>yun os 3</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>*</td>
</tr>
<tr>
<td>google</td>
<td>nexus 5</td>
<td>*</td>
<td>安卓 5</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>*</td>
</tr>
<tr>
<td>三星</td>
<td>N7100</td>
<td>4.9</td>
<td>*</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>*</td>
</tr>
<tr>
<td>三星</td>
<td>NOTE4</td>
<td>4.9</td>
<td>*</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>模式二点最大化crash</td>
</tr>
<tr>
<td>三星</td>
<td>NOTE3</td>
<td>4.9</td>
<td>*</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>*</td>
</tr>
<tr>
<td>三星</td>
<td>S4</td>
<td>5.2.7.3</td>
<td>*</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>模式二，播放有问题 </td>
</tr>
<tr>
<td>三星</td>
<td>I9300</td>
<td>4.3</td>
<td>*</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>*</td>
</tr>
<tr>
<td>三星</td>
<td>S3</td>
<td>5.2.8.2</td>
<td>*</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>*</td>
</tr>
<tr>
<td>三星</td>
<td>S5</td>
<td>5.2.7.3</td>
<td>*</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>*</td>
</tr>
<tr>
<td>魅族</td>
<td>MX2</td>
<td>*</td>
<td>*</td>
<td>√</td>
<td>*</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>*</td>
</tr>
<tr>
<td>魅族</td>
<td>MX4 PRO</td>
<td>*</td>
<td>*</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>*</td>
</tr>
<tr>
<td>魅族</td>
<td>魅蓝Note</td>
<td>*</td>
<td>*</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>*</td>
</tr>
<tr>
<td>魅族</td>
<td>MX3（安装不上）</td>
<td>*</td>
<td>*</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>*</td>
</tr>
<tr>
<td>华为</td>
<td>荣耀6</td>
<td>*</td>
<td>*</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>模式二可能播放不了</td>
</tr>
<tr>
<td>华为</td>
<td>mate7</td>
<td>*</td>
<td>*</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>模式二可能播放不了 </td>
</tr>
<tr>
<td>华为</td>
<td>c8816</td>
<td>*</td>
<td>*</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>进度条拖动会跳</td>
</tr>
<tr>
<td>华为</td>
<td>荣耀3c</td>
<td>*</td>
<td>4.4.2</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×一直展示loading的图片</td>
<td>模式二播放不了</td>
</tr>
<tr>
<td>华为</td>
<td>C8813</td>
<td>*</td>
<td>4.1.1</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>高清视频不能播放</td>
</tr>
<tr>
<td>HTC</td>
<td>MAX</td>
<td>*</td>
<td>*</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>*</td>
<td>*</td>
</tr>
<tr>
<td>HTC</td>
<td>816w</td>
<td>*</td>
<td>*</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>*</td>
</tr>
<tr>
<td>VIVO</td>
<td>Find5</td>
<td>*</td>
<td>4.1.1</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>*</td>
</tr>
<tr>
<td>VIVO</td>
<td>X3</td>
<td>*</td>
<td>4.2.2</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>*</td>
</tr>
<tr>
<td>小米</td>
<td>2S</td>
<td>*</td>
<td>4.3</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>*</td>
<td>高清的播放不了</td>
</tr>
<tr>
<td>小米</td>
<td>3</td>
<td>*</td>
<td>*</td>
<td>*</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>*</td>
<td>*</td>
</tr>
<tr>
<td>小米</td>
<td>4</td>
<td>*</td>
<td>4.4.4</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>*</td>
<td>*</td>
</tr>
<tr>
<td>索尼</td>
<td>M512</td>
<td>*</td>
<td>4.4.2</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>*</td>
</tr>
<tr>
<td>索尼</td>
<td>xperia 36l</td>
<td>*</td>
<td>4.1.2</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>*</td>
<td>*</td>
</tr>
<tr>
<td>nubia</td>
<td>nx403</td>
<td>*</td>
<td>4.2.2</td>
<td>√</td>
<td>×</td>
<td>√</td>
<td>√</td>
<td>*</td>
<td>模式一，模式二播放均有问题</td>
</tr>
<tr>
<td>锤子</td>
<td>*</td>
<td>*</td>
<td>*</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>*</td>
<td></td>
</tr>
<tr>
<td>oppo</td>
<td>x907</td>
<td>*</td>
<td>4.0.3</td>
<td>很难点到</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>*</td>
</tr>
<tr>
<td>nexus5</td>
<td>*</td>
<td>*</td>
<td>*</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>第二种模式crash</td>
</tr>
</tbody>
</table>
<p>注：模式1为video，模式2为glue native播放器</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="//img.alicdn.com/tfs/TB1YyshJVXXXXaEXVXXXXXXXXXX-900-500.jpg" alt="视频播放的那些事"></p>
<ul>
<li>视频作为淘宝教育业务的基础服务，本文根据自身在手淘中视频播放的实践，谈谈]]>
    </summary>
    
      <category term="视频" scheme="http://taobaofed.org/tags/%E8%A7%86%E9%A2%91/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[无线端的弹幕实现方案]]></title>
    <link href="http://taobaofed.org/blog/2016/05/13/barrage-in-mobile/"/>
    <id>http://taobaofed.org/blog/2016/05/13/barrage-in-mobile/</id>
    <published>2016-05-13T07:59:50.000Z</published>
    <updated>2016-07-22T05:20:24.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img.alicdn.com/tfs/TB1zithJVXXXXabXVXXXXXXXXXX-900-500.jpg" alt="无线端的弹幕实现方案"></p>
<p>前段时间做了游戏的相关业务，其中弹幕相关的内容自成一块。弹幕已经不只是最初的视频弹幕了，战火已经烧到了评论区，烧到了手机淘宝的首页搜索结果。作为一种近几年迅速燃起的内容呈现形式，有必要适时引入，对于休闲化、娱乐化的业务更是如此。那么，要做出一个较为完整的弹幕效果来，需要哪几个部分呢？尤其是，在集团内部，怎么快速地搭建起一个可用的弹幕框架来？本文分3块来阐述。</p>
<ol>
<li><a href="#client_rendering_module">弹幕渲染层</a></li>
<li><a href="#data_pipeline_module">弹幕数据通道</a></li>
<li><a href="#server_business_module">弹幕服务逻辑</a></li>
</ol>
<h2 id="弹幕渲染层"><a href="#弹幕渲染层" class="headerlink" title="弹幕渲染层"></a><a name="client_rendering_module"></a>弹幕渲染层</h2><p>目前弹幕的呈现载体主要是Web、无线客户端。因为我们的工作主要针对无线端，所以本文主要以无线端为例——包括iOS，Android两类系统。</p>
<h4 id="碰撞检测"><a href="#碰撞检测" class="headerlink" title="碰撞检测"></a>碰撞检测</h4><p>弹幕无非是动画，是分布在时间轴上图像的连续运动。自然可以用Native的动画来实现。不过弹幕动画有一个重要的特征，即保持动画元素(sprites)尽可能少地碰撞，以使弹幕承载的信息能够清晰地传达，执行碰撞检测是必须的。但弹幕里的碰撞检测相对简单，因为弹幕的运动轨迹相对简单并且容易预测，所以只需要在一条弹幕将要显示之前，根据已经显示的弹幕(位置、速度、活跃的时间等)来确定他的运动轨迹。以尽最大可能地在其生命周期内不与已有弹幕冲突。</p>
<p><img src="http://img.alicdn.com/tfs/TB1tSxyJVXXXXarXpXXXXXXXXXX-900-507.png" alt="弹幕碰撞检测范例"></p>
<h4 id="弹幕的同步问题"><a href="#弹幕的同步问题" class="headerlink" title="弹幕的同步问题"></a>弹幕的同步问题</h4><p>弹幕不是超然而独立的，往往相伴业务场景而生，目前可见最多的场景是视频，直播或者录播皆有。到此时则涉及到一个时间同步的问题。比如，一位用户在看一段时间第314s的时候突然有感而发，发出了一条弹幕，自然希望其他观众能够在看到视频此刻看到他的弹幕。所以一条弹幕上屏的时间是需要明确的，想想那些年文不对题的字幕君吧。那么，如何实现呢？一般，可以为一条弹幕提供一个时间点delay，当到了这个时刻，由控制器把这条弹幕播放出去。但仅仅这些是不够的，因为视频还存在暂停，存在快进快退，所以你必须也为弹幕组件提供类似的接口，以期能和视频内容同步。其他的应用场景也是类似的。比如下面的样子(弹幕在向左运动)：</p>
<h4 id="弹幕的样式"><a href="#弹幕的样式" class="headerlink" title="弹幕的样式"></a>弹幕的样式</h4><p>弹幕的运动样式主要有两种，一种是横向的过场弹幕，一种是纵向的浮动弹幕。弹幕的内容形式不外乎一段文字或者图片，其中以文字为主。对于文字，则有文字的颜色、背景、字体、边框等属性，这一切必须是灵活可配的。当然实际应用中一个APP需要的是风格统一的、优雅美观的弹幕动画。所以弹幕的方向不要太混乱，不要有太多不一样的主题配置。你可以定义几类色调协调但样式不同的弹幕，然后由业务代码决定使用哪一种风格的弹幕。</p>
<h4 id="渲染效率"><a href="#渲染效率" class="headerlink" title="渲染效率"></a>渲染效率</h4><p>性能直接关系到用户体验。在绝大多数场景中，锦上添花的弹幕往往伴随着具体的业务逻辑，业务逻辑会占用CPU——甚至很高的CPU，比如视频解码———所以弹幕动画应该尽可能地使用GPU渲染。为应对线上可能的大规模弹幕的情况，本地最好也能测试到大量弹幕的情况。可以使用一个定时器，模拟客户端频繁接受渲染弹幕的情况，看看实际中弹幕的性能究竟如何。</p>
<h4 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h4><p>弹幕稀稀疏疏地铺满半屏窗口，朦胧中犹抱琵琶半遮面的感觉，自然是最好的。但万一遇到弹幕决堤，内容疯狂涌来，那当如何应对？渲染内容层层堆叠，既看不清，又降低了系统应用性能，为此可以在业务或者组件中选择限流。</p>
<h2 id="弹幕数据层"><a href="#弹幕数据层" class="headerlink" title="弹幕数据层"></a><a name="data_pipeline_module"></a>弹幕数据层</h2><p>若不考虑弹幕在用户间共享，只需下图左侧的模块即可；若需引入弹幕共享、存储功能，则如下图右侧所示。</p>
<p><img src="http://img.alicdn.com/tfs/TB1omxtJVXXXXcAXpXXXXXXXXXX-616-236.png" alt="简要结构图"></p>
<p>但实际情况往往比这复杂。弹幕很多时候是实时的，最好使用长连接来传输数据。业务导向的项目，很少从零开始开发专门的弹幕服务通道，而是尽可能地应用已有的服务组件。淘宝在长连通道上有多个选择，但其功能又是不尽相同的。这种不同也会带来弹幕实现方案的不同。比如通道A支持订阅功能，消息会根据订阅关系分发；而通道B是单纯的通道，订阅关系由业务方维护，凡是发送到客户端的消息都会接收，所以流量需要业务服务端来控制。</p>
<h4 id="经过服务端的必要性"><a href="#经过服务端的必要性" class="headerlink" title="经过服务端的必要性"></a>经过服务端的必要性</h4><p>仅仅使用长连接通道是不够的，还需引入业务服务器，其原因如下：</p>
<ul>
<li>如果长连通道不支持客户端发送消息，那么弹幕的发送要走其它的接口</li>
<li>因业务原因，需要统一多个长连接通道，以便更好地做 多端同步，故引入中间服务器做协调</li>
<li>一些业务相关的需求，不适合在长连接服务器上做，比如内容过滤、弹幕存储、服务端限流等</li>
</ul>
<p>整体的数据流如下图所示：</p>
<p><img src="http://img.alicdn.com/tfs/TB1PEVtJVXXXXcHXpXXXXXXXXXX-920-335.png" alt="详细结构图"></p>
<h4 id="消息格式制定"><a href="#消息格式制定" class="headerlink" title="消息格式制定"></a>消息格式制定</h4><p>通过长连接传输的弹幕消息会有一些附加数据需要考虑，比如弹幕的样式、出现的时间，随着业务的扩展，可能需要更多的辅助字段。所以弹幕消息必须能够向后兼容，一般可设置为message，version两个字段，message为纯粹的json字符串，version表示消息的版本号。先解析version，根据判断得到的version选择响应的解析样式。太多的附加信息会降低数据的利用率，此是需要权衡的地方。当然，如果针对的是在线视频业务，弹幕的流量相比于视频流而言，就显得不那么重要了。</p>
<h4 id="自发的弹幕消息"><a href="#自发的弹幕消息" class="headerlink" title="自发的弹幕消息"></a>自发的弹幕消息</h4><p>主要有两种：</p>
<ol>
<li>用户发送了弹幕消息后，通过网络发送消息的同时直接将弹幕数据上屏，以提升用户所见即所得的体验；当收到相同的弹幕消息后，将消息抛弃。</li>
<li>用户发送了弹幕消息后，通过正常的网络接收消息然后渲染呈现，这样会因延时损失一定的用户体验，但逻辑简单，并且可以控制所有弹幕数据。</li>
</ol>
<h2 id="弹幕服务层"><a href="#弹幕服务层" class="headerlink" title="弹幕服务层"></a><a name="server_business_module"></a>弹幕服务层</h2><h4 id="主题维护"><a href="#主题维护" class="headerlink" title="主题维护"></a>主题维护</h4><p>主题代表弹幕消息围绕的中心。在不同的业务场景中，主题的呈现方式可能是不同的。在视频直播业务中，主题代表了一个个直播房间，弹幕围绕着视频展开；在新闻咨询业务中，主题代表了一则则新闻，弹幕围绕着新闻展开。客户端与主题存在多对一的关系，如下图所示：</p>
<p><img src="http://img.alicdn.com/tfs/TB1sVg7JFXXXXcraXXXXXXXXXXX-984-284.png" alt="主题房间维护"></p>
<p>用户U1、U2订阅了主题T1，用户U3、U4订阅了主题T2。由于处于不同的语境中，U1、U2发送的弹幕U3、U4应该是不能接收到的，反之亦然。很自然服务端需要维护一个用户到主题的映射表简单的实现是，客户端监测到用户进入特定主题之后，发送一条网络请求登记这样一条订阅；用户离开特定主题时发送网络请求注销登记。但由于实际客户端运行场景复杂，离开特定主题不一定来得及发送网络请求。补充方案是，由客户端每隔特定时间心跳一次，用以告知服务端维护映射表。一旦服务端一段时间没有监听到心跳信息，就取消映射表中的一条订阅。这里需要注意的是，服务端需要防止心跳的伪造，否则可能映射表可能会因攻击而混乱掉。一旦映射表正确建立，用户发送的弹幕消息就可以准确传达到相同主题的用户客户端了。</p>
<h4 id="弹幕存储"><a href="#弹幕存储" class="headerlink" title="弹幕存储"></a>弹幕存储</h4><p>对于直播等即时性业务，弹幕数据一般没有重播的必要；但是对于录播，则需要持久化弹幕，如是方能在其他用户看视频的时候看到其他人发出过的弹幕消息。持久化这类弹幕数据，必须在存储弹幕的时候带上弹幕对应的时间点。在用户进入了某一主题之后，批量返回给客户端对应的弹幕数据，由客户端将弹幕数据对应到视频业务响应的时间点上；如果此主题对应的弹幕数据很多，服务端可能实现做一定的筛选；对于录播同时新发送的弹幕，则由服务端记录并添加到对应的弹幕数据列表中。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img.alicdn.com/tfs/TB1zithJVXXXXabXVXXXXXXXXXX-900-500.jpg" alt="无线端的弹幕实现方案"></p>
<p>前段时间做了游戏的相关业务，其中弹幕相关的内容自成一块。弹幕已经不只是]]>
    </summary>
    
      <category term="无线" scheme="http://taobaofed.org/tags/%E6%97%A0%E7%BA%BF/"/>
    
      <category term="弹幕" scheme="http://taobaofed.org/tags/%E5%BC%B9%E5%B9%95/"/>
    
      <category term="无线开发" scheme="http://taobaofed.org/categories/%E6%97%A0%E7%BA%BF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android 新一代编译 toolchain Jack & Jill 简介]]></title>
    <link href="http://taobaofed.org/blog/2016/05/05/new-compiler-for-android/"/>
    <id>http://taobaofed.org/blog/2016/05/05/new-compiler-for-android/</id>
    <published>2016-05-05T07:03:37.000Z</published>
    <updated>2016-07-22T05:20:24.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img.alicdn.com/tfs/TB1brqAJFXXXXaGXVXXXXXXXXXX-900-500.jpg" alt="Android 新一代编译 toolchain Jack &amp; Jill 简介"></p>
<p>2016 年 3 月 10 日， Google 向外界发布了 Android N 的预览版，并宣布了 Android N 的 <a href="https://developer.android.com/intl/zh-cn/preview/overview.html" target="_blank" rel="external">Roadmap</a>，Android N 的最终版源代码将于今年 8 或 9 月份释出到 AOSP 项目。</p>
<p>在众多的 Android N 新特性中，有一项新工具链的出现与 Android 生态圈的所有开发者息息相关，即 Jack &amp; Jill 编译器的引入。</p>
<p>在依赖了 Sun/Oracle 的 Java 编译器十年之后，Android 终于有了自己的 Java 编译器。</p>
<p>本文试图对市面上非常有限的资料进行总结，向大家介绍 Jack &amp; Jill 的缘起，工作方式和原理。</p>
<p>Jack 是 Java Android Compiler Kit 的缩写，它可以将 Java 代码直接编译为 Dalvik 字节码，并负责 Minification, Obfuscation, Repackaging, Multidexing, Incremental compilation。它试图取代 javac/dx/proguard/jarjar/multidex 库等工具。</p>
<ul>
<li>git 源代码地址是 <a href="https://android.googlesource.com/toolchain/jack" target="_blank" rel="external">https://android.googlesource.com/toolchain/jack</a>。</li>
</ul>
<p>Jill 是 Jack Intermediate Library Linker 的缩写，它负责 “Shielding JACK from Java byte code”；实际上辅助 Jack 对.class 做预处理，生成 <code>.jack</code> 文件</p>
<ul>
<li>git 源代码地址是 <a href="https://android.googlesource.com/toolchain/jill" target="_blank" rel="external">https://android.googlesource.com/toolchain/jill</a>。</li>
</ul>
<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>虽然 Google 是在宣布 Android N 预览版时隆重介绍了Jack &amp; Jill。但是，早在 2014 年 Google 就对外宣布了新编译器 Jack 的存在 <a href="http://android-developers.blogspot.jp/2014/12/hello-world-meet-our-new-experimental.html?utm_source=feedburner&amp;utm_medium=feed&amp;utm_campaign=Feed:+blogspot/hsDu+\(Android+Developers+Blog" target="_blank" rel="external">meet our new experimental toolchain</a>, 它的开发启动时间更是远远早于 2014 年。</p>
<p>下面是我总结的 Jack 的缘起</p>
<ul>
<li>一家名叫 FlexyCore 的小公司基于 GCC toolchain 开发了 Android 平台上的 AOT 编译器，被 Google 看中并于 2013 年被收购</li>
<li>FlexyCore team 基于 LLVM toolchain 开发了 ART，并成为 Android 5.0 之后的缺省 Java Runtime</li>
<li>FlexyCore team 基于 Eclipse ecj 编译器开始开发 Jack，基于 ASM4 开发 Jill。 他们早在 2014 年 2 月就开始提交 Jill 的代码了 <a href="https://android.googlesource.com/toolchain/jill/+/e991948d20515a04e46524dbe1bf17222e872889" target="_blank" rel="external">Jill initial commit</a>； 3 月份开始提交 Jack的代码 <a href="https://android.googlesource.com/toolchain/jack/+/4eceb95409e844fdc33c9c706e1dc307bfd40303" target="_blank" rel="external">Jack initial commit</a></li>
<li>自 Android build-tools 21.1 开始，里面已经内置 jack.jar 和 jill.jar</li>
<li>Android Gradle plugin 自 0.14 开始支持 Jack &amp; Jill <a href="https://android.googlesource.com/platform/tools/base/+/3bdd23d7583603ea0839d49c25d56bff83115533" target="_blank" rel="external">initial commit</a></li>
<li>自 Android 6.0 开始，Jack &amp; Jill 成为 AOSP 的官方编译器, 也就是说所有的 Android 6.0 ROM 都是 Jack 编译出来的 <a href="https://source.android.com/source/jack.html" target="_blank" rel="external">link</a>，也代表 Google 认为 Jack 达到了一定的成熟度</li>
<li>预计等 Android 7.0 正式发布时，Jack 可能会成为官方推荐的编译器</li>
</ul>
<h3 id="为什么要抛弃-Javac-dx-开发-Jack-和-Jill"><a href="#为什么要抛弃-Javac-dx-开发-Jack-和-Jill" class="headerlink" title="为什么要抛弃 Javac/dx,开发 Jack 和 Jill"></a>为什么要抛弃 Javac/dx,开发 Jack 和 Jill</h3><p>据个人推测主要有三个目的</p>
<ul>
<li>提高编译速度</li>
<li>应对 Oracle 的法律诉讼 </li>
<li>将编译器掌控权拿在自己手中，不再受制于 Oracle，可以做一些 Android only 的优化</li>
</ul>
<p>下面比较一下旧的 javac/dx/ProGuard/jarjar toolchain 和新的 Jack 编译器的工作流程</p>
<h2 id="旧编译流程"><a href="#旧编译流程" class="headerlink" title="旧编译流程"></a>旧编译流程</h2><p>简单的说，将 Java 代码和依赖库编译为 dex 有两个大的阶段</p>
<blockquote>
<p>javac (.java –&gt; .class) –&gt; dx (.class –&gt; .dex)</p>
</blockquote>
<p>下面是用流程图表示的旧编译过程</p>
<p><img src="http://img.alicdn.com/tfs/TB10AmzJFXXXXaDXVXXXXXXXXXX-672-307.png" alt="dx"></p>
<ol>
<li>javac 将 java 代码编译为 java bytecode, 以 <code>.class</code> 的形式存在; 以 jar 和 aar 形式存在的依赖库，代码在里面以一堆.class 的形式存在</li>
<li>Proguard 工具读取 Proguard 配置，对 <code>.class</code> 做 shrinking, obfuscation，输出 Proguard mapping</li>
<li>dx 将多个 <code>.class</code> 转化为单一的 classes.dex ; 如果 dex 方法数超过 65k, 就生成 classes.dex, classes1.dex…classesN.dex</li>
</ol>
<h2 id="新编译流程"><a href="#新编译流程" class="headerlink" title="新编译流程"></a>新编译流程</h2><p>新的编译过程只有一个阶段了，它完全抛弃了 javac, ProGuard, jarjar 等工具，一个工具搞定一切</p>
<blockquote>
<p>Jack (.java –&gt; .jack –&gt; .dex)</p>
</blockquote>
<p>下面是用流程图表示的 Jill 预处理过程</p>
<p><img src="http://img.alicdn.com/tfs/TB1zUGAJFXXXXX8XVXXXXXXXXXX-943-396.png" alt="jill"></p>
<p>下面是用流程图表示的 Jack 编译过程</p>
<p><img src="http://img.alicdn.com/tfs/TB1p_53JFXXXXaiXXXXXXXXXXXX-676-617.png" alt="jack"></p>
<ol>
<li>各种依赖库仍然以 jar/aar 的形式存在</li>
<li>辅助工具 Jill 将根据依赖库中的 <code>.class</code> 生成 Jayce 格式的 IL，并调用 Jack 做 pre-dex 并生成 <code>.jack</code>，此过程只在编译 app 时发生一次</li>
<li>Jack 将 java 源代码也编译为 <code>.jack</code>，然后将多个 <code>.jack</code> 转化为单一的 <code>.dex</code>; 如果 dex 方法数超过 65k, 就生成 classes.dex, classes1.dex…classesN.dex</li>
</ol>
<p>pre-dex 的详细解释可以参阅此链接 <a href="https://sites.google.com/a/android.com/tools/tech-docs/new-build-system/tips" target="_blank" rel="external">new-build-system</a></p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Improving Build Server performance.</span><br><span class="line">The Gradle based build system has a strong focus <span class="keyword">on</span> incremental builds. One way <span class="keyword">it</span> <span class="keyword">is</span> doing this <span class="keyword">in</span> doing pre-dexing <span class="keyword">on</span> <span class="keyword">the</span> dependencies <span class="keyword">of</span> each modules, so <span class="keyword">that</span> each gets turned <span class="keyword">into</span> <span class="keyword">its</span> own dex <span class="built_in">file</span> (ie converting <span class="keyword">its</span> Java bytecode <span class="keyword">into</span> Android bytecode). This allows <span class="keyword">the</span> dex task <span class="keyword">to</span> do less work <span class="keyword">and</span> <span class="keyword">to</span> only re-dex what changed <span class="keyword">and</span> merge all <span class="keyword">the</span> dex files.</span><br></pre></td></tr></table></figure>
<h3 id="Jack中间文件"><a href="#Jack中间文件" class="headerlink" title=".Jack中间文件"></a>.Jack中间文件</h3><p><code>.Jack</code> 的具体格式如下图所示</p>
<p><img src="http://img.alicdn.com/tfs/TB1a91AJFXXXXXXXVXXXXXXXXXX-1000-539.png" alt=".jack"></p>
<p>可见里面包含了 Jayce 格式的 IL ，pre-dex，原始 aar 中的资源文件，以及 Jack 会用到的一些 meta 信息</p>
<p>下图简单比较了 java 代码转化的 <code>.class</code>, Jayce IL 和 dex 的内容异同</p>
<p><img src="http://img.alicdn.com/tfs/TB1XqKBJFXXXXacXVXXXXXXXXXX-1041-611.png" alt="compare"></p>
<p>简单比较下三种 IL 的区别：</p>
<p>Sun/Oracle Hotspot VM 是基于栈式的，所以 <code>.class</code> 文件的内容就是不断地压操作数到栈顶，从栈顶读取操作数，比较或做运算，将结果再压回栈顶</p>
<p>Dalvik VM 是基于寄存器的，所以 <code>.dex</code> 的内容就是不断地 move 操作数到寄存器，比较或做运算，将结果写回寄存器或内存地址</p>
<p>Jayce 则是 Jack&amp;Jill 专有的 IL, 目前没有查阅到更多的官方资料。只能参阅 Jill 源代码中 com.android.jill.backend.jayce 包的代码了，比如其中的 Token 类就定义了 Jayce 的 Token 定义。</p>
<p>个人推测 Jayce 存在的意义是:</p>
<ul>
<li>为了在整合多个 jack 文件，生成单一的 dex 时，方便 Jack 做一些全局性的后端编译优化。</li>
<li>从 Android 生态圈中完全去除 Oracle 的 Java Bytecode 格式</li>
</ul>
<h3 id="使用Jack编译器的优势"><a href="#使用Jack编译器的优势" class="headerlink" title="使用Jack编译器的优势"></a>使用Jack编译器的优势</h3><ul>
<li>对依赖库做 pre dex，且成果会被保存到 build/intermediates/jill/debug 目录。</li>
</ul>
<p>之后的编译过程中，只要依赖库的数目和版本不变，之前的 pre dex 成果会被复用；Jack 只需要编译变化的源代码，然后对多个 dex 进行 merge 即可，能够加速整个编译过程。</p>
<ul>
<li>编译时会启动一个 Jack compilation server，并开启并行编译</li>
</ul>
<p>Jack 文档是这么介绍的</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This server brings <span class="keyword">an</span> intrinsic speedup, because <span class="keyword">it</span> avoids launching <span class="keyword">a</span> <span class="built_in">new</span> host JRE JVM, loading Jack code, initializing Jack <span class="keyword">and</span> warming up <span class="keyword">the</span> JIT <span class="keyword">at</span> <span class="keyword">each</span> compilation. It also provides very good compilation times during small compilations (e.g. <span class="keyword">in</span> incremental mode).</span><br><span class="line">The server is also <span class="keyword">a</span> <span class="keyword">short</span>-term solution <span class="built_in">to</span> control <span class="keyword">the</span> <span class="built_in">number</span> <span class="keyword">of</span> parallel Jack compilations, <span class="keyword">and</span> so <span class="built_in">to</span> avoid overloading your computer (memory <span class="keyword">or</span> disk issue), because <span class="keyword">it</span> limits <span class="keyword">the</span> <span class="built_in">number</span> <span class="keyword">of</span> parallel compilations.</span><br></pre></td></tr></table></figure>
<ul>
<li>支持 Java 8 的一部分特性</li>
<li>Jack 由 Google 完全掌控，未来可能成为 Android sdk 的默认编译器</li>
<li>向后兼容到 Android 2.3</li>
</ul>
<h3 id="采用-Jack-对打包流程的影响"><a href="#采用-Jack-对打包流程的影响" class="headerlink" title="采用 Jack 对打包流程的影响"></a>采用 Jack 对打包流程的影响</h3><ol>
<li>不再需要独立的 ProGuard。Jack 支持读取旧的 ProGuard 配置，完成 shrinking, obfuscation 的工作</li>
<li>不再需要独立的 jarjar。Jack 支持读取旧的 jarjar 配置，完成 repackaging 的工作</li>
<li>没有 <code>.class</code> 文件了，直接操纵或读取 Java 字节码的各种工具如 JaCoCo/Lint/Mokito/Retrolambda 没有了用武之地。但是仍然可以在 Android Library 上使用这些工具，编译为 aar/jar 后作为 Jill 的输入</li>
<li>annotation processors 如 Dagger, ButterKife 仍可以使用</li>
<li>Scala/Kotlin 等第三方 JVM 语言编写的内容必须先被 Jill 处理，再作为 Jack 的输入</li>
</ol>
<h3 id="Jack-当前的局限-截止到2016-03-15"><a href="#Jack-当前的局限-截止到2016-03-15" class="headerlink" title="Jack 当前的局限(截止到2016/03/15)"></a>Jack 当前的局限(截止到2016/03/15)</h3><ol>
<li>暂时还不支持 Android Studio 2.0 的 Instant Run 特性</li>
<li>暂时还不支持 data binding</li>
</ol>
<h2 id="65k-方法数目问题"><a href="#65k-方法数目问题" class="headerlink" title="65k 方法数目问题"></a>65k 方法数目问题</h2><h3 id="为什么会有-65k-问题"><a href="#为什么会有-65k-问题" class="headerlink" title="为什么会有 65k 问题?"></a>为什么会有 65k 问题?</h3><p>当你的 app 足够复杂之后，在打包时常常会遇到这种错误提示</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unable to execute dex: method ID not in [0, 0xffff]: 65536</span><br></pre></td></tr></table></figure>
<p>为什么方法数目不能超过 65k 呢？有人说是 dexopt 的问题，有人说是 dex 格式的限制，下面我们看看这个 log 到底是哪里吐出来的，然后分析下具体原因。</p>
<ul>
<li>dex 格式的限制？</li>
</ul>
<p>首先我们看一下 dex 的结构定义</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Direct-mapped "header_item" struct.</span></span><br><span class="line"><span class="keyword">struct</span> DexHeader &#123;</span><br><span class="line">	...</span><br><span class="line">  u4  methodIdsSize;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//These match the definitions in the VM specification.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span>            u4;</span><br></pre></td></tr></table></figure>
<p>可见 dex 文件结构是用 32 位来存储 method id 的，最大支持 2 的 32 次方，因此 65k 的原因不在于此。</p>
<ul>
<li>dexopt 的原因?</li>
</ul>
<p>dexopt 是 app 已经打包成功，安装到手机之后才会发生的过程。但是 65k 问题是在打包时发生的，所以问题原因也不在此</p>
<p>一般提到的 dexopt 错误，其实是 Android 2.3 及其以下在 dexopt 执行时只分配 5M 内存，导致方法数目过多(数量不一定到 65k)时在 odex 过程中崩溃，官方称之为 Dalvik linearAlloc bug(Issue 22586) 。</p>
<p>另：这个 linearAlloc 的限制不仅存在于 dexopt 里，还在 dalvik rumtime 中存在……</p>
<p>以下链接详细解释了此问题：<a href="https://github.com/simpleton/dalvik_patch" target="_blank" rel="external">https://github.com/simpleton/dalvik_patch</a></p>
<ul>
<li>错误 log 是哪里吐出来的?</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MemberIdsSection.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (items().size() &gt; DexFormat.MAX_MEMBER_IDX + <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> DexIndexOverflowException(getTooManyMembersMessage());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line">Maximum addressable field or method index.</span><br><span class="line">The largest addressable member is 0xffff, in the "instruction formats" spec as field@CCCC or meth@CCCC.</span><br><span class="line">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_MEMBER_IDX = <span class="number">0xFFFF</span>;</span><br></pre></td></tr></table></figure>
<p>通过查阅 <a href="https://source.android.com/devices/tech/dalvik/dalvik-bytecode.html" target="_blank" rel="external">dalvik-bytecode</a> 可知，@CCCC 的范围必须在 0～65535 之间。</p>
<p>所以归根结底，65k 问题是因为 dalvik bytecode 中的指令格式使用了 16 位来放 @CCCC 导致的；所以，不仅 Method 数目不能超过 65k, Field 和 Class 数目也不能超过 65k。</p>
<h3 id="为什么-jack-没有-65k-问题"><a href="#为什么-jack-没有-65k-问题" class="headerlink" title="为什么 jack 没有 65k 问题"></a>为什么 jack 没有 65k 问题</h3><p>前文已经很清楚地解释了 65k 问题的由来，可见只要 dalvik bytecode 指令格式不升级，65k 问题是逃不掉的。</p>
<p>Jack 官网对 65k 问题是这么说的：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Multidex support</span><br><span class="line"></span><br><span class="line">Since dex <span class="built_in">files</span> are limited <span class="built_in">to</span> <span class="number">65</span>K methods, apps <span class="keyword">with</span> over <span class="number">65</span>K methods must be <span class="built_in">split</span> <span class="keyword">into</span> multiple dex <span class="built_in">files</span>. (See ‘Building Apps <span class="keyword">with</span> Over <span class="number">65</span>K Methods’ <span class="keyword">for</span> more information about multidex.)</span><br><span class="line"></span><br><span class="line">Jack offers native <span class="keyword">and</span> legacy multidex support.</span><br></pre></td></tr></table></figure>
<p>所以，Jack 和旧工具链对 multidex 的支持方式是相同的</p>
<p>被 Jack 编译出来的 app 执行时也和以前一样</p>
<ol>
<li>若是 dalvik 虚拟机，它只支持读取一个 classes.dex。而 multidex 解决方案会读取多个 <code>.dex</code>，帮我们做 dex 数组合并</li>
<li>若是 art 虚拟机，它会扫描 classes.dex, classes1.dex…classesN.dex，调用 dex2oat 转化为单一的 oat</li>
</ol>
<h2 id="Jack-是怎么支持-Java-8-的？"><a href="#Jack-是怎么支持-Java-8-的？" class="headerlink" title="Jack 是怎么支持 Java 8 的？"></a>Jack 是怎么支持 Java 8 的？</h2><p>以 lambda 表达式为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Interface lambda = i -&gt; i + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>会被转化为 anonymous classes</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Interface lambda = <span class="keyword">new</span> Interface() &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">m</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Jack当前支持的 Java 8 特性可参见 <a href="https://developer.android.com/intl/zh-cn/preview/j8-jack.html" target="_blank" rel="external">j8-jack</a>。</p>
<h2 id="如何在-Gradle-脚本中使用-Jack-编译器编译-app"><a href="#如何在-Gradle-脚本中使用-Jack-编译器编译-app" class="headerlink" title="如何在 Gradle 脚本中使用 Jack 编译器编译 app"></a>如何在 Gradle 脚本中使用 Jack 编译器编译 app</h2><p>想使用 Jack 和 Jill 需要指定你的 Build Tools version 是 21.1.0+, Gradle plugin version 是1.0.0+。</p>
<p>以下的配置是我个人测试通过的配置</p>
<ul>
<li>使用 Android Gradle 插件 2.1.0-alpha2<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  classpath <span class="string">'com.android.tools.build:gradle:2.1.0-alpha2'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>使用以下版本的 sdk 和 build-tool</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">compileSdkVersion <span class="string">'android-N'</span></span><br><span class="line">buildToolsVersion <span class="string">'24.0.0 rc1'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在 defaultConfig 中指定用 Jack</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">defaultConfig &#123;</span><br><span class="line">  jackOptions &#123;</span><br><span class="line">    enabled <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 gradle 2.10 以上</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">distributionUrl=http\<span class="symbol">://mirrors</span>.taobao.net/mirror/gradle/gradle-<span class="number">2.10</span>-bin.zip</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 Android Studio 2.1 (preview) 或者命令行编译</p>
</li>
<li><p>可能需要提升 javaMaxHeapSize</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dexOptions&#123;</span><br><span class="line">  javaMaxHeapSize <span class="string">"2g"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h2><p>经过测试，当前版本(2016/03/15)的 Jack 编译器比起 Javac+dx 在编译时间，编译出的 apk 体积，编译出的 apk 的性能上暂时并没有优势。</p>
<p>但是，可以期待 Google 将在 Jack 编译器上做大量的智力投资，Jack 的未来是光明的。</p>
<p>下图是 guardsquare 公司对 Javac+dx 和 Jack 做的对比测试</p>
<p><img src="http://img.alicdn.com/tfs/TB1odirJFXXXXaYaXXXXXXXXXXX-979-726.png" alt="buildtime"></p>
<p>对于不 proguard 的 clean build，javac/dx 耗时 56s， jack 耗时 1 m 48 s；之所以 jack 这么慢是因为它要做大量的 pre-dex。</p>
<p><img src="http://img.alicdn.com/tfs/TB1vV9LJFXXXXaXXFXXXXXXXXXX-946-673.png" alt="performance"></p>
<p>对于不 proguard 的 clean build，javac/dx 和 jack 编译出来的 app 性能相差无几。</p>
<p><img src="http://img.alicdn.com/tfs/TB1E3GnJFXXXXcmaXXXXXXXXXXX-956-640.png" alt="size"></p>
<p>对于共用 proguard 配置文件情况，javac/dx 和jack 编译出来的 app 体积也差不多。</p>
<p>我个人测试的编译速度 / apk 体积等对比也大致如此，在此不再赘述.</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>虽然 Jack 编译器的现状并不出彩，但是它终究有一天会成为 Android app 的官方推荐编译器。</p>
<p>期待 Google Android team 加倍努力，让这一天早日到来。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://www.guardsquare.com/blog/the_upcoming_jack_and_jill_compilers_in_android" target="_blank" rel="external">https://www.guardsquare.com/blog/the_upcoming_jack_and_jill_compilers_in_android</a></li>
<li><a href="http://source.android.com/devices/tech/dalvik/dex-format.html" target="_blank" rel="external">http://source.android.com/devices/tech/dalvik/dex-format.html</a></li>
<li><a href="http://tools.android.com/tech-docs/jackandjill" target="_blank" rel="external">http://tools.android.com/tech-docs/jackandjill</a></li>
<li><a href="https://developer.android.com/intl/zh-cn/tools/building/multidex.html" target="_blank" rel="external">https://developer.android.com/intl/zh-cn/tools/building/multidex.html</a></li>
<li><a href="https://www.guardsquare.com/blog/DroidconLondon2015" target="_blank" rel="external">https://www.guardsquare.com/blog/DroidconLondon2015</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img.alicdn.com/tfs/TB1brqAJFXXXXaGXVXXXXXXXXXX-900-500.jpg" alt="Android 新一代编译 toolchain Jack &amp; Jill 简介"></p>
<p>201]]>
    </summary>
    
      <category term="toolchain Jack&amp;Jill" scheme="http://taobaofed.org/tags/toolchain-Jack-Jill/"/>
    
      <category term="无线开发" scheme="http://taobaofed.org/categories/%E6%97%A0%E7%BA%BF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Promise 反模式]]></title>
    <link href="http://taobaofed.org/blog/2016/05/03/promise-anti-patterns/"/>
    <id>http://taobaofed.org/blog/2016/05/03/promise-anti-patterns/</id>
    <published>2016-05-03T08:59:13.000Z</published>
    <updated>2016-07-22T05:20:24.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://gtms02.alicdn.com/tps/i2/TB1d9xhJFXXXXa8XFXX2AXZ8pXX-900-500.png" alt="Promise 反模式"></p>
<p>Promises are about making asynchronous code retain most of the lost properties of synchronous code such as flat indentation and one exception channel. – Bluebird Wiki: Promise Anti Patterns</p>
<p>Promises 是为了让异步代码也能保持这些同步代码的属性：扁平缩进和单异常管道。</p>
<h3 id="Deferred-反模式"><a href="#Deferred-反模式" class="headerlink" title="Deferred 反模式"></a>Deferred 反模式</h3><p>这种反模式中，<code>deferred</code> 对象的创建是没有意义的，反而会增加代码的复杂度。</p>
<p>例如：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Code copyright by Twisternha http://stackoverflow.com/a/19486699/995876 CC BY-SA 2.5</span></span><br><span class="line">myApp.factory(<span class="string">'Configurations'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(Restangular, MotorRestangular, $q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> getConfigurations = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> deferred = $q.defer();</span><br><span class="line"></span><br><span class="line">        MotorRestangular.all(<span class="string">'Motors'</span>).getList().then(<span class="function"><span class="keyword">function</span> <span class="params">(Motors)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//Group by Config</span></span><br><span class="line">            <span class="keyword">var</span> g = _.groupBy(Motors, <span class="string">'configuration'</span>);</span><br><span class="line">            <span class="comment">//Map values</span></span><br><span class="line">            <span class="keyword">var</span> mapped = _.map(g, <span class="function"><span class="keyword">function</span> <span class="params">(m)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    id: m[<span class="number">0</span>].configuration,</span><br><span class="line">                    configuration: m[<span class="number">0</span>].configuration,</span><br><span class="line">                    sizes: _.map(m, <span class="function"><span class="keyword">function</span> <span class="params">(a)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> a.sizeMm</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            deferred.resolve(mapped);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> deferred.promise;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        config: getConfigurations()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这里的 <code>deferred</code> 对象并没有什么意义，而且可能在出错的情况下无法捕获。</p>
<p>正确的写法应该为：</p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">myApp.factory(<span class="string">'Configurations'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">Restangular, MotorRestangular, $q</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">var</span> getConfigurations = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//Just return the promise we already have!</span></span><br><span class="line">        <span class="keyword">return</span> MotorRestangular.all(<span class="string">'Motors'</span>).getList().then(<span class="function"><span class="keyword">function</span> (<span class="params">Motors</span>) </span>&#123;</span><br><span class="line">            <span class="comment">//Group by Cofig</span></span><br><span class="line">            <span class="built_in">var</span> g = _.groupBy(Motors, <span class="string">'configuration'</span>);</span><br><span class="line">            <span class="comment">//Return the mapped array as the value of this promise</span></span><br><span class="line">            <span class="keyword">return</span> _.map(g, <span class="function"><span class="keyword">function</span> (<span class="params">m</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    <span class="attribute">id:</span><span class="string"> m</span>[<span class="number">0</span>].configuration,</span><br><span class="line">                    <span class="attribute">configuration</span>: m[<span class="number">0</span>].configuration,</span><br><span class="line">                    <span class="attribute">sizes</span>: _.map(m, <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> a.sizeMm</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attribute">config</span>: getConfigurations()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>再举一个例子：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span></span> applicationFunction(arg1) &#123;</span><br><span class="line">  var <span class="keyword">deferred</span> = Promise.pending(); // 获取 Q.defer()</span><br><span class="line">  libraryFunction(arg1, <span class="function"><span class="keyword">function</span><span class="params">(err, value)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">deferred</span>.reject(err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">deferred</span>.resolve(<span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">deferred</span>.promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就像重复造轮子，因为回调 API 的封装应该使用 promise 库的 promisification（promise 化）方法实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> applicationFunction = <span class="built_in">Promise</span>.promisify(libraryFunction);</span><br></pre></td></tr></table></figure>
<p>通用 promise 化可能更快，因为可以借助 Promise 的内部操作，还能处理一些极端情况：例如 <code>libraryFunction</code> 同步抛异常或者用到了多个成功值。</p>
<h4 id="什么时候使用-deferred？"><a href="#什么时候使用-deferred？" class="headerlink" title="什么时候使用 deferred？"></a>什么时候使用 deferred？</h4><p>必须用的时候。</p>
<p>当要封装的回调 API 和规范不一致时，例如 <code>setTimeout</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 setTimeout 返回 promise</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delay</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> deferred = <span class="built_in">Promise</span>.pending();</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    deferred.resolve();</span><br><span class="line">  &#125;, ms);</span><br><span class="line">  <span class="keyword">return</span> deferred.promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="then-success-fail-反模式"><a href="#then-success-fail-反模式" class="headerlink" title=".then(success, fail) 反模式"></a><code>.then(success, fail)</code> 反模式</h3><p>这样使用 <code>.then</code> 就像下面这段代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t0;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  t0 = doThat();</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样报错发生时会 catch 不到</span></span><br><span class="line"><span class="keyword">var</span> staff = <span class="built_in">JSON</span>.parse(t0);</span><br></pre></td></tr></table></figure>
<p>正常的同步写法是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> stuff = <span class="built_in">JSON</span>.parse(doThat());</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以正确的 <code>.then</code> 用法应该是：</p>
<figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">doThat()</span><br><span class="line">.<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(v)</span> &#123;</span></span><br><span class="line">  <span class="keyword">return</span> JSON.parse(v);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="keyword">catch</span>(<span class="function"><span class="keyword">function</span><span class="params">(e)</span> &#123;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="嵌套-Promise"><a href="#嵌套-Promise" class="headerlink" title="嵌套 Promise"></a>嵌套 Promise</h3><p>例如：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">loadSomething().<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(something)</span></span> &#123;</span><br><span class="line">  loadAnothering().<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(another)</span></span> &#123;</span><br><span class="line">    DoSomethingOnThem(something, another);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果只是想对两个 promise 的结果做处理，可以使用 Promise.all 方法：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Promise.<span class="built_in">all</span>([loadSomething, loadAnothering]).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(something, another)</span></span> &#123;</span><br><span class="line">  DoSomethingOnThem(something, another);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="断链"><a href="#断链" class="headerlink" title="断链"></a>断链</h3><p>例如：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">anAsyncCall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> promise = doSomethingAsync();</span><br><span class="line">  promise.then(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    somethingComplicated();</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的问题在于加入 <code>somethingComplicated()</code> 出错的话不会被捕获。promise 应该链式调用。也就是说所有的 <code>then</code> 方法都应该返回一个新的 <code>promise</code>。所以上面代码的正确写法为：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">anAsyncCall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> promise = doSomethingAsync();</span><br><span class="line">  <span class="keyword">return</span> promise.then(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    somethingComplicated();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>例如需要对一个集合中的每个元素执行异步操作：</p>
<figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workMyCollection</span><span class="params">(arr)</span> &#123;</span></span><br><span class="line">  var resultArr = [];</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">_recursive</span><span class="params">(idx)</span> &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (idx &gt;= resultArr.<span class="built_in">length</span>) <span class="keyword">return</span> resultArr;</span><br><span class="line">    <span class="keyword">return</span> doSomethingAsync(arr[idx]).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(res)</span> &#123;</span></span><br><span class="line">      resultArr.push(res);</span><br><span class="line">      <span class="keyword">return</span> _recursive(idx + <span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> _recursive(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的问题在于需要遍历数组，其实可以用 <code>promise.all</code> 解决：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workMyCollection</span><span class="params">(arr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> q.all(</span><br><span class="line">    arr.map(<span class="function"><span class="keyword">function</span><span class="params">(item)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> doSomethingAsync(item);</span><br><span class="line">    &#125;)</span><br><span class="line">  );    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最容易犯的错误，没有使用 <code>catch</code> 去捕获 <code>then</code> 里抛出的报错：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// snippet1</span></span><br><span class="line">somePromise().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'oh noes'</span>);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// I caught your error! :)</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// snippet2</span></span><br><span class="line">somePromise().then(<span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'oh noes'</span>);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// I didn't catch your error! :(</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这里的问题在于 snippet2 在 function resolve 中出错时无法捕获。而 catch 则可以。</p>
<p>下面的两个示例返回结果是不一样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example1</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'foo'</span>).then(<span class="built_in">Promise</span>.resolve(<span class="string">'bar'</span>)).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);  <span class="comment">// foo</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// example2</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'foo'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">'bar'</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result); <span class="comment">// bar</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>example2 改变了返回值，因而 result 发生了变化。</p>
<h3 id="更多关键词"><a href="#更多关键词" class="headerlink" title="更多关键词"></a>更多关键词</h3><p><code>async flow control, event loop, callback, promises, generators, async/wait, coroutines</code></p>
<p>Promises 所做的承诺是保证异步代码顺序执行，并能够链式管理异常和错误。相比使用 <code>event loop</code> 和回调（callback）来控制异步代码的顺序执行，Promises 能够让代码更加清晰易懂。generator 更是从语言级别上提供了更好的支持。</p>
<h3 id="V8-优化"><a href="#V8-优化" class="headerlink" title="V8 优化"></a>V8 优化</h3><p>V8 有两个编译器：通用编译器和优化编译器。也就是V8 中的 JavaScript 代码总是被编译成机器码后才执行的。</p>
<p>例如 <code>a + b</code> 编译成汇编代码为：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, a</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ebx</span>, b</span><br><span class="line"><span class="keyword">call</span> RuntimeAdd</span><br></pre></td></tr></table></figure>
<p>但如果 <code>a</code> 和 <code>b</code> 都是整数的话，则会被编译成：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, a</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ebx</span>, b</span><br><span class="line"><span class="keyword">add</span> <span class="built_in">eax</span>, <span class="built_in">ebx</span></span><br></pre></td></tr></table></figure>
<p>这样编译后的代码性能会快很多，因为跳过了 JavaScript 对不同类型数据相加的处理。</p>
<p>通用编译器会得到前一种汇编码，优化编译器会得到后一种汇编码。两种汇编代码性能很容易产生 100 倍的差异。但是存在一些模式，这些模式下的代码优化编译器不会去处理（称为<code>bail out</code>）。Promises 属于一种被 bail out 的模式。</p>
<h3 id="他山之石"><a href="#他山之石" class="headerlink" title="他山之石"></a>他山之石</h3><p>Python greenlets（基于gevent）</p>
<p>go coroutine</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://github.com/petkaantonov/bluebird/wiki/Promise-anti-patterns#the-thensuccess-fail-anti-pattern" target="_blank" rel="external">bluebird wiki</a></li>
<li><a href="http://taoofcode.net/promise-anti-patterns/" target="_blank" rel="external">tao of code</a></li>
<li><a href="https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html" target="_blank" rel="external">https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html</a></li>
<li><a href="https://www.promisejs.org/patterns/" target="_blank" rel="external">https://www.promisejs.org/patterns/</a></li>
<li><a href="http://www.slideshare.net/domenicdenicola/callbacks-promises-and-coroutines-oh-my-the-evolution-of-asynchronicity-in-javascript" target="_blank" rel="external">http://www.slideshare.net/domenicdenicola/callbacks-promises-and-coroutines-oh-my-the-evolution-of-asynchronicity-in-javascript</a></li>
<li><a href="https://github.com/nodejs/node/wiki/Async-Exception-Handling" target="_blank" rel="external">Node.js async exception handling</a></li>
<li><a href="https://promise-nuggets.github.io/" target="_blank" rel="external">promise nuggets</a></li>
<li><a href="https://github.com/petkaantonov/bluebird/wiki/Optimization-killers" target="_blank" rel="external">Optimization Killers</a></li>
<li><a href="https://github.com/vhf/v8-bailout-reasons" target="_blank" rel="external">v8 bailout reasons</a></li>
<li><a href="https://sdiehl.github.io/gevent-tutorial/" target="_blank" rel="external">Python greenlets</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://gtms02.alicdn.com/tps/i2/TB1d9xhJFXXXXa8XFXX2AXZ8pXX-900-500.png" alt="Promise 反模式"></p>
<p>Promises are about making as]]>
    </summary>
    
      <category term="nodejs" scheme="http://taobaofed.org/tags/nodejs/"/>
    
      <category term="promise" scheme="http://taobaofed.org/tags/promise/"/>
    
      <category term="generator" scheme="http://taobaofed.org/tags/generator/"/>
    
      <category term="async" scheme="http://taobaofed.org/tags/async/"/>
    
      <category term="flow_control" scheme="http://taobaofed.org/tags/flow-control/"/>
    
      <category term="Node.js" scheme="http://taobaofed.org/categories/Node-js/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[无线性能优化：Composite]]></title>
    <link href="http://taobaofed.org/blog/2016/04/25/performance-composite/"/>
    <id>http://taobaofed.org/blog/2016/04/25/performance-composite/</id>
    <published>2016-04-25T02:21:18.000Z</published>
    <updated>2016-07-22T05:20:24.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img.alicdn.com/tfs/TB1XT4kMFXXXXaBXXXXXXXXXXXX-900-500.png" alt="无线性能优化：Composite"></p>
<p>一个 Web 页面的展示，简单来说可以认为经历了以下下几个步骤。</p>
<p><img src="https://img.alicdn.com/tps/TB1eabOLpXXXXX3XFXXXXXXXXXX-1093-167.jpg_720x720.jpg" alt=""></p>
<ul>
<li>JavaScript：一般来说，我们会使用 JavaScript 来实现一些视觉变化的效果。比如做一个动画或者往页面里添加一些 DOM 元素等。</li>
<li>Style：计算样式，这个过程是根据 CSS 选择器，对每个 DOM 元素匹配对应的 CSS 样式。这一步结束之后，就确定了每个 DOM 元素上该应用什么 CSS 样式规则。</li>
<li>Layout：布局，上一步确定了每个 DOM 元素的样式规则，这一步就是具体计算每个 DOM 元素最终在屏幕上显示的大小和位置。web 页面中元素的布局是相对的，因此一个元素的布局发生变化，会联动地引发其他元素的布局发生变化。比如，<code>&lt;body&gt;</code> 元素的宽度的变化会影响其子元素的宽度，其子元素宽度的变化也会继续对其孙子元素产生影响。因此对于浏览器来说，布局过程是经常发生的。</li>
<li>Paint：绘制，本质上就是填充像素的过程。包括绘制文字、颜色、图像、边框和阴影等，也就是一个 DOM 元素所有的可视效果。一般来说，这个绘制过程是在多个层上完成的。</li>
<li>Composite：渲染层合并，由上一步可知，对页面中 DOM 元素的绘制是在多个层上进行的。在每个层上完成绘制过程之后，浏览器会将所有层按照合理的顺序合并成一个图层，然后显示在屏幕上。对于有位置重叠的元素的页面，这个过程尤其重要，因为一旦图层的合并顺序出错，将会导致元素显示异常。</li>
</ul>
<p>当然，本文我们只来关注 Composite 部分。</p>
<h2 id="浏览器渲染原理"><a href="#浏览器渲染原理" class="headerlink" title="浏览器渲染原理"></a>浏览器渲染原理</h2><p>在讨论 Composite 之前，有必要先简单了解下一些浏览器（本文只是针对 Chrome 来说）的渲染原理，方便对之后一些概念的理解。更多详细的内容可以参阅 <a href="http://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome" target="_blank" rel="external">GPU Accelerated Compositing in Chrome</a></p>
<p>注：由于 Chrome 对 Blank 引擎某些实现的修改，某些我们之前熟知的类名有了变化，比如 RenderObject 变成了 LayoutObject，RenderLayer 变成了 PaintLayer。感兴趣的看以参阅 <a href="https://www.chromium.org/blink/slimming-paint" target="_blank" rel="external">Slimming Paint</a>。</p>
<p>在浏览器中，页面内容是存储为由 Node 对象组成的树状结构，也就是 DOM 树。每一个 HTML element 元素都有一个 Node 对象与之对应，DOM 树的根节点永远都是 Document Node。这一点相信大家都很熟悉了，但其实，从 DOM 树到最后的渲染，需要进行一些转换映射。</p>
<p><img src="https://img.alicdn.com/tps/TB1VFRDMXXXXXahXpXXXXXXXXXX-814-320.png_720x720.jpg" alt=""></p>
<h3 id="从-Nodes-到-LayoutObjects"><a href="#从-Nodes-到-LayoutObjects" class="headerlink" title="从 Nodes 到 LayoutObjects"></a>从 Nodes 到 LayoutObjects</h3><p>DOM 树中得每个 Node 节点都有一个对应的 LayoutObject 。LayoutObject 知道如何在屏幕上 paint Node 的内容。</p>
<h3 id="从-LayoutObjects-到-PaintLayers"><a href="#从-LayoutObjects-到-PaintLayers" class="headerlink" title="从 LayoutObjects 到 PaintLayers"></a>从 LayoutObjects 到 PaintLayers</h3><p>一般来说，拥有相同的坐标空间的 LayoutObjects，属于同一个渲染层（PaintLayer）。PaintLayer 最初是用来实现 <a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context" target="_blank" rel="external">stacking contest（层叠上下文）</a>，以此来保证页面元素以正确的顺序合成（composite），这样才能正确的展示元素的重叠以及半透明元素等等。因此满足形成层叠上下文条件的 LayoutObject 一定会为其创建新的渲染层，当然还有其他的一些特殊情况，为一些特殊的 LayoutObjects 创建一个新的渲染层，比如 <code>overflow != visible</code> 的元素。根据创建 PaintLayer 的原因不同，可以将其分为常见的 3 类：</p>
<ul>
<li><p>NormalPaintLayer</p>
<ul>
<li>根元素（HTML）</li>
<li>有明确的定位属性（relative、fixed、sticky、absolute）</li>
<li>透明的（opacity 小于 1）</li>
<li>有 CSS 滤镜（fliter）</li>
<li>有 CSS mask 属性</li>
<li>有 CSS mix-blend-mode 属性（不为 normal）</li>
<li>有 CSS transform 属性（不为 none）</li>
<li>backface-visibility 属性为 hidden</li>
<li>有 CSS reflection 属性</li>
<li>有 CSS column-count 属性（不为 auto）或者 有 CSS column-width 属性（不为 auto）</li>
<li>当前有对于 opacity、transform、fliter、backdrop-filter 应用动画</li>
</ul>
</li>
<li><p>OverflowClipPaintLayer</p>
<ul>
<li>overflow 不为 visible</li>
</ul>
</li>
<li><p>NoPaintLayer</p>
<ul>
<li>不需要 paint 的 PaintLayer，比如一个没有视觉属性（背景、颜色、阴影等）的空 div。</li>
</ul>
</li>
</ul>
<p>满足以上条件的 LayoutObject 会拥有独立的渲染层，而其他的 LayoutObject 则和其第一个拥有渲染层的父元素共用一个。</p>
<h3 id="从-PaintLayers-到-GraphicsLayers"><a href="#从-PaintLayers-到-GraphicsLayers" class="headerlink" title="从 PaintLayers 到 GraphicsLayers"></a>从 PaintLayers 到 GraphicsLayers</h3><p>某些特殊的渲染层会被认为是合成层（Compositing Layers），合成层拥有单独的 GraphicsLayer，而其他不是合成层的渲染层，则和其第一个拥有 GraphicsLayer 父层公用一个。</p>
<p>每个 GraphicsLayer 都有一个 GraphicsContext，GraphicsContext 会负责输出该层的位图，位图是存储在共享内存中，作为纹理上传到 GPU 中，最后由 GPU 将多个位图进行合成，然后 draw 到屏幕上，此时，我们的页面也就展现到了屏幕上。</p>
<p>渲染层提升为合成层的原因有一下几种：</p>
<p>注：渲染层提升为合成层有一个先决条件，该渲染层必须是 SelfPaintingLayer（基本可认为是上文介绍的 NormalPaintLayer）。以下所讨论的渲染层提升为合成层的情况都是在该渲染层为 SelfPaintingLayer 前提下的。</p>
<ul>
<li><p>直接原因（direct reason）</p>
<ul>
<li>硬件加速的 iframe 元素（比如 iframe 嵌入的页面中有合成层）<a href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/direct/iframe.html" target="_blank" rel="external">demo</a></li>
<li>video 元素</li>
<li>覆盖在 video 元素上的视频控制栏</li>
<li><p>3D 或者 硬件加速的 2D Canvas 元素</p>
<ul>
<li><a href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/direct/canvas.html" target="_blank" rel="external">demo：普通 2D Canvas 不会提升为合成层</a></li>
<li><a href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/direct/webgl.html" target="_blank" rel="external">demo：3D Canvas 提升为合成层</a></li>
</ul>
</li>
<li><p>硬件加速的插件，比如 flash 等等</p>
</li>
<li>在 DPI 较高的屏幕上，fix 定位的元素会自动地被提升到合成层中。但在 DPI 较低的设备上却并非如此，因为这个渲染层的提升会使得字体渲染方式由子像素变为灰阶（详细内容请参考：<a href="http://www.html5rocks.com/en/tutorials/internals/antialiasing-101/?redirect_from_locale=zh#toc-text-rendering" target="_blank" rel="external">Text Rendering</a>）</li>
<li>有 3D transform</li>
<li>backface-visibility 为 hidden</li>
<li><p>对 opacity、transform、fliter、backdropfilter 应用了 animation 或者 transition（需要是 active 的 animation 或者 transition，当 animation 或者 transition 效果未开始或结束后，提升合成层也会失效）</p>
<ul>
<li><a href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/direct/animation.html" target="_blank" rel="external">demo：animation</a></li>
<li><p><a href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/direct/transition.html" target="_blank" rel="external">demo：transition</a></p>
<p><img src="https://img.alicdn.com/tps/TB1XMzqMXXXXXXsXFXXXXXXXXXX-959-370.jpg" alt=""></p>
</li>
</ul>
</li>
<li><p>will-change 设置为 opacity、transform、top、left、bottom、right（其中 top、left 等需要设置明确的定位属性，如 relative 等）<a href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/direct/will-change.html" target="_blank" rel="external">demo</a></p>
</li>
</ul>
</li>
<li><p>后代元素原因</p>
<ul>
<li>有合成层后代同时本身有 transform、opactiy（小于 1）、mask、fliter、reflection 属性 <a href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/descendant/combo.html" target="_blank" rel="external">demo</a></li>
<li>有合成层后代同时本身 overflow 不为 visible（如果本身是因为明确的定位因素产生的 SelfPaintingLayer，则需要 z-index 不为 auto） <a href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/descendant/overflow.html" target="_blank" rel="external">demo</a></li>
<li>有合成层后代同时本身 fixed 定位 <a href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/descendant/fixed.html" target="_blank" rel="external">demo</a></li>
<li>有 3D transfrom 的合成层后代同时本身有 preserves-3d 属性 <a href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/descendant/preserves-3d.html" target="_blank" rel="external">demo</a></li>
<li>有 3D transfrom 的合成层后代同时本身有 perspective 属性 <a href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/descendant/perspective.html" target="_blank" rel="external">demo</a></li>
</ul>
</li>
<li><p>overlap 重叠原因</p>
<p>  为什么会因为重叠原因而产生合成层呢？举个简单的栗子。</p>
<p>  <img src="https://img.alicdn.com/tps/TB1sZbvMXXXXXXlXXXXXXXXXXXX-491-300.jpg" alt=""></p>
<p>  蓝色的矩形重叠在绿色矩形之上，同时它们的父元素是一个 GraphicsLayer。此时假设绿色矩形为一个 GraphicsLayer，如果 overlap 无法提升合成层的话，那么蓝色矩形不会提升为合成层，也就会和父元素公用一个 GraphicsLayer。</p>
<p>  <img src="https://img.alicdn.com/tps/TB1qzzmMXXXXXX1XpXXXXXXXXXX-491-300.jpg" alt=""></p>
<p>  此时，渲染顺序就会发生错误，因此为保证渲染顺序，overlap 也成为了合成层产生的原因，也就是如下的正常情形。</p>
<p>  <img src="https://img.alicdn.com/tps/TB13cYmMXXXXXaXXpXXXXXXXXXX-491-300.jpg" alt=""></p>
<p>  当然 overlap 的原因也会细分为几类，接下来我们会详细看下。</p>
<ul>
<li><p>重叠或者说部分重叠在一个合成层之上。</p>
<p>  那如何算是重叠呢，最常见和容易理解的就是元素的 border box（content + padding + border） 和合成层的有重叠，比如：<a href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/overlap/normal.html" target="_blank" rel="external">demo</a>，当然 margin area 的重叠是无效的（<a href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/overlap/margin.html" target="_blank" rel="external">demo</a>）。其他的还有一些不常见的情况，也算是同合成层重叠的条件，如下：</p>
<ul>
<li>filter 效果同合成层重叠 <a href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/overlap/filter.html" target="_blank" rel="external">demo</a></li>
<li>transform 变换后同合成层重叠 <a href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/overlap/transform.html" target="_blank" rel="external">demo</a></li>
<li>overflow scroll 情况下同合成层重叠。即如果一个 overflow scroll（不管 <code>overflow:auto</code> 还是 <code>overflow:scrill</code>，只要是能 scroll 即可） 的元素同一个合成层重叠，则其可视子元素也同该合成层重叠 <a href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/overlap/overflow.html" target="_blank" rel="external">demo</a></li>
</ul>
</li>
<li><p>假设重叠在一个合成层之上（assumedOverlap）。</p>
<p>  这个原因听上去有点虚，什么叫假设重叠？其实也比较好理解，比如一个元素的 CSS 动画效果，动画运行期间，元素是有可能和其他元素有重叠的。针对于这种情况，于是就有了 assumedOverlap 的合成层产生原因，示例可见：<a href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/overlap/animation.html" target="_blank" rel="external">demo</a>。在本 demo 中，动画元素视觉上并没有和其兄弟元素重叠，但因为 assumedOverlap 的原因，其兄弟元素依然提升为了合成层。</p>
<p>  需要注意的是该原因下，有一个很特殊的情况：</p>
<p>  如果合成层有内联的 transform 属性，会导致其兄弟渲染层 assume overlap，从而提升为合成层。比如：<a href="http://taobaofed.github.io/demo/performance-composite-demo/layer-create/overlap/inline.html" target="_blank" rel="external">demo</a>。</p>
</li>
</ul>
</li>
</ul>
<h4 id="层压缩"><a href="#层压缩" class="headerlink" title="层压缩"></a>层压缩</h4><p>基本上常见的一些合成层的提升原因如上所说，你会发现，由于重叠的原因，可能随随便便就会产生出大量合成层来，而每个合成层都要消耗 CPU 和内存资源，岂不是严重影响页面性能。这一点浏览器也考虑到了，因此就有了层压缩（Layer Squashing）的处理。如果多个渲染层同一个合成层重叠时，这些渲染层会被压缩到一个 GraphicsLayer 中，以防止由于重叠原因导致可能出现的“层爆炸”。具体可以看如下 <a href="http://taobaofed.github.io/demo/performance-composite-demo/squash/squash-hover.html" target="_blank" rel="external">demo</a>。一开始，蓝色方块由于<br><code>translateZ</code> 提升为了合成层，其他的方块元素因为重叠的原因，被压缩了一起，大小就是包含这 3 个方块的矩形大小。</p>
<p><img src="https://img.alicdn.com/tps/TB1yslCMXXXXXahaXXXXXXXXXXX-755-406.png_720x720.jpg" alt=""></p>
<p>当我们 hover 绿色方块时，会给其设置 <code>translateZ</code> 属性，导致绿色方块也被提升为合成层，则剩下的两个被压缩到了一起，大小就缩小为包含这 2 个方块的矩形大小。</p>
<p><img src="https://img.alicdn.com/tps/TB1xxh1MXXXXXX_XXXXXXXXXXXX-755-406.png_720x720.jpg" alt=""></p>
<p>当然，浏览器的自动的层压缩也不是万能的，有很多特定情况下，浏览器是无法进行层压缩的，如下所示，而这些情况也是我们应该尽量避免的。（注：以下情况都是基于重叠原因而言）</p>
<ul>
<li><p>无法进行会打破渲染顺序的压缩（squashingWouldBreakPaintOrder）</p>
<p>  示例如下：<a href="http://taobaofed.github.io/demo/performance-composite-demo/squash/squashingWouldBreakPaintOrder-mask.html" target="_blank" rel="external">demo</a></p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span><br><span class="line">  <span class="selector-id">#ancestor</span> &#123;</span><br><span class="line">    <span class="attribute">-webkit-mask-image</span>: <span class="built_in">-webkit-linear-gradient</span>(rgba(0,0,0,1), <span class="built_in">rgba</span>(0,0,0,0));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="selector-id">#composited</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateZ</span>(0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-id">#container</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">60px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-id">#overlap-child</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span> ;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">60px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: orange;</span><br><span class="line">  &#125;</span><br><span class="line"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"composited"</span>&gt;</span>Text behind the orange box.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"ancestor"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"overlap-child"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>  在本例中，<code>#overlap-child</code> 同合成层重叠，如果进行压缩，会导致渲染顺序的改变，其父元素 <code>#ancestor</code> 的 mask 属性将失效，因此类似这种情况下，是无法进行层压缩的。目前常见的产生这种原因的情况有两种，一种是上述的祖先元素使用 mask 属性的情况，另一种是祖先元素使用 filter 属性的情况（<a href="http://taobaofed.github.io/demo/performance-composite-demo/squash/squashingWouldBreakPaintOrder-filter.html" target="_blank" rel="external">demo</a>）。</p>
</li>
<li><p>video 元素的渲染层无法被压缩同时也无法将别的渲染层压缩到 video 所在的合成层上（squashingVideoIsDisallowed）<a href="http://taobaofed.github.io/demo/performance-composite-demo/squash/video.html" target="_blank" rel="external">demo</a></p>
</li>
<li><p>iframe、plugin 的渲染层无法被压缩同时也无法将别的渲染层压缩到其所在的合成层上（squashingLayoutPartIsDisallowed）<a href="http://taobaofed.github.io/demo/performance-composite-demo/squash/layoutpart.html" target="_blank" rel="external">demo</a></p>
</li>
<li><p>无法压缩有 reflection 属性的渲染层（squashingReflectionDisallowed）<a href="http://taobaofed.github.io/demo/performance-composite-demo/squash/reflection.html" target="_blank" rel="external">demo</a></p>
</li>
<li><p>无法压缩有 blend mode 属性的渲染层（squashingBlendingDisallowed）<a href="http://taobaofed.github.io/demo/performance-composite-demo/squash/blend-mode.html" target="_blank" rel="external">demo</a></p>
</li>
<li><p>当渲染层同合成层有不同的裁剪容器（clipping container）时，该渲染层无法压缩（squashingClippingContainerMismatch）。</p>
<p>  示例如下：<a href="http://taobaofed.github.io/demo/performance-composite-demo/squash/squashingClippingContainerMismatch.html" target="_blank" rel="external">demo</a></p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span><br><span class="line">  <span class="selector-class">.clipping-container</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">10px</span>; </span><br><span class="line">    <span class="attribute">background-color</span>: blue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.composited</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateZ</span>(0); </span><br><span class="line">    <span class="attribute">height</span>: <span class="number">10px</span>; </span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.target</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">position</span>:absolute; </span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0px</span>; </span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100px</span>; </span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100px</span>; </span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"clipping-container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"composited"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"target"</span>&gt;</span>不会被压缩到 composited div 上<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>  本例中 <code>.target</code> 同 合成层 <code>.composited</code> 重叠，但是由于 <code>.composited</code> 在一个 <code>overflow: hidden</code> 的容器中，导致 <code>.target</code> 和合成层有不同的裁剪容器，从而 <code>.target</code> 无法被压缩。</p>
</li>
<li><p>相对于合成层滚动的渲染层无法被压缩（scrollsWithRespectToSquashingLayer）</p>
<p>  示例如下：<a href="http://taobaofed.github.io/demo/performance-composite-demo/squash/scrollsWithRespectToSquashingLayer.html" target="_blank" rel="external">demo</a></p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">1500px</span>;</span><br><span class="line">    <span class="attribute">overflow-x</span>: hidden;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.composited</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateZ</span>(0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.overlap</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">    <span class="attribute">position</span>: fixed;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0px</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"composited"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"overlap"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>  本例中，红色的 <code>.composited</code> 提升为了合成层，绿色的 <code>.overlap</code> fix 在页面顶部，一开始只有 <code>.composited</code> 合成层。</p>
<p>  <img src="https://img.alicdn.com/tps/TB1SHBOMXXXXXbnXFXXXXXXXXXX-690-484.jpg_640x640.jpg" alt=""></p>
<p>  当滑动页面，<code>.overlap</code> 重叠到 <code>.composited</code> 上时，<code>.overlap</code> 会因重叠原因提升为合成层，同时，因为相对于合成层滚动，因此无法被压缩。</p>
<p>  <img src="https://img.alicdn.com/tps/TB1IrRGMXXXXXXxaXXXXXXXXXXX-690-484.jpg_640x640.jpg" alt=""></p>
</li>
<li><p>当渲染层同合成层有不同的具有 opacity 的祖先层（一个设置了 opacity 且小于 1，一个没有设置 opacity，也算是不同）时，该渲染层无法压缩（squashingOpacityAncestorMismatch，同 squashingClippingContainerMismatch）<a href="http://taobaofed.github.io/demo/performance-composite-demo/squash/squashingOpacityAncestorMismatch.html" target="_blank" rel="external">demo</a></p>
</li>
<li><p>当渲染层同合成层有不同的具有 transform 的祖先层时，该渲染层无法压缩（squashingTransformAncestorMismatch，同上） <a href="http://taobaofed.github.io/demo/performance-composite-demo/squash/squashingTransformAncestorMismatch.html" target="_blank" rel="external">demo</a></p>
</li>
<li><p>当渲染层同合成层有不同的具有 filter 的祖先层时，该渲染层无法压缩（squashingFilterAncestorMismatch，同上）<a href="http://taobaofed.github.io/demo/performance-composite-demo/squash/squashingFilterAncestorMismatch.html" target="_blank" rel="external">demo</a></p>
</li>
<li><p>当覆盖的合成层正在运行动画时，该渲染层无法压缩（squashingLayerIsAnimating），当动画未开始或者运行完毕以后，该渲染层才可以被压缩 <a href="http://taobaofed.github.io/demo/performance-composite-demo/squash/animating.html" target="_blank" rel="external">demo</a></p>
<p>  <img src="https://img.alicdn.com/tps/TB1mJjwMXXXXXajXpXXXXXXXXXX-960-391.jpg" alt=""></p>
</li>
</ul>
<h2 id="如何查看合成层"><a href="#如何查看合成层" class="headerlink" title="如何查看合成层"></a>如何查看合成层</h2><p>使用 Chrome DevTools 工具来查看页面中合成层的情况。</p>
<p>比较简单的方法是打开 DevTools，勾选上 <code>Show layer borders</code></p>
<p><img src="https://img.alicdn.com/tps/TB1dZG.MXXXXXX2XVXXXXXXXXXX-276-164.png" alt=""></p>
<p>其中，页面上的合成层会用黄色边框框出来。</p>
<p><img src="https://img.alicdn.com/tps/TB1EQu4MXXXXXXiaXXXXXXXXXXX-709-717.png_600x600.jpg" alt=""></p>
<p>当然，更加详细的信息可以通过 Timeline 来查看。</p>
<p>每一个单独的帧，看到每个帧的渲染细节：</p>
<p><img src="https://img.alicdn.com/tps/TB1.uznMXXXXXbcXFXXXXXXXXXX-325-195.jpg" alt=""></p>
<p>点击之后，你就会在视图中看到一个新的选项卡：Layers。</p>
<p><img src="https://img.alicdn.com/tps/TB1uCgsLpXXXXXNXFXXXXXXXXXX-333-260.jpg" alt=""></p>
<p>点击这个 Layers 选项卡，你会看到一个新的视图。在这个视图中，你可以对这一帧中的所有合成层进行扫描、缩放等操作，同时还能看到每个渲染层被创建的原因。</p>
<p><img src="https://img.alicdn.com/tps/TB163nGMXXXXXatXXXXXXXXXXXX-1440-756.jpg_720x720.jpg" alt=""></p>
<p>有了这个视图，你就能知道页面中到底有多少个合成层。如果你在对页面滚动或渐变效果的性能分析中发现 Composite 过程耗费了太多时间，那么你可以从这个视图里看到页面中有多少个渲染层，它们为何被创建，从而对合成层的数量进行优化。</p>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>提升为合成层简单说来有以下几点好处：</p>
<ul>
<li>合成层的位图，会交由 GPU 合成，比 CPU 处理要快</li>
<li>当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层</li>
<li>对于 transform 和 opacity 效果，不会触发 layout 和 paint</li>
</ul>
<p>利用合成层对于提升页面性能方面有很大的作用，因此我们也总结了一下几点优化建议。</p>
<h3 id="提升动画效果的元素"><a href="#提升动画效果的元素" class="headerlink" title="提升动画效果的元素"></a>提升动画效果的元素</h3><p>合成层的好处是不会影响到其他元素的绘制，因此，为了减少动画元素对其他元素的影响，从而减少 paint，我们需要把动画效果中的元素提升为合成层。</p>
<p>提升合成层的最好方式是使用 CSS 的 will-change 属性。从上一节合成层产生原因中，可以知道 will-change 设置为 opacity、transform、top、left、bottom、right 可以将元素提升为合成层。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#target</span> &#123;</span><br><span class="line">  <span class="attribute">will-change</span>: transform;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其兼容如下所示：</p>
<p><img src="https://img.alicdn.com/tps/TB1_6P9LpXXXXblXXXXXXXXXXXX-1252-284.png_720x720.jpg" alt=""></p>
<p>对于那些目前还不支持 will-change 属性的浏览器，目前常用的是使用一个 3D transform 属性来强制提升为合成层：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#target</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateZ</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但需要注意的是，不要创建太多的渲染层。因为每创建一个新的渲染层，就意味着新的内存分配和更复杂的层的管理。之后我们会详细讨论。</p>
<p>如果你已经把一个元素放到一个新的合成层里，那么可以使用 Timeline 来确认这么做是否真的改进了渲染性能。别盲目提升合成层，一定要分析其实际性能表现。</p>
<h3 id="使用-transform-或者-opacity-来实现动画效果"><a href="#使用-transform-或者-opacity-来实现动画效果" class="headerlink" title="使用 transform 或者 opacity 来实现动画效果"></a>使用 transform 或者 opacity 来实现动画效果</h3><p>文章最开始，我们讲到了页面呈现出来所经历的渲染流水线，其实从性能方面考虑，最理想的渲染流水线是没有布局和绘制环节的，只需要做合成层的合并即可：</p>
<p><img src="https://img.alicdn.com/tps/TB14YwvLpXXXXXGXFXXXXXXXXXX-1093-167.jpg_720x720.jpg" alt=""></p>
<p>为了实现上述效果，就需要只使用那些仅触发 Composite 的属性。目前，只有两个属性是满足这个条件的：transforms 和 opacity。更详细的信息可以查看 <a href="http://csstriggers.com/" target="_blank" rel="external">CSS Triggers</a>。</p>
<p>注意：元素提升为合成层后，transform 和 opacity 才不会触发 paint，如果不是合成层，则其依然会触发 paint。具体见如下两个 demo。</p>
<ul>
<li><p><a href="http://taobaofed.github.io/demo/performance-composite-demo/paint/promote-element/no-promote-transform.html" target="_blank" rel="external">demo 1：transform</a></p>
<p>  <img src="https://img.alicdn.com/tps/TB1XsAVLpXXXXbzXpXXXXXXXXXX-712-411.png_640x640.jpg" alt="no-promote-transform"></p>
</li>
<li><p><a href="http://taobaofed.github.io/demo/performance-composite-demo/paint/promote-element/no-promote-opacity.html" target="_blank" rel="external">demo 2：opacity</a></p>
<p>  <img src="https://img.alicdn.com/tps/TB1j9M7LpXXXXaiXXXXXXXXXXXX-713-424.png_640x640.jpg" alt="no-promote-opacity"></p>
</li>
</ul>
<p>可以看到未提升 target element 为合成层，transform 和 opacity 依然会触发 paint。</p>
<h3 id="减少绘制区域"><a href="#减少绘制区域" class="headerlink" title="减少绘制区域"></a>减少绘制区域</h3><p>对于不需要重新绘制的区域应尽量避免绘制，以减少绘制区域，比如一个 fix 在页面顶部的固定不变的导航 header，在页面内容某个区域 repaint 时，整个屏幕包括 fix 的 header 也会被重绘，见 <a href="http://taobaofed.github.io/demo/performance-composite-demo/paint/reduce/no-reduce.html" target="_blank" rel="external">demo</a>，结果如下：</p>
<p><img src="https://img.alicdn.com/tps/TB1SK_9LpXXXXcaaXXXXXXXXXXX-699-304.png" alt="no-reduce"></p>
<p>而对于固定不变的区域，我们期望其并不会被重绘，因此可以通过之前的方法，将其提升为独立的合成层。</p>
<p>减少绘制区域，需要仔细分析页面，区分绘制区域，减少重绘区域甚至避免重绘。</p>
<h3 id="合理管理合成层"><a href="#合理管理合成层" class="headerlink" title="合理管理合成层"></a>合理管理合成层</h3><p>看完上面的文章，你会发现提升合成层会达到更好的性能。这看上去非常诱人，但是问题是，创建一个新的合成层并不是免费的，它得消耗额外的内存和管理资源。实际上，在内存资源有限的设备上，合成层带来的性能改善，可能远远赶不上过多合成层开销给页面性能带来的负面影响。同时，由于每个渲染层的纹理都需要上传到 GPU 处理，因此我们还需要考虑 CPU 和 GPU 之间的带宽问题、以及有多大内存供 GPU 处理这些纹理的问题。</p>
<p>对于合成层占用内存的问题，我们简单做了几个 demo 进行了验证。</p>
<p><a href="http://taobaofed.github.io/demo/performance-composite-demo/memory/multi-layers-expect.html" target="_blank" rel="external">demo 1</a> 和 <a href="http://taobaofed.github.io/demo/performance-composite-demo/memory/multi-layers.html" target="_blank" rel="external">demo 2</a> 中，会创建 2000 个同样的 div 元素，不同的是 <a href="http://taobaofed.github.io/demo/performance-composite-demo/memory/multi-layers.html" target="_blank" rel="external">demo 2</a> 中的元素通过 will-change 都提升为了合成层，而两个 demo 页面的内存消耗却有很明显的差别。</p>
<p><img src="https://img.alicdn.com/tps/TB1EMYKMXXXXXcUXXXXXXXXXXXX-972-480.jpg" alt=""></p>
<h4 id="防止层爆炸"><a href="#防止层爆炸" class="headerlink" title="防止层爆炸"></a>防止层爆炸</h4><p>通过之前的介绍，我们知道同合成层重叠也会使元素提升为合成层，虽然有浏览器的层压缩机制，但是也有很多无法进行压缩的情况。也就是说除了我们显式的声明的合成层，还可能由于重叠原因不经意间产生一些不在预期的合成层，极端一点可能会产生大量的额外合成层，出现层爆炸的现象。我们简单写了一个极端点但其实在我们的页面中比较常见的 <a href="http://taobaofed.github.io/demo/performance-composite-demo/memory/layer-explode.html" target="_blank" rel="external">demo</a>。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span><br><span class="line">  @-<span class="keyword">webkit</span>-<span class="keyword">keyframes</span> slide &#123;</span><br><span class="line">    <span class="selector-tag">from</span> &#123; <span class="attribute">transform</span>: none; &#125;</span><br><span class="line">    <span class="selector-tag">to</span> &#123; <span class="attribute">transform</span>: <span class="built_in">translateX</span>(100px); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.animating</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: orange;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">      <span class="attribute">-webkit-animation</span>: slide <span class="number">5s</span> alternate linear infinite;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">ul</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.box</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: blue;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="comment">/* 会导致无法压缩：squashingClippingContainerMismatch */</span></span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.inner</span> &#123;</span><br><span class="line">      <span class="attribute">position</span>: absolute;</span><br><span class="line">      <span class="attribute">top</span>: <span class="number">2px</span>;</span><br><span class="line">      <span class="attribute">left</span>: <span class="number">2px</span>;</span><br><span class="line">      <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">      <span class="attribute">line-height</span>: <span class="number">16px</span>;</span><br><span class="line">      <span class="attribute">padding</span>: <span class="number">2px</span>;</span><br><span class="line">      <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">      <span class="attribute">background-color</span>: green;</span><br><span class="line">    &#125;</span><br><span class="line"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 动画合成层 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"animating"</span>&gt;</span>composited animating<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- assume overlap --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- assume overlap --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"inner"</span>&gt;</span>asume overlap, 因为 squashingClippingContainerMismatch 无法压缩<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><a href="http://taobaofed.github.io/demo/performance-composite-demo/memory/layer-explode.html" target="_blank" rel="external">demo</a> 中，<code>.animating</code> 的合成层在运行动画，会导致 <code>.inner</code> 元素因为上文介绍过的 assumedOverlap 的原因，而被提升为合成层，同时，<code>.inner</code> 的父元素 <code>.box</code> 设置了 <code>overflow: hidden</code>，导致 <code>.inner</code> 的合成层因为 squashingClippingContainerMismatch 的原因，无法压缩，就出现了层爆炸的问题。</p>
<p><img src="https://img.alicdn.com/tps/TB1E7PEMXXXXXbAXpXXXXXXXXXX-1390-778.jpg_720x720.jpg" alt=""></p>
<p>这种情况平时在我们的业务中还是很常见的，比如 slider + list 的结构，一旦满足了无法进行层压缩的情况，就很容易出现层爆炸的问题。</p>
<p>解决层爆炸的问题，最佳方案是打破 overlap 的条件，也就是说让其他元素不要和合成层元素重叠。对于上述的示例，我们可以将 <code>.animation</code> 的 z-index 提高。修改后 <a href="http://taobaofed.github.io/demo/performance-composite-demo/memory/layer-explode-zIndex.html" target="_blank" rel="external">demo</a></p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.animating</span> &#123;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">/* 让其他元素不和合成层重叠 */</span></span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，就只有 <code>.animating</code> 提升为合成层，如下：</p>
<p><img src="https://img.alicdn.com/tps/TB1LxrnMXXXXXcIXVXXXXXXXXXX-1366-777.jpg_720x720.jpg" alt=""></p>
<p>同时，内存占用比起之前也降低了很多。</p>
<p><img src="https://img.alicdn.com/tps/TB1FoDwMXXXXXc2XFXXXXXXXXXX-947-485.jpg" alt=""></p>
<p>如果受限于视觉需要等因素，其他元素必须要覆盖在合成层之上，那应该尽量避免无法层压缩情况的出现。针对上述示例中，无法层压缩的情况（squashingClippingContainerMismatch），我们可以将 <code>.box</code> 的 <code>overflow: hidden</code> 去掉，这样就可以利用浏览器的层压缩了。修改后 <a href="http://taobaofed.github.io/demo/performance-composite-demo/memory/layer-explode-squash.html" target="_blank" rel="external">demo</a></p>
<p>此时，由于第一个 <code>.box</code> 因为 squashingLayerIsAnimating 的原因无法压缩，其他的都被压缩到了一起。</p>
<p><img src="https://img.alicdn.com/tps/TB1OE6uMXXXXXc8XFXXXXXXXXXX-1368-774.jpg_720x720.jpg" alt=""></p>
<p>同时，内存占用比起之前也降低了很多。</p>
<p><img src="https://img.alicdn.com/tps/TB1eYvqMXXXXXbJXVXXXXXXXXXX-936-480.jpg" alt=""></p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>之前无线开发时，大多数人都很喜欢使用 <code>translateZ(0)</code> 来进行所谓的硬件加速，以提升性能，但是性能优化并没有所谓的“银弹”，<code>translateZ(0)</code> 不是，本文列出的优化建议也不是。抛开了对页面的具体分析，任何的性能优化都是站不住脚的，盲目的使用一些优化措施，结果可能会适得其反。因此切实的去分析页面的实际性能表现，不断的改进测试，才是正确的优化途径。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://code.google.com/p/chromium/codesearch#chromium/src/third_party/WebKit/Source/core/paint/PaintLayer.h" target="_blank" rel="external">PaintLayer.h</a></li>
<li><a href="https://code.google.com/p/chromium/codesearch#chromium/src/third_party/WebKit/Source/core/paint/PaintLayer.cpp" target="_blank" rel="external">PaintLayer.cpp</a></li>
<li><a href="https://code.google.com/p/chromium/codesearch#chromium/src/third_party/WebKit/Source/platform/graphics/CompositingReasons.cpp" target="_blank" rel="external">CompositingReasons.cpp</a></li>
<li><a href="https://code.google.com/p/chromium/codesearch#chromium/src/third_party/WebKit/Source/platform/graphics/CompositingReasons.h" target="_blank" rel="external">CompositingReasons.h</a></li>
<li><a href="https://code.google.com/p/chromium/codesearch#chromium/src/third_party/WebKit/Source/core/layout/compositing/CompositingRequirementsUpdater.cpp&amp;q=CompositingRequirementsUpdater&amp;sq=package:chromium&amp;type=cs&amp;l=212" target="_blank" rel="external">CompositingRequirementsUpdater.cpp</a></li>
<li><a href="https://www.chromium.org/developers/testing/webkit-layout-tests" target="_blank" rel="external">chrome layout test</a></li>
<li><a href="https://www.chromium.org/blink/slimming-paint" target="_blank" rel="external">Slimming Paint</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context" target="_blank" rel="external">The stacking contest</a></li>
<li><a href="https://docs.google.com/presentation/d/1WOhbWLkhMyo4vZUaHq-FO-mt0B2sejXw-lMwohD5iUo/edit?pref=2&amp;pli=1#slide=id.g2a949df15_00" target="_blank" rel="external">Blink Compositing Update: Recap and Squashing</a></li>
<li><a href="http://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome" target="_blank" rel="external">GPU Accelerated Compositing in Chrome</a></li>
<li><a href="http://csstriggers.com/" target="_blank" rel="external">CSS Triggers</a></li>
<li><a href="https://developers.google.com/web/fundamentals/performance/rendering/?hl=zh-cn" target="_blank" rel="external">google render performance</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img.alicdn.com/tfs/TB1XT4kMFXXXXaBXXXXXXXXXXXX-900-500.png" alt="无线性能优化：Composite"></p>
<p>一个 Web 页面的展示，简单来说可以认为经历了以下下几个]]>
    </summary>
    
      <category term="性能" scheme="http://taobaofed.org/tags/%E6%80%A7%E8%83%BD/"/>
    
      <category term="无线开发" scheme="http://taobaofed.org/categories/%E6%97%A0%E7%BA%BF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何定位 Node.js 的内存泄漏]]></title>
    <link href="http://taobaofed.org/blog/2016/04/15/how-to-find-memory-leak/"/>
    <id>http://taobaofed.org/blog/2016/04/15/how-to-find-memory-leak/</id>
    <published>2016-04-15T09:58:18.000Z</published>
    <updated>2016-07-22T05:20:24.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img.alicdn.com/tps/TB1Fs7jMpXXXXabXXXXXXXXXXXX-900-500.jpg" alt="如何定位 Node.js 的内存泄漏"></p>
<p>在 <a href="http://taobaofed.org/blog/2016/01/14/nodejs-memory-leak-analyze/">《一次 Node.js 应用内存暴涨分析》</a>中，我们处理了一个 Node.js vm 引发的内存泄漏问题，处理过程也是比较艰辛。而在我们实际开发中，可能经常会碰到内存泄漏的问题，但很多情况下，我们对于这种问题的处理是有些迷茫的，没有一定的操作流程，效率比较低。虽然这种问题对于经验的要求比较高，但如果有一个简单的排查流程，还是会有一定帮助的。</p>
<p>这里简单整理一个流程，欢迎一起探讨，补充。</p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>Node.js 进程的内存管理，都是有 V8 自动处理的，包括内存分配和释放。那么 V8 什么时候会将内存释放呢？</p>
<p>在 V8 内部，会为程序中的所有变量构建一个图，来表示变量间的关联关系，当变量从根节点无法触达时，就意味着这个变量不会再被使用了，就是可以回收的了。<br>而这个回收是一个过程性的，从快速 GC 到 最后的 Full GC，是需要一段时间的。<br>另外，Full GC 是有触发阈值的，所以可能会出现内存长期占用在一个高值，也可以算是一种内存泄漏，可以从《一次 Node.js 应用内存暴涨分析》中找到例子。还有一种就是引用不释放，导致无法进入 GC 环节，并且一直产生新的占用，这一般会发生在 Javascript 层面。</p>
<p>所以，定位内存泄漏问题，一般方案就是找那些不被使用又不会被释放的变量，处理了这些变量，问题一般就可以解决了。如果是 Node.js 底层变量不释放，除了提交 issue 等待解决外，只能通过优化启动参数来解决。</p>
<h2 id="如何找出并解决问题"><a href="#如何找出并解决问题" class="headerlink" title="如何找出并解决问题"></a>如何找出并解决问题</h2><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>工欲善其事必先利其器，在排查时，我们还是需要一些工具来帮忙的。</p>
<h4 id="devTool"><a href="#devTool" class="headerlink" title="devTool"></a>devTool</h4><p>这个是今年初出的 Node.js 调试工具，基于 Electron 将 Node.js 和 Chromium 的功能融合在了一起。操作起来比 node-inspector 方便，开放的 Timeline 功能还是比较实用的，虽然不是实时显示。<br>仅需要 <code>devtool xxx.js</code>，还可以通过 .devtoolrc 来进行参数定制，具体见 <a href="https://github.com/Jam3/devtool" target="_blank" rel="external">GitHub</a></p>
<h4 id="heapdump-chrome-devTool"><a href="#heapdump-chrome-devTool" class="headerlink" title="heapdump + chrome devTool"></a>heapdump + chrome devTool</h4><p>这个是比较传统的定位内存泄漏的组合。heapdump 可以直接在代码中调用生成内存快照，然后将快照文件导入到 chrome devTool 进行分析，之后操作其实和前者就差不多了。不过，这个方案和前者有一点区别就是，前者实际还是在浏览器环境中，所以生成的内存快照会有一些 DOM 对象的存在，会有一定的干扰。而这个方案，是直接调用底层 V8 的方法，生成的快照只有 Node.js 环境中的对象。</p>
<h4 id="memwatch"><a href="#memwatch" class="headerlink" title="memwatch"></a>memwatch</h4><p>这个可以在代码里直接使用，实时检测内存动态，当发生内存泄漏的时候，会触发 ‘leak’ 事件，会传递当前的堆状态，配合 heapdump 有奇效。详见 <a href="https://www.npmjs.com/package/memwatch" target="_blank" rel="external">memwatch</a>。</p>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><h4 id="一、重现问题"><a href="#一、重现问题" class="headerlink" title="一、重现问题"></a>一、重现问题</h4><p>对于垃圾回收，V8 引擎有很复杂的逻辑来决定什么时候进行回收。很多时候，当我们发现 Node.js 进程所使用的内存快速增长的时候，并不能确定是否是内存泄漏导致的，很有可能是程序设计问题，导致内存的不合理利用。只有当垃圾回收触发，未使用内存被释放后，内存增长还在持续，我们才能确定是发生了内存泄漏。</p>
<p>隐藏的内存泄漏问题，大多是有触发条件的，重现问题是需要这些条件的，所以我们在平时写代码的时候，可以将一些重要环节的参数细节打印在 log 中，这样我们在重现问题是就不会摸不着头脑，乱试一气。</p>
<p>有了参数可以用来重现问题，接下来要确定问题。我们要确定，这部分内存是否没有被 GC 正确释放。那么问题来了，我们如何知道程序进行了垃圾回收呢？很显然，等待并不是办法，我们要主动。</p>
<p>在 Node.js 的启动参数中，提供了暴露手动调用 GC 方法的参数，即 <code>--expose-gc</code>。我们用这个参数来启动应用后，就可以在代码中调用 <code>global.gc()</code> 手动触发垃圾回收操作。同时，使用 <code>process.memoryUsage().heapUsed</code> 获取进程运行时所占用的内存。如果 GC 之后，内存依然没有下降，就可以确定是内存泄露了。</p>
<h4 id="二、生成内存快照"><a href="#二、生成内存快照" class="headerlink" title="二、生成内存快照"></a>二、生成内存快照</h4><p>既然内存是问题，我们就需要获取程序运行的内存快照来帮助定位问题。但内存快照并不是随便打得，是有一定技巧的。</p>
<p>我们<strong>至少要生成三次内存快照</strong>，才能更好的定位问题。这三次中又一次要在问题出现前生成，之后可以在问题持续的过程中生成两次或更多。</p>
<p>为什么要这样做呢？理解起来很简单。第一次是为了获取正常情况下的堆栈信息，而在问题出现后，堆栈信息一定会发生变化，有了第一次的信息，我们才好进行后面的比对，过滤一些无用的信息。而后两次的快照，用来比对某一对象的堆栈变化，来确定是否是有问题的对象。下面会详细应用到。</p>
<h4 id="三、定位问题"><a href="#三、定位问题" class="headerlink" title="三、定位问题"></a>三、定位问题</h4><p>用 devTool 的可以忽略下面的过程：</p>
<blockquote>
<p>打开 Chrome Devtools ，进入到 Profiles 选项卡，点 Load 按钮，加载之前生成的快照。</p>
</blockquote>
<p>对于内存快照，有四个视图，Summary，Comparison，Containment，Statistics，这里面常用的是前三个。</p>
<p>在 Summary 视图中，我们可以看到当前快照的全部信息，以及多个快照之间的信息。在列表里显示的都是对象的构造函数名字，可以先忽略被括号包裹的对象，优先观察其他的对象，最后再来看他们。后面的 <code>shallow size</code> 表示的是对象自身的大小，<code>retained size</code> 表示的是对象和它依赖对象的大小，一般是 GC 不可达的。</p>
<p>在 Comparison 视图中，我们可以进行多个快照之间的对比，这个用处比较大，如果我们将前两次快照进行对比，可能比较快速的定位出问题的对象。注意观察 New、Deleted、Delta，如果是内存泄漏的对象，可能是一直在 New，而没有 Deleted。</p>
<p>在 Containment 视图中，我们可以查看整个 GC 路径，当然一般不会用到。因为展开在 Summary 和 Comparison 列举的每一项，都可以看到从 GC roots 到这个对象的路径。通过这些路径，你可以看到这个对象的句柄被什么持有，从而定位问题产生的原因。值的注意的是，其中背景色黄色的，表示这个对象在 Javascript 中还存在引用，所以可能没有被清除。如果是红色的，表示的是这个对象在 Javascript 中不存在引用，但是依然存活在内存中，一般常见于 DOM 对象，它们存放的位置和 Javascript 中对象还是有不同的，在 Node.js 中很少遇见。</p>
<p>更多的操作方法，可以看这个视频 <a href="https://youtu.be/L3ugr9BJqIs" target="_blank" rel="external">Memory Profiling with Chrome DevTools</a> 和 <a href="https://youtu.be/LaxbdIyBkL0" target="_blank" rel="external">Memory Management Masterclass</a>。还有 Chrome 的文档 <a href="https://developer.chrome.com/devtools/docs/javascript-memory-profiling" target="_blank" rel="external">Memory Profiling</a>（旧） 和 <a href="https://developers.google.com/web/tools/chrome-devtools/profile/memory-problems/memory-diagnosis" target="_blank" rel="external">Memory Diagnosis</a>（新）。讲的还是很详细的。（请自备梯子）</p>
<h4 id="四、解决问题"><a href="#四、解决问题" class="headerlink" title="四、解决问题"></a>四、解决问题</h4><p>一般在 Javascript 中存在引用而导致内存泄漏的情况，是比较好处理的，只需要在使用后及时的将引用释放掉即可。</p>
<p>但像 <a href="http://taobaofed.org/blog/2016/01/14/nodejs-memory-leak-analyze/">《一次 Node.js 应用内存暴涨分析》</a> 所存在的那种内存问题，是属于底层机制的问题，如果等不了 bugfix，就只能先通过一些启动参数来优化内存管理。常用的参数：</p>
<ul>
<li><code>--max-old-space-size</code> 限制老生区大小，可以控制内存占用的最大值，即使发生泄漏，也不会让内存占用保持很高。可以根据开启进程数以及是否同机部署来优化。</li>
<li><code>--gc_global</code> 这其实是个 V8 的 debug flag，让 GC 永远都是 Full GC，使用上会有一定的性能损耗，根据应用复杂度不同，损耗不同。</li>
</ul>
<p>当我们找到问题，进行修复后，重复上面的步骤，确认问题已经被解决。有时可能一次并不能解决问题，所以耐心还是很重要的。</p>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>可以在这里下载使用到的代码， <a href="https://github.com/taobaofed/demo" target="_blank" rel="external">GitHub</a>，进入 memory-leak 文件夹。<br>我们来举个例子，应用上面的步骤排查问题，使用 leak-memory 的例子，代码还有另外一个例子，可以自己实践。</p>
<p>这里我们为了方便，我们使用了 devTool。</p>
<p><code>devTool leak-memory.js</code></p>
<p>然后在打开的界面中进入内存快照界面，生成第一次快照。当控制台有输出后，间隔的生成两次快照，结果如下。</p>
<p><img src="http://img.alicdn.com/tps/TB1ejYNMpXXXXcsXVXXXXXXXXXX-2880-1708.jpg" alt="screenshot"></p>
<p>我们切换视图，对比下三次快照间的区别，可以看到 <code>Foo</code> 这个对象一直在创建而没有被删除。</p>
<p><img src="http://img.alicdn.com/tps/TB1utodMpXXXXcWXXXXXXXXXXXX-2876-660.jpg" alt="screenshot"></p>
<p><img src="http://img.alicdn.com/tps/TB1FYDUMpXXXXc1XFXXXXXXXXXX-2880-474.jpg" alt="screenshot"></p>
<p>我们展开 <code>Foo</code>，选择下面的一个实例，查看它的 GC path，可以看到它一直被 neverRelease 持有引用（黄色），所以没有被释放，之后就可以进行问题的处理了。</p>
<p><img src="http://img.alicdn.com/tps/TB1DUz4MpXXXXXLXFXXXXXXXXXX-2876-852.jpg" alt="screenshot"></p>
<p>去掉 <code>// neverRelease.splice(index, 1);</code>  前的注释，然后在重复上面的步骤，你会发现内存的变化已经正常了。</p>
<blockquote>
<p>在使用 devTool 时，可以查看运行时的 memory timeline，如果图像呈现阶梯式增长，一般就是存在内存泄漏问题了。正常的应用曲线会类似于锯齿，如图：</p>
</blockquote>
<p><img src="http://img.alicdn.com/tps/TB17UkfMpXXXXbEXXXXXXXXXXXX-2358-500.jpg" alt="screenshot"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><p>内存泄漏问题的定位，经验很重要，但有了良好工具的辅助，可以节省很多时间。如果懒得自己一步步的操作，可以接入 <a href="http://alinode.aliyun.com/" target="_blank" rel="external">alinode</a>，这个可以帮助你很方便的生成快照等运行时数据，并有一定的分析辅助，还是方便的。</p>
</li>
<li><p>你可能看到很多内存分析的文章会有一些图来表示内存的增长，可以使用 python 来快速生成相关的图片，使用 <code>matplotlib.pyplot</code> 这个包。</p>
</li>
</ol>
<p><img src="http://img.alicdn.com/tps/TB1J8gkMpXXXXXuXXXXXXXXXXXX-1194-914.jpg" alt="screenshot"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://developers.google.com/web/tools/chrome-devtools/profile/memory-problems/memory-diagnosis" target="_blank" rel="external">memory-diagnosis</a></li>
<li><a href="https://www.youtube.com/watch?v=L3ugr9BJqIs&amp;feature=youtu.be" target="_blank" rel="external">Memory Profiling with Chrome DevTools</a></li>
<li><a href="http://www.alexkras.com/simple-guide-to-finding-a-javascript-memory-leak-in-node-js/" target="_blank" rel="external">Simple Guide to Finding a JavaScript Memory Leak in Node.js</a></li>
<li><a href="http://jayconrod.com/posts/55/a-tour-of-v8-garbage-collection" target="_blank" rel="external">A tour of V8: Garbage Collection</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img.alicdn.com/tps/TB1Fs7jMpXXXXabXXXXXXXXXXXX-900-500.jpg" alt="如何定位 Node.js 的内存泄漏"></p>
<p>在 <a href="http://taobaofed]]>
    </summary>
    
      <category term="Node.js" scheme="http://taobaofed.org/tags/Node-js/"/>
    
      <category term="memory leak" scheme="http://taobaofed.org/tags/memory-leak/"/>
    
      <category term="Node.js" scheme="http://taobaofed.org/categories/Node-js/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[H5 页面高级字体应用实践]]></title>
    <link href="http://taobaofed.org/blog/2016/04/12/webfont-practice/"/>
    <id>http://taobaofed.org/blog/2016/04/12/webfont-practice/</id>
    <published>2016-04-12T01:11:03.000Z</published>
    <updated>2016-07-22T05:20:24.000Z</updated>
    <content type="html"><![CDATA[<p><img src="//img.alicdn.com/tps/TB1kaazMpXXXXacXFXXXXXXXXXX-900-500.jpg" alt="H5 页面高级字体应用实践"></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ul>
<li>最近在开发一个 H5 活动页快速搭建平台，可以通过拖拽编辑图片，文字等元素组件，快速搭建出一个移动端的活动页面，基本交互和成品效果类似 PPT 软件。这类活动大量在微信等平台上传播，其中会包含各种动画和特效，而各类高级艺术字体（如：方正兰亭黑，方正彩云，方正大草，方正剑体等）的应用也非常广泛。</li>
<li>之前用户只能通过 ps 等软件将文字转化为图片再贴到平台上使用。使用成本很高，修改，调试都非常不便，而且图片占用的资源也比较多，为了降低用户的使用成本，基于一站式搭建的理念，我们需要将高级字体的使用透明化，使用户和使用 PPT 一样直接选择字体使用即可。</li>
</ul>
<h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><ul>
<li>第一种方案是通过用户输入的文字，和选择的字体，通过服务器生成对应的图片来使用。这种方案的优点是逻辑简单，缺点是搭建/修改时增加了复杂度，调试时无法实时预览文字在活动中的效果。而且容易出现大量冗余图片，最终页面的图片请求也会增加。</li>
<li>第二种方案是调用 iconfont.cn 的服务接口，通过传递字体和文字内容来获取字体文件。这种方案的优点是可以直接利用现有成熟平台，开发成本低，可靠。缺点是增加了外部依赖，不但面临合作方配合的限制，而且无法自行控制可供的选择字体等。</li>
<li>最终采用的的第三种方案是直接使用 iconfont.cn 的 Node.js 模块 （font-carrier） ，自行解析/生成字体，将生成的字体放在我们自己申请的 OSS 中存储使用。这种方法的开发量最大，且要消耗额外的 OSS 资源，但是整个流程独立自主，可以不断定制优化，自行添加字体等，由于我们的服务只面向移动端，所以只需要生成 ttf 或者 woff 一种文件类型即可兼容。</li>
</ul>
<h2 id="字体文件解析的基本原理"><a href="#字体文件解析的基本原理" class="headerlink" title="字体文件解析的基本原理"></a>字体文件解析的基本原理</h2><h3 id="字体文件的核心结构"><a href="#字体文件的核心结构" class="headerlink" title="字体文件的核心结构"></a>字体文件的核心结构</h3><p>以 ttf 文件为例，字体文件中主要包含了字体头表，位置索引表和图元数据表等等，其中最核心的部分就是图元数据表，也就是字形描述表，它可以包含可变数目的图元，每个图元可以有不同数目的控制点，甚至还可以有数量可变的图元指令，通过位置索引表对应到每个字符上，通过图元数据表，使其只包含需要使用的字符的图元描述。即可最小化字体，使其可用于生产环境的页面中，其他类型的字体文件（如 woff， eot， svg 等）原理也是大同小异，仅仅是压缩方式和字形描述规范不同，也可以互相转化。</p>
<h3 id="font-carrier-模块基本原理"><a href="#font-carrier-模块基本原理" class="headerlink" title="font-carrier 模块基本原理"></a>font-carrier 模块基本原理</h3><p>font-carrier 模块使用 OpenType 模块分析 ttf 文件，可以文件的内容脚本化，使其成为一个字符 unicode 编码和其字形描述的键值对象。通过对这个对象的 min 方法，可以使其最小化，并且再逆向生成文件 Buffer 供用户使用。</p>
<h2 id="一期实现流程"><a href="#一期实现流程" class="headerlink" title="一期实现流程"></a>一期实现流程</h2><ul>
<li>在程序启动后通过 font-carrier 模块将本地的字体文件包装成字体对象，保存在服务器内存中。</li>
<li>用户保存页面时，记录下此活动所有使用的高级字体和相应的文字内容</li>
<li>通过 font-carrier 模块找到字体对应的字体对象，使用 min 命令生成最小化的字体对象</li>
<li>使用 min 命令生成缩小后的字体文件，保存到 OSS，并以活动的 id 为路径，字体的名字为文件名。</li>
<li>最终渲染时通过记录的活动使用的字体名拼出 OSS 路径来引用文件</li>
</ul>
<h4 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h4><ul>
<li>由于字体数量较多，启动时将本地字体文件包装成字体对象的时间非常长，可达到数十分钟。</li>
<li>字体对象常驻内存，占用巨大，甚至可能直接吃光内存</li>
</ul>
<h4 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h4><p>因为 font-carrier 模块生成的字体对象无法通过文件来持久化保存，只能生成后常驻内存中，而字体的数量多，大小也大，所以不管是生成的时间，生成时消耗的性能，生成后占用的内存都非常巨大。所以问题的关键在于如何把字体的分析结果持久化保存在服务器中。</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>在咨询了 font-carrier 模块的开发者后，了解到 font-carrier 模块还有生成字体的 svg 片段的方法，可以将字体的图元数据转变为 svg 输出，并可以将 svg 逆向导入到空字体文件中来生成最终字体文件。<br>通过将字体分析转译后的 svg 片段结果保存在数据库中，即可持久化分析结果。使用的时候通过创建空字体-&gt;配置字符-svg 的对应关系-&gt;提取字体-&gt;上传到 OSS 的流程来使用最小化后的字体即可。</p>
<h2 id="二期实现流程"><a href="#二期实现流程" class="headerlink" title="二期实现流程"></a>二期实现流程</h2><ul>
<li>建立提取字体任务，运行时遍历字体文件，提取其中的 svg 片段存入数据库</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> transFont = fontCarrier.transfer(__dirname + <span class="string">'/../../www/fonts/'</span> + fontInfo.font_name + <span class="string">'.ttf'</span>);</span><br><span class="line"><span class="keyword">var</span> words = [];</span><br><span class="line">	_.each(transFont.__glyphs， <span class="function"><span class="keyword">function</span>(<span class="params">n, word</span>) </span>&#123;</span><br><span class="line">	words.push(&#123;</span><br><span class="line">	  word: word,</span><br><span class="line">	  fontId: fontInfo.id,</span><br><span class="line">	  svg: transFont.getSvg(word, &#123;</span><br><span class="line">	    skipViewport: <span class="literal">true</span></span><br><span class="line">	  &#125;)</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>以下是一段方正喵呜体中的“我”字提取的 svg 片段<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line">  <span class="meta">&lt;!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">svg</span> <span class="attr">version</span>=<span class="string">"1.1"</span> <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/2000/svg"</span> <span class="attr">xmlns:xlink</span>=<span class="string">"http://www.w3.org/1999/xlink"</span> <span class="attr">x</span>=<span class="string">"0"</span> <span class="attr">y</span>=<span class="string">"0"</span> <span class="attr">width</span>=<span class="string">"100px"</span> <span class="attr">height</span>=<span class="string">"100px"</span> <span class="attr">viewBox</span>=<span class="string">"0 0 1000 1000"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">"M324 857Q324 837 332 819 340 801 340 775 317 775 296.5 776.5 276 778 253 778 237 778 224.5 769.5 212 761 212 742 212 731 221 722 230 713 242 712L333 703Q348 703 353 691 357 662 357.5 643 358 624 358 596L358 559Q357 554 353 554 351 554 349 554 313 554 278 558.5 243 563 208 563 193 563 182 557 171 551 171 533.5 171 516 184 507 197 498 217.5 494 238 490 261 489 286 489 306.5 488.5 327 488 342 487 357 486 358 479L358 461Q358 458 356.5 434.5 355 411 352 384 349 357 344.5 335 340 313 333 313 332 313 329 315 326 317 325 318L270 372Q265 377 259 378 255 381 248 381 217 381 217 348 217 340 218 334 219 328 225 322L420 132Q426 125 432 124 438 123 446 123 460 123 469.5 130.5 479 138 479 152 479 160 474 168 471 176 465 181 462 185 452.5 194.5 443 204 432 214.5 421 225 411.5 234.5 402 244 399 247 398 249 397 252 396 255 395 256L395 259 395 260Q402 290 408 315 414 340 417.5 364.5 421 389 423.5 414.5 426 440 428 471L433 479Q433 480 442 480 451 480 456 480 475 480 492 479.5 509 479 528 476L528 449Q528 399 523.5 348.5 519 298 519 247 519 228 523 215 529 201 550 201 565 201 573 209.5 581 218 584 231 587 244 587.5 257.5 588 271 589 281 589 287 591 310 593 335 594 362 595 389 596 412 598 437 598 442 598 447 598 451 598 457 600 462L602 476 611 479 723 479Q742 480 759.5 486.5 777 493 777 515 777 526 770.5 536 764 546 752 546L628 546 615 550Q614 551 614 553 614 557 614 559 614 564 619 583 623 604 629 625 635 646 642.5 663 650 680 656 680 666 680 673 667 682 655 691 639 701 625 714 611 726 599 743 599 756 599 766.5 606.5 777 614 777 629 777 642 764.5 658.5 752 675 736 692 722 709 709 723 697 739 697 747L697 748Q697 749 698 749 704 756 710 764 718 773 726.5 780.5 735 788 745 794 755 800 764.5 800 774 800 782 796 790 794 799 794 812 794 821 805 830 816 830 829 830 851 812 862 796 873 777 873 755 873 736.5 866 718 859 701.5 847 685 835 669.5 821 654 807 640 795 631 800 623.5 806.5 616 813 609 818.5 602 824 593.5 828.5 585 833 575 833 544 833 544 803 544 798 544.5 794.5 545 791 548 786L598 737 598 725Q576 688 562.5 642 549 596 540 554 538 550 532.5 548 527 546 522 546L519 546Q514 546 503 546 493 548 481.5 548.5 470 549 459.5 549.5 449 550 445 550 442 552 438.5 553.5 435 555 433.5 558.5 432 562 429 574 428 588 428 591 428 596 427.5 607.5 427 619 426 632.5 425 646 424 657 424 670 424 674 424 681 426 682 428 683 432 683 444 683 454.5 681 465 679 477.5 679 490 679 500.5 686.5 511 694 511 708 511 727 499 733 486 741 470 744 454 747 439.5 749 425 751 420 761 419 763 417.5 767.5 416 772 416 774 415 779 411.5 791.5 408 804 404.5 817.5 401 831 398 843 396 857 395 861 385 886 357 886 343 886 333.5 878.5 324 871 324 857M668 269Q668 254 677 246 687 240 699 240 716 240 726 251 736 262 743 277 745 281 750 292 755 303 760 316 765 329 769.5 339.5 774 350 777 355L777 369Q777 385 770.5 393.5 764 402 746 402 735 402 721.5 385 708 368 696.5 346 685 324 676 301 668 280 668 269Z"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>保存活动时创建空字体，导入需要的字符和其对应的 svg，并将这个字体保存到 OSS</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建空白字体，使用 svg 生成字体</span></span><br><span class="line"><span class="keyword">var</span> font = fontCarrier.create();</span><br><span class="line">values.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  font.setSvg(v.word，v.svg);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">return</span> font.output(&#123;</span><br><span class="line">  types:[<span class="string">'woff'</span>]</span><br><span class="line">&#125;)[<span class="string">'woff'</span>];</span><br></pre></td></tr></table></figure>
<ul>
<li>最终渲染时通过的记录的活动使用的字体名拼出 OSS 路径来引用文件</li>
</ul>
<h4 id="新的问题"><a href="#新的问题" class="headerlink" title="新的问题"></a>新的问题</h4><p>在正常运行了一段时间后，用户反馈了新的问题，编辑和预览时的字宽度不匹配，现象为所有的字符都变为了全角模式，数字，字母和符号，都占用了一个汉字的位置。如图：</p>
<p><img src="http://img4.tbcdn.cn/L1/461/1/bf9de797cecf959b7becc43476a85c32f49b6ea3.png" alt="新的问题"></p>
<h4 id="分析问题-1"><a href="#分析问题-1" class="headerlink" title="分析问题"></a>分析问题</h4><p>经过排查和测试，最后发现原因在于生成 svg 片段时，模块给这个 svg 加上了宽和高，这是不必要的，在显示汉字等全角字符时，一切正常，而在显示半角字符时，则会导致两边出现空隙。</p>
<h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><p>在无法改变 font-carrier 模块的前提下，只能在我们自己的流程中加补丁，我在读取 svg 使用前，额外增加了替换代码将宽高删除，证明可以解决该问题。另外我也知会了模块开发者，在未来的版本中修复此问题。修复后效果如图：</p>
<p><img src="http://img1.tbcdn.cn/L1/461/1/f61a003304e10548610be4c933c13b6a83a06c5d.png" alt="修复问题"></p>
<h2 id="未来展望"><a href="#未来展望" class="headerlink" title="未来展望"></a>未来展望</h2><ul>
<li>目前我们采用引用字体文件的方式来定义高级字体，而最近团队的无线端最佳实践的要求，无线端使用的字体将字体文件 base 64 化，以减少请求数，未来我们也将改造成这种方式，不但符合最佳实践的要求，同时还可以节省 OSS 存储的资源。</li>
<li>下一阶段我们将调研 svg 在移动端的兼容性和性能，未来开发的插入几何形状功能将考虑使用这一技术，同是我们也会尝试直接用 svg 绘制字体，产生更多的可能性（比如 svg 动画等），需要考虑兼容性和渐进方案。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="//img.alicdn.com/tps/TB1kaazMpXXXXacXFXXXXXXXXXX-900-500.jpg" alt="H5 页面高级字体应用实践"></p>
<h2 id="背景"><a href="#背景" class="headerl]]>
    </summary>
    
      <category term="webfont" scheme="http://taobaofed.org/tags/webfont/"/>
    
      <category term="艺术字" scheme="http://taobaofed.org/tags/%E8%89%BA%E6%9C%AF%E5%AD%97/"/>
    
      <category term="字体" scheme="http://taobaofed.org/tags/%E5%AD%97%E4%BD%93/"/>
    
      <category term="TTF" scheme="http://taobaofed.org/tags/TTF/"/>
    
      <category term="无线开发" scheme="http://taobaofed.org/categories/%E6%97%A0%E7%BA%BF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[企业级 Node.js Web 应用解决方案设计的零零总总]]></title>
    <link href="http://taobaofed.org/blog/2016/04/08/node-web-framework-design/"/>
    <id>http://taobaofed.org/blog/2016/04/08/node-web-framework-design/</id>
    <published>2016-04-08T08:28:29.000Z</published>
    <updated>2016-07-22T05:20:24.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://gtms01.alicdn.com/tps/i1/TB146VMMpXXXXXqXXXXWPiOLXXX-900-500.jpeg" alt="企业级 Node.js Web 应用解决方案设计的零零总总"></p>
<p>年前一直在忙着做新版 Midway 升级的事情，不少同学都知道 Midway 是淘宝的 Node.js Web 应用解决方案，目的是为了更好的做前后端分离，让前端同学开发更简单，生活更幸福（笑）。</p>
<p>如今 Midway 5 正式发布了，横跨了几个月的开发个工作，期间带来的感慨，也算是史上最多。</p>
<p>Midway 的诞生也有 2 年多的时间，我个人参与维护也有 1 年多，经历了从 v3 到 v5 的变化，最大的感慨莫过于，<strong>分分合合</strong>，以前总想着灵活性，要做分离，后来就想着统一升级，又合并回去， 折腾的是自己，也是用户，不管怎么说，之前欠着的债总是要还的，历史包袱总是框架开发者的胸口大石，不破不立才是最终的方案。</p>
<h2 id="代码风格选型"><a href="#代码风格选型" class="headerlink" title="代码风格选型"></a>代码风格选型</h2><p>随着 ES6 乃至 ES2015 的出现，<code>generator</code> 和 <code>promise</code> 配合的开发方式渐渐的趋于稳定和标准化，再结合未来 <code>async/await</code> 的方式，使用 <code>Koa 1.0</code> 是比较中和的选择，在 2.0 推出之前，可以使用  <code>yield</code> 的写法来简化异步操作，将大部分的异步代码扁平化，同时也可以对未来的 <code>Koa 2.0</code> 代码进行一个很好的兼容和补充。</p>
<p>有人不禁会问，为什么不用 <code>babel</code> ，当然这是一种选择，在 <code>Node.js</code> 没有原生支持这些语法特性，乃至 <code>--harmony</code> 也无法启用的新特性的时候，我们不会考虑使用，这是在做企业级框架的一些基本原则，在面对数千万用户的期待的时候，我们不能拿稳定性来试错。</p>
<h2 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h2><p>框架的稳定性和业务的稳定性是两个不同的方向，业务需要的是容错，而框架需要的是兜底。很多时候业务代码只需要 <code>try/catch</code> 就能解决，再不然 <code>promise.catch</code> 也好，然后 <code>logger.error</code> 就可以了，但是框架不行。</p>
<p>Midway 使用的是 <code>Master/Agent/Worker</code> 进程方案，同时会启动 N+2 的进程，每个 Worker 进程可能会和 <code>Master/Agent</code> 进程进行通信，一旦有进程错误甚至挂掉，都是一个复杂的情况，所以要处理所有类型的错误就变得非常重要。</p>
<p>进程本身有着一些简单的处理，比如在接受到正常的信息消息的时候正常退出流程，并且杀死其他子进程（碰到过其他子进程杀不死的，所以要强制再杀一下）:</p>
<pre><code>// SIGTERM AND SIGINT will trigger the exit event.
process.once(&apos;SIGQUIT&apos;, function() {
  process.exit(0);
});

process.once(&apos;SIGTERM&apos;, function() {
  process.exit(0);
});

process.once(&apos;SIGINT&apos;, function() {
  process.exit(0);
});

process.on(&apos;exit&apos;, function(code) {
  killAgentWorker();
});
</code></pre><p>当然，进程也有一些奇奇怪怪的异常，这些异常必须通过日志记录，然后才能进行安全的退出或者其他自定义行为。</p>
<pre><code>process.on(&apos;unhandledRejection&apos;, function(err, p) {
     //logger
});
</code></pre><p>除了以上标准流程之外，就得考虑非主进程出错退出时的情况并做相应的处理，比如 Agent 进程属于非常重要的业务进程，假如第一次启动就出问题，那必然需要强制退出，如果进程在某些情况下意外挂掉，必须有一些自重启机制来保证稳定运行，同时需要处理一些事件（之前出现过事件绑定过多内存泄露的事故）。</p>
<pre><code>agentWorker.once(&apos;exit&apos;, function(code, signal) {
  coreLogger.error(err);
  // 防止事件泄漏
  agentWorker.removeAllListeners(&apos;message&apos;);
  agentWorker = null;

  if (allWorkerStartSuccess) {
    // restart agent
    setTimeout(startAgent.bind(null, opts), 1000);
  } else {
    // AgentWorker 初始化过程发生异常，主进程直接退出
    // coreLogger.error(&apos;Agent worker init exception occurs. Master exits therefor.&apos;);
    process.exit(1);
  }
});
</code></pre><p>Worker 进程虽然使用 cluster 机制来启动，但是处理方式和 Agent 差不太多，除了挂掉自启之外，还需要有一些不一样的地方，比如进程的数量，原本默认的是 CPU 的核数，但是可能会根据当前的运行环境稍稍进行一些降低以保证内存的可用。此外，进程重启次数过多可能也是一大问题，需要进行额外的计数和报警，当然代码很简单，这边就不再赘述。</p>
<p>当然框架稳定性不仅仅只有这些，进程的处理只是最重要的一环，整个架构的设计中都必须考虑。</p>
<h2 id="框架设计"><a href="#框架设计" class="headerlink" title="框架设计"></a>框架设计</h2><p>Midway 新的设计理念是 <code>Everything is a plugin</code>，即所有的都是插件，包括框架和普通应用，这样的设计可以最大化的复用代码，简化使用。</p>
<p>一个简单的应用的结构和插件的结构，乃至框架的结构大致是一样的，经过集团 Node 小组的讨论形成了一套规范，也算是一次大统一。</p>
<pre><code>app_name/
├─app/   
|  ├─extends/
|  │  └─application.js      
│  ├─controllers/         
│  │  └─home.js            
│  ├─router.js             
│  └─views/               
│     └─home.xtpl 
├─bin/                     
│  ├─build.sh
│  └─server.js 
├─config/
│  ├─config.js 
│  ├─config.local.conf 
│  ├─config.prod.conf 
├─node_modules/
├─package.json              
└─README.md
</code></pre><p>看起来非常简单，除了常见的 node_modules 之外，还有一些淘宝特有的 <code>bin/app</code> 目录和一些 <code>xtpl</code> 模板文件。_bin 是启动目录，这边暂且不谈。</p>
<p>所有的插件的目录结构除了没有 <code>controllers</code> 和 <code>routers</code> 之外，和应用的目录结构是一样的，这其中最重要的一环就是加载方式。</p>
<p>Midway 的加载思路非常清晰简单：</p>
<ul>
<li>顺序加载插件</li>
<li>把应用作为最后一个插件加载进来</li>
<li>后边的插件覆盖之前的插件</li>
</ul>
<p>作为一个需要满足大部分场景的框架（插件、应用），需要加载东西有几样，配置文件、Koa 扩展、中间件，控制器，路由，这个时候需要一个通用的加载方法，这个方法可能是长这个样子。</p>
<pre><code>_loadFiles(files, opts) {
  //...

  loadDirs.forEach((dir)=&gt; {
    let fileResults = globby.sync(files, {cwd: dir});

    fileResults.forEach((f)=&gt; {
      let m = util.tryRequire(path.join(dir, f), opts.required);
      let result = (is.function(m) &amp;&amp; !is.class(m) &amp;&amp; needCall) ? m.apply(this, opts.inject ? [].concat(opts.inject) : [this.app]) : m;

      results.push(opts.resultHandler ? opts.resultHandler.call(this, result, f, dir, m) : result);

      if (opts.target) {
        extend(true, opts.target, result);
      }
    });
  });

  return results;
}
</code></pre><p>整个方法核心的思路就是加载(<code>tryRequire</code>)，除此之外，就是对加载之后的内容进行判断，处理，合并，返回。所有的加载都通过这一方法来做，就目前来看，大部分场景都已经满足了（笑）。</p>
<p>至此，一个框架的主线已经比较明确，核心功能也可用，剩下的就是插件的开发和补充，以及一些细节的修补。</p>
<h2 id="细节和纠结"><a href="#细节和纠结" class="headerlink" title="细节和纠结"></a>细节和纠结</h2><p>一个企业级框架的开发肯定没那么简单，主线设计相对容易一些，更麻烦的是细节，往往细节才是区别不同的框架最重要的地方。</p>
<h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><p>框架的历史包袱很大一部分体现在升级和兼容性上，但是框架的大版本更新往往是很多的不兼容，要让旧版本用户升级是一件非常头疼的事情。</p>
<p>Midway 也一样。</p>
<p>以前的 Midway 使用的是 <code>Proxy</code> 方式，所有暴露的外部接口都从 <code>midway.getXXXX</code> 中体现，而现有的进程加载方式使得 Midway 从 Worker 进程变为了 Master 进程，导致无法使用原本的方式了。</p>
<p>经历了多次讨论，最后还是为了用户妥协，将入口的文件(require 的部分) 变为 Worker ，而真正用户启动的 <code>server.js</code> 变为了 <code>midway/server</code>，也算是一个圆满的解决方案。</p>
<h3 id="测试和调试"><a href="#测试和调试" class="headerlink" title="测试和调试"></a>测试和调试</h3><p>由于将 Worker 机制内置到了 Midway 框架中，本来用户通过 app.js 的调试方式就行不通了，现在必须通过 <code>bin/server.js</code> 的方式来调试，略显繁琐。</p>
<p>根据新升级的 <a href="http://taobaofed.org/blog/2016/01/26/nodejs-ipc/">IPC 通信方式</a>，我们想到了可以通过只启动一个进程的方式来调试代码。所以在测试用例中也可以不用启动多个进程来测试代码了。</p>
<p>在大部分情况下测试代码使用 <code>mocha + supertest</code> 已经可以完美的完成了，但是偶尔会在运行多个的时候抽个风，这个问题属于 Agent 进程通信在本地无法判断出相同目录下是否是同一个实例的问题，除此之外，其他还没发现问题（笑:)）。</p>
<h3 id="更新机制"><a href="#更新机制" class="headerlink" title="更新机制"></a>更新机制</h3><p>新 Midway 的设计理念是简化开发，以往的经历告诉我们，推动用户升级是不现实的，花了许多的时间在给用户升级脚本，升级 Node.js 上，不仅给自己带来了很多不必要的工作量，也给用户带来了很多麻烦和隐患。</p>
<p>在新的设计中，把插件都内置到了自身的依赖中，由框架统一来处理版本，同时，把打包脚本和启动脚本也固化到了框架中，随着框架一起升级，至少在框架使用到现在，已经非常明显的减少客服量。</p>
<p>Midway 本身的升级由 <code>npm tag</code> 版本来控制，这个是由脚手架来处理的，用户每次部署 <code>install</code>，都使用的是该版本最新的框架。</p>
<pre><code>&quot;publishConfig&quot;: {
   &quot;tag&quot;: &quot;release-5.1&quot;
 },
</code></pre><p>当然这样的行为也是有隐患的，比如某个插件升级导致框架出错，不过作为一个内部的框架，我们尽可能保证插件的兼容性和稳定性，必须符合 <a href="http://semver.org/" target="_blank" rel="external">semver</a> 的版本规范，必须有一定的测试覆盖率，如果有不兼容的情况，整个框架都会一起升级 tag，尽可能减少给用户带来问题的机会。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>一个解决方案、一个框架的诞生背后总有一群抓耳挠腮的开发者，经常为了一些小的地方，团队会讨论许久，不光是为用户负责，也对自己负责，Midway 不会走 102 年，只是希望在能做的事情上，稍微多做一点罢了。</p>
<p>想来随着 Midway 5 的发布，有一阵子可以不用考虑该如何权衡和取舍了，可以更加把事情专注在服务用户，提升效率这些事情上了（笑）。</p>
<p>最后，铭记，不忘初心，奋勇前行。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://gtms01.alicdn.com/tps/i1/TB146VMMpXXXXXqXXXXWPiOLXXX-900-500.jpeg" alt="企业级 Node.js Web 应用解决方案设计的零零总总"></p>
<p>年前一直在忙着做新]]>
    </summary>
    
      <category term="node.js" scheme="http://taobaofed.org/tags/node-js/"/>
    
      <category term="midway" scheme="http://taobaofed.org/tags/midway/"/>
    
      <category term="Node.js" scheme="http://taobaofed.org/categories/Node-js/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[淘宝首页性能优化实践]]></title>
    <link href="http://taobaofed.org/blog/2016/04/05/optimize-in-tbhome/"/>
    <id>http://taobaofed.org/blog/2016/04/05/optimize-in-tbhome/</id>
    <published>2016-04-05T08:17:53.000Z</published>
    <updated>2016-07-22T05:20:24.000Z</updated>
    <content type="html"><![CDATA[<p><img src="https://img.alicdn.com/tps/TB1QzViMpXXXXXZXXXXXXXXXXXX-900-500.jpg" alt="淘宝首页性能优化实践"></p>
<p>想必很多人都已经看到了新版的淘宝首页，它与以往不太一样，这一版页面中四处弥散着个性化的味道，由于独特的个性化需求，前端也面临各方面的技术挑战：</p>
<ul>
<li>数据来源多</li>
<li>串行请求渲染一个模块</li>
<li>运营数据和个性化数据匹配和管理</li>
<li>数据兜底容灾</li>
</ul>
<p>本次淘宝首页改版，虽已不再支持 IE6 和 IE7 等低版本的古董浏览器，但依然存在多个影响首页性能的因素：</p>
<ul>
<li><b>依赖系统过多</b>，数据的请求分为三块，其一是静态资源（如 js/css/image/iconfont 等）；其二是推到 CDN 的静态数据（如运营填写的数据、前端配置信息等）；其三是后端接口，不同的模块对应不同的业务，而且页面中还有不少的广告内容，粗略估计页面刚加载时首屏发出的接口请求就有 8 个，滚到最底下，得发出 20 多个请求。</li>
<li><b>无法直接输出首屏数据</b>，首屏很多数据是通过异步请求获取的，由于系统限制，这些请求不可避免，而且请求个数较多，十分影响首屏时间。</li>
<li><b>模块过多</b>，为了能够在后台隔离运营之间填写数据的权限，模块必须做细粒度的拆分，如下图所示：<br><img src="http://gtms01.alicdn.com/tps/i1/TB1W6IyLVXXXXbQaXXXvLv21FXX-1846-1074.png_800x800.jpg" alt="多模块的拆分"><br>一个简单的模块必须拆分成多个行业小模块，页面中其他位置也是如此，而且这些被拆分出来的模块还不一定会展现出来，需要让算法告诉前端展示哪些模块。</li>
<li><b>图片过多</b>，翻页往下滚动，很明显看到，页面整屏整屏的图片，有些图片是运营填写，有些图片由个性化接口提供，这些图片都没有固定的尺寸。</li>
</ul>
<h2 id="网页性能衡量指标"><a href="#网页性能衡量指标" class="headerlink" title="网页性能衡量指标"></a>网页性能衡量指标</h2><p>网页性能衡量指标有很多，倘若能够把握关键的几个，集中优化，性能自然也就上去了。</p>
<h3 id="FPS"><a href="#FPS" class="headerlink" title="FPS"></a>FPS</h3><p>最能反映页面性能的一个指标是 FPS（frame per second），一般系统设定屏幕的刷新率为 60fps，当页面元素动画、滚动或者渐变时绘制速率小于 60，就会不流畅，小于 24 就会卡顿，小于 12 基本认定卡爆了。</p>
<p>1 帧的时长约 16ms，除去系统上下文切换开销，每一帧中只留给我们 10ms 左右的程序处理时间，如果一段脚本的处理时间超过 10ms，那么这一帧就可以被认定为丢失，如果处理时间超过 26ms，可以认定连续两帧丢失，依次类推。我们不能容忍页面中多次出现连续丢失五六帧的情况，也就是说必须想办法分拆执行时间超过 80ms 的代码程序，这个工作并不轻松。</p>
<p>页面在刚开始载入的时候，需要初始化很多程序，也可能有大量耗时的 DOM 操作，所以前 1s 的必要操作会导致帧率很低，我们可以忽略。当然，这是对 PC 而言，Mobile 内容少，无论是 DOM 还是 JS 脚本量都远小于 PC，1s 可能就有点长了。</p>
<h3 id="DOMContentLoaded-和-Load"><a href="#DOMContentLoaded-和-Load" class="headerlink" title="DOMContentLoaded 和 Load"></a>DOMContentLoaded 和 Load</h3><p>DOM 加载并且解析完成才会触发 DOMContentLoaded 事件，倘若源码输出的内容过多，客户端解析 DOM 的时间也会响应加长，不要小看这里的解析时间，如果 DOM 数量增加 2000 个并且嵌套层级较深，解析时间也会相应增加 50-200ms，这个消耗对大多数页面来说其实是没必要的，保证首屏输出即可，后续的内容只保留钩子，利用 JS 动态渲染。</p>
<p>Load 时间可以用来衡量首屏加载中，客户端接受的信息总量，如果在首屏中充满了大尺寸图片或者客户端与后端建立连接次数较多，Load 时间也会相应被拖长。</p>
<h3 id="流畅度"><a href="#流畅度" class="headerlink" title="流畅度"></a>流畅度</h3><p>流畅度是对 FPS 的视觉反馈，FPS 值越高，视觉呈现越流畅。为了保障页面的加载速度，很多内容不会在页面打开的时候全部加载到客户端。这里提到的流畅度是等待过程中的视觉缓冲，如下方是 Google Plus 页面的一个效果图：</p>
<p><img src="http://gtms04.alicdn.com/tps/i4/TB1CbQPLVXXXXauXFXXIrP49pXX-446-537.gif" alt="Google Plus Item"></p>
<p>墙内访问 google 的速度不是很快，上面元素中的的很多内容都是通过异步方式加载，而从上图可以看出 Google 并没有让用户产生等待的焦虑感。</p>
<h2 id="淘宝首页的性能优化"><a href="#淘宝首页的性能优化" class="headerlink" title="淘宝首页的性能优化"></a>淘宝首页的性能优化</h2><p>由于平台限制，淘宝首页面临一个先天的性能缺陷，首屏的渲染需要从 7 个不同的后端取数据，这些数据请求是难以合并的，如果用户屏幕比较大，则首屏的面积也比较大，对应的后端平台数据接口就更多。数据是个性化内容或者为广告内容，故请求也不能缓存。</p>
<h3 id="关键模块优先"><a href="#关键模块优先" class="headerlink" title="关键模块优先"></a>关键模块优先</h3><p>不论用户首屏的面积有多大，<b>保证关键模块优先加载</b>。下面代码片段是初始化所有模块的核心部分：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'.J_Module'</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params">mod</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> $mod = $(mod);</span><br><span class="line">  <span class="keyword">var</span> name = $mod.attr(<span class="string">'tms'</span>);</span><br><span class="line">  <span class="keyword">var</span> data = $mod.attr(<span class="string">'tms-data'</span>);</span><br><span class="line">  <span class="keyword">if</span>($mod.hasClass(<span class="string">'tb-pass'</span>)) &#123;</span><br><span class="line">    Reporter.send(&#123;</span><br><span class="line">      msg: <span class="string">"跳过模块 "</span> + name</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 保证首屏模块先加载</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="regexp">/promo|tmall|tanx|notice|member/</span>.test(name)) &#123;</span><br><span class="line">    <span class="built_in">window</span>.requestNextAnimationFrame(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="comment">// 最后一个参数为 Force, 强制渲染, 不懒加载处理</span></span><br><span class="line">      <span class="keyword">new</span> Loader($mod, data, <span class="regexp">/tanx/</span>.test(name));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 剩下的模块进入懒加载队列</span></span><br><span class="line">    lazyQueue.push(&#123;</span><br><span class="line">      $mod: $mod,</span><br><span class="line">      data: data,</span><br><span class="line">      force: <span class="regexp">/fixedtool|decorations|bubble/</span>.test(name)</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>TMS 输出的模块都会包含一个 <code>.J_Module</code> 钩子，并且会预先加载 js 和 css 文件。</p>
<p>对于无 JS 内容的模块，会预先打上 <code>tb-pass</code> 的标记，初始化的时候跳过此模块；对于首屏模块关键模块，会直接进入懒加载监控：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $box 进入浏览器视窗后渲染</span></span><br><span class="line"><span class="comment">// new Loader($box, data) -&gt;</span></span><br><span class="line">datalazyload.addCallback($box, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  self.loadModule($box, data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// $box 立即渲染</span></span><br><span class="line"><span class="comment">// new Loader($box, data, true) -&gt;</span></span><br><span class="line">self.loadModule($box, data);</span><br></pre></td></tr></table></figure>
<p>除必须立即加载的模块外，关键模块被加到懒加载监控，原因是，部分用户进入页面就可能急速往下拖拽页面，此时，没必要渲染这些首屏模块。</p>
<p>非关键模块统一送到 <code>lazyQueue</code> 队列，没有基于将非关键模块加入到懒加载监控，这里有两个原因：</p>
<ul>
<li>一旦加入监控，程序滚动就需要对每个模块做计算判断，模块太多，这里可能存在性能损失</li>
<li>如果关键模块还没有加载好，非关键模块进入视窗就会开始渲染，这势必会影响关键模块的渲染</li>
</ul>
<p>那么，什么时候开始加载非关键模块呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> __lazyLoaded = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runLazyQueue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(__lazyLoaded) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  __lazyLoaded = <span class="literal">true</span>;</span><br><span class="line">  $(<span class="built_in">window</span>).detach(<span class="string">"mousemove scroll mousedown touchstart touchmove keydown resize onload"</span>, runLazyQueue);</span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">module</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">module</span> = lazyQueue.shift()) &#123;</span><br><span class="line">    ~<span class="function"><span class="keyword">function</span>(<span class="params">m</span>)</span>&#123;</span><br><span class="line">      <span class="comment">// 保证在浏览器空闲时间处理 JS 程序, 保证不阻塞</span></span><br><span class="line">      <span class="built_in">window</span>.requestNextAnimationFrame(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Loader(m.$mod, m.data, m.force);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;(<span class="built_in">module</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">$(<span class="built_in">window</span>).on(<span class="string">"mousemove scroll mousedown touchstart touchmove keydown resize onload"</span>, runLazyQueue);</span><br><span class="line"><span class="comment">// 担心未触发 onload 事件, 5s 之后执行懒加载队列</span></span><br><span class="line"><span class="built_in">window</span>.requestNextAnimationFrame(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  runLazyQueue();</span><br><span class="line">&#125;, <span class="number">5E3</span>);</span><br></pre></td></tr></table></figure>
<p>上面的代码应该十分清晰，两种请求下会开始将非关键模块加入懒加载监控：</p>
<ul>
<li>当页面中触发 <code>mousemove scroll mousedown touchstart touchmove keydown resize onload</code> 这些事件的时候，说明用户开始与页面交互了，程序必须开始加载。</li>
<li>如果用户没有交互，但是页面已经 onload 了，程序当然不能浪费这个绝佳的空档机会，趁机加载内容；经测试，部分情况下，onload 事件没有触发（原因尚不知），所以还设定了一个超时加载，5s 之后，不论页面加载情况如何，都会将剩下的非关键模块加入到懒加载监控。</li>
</ul>
<h3 id="懒执行，有交互才执行"><a href="#懒执行，有交互才执行" class="headerlink" title="懒执行，有交互才执行"></a>懒执行，有交互才执行</h3><p>如果说上面的优化叫做懒加载，那么这里的优化可以称之为懒执行。</p>
<p>首页上有几个模块是包含交互的，如头条区域的 tab ，便民服务的浮层和主题市场的浮层，部分用户进入页面可能根本不会使用这些功能，所以<b>程序上并没有对这些模块做彻底的初始化</b>，而是等到用户 hover 到这个模块上再执行全部逻辑。</p>
<h3 id="更懒的执行，刷新页面才执行"><a href="#更懒的执行，刷新页面才执行" class="headerlink" title="更懒的执行，刷新页面才执行"></a>更懒的执行，刷新页面才执行</h3><p>首屏中有两个次要请求，一个是主题市场的 hot 标，将用户最常逛的三个类目打标；第二个是个人中心的背景，不同的城市会展示不同的背景图片，这里需要请求拿到城市信息。</p>
<p>这两处的渲染策略都是，在程序的 idle（空闲）时期，或者 <code>window.onload</code> 十秒之后去请求，然后将请求的结果缓存到本地，当用户第二次访问淘宝首页时能够看到效果。<b>这是一种更懒的执行，用户刷新页面才看得到</b>.这种优化是产品能够接受，也是技术上合理的优化手段。</p>
<h3 id="图片尺寸的控制和懒加载"><a href="#图片尺寸的控制和懒加载" class="headerlink" title="图片尺寸的控制和懒加载"></a>图片尺寸的控制和懒加载</h3><p>不论图片链接的来源是运营填写还是接口输出，都难以保证图片具备恰当的宽高，加上如今 retina 的屏幕越来越多，对于这种用户也要提供优质的视觉体验，图片这块的处理并不轻松。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">'//g.alicdn.com/s.gif'</span> <span class="attr">data-src</span>=<span class="string">'//g.alicdn.com/real/path/to/img.png'</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>阿里 CDN 是支持对图片尺寸做压缩处理的，如下图为 200x200 尺寸的图片：</p>
<p><img src="https://img.alicdn.com/tps/TB1JZa9LVXXXXb3XFXXXXXXXXXX-200-200.gif" alt="200x200"></p>
<p>加上 <code>_100x100.jpg</code> 的参数后，会变成小尺寸：</p>
<p><img src="https://img.alicdn.com/tps/TB1JZa9LVXXXXb3XFXXXXXXXXXX-200-200.gif_100x100.jpg" alt="100x100"></p>
<p>我们知道 webp 格式的图片比对应的 jpg 要小三分之一，如上图加上 <code>_.webp</code> 参数后:</p>
<p><img src="https://img.alicdn.com/tps/TB1JZa9LVXXXXb3XFXXXXXXXXXX-200-200.gif_100x100.jpg_.webp" alt="100x100 webp"></p>
<p>视觉效果并没有什么折扣，但是图片体积缩小了三分之一，图片越大，节省的越明显。显然，淘宝首页的所有图片都做了如上的限制，针对坑位大小对图片做压缩处理，只是这里需要注意的是，运营填写的图片可能已经是压缩过的，如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$img = '//g.alicdn.com/real/path/to/img.png_400x400.jpg';</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">'&#123;&#123;$img&#125;&#125;_100x100jpg_.webp'</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面这种情况，图片是不会正确展示的。首页对所有的图片的懒加载都做了统一的函数处理：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">src = src.replace(<span class="regexp">/\s/g</span>, <span class="string">''</span>);</span><br><span class="line"><span class="keyword">var</span> arr;</span><br><span class="line"><span class="keyword">if</span> (<span class="regexp">/(_\d&#123;2,&#125;x\d&#123;2,&#125;\w*?\.(?:jpg|png))&#123;2,&#125;/</span>.test(src) &amp;&amp; src.indexOf(<span class="string">'_!!'</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">  arr = src.split(<span class="string">'_'</span>);</span><br><span class="line">  <span class="keyword">if</span> (arr[arr.length - <span class="number">1</span>] == <span class="string">'.webp'</span>) &#123;</span><br><span class="line">    src = [arr[<span class="number">0</span>], arr[arr.length - <span class="number">2</span>], arr[arr.length - <span class="number">1</span>]].join(<span class="string">'_'</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    src = [arr[<span class="number">0</span>], arr[arr.length - <span class="number">1</span>]].join(<span class="string">'_'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (src.indexOf(<span class="string">'_!!'</span>) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">  src = src.replace(<span class="regexp">/((_\d&#123;2,&#125;x\d&#123;2,&#125;[\w\d]*?|_co0)\.(jpg|png))+/</span>, <span class="string">'$1'</span>);</span><br><span class="line">&#125;</span><br><span class="line">WebP.isSupport(<span class="function"><span class="keyword">function</span>(<span class="params">isSupportWebp</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// https 协议访问存在问题 IE8，去 schema</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="regexp">/^http:/</span>.test(src)) &#123;</span><br><span class="line">    src = src.slice(<span class="number">5</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 支持 webp 格式，并且 host 以 taobaocdn 和 alicdn 结尾，并且不是 s.gif 图片</span></span><br><span class="line">  <span class="keyword">if</span> (isSupportWebp &amp;&amp; <span class="regexp">/(taobaocdn|alicdn)\.com/</span>.test(src) &amp;&amp; (src.indexOf(<span class="string">'.jpg'</span>) ||</span><br><span class="line">    src.indexOf(<span class="string">'.png'</span>)) &amp;&amp; !<span class="regexp">/webp/</span>.test(src) &amp;&amp; !ignoreWebP &amp;&amp; !<span class="regexp">/\/s\.gif$/</span>.test(src)) &#123;</span><br><span class="line">    src += <span class="string">'_.webp'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  $img.attr(<span class="string">'src'</span>, src);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="模块去钩子，走配置"><a href="#模块去钩子，走配置" class="headerlink" title="模块去钩子，走配置"></a>模块去钩子，走配置</h3><p>TMS 的模块在输出的时候会将数据的 id 放在钩子上：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'J_Module'</span> <span class="attr">tms-datakey</span>=<span class="string">'2483'</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果模块是异步展示的，可以通过 <code>tms-datakey</code> 找到模块数据，而首页的个性化是从几十上百个模块中通过算法选出几个，如果把这些模块钩子全部输出来，虽说取数据方便了很多，却存在大量的冗余，对此的优化策略是：将数据格式相同的模块单独拿出来，新建页面作为数据页。所以可以在源码中看到好几段这样的配置信息：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">class</span>=<span class="string">"tb-hide"</span>&gt;</span>[&#123;"backup":"false","baseid":"1","mid":"222726","name":"iFashion","per":"false","tid":"3","uid":"1000"&#125;,&#123;"backup":"false","baseid":"3","mid":"222728","name":"美妆秀","per":"false","tid":"3","uid":"1001"&#125;,&#123;"backup":"false","baseid":"4","mid":"222729","name":"爱逛街","per":"false","tid":"4","uid":"1002"&#125;,&#123;"backup":"false","baseid":"2","mid":"222727","name":"全球购","per":"false","tid":"4","uid":"1003"&#125;]<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>减少了大量的源码以及对 DOM 的解析。</p>
<h3 id="低频修改模块，缓存请求"><a href="#低频修改模块，缓存请求" class="headerlink" title="低频修改模块，缓存请求"></a>低频修改模块，缓存请求</h3><p>有一些模块数据是很少被修改的，比如接口的兜底数据、阿里 APP 模块数据等，可以通过调整参数，设置模块的缓存时间，如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">io(&#123;</span><br><span class="line">  url: URL,</span><br><span class="line">  dataType: <span class="string">'jsonp'</span>,</span><br><span class="line">  cache: <span class="literal">true</span>,</span><br><span class="line">  jsonpCallback: <span class="string">'jsonp'</span> + <span class="built_in">Math</span>.floor(<span class="keyword">new</span> <span class="built_in">Date</span> / (<span class="number">1000</span> * <span class="number">60</span>)),</span><br><span class="line">  success: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>Math.floor(new Date / (1000 * 60))</code> 这个数值在一分钟内是不会发生变化的，也就是说将这个请求在本地缓存一分钟，对于低频修改模块，缓存时间可以设置为一天，即：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.floor(<span class="keyword">new</span> <span class="built_in">Date</span> / (<span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>))</span><br></pre></td></tr></table></figure>
<p>当然，我们也可以采用本地储存的方式缓存这个模块数据：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">offline.setItem(<span class="string">'cache-moduleName'</span>, <span class="built_in">JSON</span>.stringify(data), <span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>);</span><br></pre></td></tr></table></figure>
<p>缓存过期时间设置为 1 天，淘宝首页主要采用本地缓存的方式。</p>
<h4 id="使用缓动效果减少等待的焦急感"><a href="#使用缓动效果减少等待的焦急感" class="headerlink" title="使用缓动效果减少等待的焦急感"></a>使用缓动效果减少等待的焦急感</h4><p>这方面的优化不是很多，但是也有一点效果，很多模块的展示并不是干巴巴的 <code>.show()</code>，而是通过动画效果，缓动呈现，这方面的优化推荐使用 CSS3 属性去控制，性能消耗会少很多。</p>
<h2 id="优化的思考角度"><a href="#优化的思考角度" class="headerlink" title="优化的思考角度"></a>优化的思考角度</h2><p>页面优化的切入点很多，我们不一定能够面面俱到，但是对于一个承载较大流量的页面来说，下面几条必须有效执行：</p>
<ul>
<li>首屏一定要快</li>
<li>滚屏一定要流畅</li>
<li>能不加载的先别加载</li>
<li>能不执行的先别执行</li>
<li>渐进展现、圆滑展现</li>
</ul>
<p>当然，性能优化的切入角度不仅仅是上几个方面，对照 Chrome 的 Timeline 柱状图和折线图，我们还可以找到很多优化的点，如：</p>
<p><img src="http://gtms02.alicdn.com/tps/i2/TB1qwc6LVXXXXcnXXXX5W.tKFXX-1818-1096.png" alt="淘宝首页 Chrome Timeline"></p>
<ul>
<li>在 1.0s 左右存在一次 painting 阻塞，可能因为一次性展示的模块面积过大</li>
<li>从 FPS 的柱状图可以看出，在 1.5s-2.0s 之间，存在几次 Render 和 JavaScript 丢帧</li>
<li>从多出的红点可以看出页面 jank 次数，也能够定位到代码堆栈</li>
</ul>
<p>在优化的过程中需要更多地思考，如何让阻塞的脚本分批执行，如何将长时间执行的脚本均匀地分配到时间线上。这些优化都体现在代码的细节上，宏观上的处理难以有明显的效果。当然，在宏观上，淘宝首页也有一个明显的优化：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://gist.github.com/miksago/3035015#file-raf-js</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> lastTime = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> vendors = [<span class="string">'ms'</span>, <span class="string">'moz'</span>, <span class="string">'webkit'</span>, <span class="string">'o'</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> x = <span class="number">0</span>; x &lt; vendors.length &amp;&amp; !<span class="built_in">window</span>.requestAnimationFrame; ++x) &#123;</span><br><span class="line">    <span class="built_in">window</span>.requestAnimationFrame = <span class="built_in">window</span>[vendors[x]+<span class="string">'RequestAnimationFrame'</span>];</span><br><span class="line">    <span class="built_in">window</span>.cancelAnimationFrame = <span class="built_in">window</span>[vendors[x]+<span class="string">'CancelAnimationFrame'</span>] || <span class="built_in">window</span>[vendors[x]+<span class="string">'CancelRequestAnimationFrame'</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">window</span>.requestAnimationFrame) &#123;</span><br><span class="line">    <span class="built_in">window</span>.requestAnimationFrame = <span class="function"><span class="keyword">function</span>(<span class="params">callback, element</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> currTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">      <span class="keyword">var</span> timeToCall = <span class="built_in">Math</span>.max(<span class="number">0</span>, <span class="number">16</span> - (currTime - lastTime));</span><br><span class="line">      <span class="keyword">var</span> id = <span class="built_in">window</span>.setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; callback(currTime + timeToCall); &#125;, timeToCall);</span><br><span class="line">      lastTime = currTime + timeToCall;</span><br><span class="line">      <span class="keyword">return</span> id;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">window</span>.cancelAnimationFrame) &#123;</span><br><span class="line">    <span class="built_in">window</span>.cancelAnimationFrame = <span class="function"><span class="keyword">function</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">      clearTimeout(id);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>这段代码基本保证每个模块的初始化都是在浏览器空闲时期，减少了很多不必要的丢帧。这个优化也可以被应用到每个模块的细节代码之中，不过优化难度会更高。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>代码的性能优化是一个精细活，如果你要在一个庞大的未经优化的页面上做性能优化，可能会面临一次重构代码。本文从淘宝首页个性化引出的问题出发，从微观到宏观讲述了页面的优化实践，提出了几条可以借鉴的优化标准，希望对你有所启发。优化的细节点描述的不够完善也不够全面，但是都是值得去优化的方向。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="https://img.alicdn.com/tps/TB1QzViMpXXXXXZXXXXXXXXXXXX-900-500.jpg" alt="淘宝首页性能优化实践"></p>
<p>想必很多人都已经看到了新版的淘宝首页，它与以往不太一样，这一版页面中]]>
    </summary>
    
      <category term="性能优化" scheme="http://taobaofed.org/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[「开往春天的 Node.js」 - Node 地下铁第二期线下沙龙总结]]></title>
    <link href="http://taobaofed.org/blog/2016/04/01/node-subway-shanghai/"/>
    <id>http://taobaofed.org/blog/2016/04/01/node-subway-shanghai/</id>
    <published>2016-04-01T03:41:23.000Z</published>
    <updated>2016-07-22T05:20:24.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img.alicdn.com/tps/TB1bA_SMXXXXXckXpXXXXXXXXXX-900-500.jpg" alt="「开往春天的 Node.js」 - Node 地下铁第二期线下沙龙总结"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>寒冬已逝，春之伊始。</p>
<p>3 月 26 日下午，Node 地下铁第 2 次线下沙龙在上海世博展览馆万信酒店举行。本次沙龙邀请了四位在不同领域应用 Node.js 进行探索的大牛，带着我们在温暖的午后，感受 Node.js 的魅力。</p>
<p>虽然当天是近来久违的好天气，而且会场地点有些偏，但这些都没有令同学们对 Node.js 的热情衰减，13 点半签到，很快会议室的位置所剩无几了，在这里，组委会感谢各位同学的支持。</p>
<p><img src="http://img.alicdn.com/tps/TB12YYVMXXXXXa0XpXXXXXXXXXX-5184-3456.jpg" alt="图一"></p>
<p><img src="http://img.alicdn.com/tps/TB1LevOMXXXXXaPXFXXXXXXXXXX-5184-3456.jpg" alt="图二"></p>
<h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><h3 id="Node-js-源站的发展与挑战"><a href="#Node-js-源站的发展与挑战" class="headerlink" title="Node.js 源站的发展与挑战"></a>Node.js 源站的发展与挑战</h3><p>淘宝首页是淘宝很重要的一个页面，它原本一直运行在数量庞大的应用集群上，性能浪费非常严重。过去的一年，淘宝使用 Node.js 源站解决了已有的问题，我们用几十台虚拟机支撑了淘宝数十亿 PV 的流量。</p>
<p>但 Node.js 源站也为我们带来了新的挑战：</p>
<ul>
<li>如何设计伪静态的缓存方案，保障对时间、多终端的良好支持？</li>
<li>如何优化模块文件合并分发渠道，让首页数百个模块不再产生 IO 瓶颈？</li>
<li>如何在高压力下解决源站的异地多活等高可用问题？</li>
</ul>
<p>你可以在基德同学的分享中深入了解这其中的奥妙，另外，也欢迎喜欢挑战的人加入我们，让 Node.js 源站更加强大。</p>
<p><img src="http://img.alicdn.com/tps/TB1_APUMXXXXXa4XpXXXXXXXXXX-5184-3456.jpg" alt="基德"></p>
<h3 id="alinode-基于-Node-js-运行时的应用性能管理解决方案"><a href="#alinode-基于-Node-js-运行时的应用性能管理解决方案" class="headerlink" title="alinode - 基于 Node.js 运行时的应用性能管理解决方案"></a>alinode - 基于 Node.js 运行时的应用性能管理解决方案</h3><p>你是否还在为自己的 Node.js 应用的稳定性而担忧？是否在应用出错时手足无措，不知道从何下手？是否每每在内存溢出发生时，才发现自己原来挖了这样一个坑？</p>
<p>有了 alinode，这些苦恼便能轻松化解。它是阿里云出品的 Node.js 应用服务解决方案，是一套基于社区 Node.js 改进的运行时环境和服务平台。在社区的基础上内建了强大的支持功能，帮助开发者迅速洞见性能细节，快速定位疑难杂症，直探问题根源。</p>
<p>在穆客的分享中，你可以详细了解 alinode 的使用，以及手把手的问题处理教程。</p>
<p><img src="http://img.alicdn.com/tps/TB1Ht6AMXXXXXXlaXXXXXXXXXXX-5184-3456.jpg" alt="穆客"></p>
<h3 id="使用-NW-js-构建桌面钉钉"><a href="#使用-NW-js-构建桌面钉钉" class="headerlink" title="使用 NW.js 构建桌面钉钉"></a>使用 NW.js 构建桌面钉钉</h3><p>移动端技术和工具链最近几年发展的非常快，桌面端却没有太大的发展。WEB 技术发展的也非常快，同时 Chromium 项目提供了优秀的跨平台浏览器内核，现在最快的构建桌面应用的方式变成了 nw.js 或者 Electron 这样的利用 WEB 技术加 Node.js 的方案。</p>
<p>在钉钉，使用了 NW.js 来构建跨平台的桌面应用，但只靠 JavaScript 依然搞不定所有的事情，比如自动更新应用，截图功能，读写系统剪切版等等。结合 Node.js Addon 技术来和 C++ 模块的实用，完成一些 Javascript 暂时不好实现的需求。</p>
<p>想了解钉钉为什么不使用风头正热的 Electron，或者想知道如何使用 nw.js 构建一个体验不输给 Native 的应用以及面临的挑战，快来听听云际的分享吧。</p>
<p><img src="http://img.alicdn.com/tps/TB1Wf22MXXXXXbyXXXXXXXXXXXX-5184-3456.jpg" alt="云际"></p>
<h3 id="Thunk-Redis"><a href="#Thunk-Redis" class="headerlink" title="Thunk-Redis"></a>Thunk-Redis</h3><p>thunks 和 redis 对大家来说也许并不陌生，但是两者的结合你了解吗？是在造轮子，还是在追求极致的速度体验。</p>
<p>在来自 Teambition 严清的分享中，我们可以了解到如何遵照 RESP (REdis Serialization Protocol) 协议，实现一个更快，更强大的 Redis 客户端，以及 Redis 和 Node.js 在 Teambition 关键系统中的使用，比如：消息系统，邮件队列等。感觉要学到很多姿势了呢。</p>
<p><img src="http://img.alicdn.com/tps/TB1Iq6wMXXXXXbhaXXXXXXXXXXX-5184-3456.jpg" alt="严清"></p>
<h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p><img src="http://img.alicdn.com/tps/TB1O2nPMXXXXXc5XpXXXXXXXXXX-5184-3456.jpg" alt="讨论"></p>
<p>四位同学的精彩分享结束后，接下来的环节是圆桌讨论（并没有圆桌 - -！）。在讨论中，大家纷纷提出了自己在 Node.js 实践中遇到的问题，也有的分享了自己在实践中的一些心得。</p>
<p>几个比较受关注的问题：</p>
<ul>
<li><p>NPM 的安全以及可靠性，对 Node.js 生态的担忧等。</p>
<p>  这是由最近 @Azer 在 NPM 社区中引发的讨论。@johnhax 等人纷纷表达了自己的观点。爱之深，责之切，依赖质量以及依赖方式，确实是 Node.js 生态中目前比较薄弱的环节，但是在一个活跃的社区推动下，这些都会有很好的解决方案的，毕竟 Node.js 也在成长。</p>
</li>
<li><p>如何使用 aliNode 分析错误，以及错误处理的相关经验</p>
<p>  社区中，有很多人在使用 aliNode 来监控、分析自己应用的性能以及问题。但是，对于新人来说，从一个 heapdump 中分析出问题所在，还是有一些难度的，很多人希望可以学习到一些经验，当然，很多人也分享了自己如果踩坑、填坑的。</p>
</li>
<li><p>在开发 Node.js 应用中遇到的问题</p>
<p>  这部分主要围绕如何填开发过程中踩过的坑。比如一位同学提到，自己在用 Node.js live reload 配置文件时，经常会导致内存占用过高的情况，大家根据他的描述，提出了一些解决方案。小编认为，如果合理的使用 Node.js 的流 API，或许能解决这个问题。</p>
</li>
<li><p>想使用 Node.js 或者在 Node.js 和其他语言混用的情况</p>
<p>  有些来参会的同学，并是不以 Node.js 作为主语言的人，想尝试一下，通过讨论，使他们对 Node.js 有了更深入的了解。跟淘宝一样，很多公司也面临着 Node.js 和其他语言混用的情况，嘉宾们和同学沟通了自己所采用的方案，希望可以给你们提供一些思路。</p>
</li>
</ul>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>在此感谢各位同学的参与，我们下次再约！同时感谢博文视点对本次活动的图书赞助！欢迎关注 Node 地下铁微信公共账号，随时关注下一次线下沙龙动态。</p>
<p>错过了这次分享的同学也不要急，我们不会忘了你们的，请往下拉。。。</p>
<h2 id="分享资料下载"><a href="#分享资料下载" class="headerlink" title="分享资料下载"></a>分享资料下载</h2><ul>
<li><p>PPT</p>
<p>  下载地址：<a href="http://pan.baidu.com/s/1c1zV9oW" target="_blank" rel="external">网盘</a></p>
</li>
<li><p>视频</p>
<ul>
<li><a href="http://v.youku.com/v_show/id_XMTUxODMzNDMyNA==.html" target="_blank" rel="external">《Node.js 源站的发展与挑战》- 基德 @淘宝</a></li>
<li><a href="http://v.youku.com/v_show/id_XMTUxODMzODkzNg==.html" target="_blank" rel="external">《aliNode - 基于 Node.js 运行时的应用性能管理解决方案》 - 穆客 @阿里云</a></li>
<li><a href="http://v.youku.com/v_show/id_XMTUxODM0MTc5Mg==.html" target="_blank" rel="external">《使用 NW.js 构建桌面钉钉》- 云际 @钉钉</a></li>
<li><a href="http://v.youku.com/v_show/id_XMTUxODM0NjAzMg==.html" target="_blank" rel="external">《Thunk-Redis》- 严清 @Teambition</a></li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img.alicdn.com/tps/TB1bA_SMXXXXXckXpXXXXXXXXXX-900-500.jpg" alt="「开往春天的 Node.js」 - Node 地下铁第二期线下沙龙总结"></p>
<h2 id="前言"><]]>
    </summary>
    
      <category term="Node-subway" scheme="http://taobaofed.org/tags/Node-subway/"/>
    
      <category term="沙龙" scheme="http://taobaofed.org/tags/%E6%B2%99%E9%BE%99/"/>
    
      <category term="Node地下铁" scheme="http://taobaofed.org/tags/Node%E5%9C%B0%E4%B8%8B%E9%93%81/"/>
    
      <category term="Node.js" scheme="http://taobaofed.org/categories/Node-js/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[页面跳转时，统计数据丢失问题探讨]]></title>
    <link href="http://taobaofed.org/blog/2016/04/01/lose-statistics/"/>
    <id>http://taobaofed.org/blog/2016/04/01/lose-statistics/</id>
    <published>2016-04-01T03:33:34.000Z</published>
    <updated>2016-07-22T05:20:24.000Z</updated>
    <content type="html"><![CDATA[<p><img src="https://gw.alicdn.com/tps/TB1VF2YMXXXXXX2XpXXXXXXXXXX-900-500.png" alt="页面跳转时，统计数据丢失问题探讨"></p>
<p>为了更好地了解用户对产品的使用情况，业务中，我们经常会收到埋点统计的需求，比如：</p>
<ul>
<li>收集一段时间内用户光标在页面中的运动情况，包括光标移动、点击等行为</li>
<li>统计用户滚屏行为</li>
<li>统计用户在站点的停留时长</li>
<li>收集页面链接的点击数量等</li>
</ul>
<a id="more"></a>
<p>无论是移动端还是 PC 端，相信很多朋友都遇到了这么几个十分让人头疼的问题：</p>
<ul>
<li>统计某个链接的点击量，但是这个链接点击后直接跳转走了</li>
<li>统计页面时长问题，unload 的时候发送的统计丢失了</li>
<li>统计脚本还没有初始化，用户不感兴趣已经走人了等</li>
</ul>
<p>如果我们把这样的数据交给了产品同学，可能会让他们对用户行为产生错误的认知，一定程度上影响产品的下一步改善。</p>
<h3 id="传统解决方案"><a href="#传统解决方案" class="headerlink" title="传统解决方案"></a>传统解决方案</h3><p>上面提到的问题，从技术角度可以归纳为两点：</p>
<ul>
<li>用户关闭页面过早，统计脚本还未加载/初始化完成</li>
<li>用户关闭或者跳出页面的时候，请求未发出</li>
</ul>
<p>针对第一点，概率较小，一般的处理方式就是，不要把统计脚本参合到其他脚本中，单独加载，并且放在前头，让它优先加载。很多公司的做法是，不让开发者关心统计脚本的加载，用户请求页面的时候，Nginx 会在 Body 开始标签位置注入一段脚本。</p>
<p>对于问题二，处理方案就有很多了。</p>
<p><strong>1. 阻塞式的 AJAX 请求</strong></p>
<p>还记得 <code>XMLHttpRequest::open</code> 方法的第三个参数吧，如果设置为 false 就是同步加载，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'unload'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest(),</span><br><span class="line">  xhr.setRequestHeader(<span class="string">"Content-Type"</span>, <span class="string">"text/plain;charset=UTF-8"</span>);</span><br><span class="line">  xhr.open(<span class="string">'post'</span>, <span class="string">'/log'</span>, <span class="literal">false</span>); <span class="comment">// 同步请求</span></span><br><span class="line">  xhr.send(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>阻塞页面关闭，当然可以在 <code>readState</code> 为 2 的时候就 abort 请求，因为我们不关心响应的内容，只要请求发出去就行了。</p>
<p><strong>2. 暴力的死循环</strong></p>
<p>原理跟上面类似，只不过是使用一个空的死循环阻塞页面关闭，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'unload'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  send(data);</span><br><span class="line">  <span class="keyword">var</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="keyword">new</span> <span class="built_in">Date</span> - now &gt;= <span class="number">10</span>) &#123;&#125; <span class="comment">// 阻塞 10ms</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>3. 发一个图片请求阻塞</strong></p>
<p>大部分浏览器都会等待图片的加载，趁这个机会把统计数据发送出去</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'unload'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  send(data);</span><br><span class="line">  (<span class="keyword">new</span> Image).src = <span class="string">'http://example.com/s.gif'</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>以上提到的几个方案都是一个原理，让浏览器继续保持阻塞状态，等数据发送出去后再跳转，这里存在的问题是：</p>
<ul>
<li>少量浏览器下可能不奏效</li>
<li>等待一会儿再跳转，用户体验上打了折扣，尤其是移动端上</li>
</ul>
<p>是否有更好的方案解决这个问题呢，前端同学秉着「小强精神」也提出了两个可实践的方案。</p>
<h3 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h3><p>不就是埋点统计数据嘛，非得在当前页面发送出去？优化方案的思路具有一定的跳跃性，我们考虑将数据在下跳页中发送，那么问题就转换为，如何将数据传递给下跳页？</p>
<p>对于链接点击量的统计，我们可以将链接信息通过 URL 传递给下跳页，传递思路如下：</p>
<p><strong>1. URL 传参</strong></p>
<p>通过数组标识一个链接的位置信息，如 <code>[站点 id，页面 id，模块 id，链接 index]</code>，通过四个参数可以惟一标识链接位置属性，使用 URL param 参数将数组数据传递给下跳页，等待由下跳页将数据发送出去。</p>
<p>这里存在的问题是，下跳页中必须部署同样的统计脚本，但对一个系统来说，这是很容易做到的。我们也不会在自己的网页上放其他网站的链接吧，所以整个数据的统计都在一个闭环内。</p>
<p><strong>2. 通过 <code>window.name</code> 传递数据</strong></p>
<p><code>window.name</code> 是浏览器给我们开放的一个接口，设置该属性的值后，即便页面发生了跳转，这个值依然不会变化，并且可以跨域使用。</p>
<p>这里存在的问题是，该属性可能被开发者用于其他途径。我们可以限制开发者直接使用 <code>window.name</code>，封装接口，通过接口调用，如 aralejs 提供的 <a href="https://github.com/aralejs/name-storage" target="_blank" rel="external">nameStorage</a>，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nameStorage.setItem(key, value);</span><br><span class="line">nameStorage.getItem(key);</span><br><span class="line">nameStorage.removeItem(key);</span><br></pre></td></tr></table></figure>
<p>储存形式为：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    scheme                  nameStorage datas</span><br><span class="line">      |                            |</span><br><span class="line"><span class="comment">------------           ------------------------</span></span><br><span class="line">nameStorage:origin-<span class="built_in">name</span>?key1=value1&amp;key2=value2</span><br><span class="line">            <span class="comment">-----------</span></span><br><span class="line">                 |</span><br><span class="line">         window origin <span class="built_in">name</span></span><br></pre></td></tr></table></figure>
<p>以上虽然基本解决了数据丢失和体验差的问题，但是这也很大程度依赖于开发者的编程习惯，如不能随便玩耍 <code>window.name</code>；也对系统有一定的要求，必须在所有页面上部署同样的埋点脚本。</p>
<h3 id="这件事情应该交给浏览器来解决"><a href="#这件事情应该交给浏览器来解决" class="headerlink" title="这件事情应该交给浏览器来解决"></a>这件事情应该交给浏览器来解决</h3><p>上面提到的各种方案，不乏黑科技，然而存在的问题还是一大堆，如果团队的开发者执行力不够，中途容易出现各种麻烦。所以真正能够解决这个问题的，必然还是浏览器本身！</p>
<p>为什么不能给用户提供这样一个 API，即使页面跳转了，也能够将上个页面的请求发出去呢？庆幸的是，W3C 工作组也想到了这个问题，提出了 <code>Beacon API</code> 的 <a href="https://www.w3.org/TR/beacon/" target="_blank" rel="external">草案</a>。</p>
<p><code>Beacon API</code> 允许开发者发送少量错误分析和上报的信息，它的特点很明显：</p>
<ul>
<li>在空闲的时候异步发送统计，不影响页面诸如 JS、CSS Animation 等执行</li>
<li>即使页面在 unload 状态下，也会异步发送统计，不影响页面过渡/跳转到下跳页</li>
<li>能够被客户端优化发送，尤其在 Mobile 环境下，可以将 Beacon 请求合并到其他请求上，一同处理</li>
</ul>
<p><code>sendBeacon</code> 函数挂在在 navigator 上，在 unload 之前，这个函数一定是被初始化了的。其使用方式为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'unload'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  navigator.sendBeacon(<span class="string">'/collector'</span>, data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>navigator.sendBeacon(url, data);</code>，第一个参数为数据上报的地址，第二个参数为要发送的数据，支持的数据格式有：ArrayBufferView, Blob, DOMString, 和 FormData。</p>
<p><code>Beacon</code> 的还有一个非常实用的移动端使用场景，当用户从浏览器切换到其他 app 界面或者 Home 屏的时候，部分浏览器默认会停止页面脚本的执行，如果在这个时候使用了 unload 时间，可能会让你失望，因为 unload 事件并不会触发，此时，<code>Beacon</code> 就派上用途了，它是不会受影响的。</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>本文是对页面打点丢失问题的简单探讨，枚举了我们通常会用到的一些解决方案，可能不是很完善，如果你有更好的建议，可以提出来。</p>
<p>很多问题，我们绞尽脑汁，可能很少会考虑，这个问题是不是应该有我们来解决，或者说这个问题交给谁处理是最恰当的。本文的探讨可以看到，浏览器本身才是最好的问题解决方，当网站流量变大之后，上面提到的丢失问题就更加明显，这也迫使浏览器本身做了改善，自然也在情理之中。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="https://gw.alicdn.com/tps/TB1VF2YMXXXXXX2XpXXXXXXXXXX-900-500.png" alt="页面跳转时，统计数据丢失问题探讨"></p>
<p>为了更好地了解用户对产品的使用情况，业务中，我们经常会收到埋点统计的需求，比如：</p>
<ul>
<li>收集一段时间内用户光标在页面中的运动情况，包括光标移动、点击等行为</li>
<li>统计用户滚屏行为</li>
<li>统计用户在站点的停留时长</li>
<li>收集页面链接的点击数量等</li>
</ul>]]>
    
    </summary>
    
      <category term="数据统计" scheme="http://taobaofed.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1/"/>
    
      <category term="埋点" scheme="http://taobaofed.org/tags/%E5%9F%8B%E7%82%B9/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从 left-pad 事件我们可以学到什么]]></title>
    <link href="http://taobaofed.org/blog/2016/03/31/what-can-we-learn-from-left-pad-event/"/>
    <id>http://taobaofed.org/blog/2016/03/31/what-can-we-learn-from-left-pad-event/</id>
    <published>2016-03-31T08:35:09.000Z</published>
    <updated>2016-07-22T05:20:24.000Z</updated>
    <content type="html"><![CDATA[<p><img src="https://img.alicdn.com/tps/TB1XPPdMXXXXXc0XVXXXXXXXXXX-900-500.jpg" alt="从 left-pad 事件我们可以学到什么"></p>
<p>最近 NPM 圈发生了“一个 17 行代码的模块引发的血案”。<a href="https://github.com/azer/left-pad/blob/master/index.js" target="_blank" rel="external">left-pad</a> 工具模块被作者从 NPM 上撤下，所有直接或者间接依赖这个模块的 NPM 包就忧伤的挂掉了，包括 babel 这样的热门项目。</p>
<p>而其中的原因大概是这样：作者 Azer 写了一个叫 <a href="https://github.com/starters/kik" target="_blank" rel="external">kik</a> 的工具和某个公司同名了，这天公司的律师要求其删掉这个模块，把 kik 这个名字“让”给他们，作者不答应，律师就直接找 NPM 了，而 NPM 未经作者同意就把包的权限转移给了这家公司。于是，Azer 一怒冲冠，将他所有的 NPM 包全部删掉了。</p>
<p>我们不打算讨论这件事中的价值观、自由之精神、法律细节等等，我只想站在一个程序员的角度来凑个热闹，聊聊看法。</p>
<h2 id="细分模块是必要的"><a href="#细分模块是必要的" class="headerlink" title="细分模块是必要的"></a>细分模块是必要的</h2><p>有人会觉得就这几行函数有必要单独抽取成一个模块吗？我觉得有必要，原因如下：</p>
<ul>
<li>你应该不想把这个工具函数在各个项目里面重复的去复制粘贴，毕竟 DRY（Don’t Repeat Yourself） 嘛。</li>
<li>人们管理软件复杂度的通常方法都是拆分，写好一个模块，做好测试，然后直接使用这个模块。“small module” 的想法本来就是很好的。</li>
<li>另外一种想法是我所有的工具函数都统一放在一个模块，这很容易造成工具模块越来越大，什么都往里放。而别人使用这个庞大的工具模块时，很可能其中很多东西根本就用不上。</li>
<li>还有人说这个功能根本不用这么多代码，但是到处写这一行代码也挺烦不是？况且你也不知道一个几行代码能解决的问题有可能随着需求的变化需要更复杂的实现（比如：更多的定制性、性能要求）。</li>
</ul>
<p>所以，NPM 一直提倡和推动的 small module 的理念并没有什么错，我们不应该因为这个事件就把各种“小模块”的依赖从自己项目中去掉，甚至自己也不写“小模块”了。</p>
<h2 id="不要太依赖他人"><a href="#不要太依赖他人" class="headerlink" title="不要太依赖他人"></a>不要太依赖他人</h2><p>如果我们真想构建稳定的应用，非常重要的一点就是“不要将自己的全部身家都拴在别人的裤腰带”上，你永远不知道那个别人什么时候会“扑街”。其实在代码实现中，我们一直都被教导要小心强依赖，依赖过强会导致我们不够灵动。“牵一发而动全身”是很可怕的一件事。</p>
<p>具体到 Node 模块的依赖这件事上，太依赖他人会有些什么“可怕”的事情？</p>
<ol>
<li>模块全部要从 NPM 的 registry 拉取然后安装，每天的持续集成越来越慢、越来越慢。</li>
<li>像 left-pad 这个模块一样，你依赖的模块被作者怒删了，应用挂掉。</li>
<li>你在 package.json 里面指定依赖时使用了 <code>~a.b.c</code> 这种表示法（意思是小版本我都要），这表示每次 npm install 时其实获取到的模块依赖很可能是和你测试后发布的版本不一致的（依赖模块频繁发布了新的小版本），心里慌慌的。</li>
<li>你依赖模块的作者是个傻逼，不小心将不兼容的改动当作小版本发布了一个新版。npm install 或者 npm update 以后你依赖了这个新版，应用挂掉了。</li>
</ol>
<p>是不是有点“细思极恐”？那这里抛出一个解决方案。如果有更好的方案，欢迎讨论。</p>
<h2 id="破解强依赖"><a href="#破解强依赖" class="headerlink" title="破解强依赖"></a>破解强依赖</h2><p>先来列出我们需要些什么：</p>
<ul>
<li>在发布前“冻结”依赖模块的版本号。这让我们对安装的依赖有信心，依赖模块的版本都是我们验证、测试过的。</li>
<li>在发布前“打包”依赖模块到自己项目。这让我们可以坦然面对我们依赖的某个模块“没有了”这样的囧境。</li>
</ul>
<h3 id="冻结依赖模块"><a href="#冻结依赖模块" class="headerlink" title="冻结依赖模块"></a>冻结依赖模块</h3><p>冻结依赖模块的版本号最简单的办法就是直接在 package.json 里面写死版本号，但是这解决不了深度依赖的问题。我们来看个例子。</p>
<p>假设有下面这样的依赖：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A<span class="variable">@0</span>.<span class="number">1.0</span></span><br><span class="line">└─┬ B<span class="variable">@0</span>.<span class="number">0.1</span></span><br><span class="line">  └── C<span class="variable">@0</span>.<span class="number">0.1</span></span><br></pre></td></tr></table></figure>
<p>A 模块依赖了 B 模块，B 模块又依赖了 C 模块。我们可以将 B 模块的依赖写死成 <code>0.0.1</code> 版本，但是如果 B 模块对 C 模块的依赖写的是 <code>C: ~0.0.1</code>，会怎样？</p>
<p>这时候 C 模块更新到了 <code>0.0.2</code> 版本，虽然我们安装的 B 模块是 <code>B@0.0.1</code>，但是安装的 C 模块却是 <code>C@0.0.2</code>。如果不巧这个 <code>C@0.0.2</code> 刚好有 bug，那我们的模块很有可能就不能正常工作了。</p>
<p>实际上，NPM 提供了一个叫做 <code>npm shrinkwrap</code> 的命令来解决这个问题：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NAME</span><br><span class="line">  npm-shrinkwrap -- Lock down dependency versions</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">  npm shrinkwrap</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">  This  command  locks down the versions of a package<span class="string">'s dependencies so that you can control exactly which versions of each  dependency  will be used when your package is installed.</span></span><br></pre></td></tr></table></figure>
<p>这条命令会根据目前我们 <code>node_modules</code> 目录下的模块来生成一份“冻结”住的模块依赖（npm-shrinkwrap.json）。</p>
<p>还是上面的例子，我们在模块 A 的根目录执行 <code>npm shrinkwrap</code> 后，生成的 <code>npm-shrinkwrap.json</code> 文件内容大概是下面这样：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"A"</span>,</span><br><span class="line">    <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">        <span class="attr">"B"</span>: &#123;</span><br><span class="line">            <span class="attr">"version"</span>: <span class="string">"0.0.1"</span>,</span><br><span class="line">            <span class="attr">"resolved"</span>: <span class="string">"http://registry.npmjs.com/B-0.0.1.tgz"</span>,</span><br><span class="line">            <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">                <span class="attr">"C"</span>: &#123;  </span><br><span class="line">	                <span class="attr">"version"</span>: <span class="string">"0.0.1"</span>,</span><br><span class="line">	                <span class="attr">"resolved"</span>: <span class="string">"http://registry.npmjs.com/C-0.0.1.tgz"</span></span><br><span class="line">		        &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，当我们执行 <code>npm install</code> 时，依赖查找的“来源”不再是 <code>package.json</code>，而是我们生成的 <code>npm-shrinkwrap.json</code>，再也不会突然装上什么 <code>C@0.0.2</code> 了，依赖里面的模块版本都是我们验证、测试后的版本，让人安心。</p>
<p>注：<code>npm shrinkwrap</code> 默认只会生成 <code>dependencies</code> 的依赖，不会生成 <code>devDependencies</code> 的依赖，如果你真的需要，可以加 <code>--dev</code> 参数。</p>
<h3 id="打包依赖模块"><a href="#打包依赖模块" class="headerlink" title="打包依赖模块"></a>打包依赖模块</h3><p>实际上，使用 shrinkwrap 冻结依赖模块的版本号后已经“安全”许多了，pack 这一步看实际情况可以省略，毕竟它还是会带来一些问题的（比如：项目提交的增大、安装时不能很好的利用已有模块的本地缓存等）。那我们来看看怎样把依赖打包进我们的项目。</p>
<p>上面生成的 <code>npm-shrinkwrap.json</code> 里面有个 <code>resolved</code> 字段，表示模块所在的位置，实际上这个字段完全可以写一个文件路径。所以，我们可以递归的遍历 <code>npm-shrinkwrap.json</code> 文件，将所有的 tgz 包先下载到我们项目的某个目录，然后改写 <code>resolved</code> 字段为对应的文件路径。这样的功能有开发者已经实现了，我们可以直接享用：<a href="https://github.com/JamieMason/shrinkpack" target="_blank" rel="external">https://github.com/JamieMason/shrinkpack</a></p>
<p>还是上面的例子：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A<span class="variable">@0</span>.<span class="number">1.0</span></span><br><span class="line">└─┬ B<span class="variable">@0</span>.<span class="number">0.1</span></span><br><span class="line">  └── C<span class="variable">@0</span>.<span class="number">0.1</span></span><br></pre></td></tr></table></figure>
<p>执行 <code>shrinkpack</code> 后，会生成下面的打包目录：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">node_shrinkpack</span></span><br><span class="line"> <span class="selector-tag">-</span> <span class="selector-tag">B-0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-class">.tgz</span></span><br><span class="line"> <span class="selector-tag">-</span> <span class="selector-tag">C-0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-class">.tgz</span></span><br></pre></td></tr></table></figure>
<p>和 <code>node-shrinkwrap.json</code> 文件：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"A"</span>,</span><br><span class="line">    <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">        <span class="attr">"B"</span>: &#123;</span><br><span class="line">            <span class="attr">"version"</span>: <span class="string">"0.0.1"</span>,</span><br><span class="line">            <span class="attr">"resolved"</span>: <span class="string">"./node_shrinkpack/B-0.0.1.tgz"</span>,</span><br><span class="line">            <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">                <span class="attr">"C"</span>: &#123;  </span><br><span class="line">	                <span class="attr">"version"</span>: <span class="string">"0.0.1"</span>,</span><br><span class="line">	                <span class="attr">"resolved"</span>: <span class="string">"./node_shrinkpack/C-0.0.1.tgz"</span></span><br><span class="line">		        &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>于是，我们以后再进行 <code>npm install --loglevel=http</code> 时会发现依赖模块的安装根本没有网络请求了（因为依赖都在我们自己的仓库里了嘛）。</p>
<p>可能有人会说，为啥不直接把 <code>node_modules</code> 目录提交进仓库算了？原因主要是这样：</p>
<ul>
<li>有些模块需要编译，编译是和环境有关的，你当前的环境编译可用，其他环境直接使用该模块不一定能用。</li>
<li><code>node_modules</code> 目录里面啥东西都有，太凌乱，很容易把提交给搅乱。diff 时突然 diff 出 <code>node_modules</code> 下的源代码、README，你应该不想这样吧？</li>
</ul>
<p>只存储模块的 tgz 包，安装编译的过程交给 NPM 命令更明智。</p>
<h3 id="新方式"><a href="#新方式" class="headerlink" title="新方式"></a>新方式</h3><p>于是，现在我们使用 NPM 模块的正确姿势应该是这样了：</p>
<ol>
<li>本地安装、更新需要的模块，测试、验证</li>
<li>执行 <code>npm shrinkwrap</code> 将依赖模块的版本冻结</li>
<li>执行 <code>shrinkpack .</code> 将依赖模块打包进仓库</li>
<li>提交代码（注意要将 <code>npm-shrinkwrap.json</code> 和 <code>node_shrinkpack</code> 一起提交哦）</li>
<li>发布模块或者部署应用</li>
</ol>
<p>如果你觉得这样很繁琐，可以定义一个 NPM 命令：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "pack": "npm shrinkwrap &amp; shrinkpack ."</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>拆分模块是必要的，我们应该坚持模块“小而美”</li>
<li>不要太依赖他人，一定要有依赖方挂掉的应急方案</li>
<li>推荐使用 <code>npm shrinkwrap</code>（冻结依赖模块的版本） 加 <code>shrinkpack</code>（打包依赖模块到自己项目） 来解决依赖模块的不确定性</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://docs.npmjs.com/cli/shrinkwrap" target="_blank" rel="external">https://docs.npmjs.com/cli/shrinkwrap</a></li>
<li><a href="https://github.com/JamieMason/shrinkpack" target="_blank" rel="external">https://github.com/JamieMason/shrinkpack</a></li>
<li><a href="https://nodejs.org/en/blog/npm/managing-node-js-dependencies-with-shrinkwrap/" target="_blank" rel="external">https://nodejs.org/en/blog/npm/managing-node-js-dependencies-with-shrinkwrap/</a></li>
<li><a href="http://blog.keithcirkel.co.uk/how-to-use-npm-as-a-build-tool/" target="_blank" rel="external">http://blog.keithcirkel.co.uk/how-to-use-npm-as-a-build-tool/</a></li>
</ul>
<p>题图：<a href="https://pixabay.com/zh/%E5%A4%9A%E7%B1%B3%E8%AF%BA%E9%AA%A8%E7%89%8C-%E7%A7%8B%E5%A4%A9-%E6%91%94%E5%80%92%E4%BA%86-%E6%B8%B8%E6%88%8F-%E8%A1%8C-719199/" target="_blank" rel="external">正在倒下的多米诺骨牌</a>，请小心“牵一发而动全身”。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="https://img.alicdn.com/tps/TB1XPPdMXXXXXc0XVXXXXXXXXXX-900-500.jpg" alt="从 left-pad 事件我们可以学到什么"></p>
<p>最近 NPM 圈发生了“一个 17 行代码的模]]>
    </summary>
    
      <category term="node.js" scheme="http://taobaofed.org/tags/node-js/"/>
    
      <category term="left-pad" scheme="http://taobaofed.org/tags/left-pad/"/>
    
      <category term="npm" scheme="http://taobaofed.org/tags/npm/"/>
    
      <category term="Node.js" scheme="http://taobaofed.org/categories/Node-js/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[新版卖家中心 Bigpipe 实践（二）]]></title>
    <link href="http://taobaofed.org/blog/2016/03/25/seller-bigpipe-coding/"/>
    <id>http://taobaofed.org/blog/2016/03/25/seller-bigpipe-coding/</id>
    <published>2016-03-25T02:54:04.000Z</published>
    <updated>2016-07-22T05:20:24.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://gtms04.alicdn.com/tps/i4/TB1w6tIMXXXXXcDaXXXlzJZ8pXX-900-500.jpg" alt="新版卖家中心 Bigpipe 实践（二）"></p>
<p>自从上次通过 <a href="http://taobaofed.org/blog/2015/12/17/seller-bigpipe/">新版卖家中心 Bigpipe 实践（一）</a> 阐述了 Bigpipe 实现思路和原理之后，一转眼春天就来了。而整个实践过程，从开始冬天迎着冷风前行，到现在逐渐回暖。其中感受和收获良多，和大家分享下。代码偏多，请自带编译器。</p>
<h2 id="核心问题"><a href="#核心问题" class="headerlink" title="核心问题"></a>核心问题</h2><p>一切技术的产生或者使用都是为了解决问题，所以开始前，看下要解决的问题：</p>
<ul>
<li>同步加载首屏模块，服务端各个模块并行生成内容，客户端渲染内容依赖于最后一个内容的生成时间。这里的痛点是 <strong><em>同步</em></strong>。因为要多模块同步，所以难免浏览器要等待，浏览器等待也就是用户等待。</li>
<li>于是我们采用了滚动异步加载模块，页面框架优先直出，几朵菊花旋转点缀，然后首屏模块通过异步请求逐个展现出来。虽然拿到什么就能在客户端渲染显示，但还是有延迟感。这里的痛点是 <strong><em>请求</em></strong>，每个模块都需要多一个请求，也需要时间。</li>
<li>Facebook 的工程师们会不会是这样想的：一次请求，各个首屏模块服务端并行处理生成内容，生成的内容能直接传输给客户端渲染，用户能马上看到内容，这样好猴赛雷~</li>
<li>其实 Bigpipe  的思路是从<a href="https://en.wikipedia.org/wiki/Instruction_pipelining" target="_blank" rel="external">微处理器的流水线</a>中受到启发</li>
</ul>
<h2 id="技术突破口"><a href="#技术突破口" class="headerlink" title="技术突破口"></a>技术突破口</h2><p>卖家中心主体也是功能模块化，和 Facebook 遇到的问题是一致的。核心的问题换个说法： <strong><em>通过一个请求链接，服务端能否将动态内容分块传输到客户端实时渲染展示，直到内容传输结束，请求结束。</em></strong></p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li>技术点：HTTP 协议的分块传输（在 HTTP 1.1 提供）<a href="https://zh.wikipedia.org/wiki/%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93%E7%BC%96%E7%A0%81" target="_blank" rel="external">概念入口</a></li>
<li>如果一个 HTTP 消息（请求消息或应答消息）的 Transfer-Encoding 消息头的值为 chunked ，那么，消息体由数量未定的块组成，并以最后一个大小为 0 的块为结束。</li>
<li>这种机制使得网页内容分成多个内容块，服务器和浏览器建立管道并管理他们在不同阶段的运行。</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>如何实现数据分块传输，各个语言的方式并不一样。</p>
<h4 id="PHP-的方式"><a href="#PHP-的方式" class="headerlink" title="PHP 的方式"></a>PHP 的方式</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>php chunked<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="php"><span class="meta">&lt;?php</span> sleep(<span class="number">1</span>); <span class="meta">?&gt;</span></span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"moduleA"</span>&gt;</span><span class="php"><span class="meta">&lt;?php</span> <span class="keyword">echo</span> <span class="string">'moduleA'</span> <span class="meta">?&gt;</span></span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="php"><span class="meta">&lt;?php</span> ob_flush(); flush(); <span class="meta">?&gt;</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="php"><span class="meta">&lt;?php</span> sleep(<span class="number">3</span>); <span class="meta">?&gt;</span></span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"moduleB"</span>&gt;</span><span class="php"><span class="meta">&lt;?php</span> <span class="keyword">echo</span> <span class="string">'moduleB'</span> <span class="meta">?&gt;</span></span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="php"><span class="meta">&lt;?php</span> ob_flush(); flush(); <span class="meta">?&gt;</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="php"><span class="meta">&lt;?php</span> sleep(<span class="number">2</span>); <span class="meta">?&gt;</span></span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"moduleC"</span>&gt;</span><span class="php"><span class="meta">&lt;?php</span> <span class="keyword">echo</span> <span class="string">'moduleC'</span> <span class="meta">?&gt;</span></span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="php"><span class="meta">&lt;?php</span> ob_flush(); flush(); <span class="meta">?&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>PHP 利用  ob_flush 和 flush 把页面分块刷新缓存到浏览器，查看 network ，页面的 Transfer-Encoding=chunked ，实现内容的分块渲染。</li>
<li>PHP 不支持线程，所以服务器无法利用多线程去并行处理多个模块的内容。</li>
<li>PHP  也有并发执行的方案，这里不做扩展，有兴趣地可以去深入研究下。</li>
</ul>
<h4 id="Java-的方式"><a href="#Java-的方式" class="headerlink" title="Java 的方式"></a>Java 的方式</h4><ul>
<li>Java 也有类似于 flush 的函数 实现简单页面的分块传输。</li>
<li>Java 是多线程的，方便并行地处理各个模块的内容。</li>
</ul>
<h3 id="flush-的思考"><a href="#flush-的思考" class="headerlink" title="flush 的思考"></a>flush 的思考</h3><ul>
<li>Yahoo 34 条性能优化 Rules 里面提到 flush 时机是 head 之后，可以让浏览器先行下载 head 中引入的 CSS/js。</li>
<li>我们会把内容分成一块一块 flush 到浏览器端，flush 的内容优先级应该是用户关心的。比如 Yahoo 之前优先 flush 的就是搜索框，因为这个是核心功能。</li>
<li>flush 的内容大小需要进行有效地拆分，大内容可以拆成小内容。</li>
</ul>
<h2 id="Node-js-实现"><a href="#Node-js-实现" class="headerlink" title="Node.js 实现"></a>Node.js 实现</h2><p>通过对比 PHP 和 Java 在实现 Bigpipe 上的优势和劣势，很容易在 Node.js 上找到幸福感。</p>
<ul>
<li>Node.js 的异步特性可以很容易地处理并行的问题。</li>
<li>View 层全面控制，对于需要服务端处理数据和客户端渲染有天然的优势。</li>
<li>Node.js 中的 HTTP 接口的设计支持许多 HTTP 协议中原本用起来很困难的特性。</li>
</ul>
<h3 id="回到-HelloWorld"><a href="#回到-HelloWorld" class="headerlink" title="回到 HelloWorld"></a>回到 HelloWorld</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var http = require(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line">http.createServer(function (request, response)&#123;</span><br><span class="line">  response.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/html'</span>&#125;);</span><br><span class="line">  response.<span class="built_in">write</span>(<span class="string">'hello'</span>);</span><br><span class="line">  response.<span class="built_in">write</span>(<span class="string">' world '</span>);</span><br><span class="line">  response.<span class="built_in">write</span>(<span class="string">'~ '</span>);</span><br><span class="line">  response.<span class="built_in">end</span>();</span><br><span class="line">&#125;).<span class="built_in">listen</span>(<span class="number">8080</span>, <span class="string">"127.0.0.1"</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>HTTP 头 Transfer-Encoding=chunked ，我的天啊，太神奇了！</li>
<li>如果只是 response.write 数据，没有指示 response.end ，那么这个响应就没有结束，浏览器会保持这个请求。在没有调用 response.end 之前，我们完全可以通过 response.write 来 flush 内容。</li>
<li>把 Bigpipe  Node.js 实现是从 HelloWorld 开始，心情有点小激动。</li>
</ul>
<h3 id="完整点"><a href="#完整点" class="headerlink" title="完整点"></a>完整点</h3><p><strong>layout.html</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- css and js tags --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"index.css"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">renderFlushCon</span>(<span class="params">selector, html</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.querySelector(selector).innerHTML = html;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"A"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"B"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"C"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>head 里面放我们要加载的 assets</li>
<li>输出页面框架，A/B/C 模块的占位</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">  response.writeHead(<span class="number">200</span>, &#123; <span class="string">'Content-Type'</span>: <span class="string">'text/html'</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// flush layout and assets</span></span><br><span class="line">  <span class="keyword">var</span> layoutHtml = fs.readFileSync(__dirname + <span class="string">"/layout.html"</span>).toString();</span><br><span class="line">  response.write(layoutHtml);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// fetch data and render</span></span><br><span class="line">  response.write(<span class="string">'&lt;script&gt;renderFlushCon("#A","moduleA");&lt;/script&gt;'</span>);</span><br><span class="line">  response.write(<span class="string">'&lt;script&gt;renderFlushCon("#C","moduleC");&lt;/script&gt;'</span>);</span><br><span class="line">  response.write(<span class="string">'&lt;script&gt;renderFlushCon("#B","moduleB");&lt;/script&gt;'</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// close body and html tags</span></span><br><span class="line">  response.write(<span class="string">'&lt;/body&gt;&lt;/html&gt;'</span>);</span><br><span class="line">  <span class="comment">// finish the response</span></span><br><span class="line">  response.end();</span><br><span class="line">&#125;).listen(<span class="number">8080</span>, <span class="string">"127.0.0.1"</span>);</span><br></pre></td></tr></table></figure>
<p>页面输出：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">moduleA</span></span><br><span class="line">moduleB</span><br><span class="line">moduleC</span><br></pre></td></tr></table></figure>
<ul>
<li>flush layout 的内容 包含浏览器渲染的函数</li>
<li>然后进入核心的取数据、模板拼装，将可执行的内容 flush 到浏览器</li>
<li>浏览器进行渲染（此处还未引入并行处理）</li>
<li>关闭 body 和 HTML 标签</li>
<li>结束响应 完成一个请求</li>
</ul>
<h3 id="express-实现"><a href="#express-实现" class="headerlink" title="express 实现"></a>express 实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// flush layout and assets</span></span><br><span class="line">  <span class="keyword">var</span> layoutHtml = fs.readFileSync(__dirname + <span class="string">"/layout.html"</span>).toString();</span><br><span class="line">  res.write(layoutHtml);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// fetch data and render</span></span><br><span class="line">  res.write(<span class="string">'&lt;script&gt;renderFlushCon("#A","moduleA");&lt;/script&gt;'</span>);</span><br><span class="line">  res.write(<span class="string">'&lt;script&gt;renderFlushCon("#C","moduleC");&lt;/script&gt;'</span>);</span><br><span class="line">  res.write(<span class="string">'&lt;script&gt;renderFlushCon("#B","moduleB");&lt;/script&gt;'</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// close body and html tags</span></span><br><span class="line">  res.write(<span class="string">'&lt;/body&gt;&lt;/html&gt;'</span>);</span><br><span class="line">  <span class="comment">// finish the response</span></span><br><span class="line">  res.end();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
<p>页面输出：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">moduleA</span></span><br><span class="line">moduleB</span><br><span class="line">moduleC</span><br></pre></td></tr></table></figure>
<ul>
<li>express 建立在 Node.js 内置的 HTTP 模块上，实现的方式差不多</li>
</ul>
<h3 id="koa-实现"><a href="#koa-实现" class="headerlink" title="koa 实现"></a>koa 实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">var</span> app = koa();</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span> *(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.body = <span class="string">'Hello world'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Koa 不支持 直接调用底层 res 进行响应处理。</strong> res.write()/res.end() 就是个雷区，有幸踩过。</li>
<li>koa 中，this 这个上下文对 Node.js 的 request 和 response 对象的封装。this.body 是 response 对象的一个属性。</li>
<li>感觉 koa 的世界就剩下了 generator 和  this.body ，怎么办？继续看文档~</li>
<li>this.body 可以设置为字符串， buffer 、stream 、 对象 、 或者 null 也行。</li>
<li><strong>stream</strong>  <strong>stream</strong>  <strong>stream</strong>  说三遍可以变得很重要。</li>
</ul>
<h2 id="流的意义"><a href="#流的意义" class="headerlink" title="流的意义"></a>流的意义</h2><p>关于流，推荐看 @愈之的<a href="http://taobaofed.org/blog/2016/01/28/nodejs-stream/">通通连起来 – 无处不在的流</a>，感触良多，对流有了新的认识，于是接下来连连看。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">var</span> View = <span class="built_in">require</span>(<span class="string">'./view'</span>);</span><br><span class="line"><span class="keyword">var</span> app = <span class="built_in">module</span>.exports = koa();</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.type = <span class="string">'html'</span>;</span><br><span class="line">  <span class="keyword">this</span>.body = <span class="keyword">new</span> View(<span class="keyword">this</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
<p><strong>view.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Readable = <span class="built_in">require</span>(<span class="string">'stream'</span>).Readable;</span><br><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="keyword">var</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = View</span><br><span class="line"></span><br><span class="line">util.inherits(View, Readable);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">View</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  Readable.call(<span class="keyword">this</span>, &#123;&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// render the view on a different loop</span></span><br><span class="line">  co.call(<span class="keyword">this</span>, <span class="keyword">this</span>.render).catch(context.onerror);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">View.prototype._read = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">View.prototype.render = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// flush layout and assets</span></span><br><span class="line">  <span class="keyword">var</span> layoutHtml = fs.readFileSync(__dirname + <span class="string">"/layout.html"</span>).toString();</span><br><span class="line">  <span class="keyword">this</span>.push(layoutHtml);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// fetch data and render</span></span><br><span class="line">  <span class="keyword">this</span>.push(<span class="string">'&lt;script&gt;renderFlushCon("#A","moduleA");&lt;/script&gt;'</span>);</span><br><span class="line">  <span class="keyword">this</span>.push(<span class="string">'&lt;script&gt;renderFlushCon("#C","moduleC");&lt;/script&gt;'</span>);</span><br><span class="line">  <span class="keyword">this</span>.push(<span class="string">'&lt;script&gt;renderFlushCon("#B","moduleB");&lt;/script&gt;'</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// close body and html tags</span></span><br><span class="line">  <span class="keyword">this</span>.push(<span class="string">'&lt;/body&gt;&lt;/html&gt;'</span>);</span><br><span class="line">  <span class="comment">// end the stream</span></span><br><span class="line">  <span class="keyword">this</span>.push(<span class="literal">null</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>页面输出：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">moduleA</span></span><br><span class="line">moduleB</span><br><span class="line">moduleC</span><br></pre></td></tr></table></figure>
<ul>
<li>Transfer-Encoding:chunked </li>
<li>服务端和浏览器端建立管道，通过 this.push 将内容从服务端传输到浏览器端</li>
</ul>
<h2 id="并行的实现"><a href="#并行的实现" class="headerlink" title="并行的实现"></a>并行的实现</h2><p>目前我们已经完成了 koa 和 express 分块传输的实现，我们知道要输出的模块 A 、模块 B 、模块 C 需要并行在服务端生成内容。<br>在这个时候来回顾下传统的网页渲染方式，A / B / C 模块同步渲染：</p>
<p><img src="http://gtms04.alicdn.com/tps/i4/TB1XhFPMXXXXXX_XpXXWYGF8FXX-1438-688.png" width="500px"></p>
<p>采用分块传输的模式，A / B / C 服务端顺序执行，A / B / C 分块传输到浏览器渲染：</p>
<p><img src="http://gtms02.alicdn.com/tps/i2/TB1eRpLMXXXXXbBXpXXu4A.4VXX-1432-796.png" width="500px"></p>
<p>时间明显少了，然后把服务端的顺序执行换成并行执行的话：</p>
<p><img src="http://gtms01.alicdn.com/tps/i1/TB1NxVVMXXXXXanXXXX871P.FXX-1446-742.png" width="500px"></p>
<p>通过此图，并行的意义是显而易见的。为了寻找并行执行的方案，就不得不<a href="http://wwsun.github.io/posts/evolution-of-javascript-async.html" target="_blank" rel="external">追溯异步编程</a>的历史。（读史可以明智，可以知道当下有多不容易）</p>
<h3 id="callback-的方式"><a href="#callback-的方式" class="headerlink" title="callback  的方式"></a>callback  的方式</h3><ul>
<li>首先 过多 callback 嵌套 实现异步编程是地狱</li>
<li>第二 选择绕过地狱，选择成熟的模块来取代</li>
</ul>
<h3 id="async-的方式"><a href="#async-的方式" class="headerlink" title="async 的方式"></a>async 的方式</h3><ul>
<li>async 算是异步编码流程控制中的元老。</li>
<li>parallel(tasks, [callback]) 并行执行多个函数，每个函数都是立即执行，不需要等待其它函数先执行。传给最终 callback 的数组中的数据按照 tasks 中声明的顺序，而不是执行完成的顺序。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Readable = <span class="built_in">require</span>(<span class="string">'stream'</span>).Readable;</span><br><span class="line"><span class="keyword">var</span> inherits = <span class="built_in">require</span>(<span class="string">'util'</span>).inherits;</span><br><span class="line"><span class="keyword">var</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> <span class="keyword">async</span> = <span class="built_in">require</span>(<span class="string">'async'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">inherits(View, Readable);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">View</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  Readable.call(<span class="keyword">this</span>, &#123;&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// render the view on a different loop</span></span><br><span class="line">  co.call(<span class="keyword">this</span>, <span class="keyword">this</span>.render).catch(context.onerror);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">View.prototype._read = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">View.prototype.render = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// flush layout and assets</span></span><br><span class="line">  <span class="keyword">var</span> layoutHtml = fs.readFileSync(__dirname + <span class="string">"/layout.html"</span>).toString();</span><br><span class="line">  <span class="keyword">this</span>.push(layoutHtml);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> context = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span>.parallel([</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        context.push(<span class="string">'&lt;script&gt;renderFlushCon("#A","moduleA");&lt;/script&gt;'</span>);</span><br><span class="line">        cb();</span><br><span class="line">      &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">      context.push(<span class="string">'&lt;script&gt;renderFlushCon("#C","moduleC");&lt;/script&gt;'</span>);</span><br><span class="line">      cb();</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        context.push(<span class="string">'&lt;script&gt;renderFlushCon("#B","moduleB");&lt;/script&gt;'</span>);</span><br><span class="line">        cb();</span><br><span class="line">      &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  ], <span class="function"><span class="keyword">function</span> (<span class="params">err, results</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// close body and html tags</span></span><br><span class="line">    context.push(<span class="string">'&lt;/body&gt;&lt;/html&gt;'</span>);</span><br><span class="line">    <span class="comment">// end the stream</span></span><br><span class="line">    context.push(<span class="literal">null</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = View;</span><br></pre></td></tr></table></figure>
<p>页面输出：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">moduleC</span></span><br><span class="line">moduleA</span><br><span class="line">moduleB</span><br></pre></td></tr></table></figure>
<ul>
<li>模块显示的顺序是 C&gt;A&gt;B ，这个结果也说明了  Node.js IO 不阻塞</li>
<li>优先 flush layout 的内容</li>
<li>利用 async.parallel 并行处理 A 、B 、C ，通过 cb() 回调来表示该任务执行完成</li>
<li>任务执行完成后 执行结束回调，此时关闭 body/html 标签 并结束 stream</li>
</ul>
<p>每个 task 函数执行中，如果有出错，会直接最后的 callback。此时会中断，其他未执行完的任务也会停止，所以这个并行执行的方法处理异常的情况需要比较谨慎。</p>
<p>另外 async 里面有个 each 的方法也可以实现异步编程的并行执行：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">each(<span class="name">arr</span>, iterator(<span class="name">item</span>, callback), callback(<span class="name">err</span>))</span><br></pre></td></tr></table></figure>
<p>稍微改造下：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> options = [</span><br><span class="line">  &#123;id:<span class="string">"A"</span>,html:<span class="string">"moduleA"</span>,delay:<span class="number">1000</span>&#125;,</span><br><span class="line">  &#123;id:<span class="string">"B"</span>,html:<span class="string">"moduleB"</span>,delay:<span class="number">0</span>&#125;,</span><br><span class="line">  &#123;id:<span class="string">"C"</span>,html:<span class="string">"moduleC"</span>,delay:<span class="number">2000</span>&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">async.forEach(options, <span class="function"><span class="keyword">function</span><span class="params">(item, callback)</span> </span>&#123; </span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    context.push(<span class="string">'&lt;script&gt;renderFlushCon("#'</span>+item.id+<span class="string">'","'</span>+item.html+<span class="string">'");&lt;/script&gt;'</span>);</span><br><span class="line">    <span class="keyword">callback</span>();</span><br><span class="line">  &#125;, item.delay);</span><br><span class="line">  </span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span><span class="params">(err)</span> </span>&#123; </span><br><span class="line">  <span class="comment">// close body and html tags</span></span><br><span class="line">  context.push(<span class="string">'&lt;/body&gt;&lt;/html&gt;'</span>);</span><br><span class="line">  <span class="comment">// end the stream</span></span><br><span class="line">  context.push(<span class="literal">null</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>结果和 parallel 的方式是一致的，不同的是这种方式关注执行过程，而 parallel 更多的时候关注任务数据</li>
</ul>
<p>我们会发现在使用 async 的时候，已经引入了 co ，co 也是异步编程的利器，看能否找到更简便的方法。</p>
<h3 id="co"><a href="#co" class="headerlink" title="co"></a>co</h3><p>co 作为一个异步流程简化工具，能否利用强大的生成器特性实现我们的并行执行的目标。其实我们要的场景很简单：</p>
<p><strong>多个任务函数并行执行，完成最后一个任务的时候可以进行通知执行后面的任务。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Readable = <span class="built_in">require</span>(<span class="string">'stream'</span>).Readable;</span><br><span class="line"><span class="keyword">var</span> inherits = <span class="built_in">require</span>(<span class="string">'util'</span>).inherits;</span><br><span class="line"><span class="keyword">var</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="comment">// var async = require('async');</span></span><br><span class="line"></span><br><span class="line">inherits(View, Readable);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">View</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  Readable.call(<span class="keyword">this</span>, &#123;&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// render the view on a different loop</span></span><br><span class="line">  co.call(<span class="keyword">this</span>, <span class="keyword">this</span>.render).catch(context.onerror);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">View.prototype._read = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">View.prototype.render = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// flush layout and assets</span></span><br><span class="line">  <span class="keyword">var</span> layoutHtml = fs.readFileSync(__dirname + <span class="string">"/layout.html"</span>).toString();</span><br><span class="line">  <span class="keyword">this</span>.push(layoutHtml);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> context = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> options = [</span><br><span class="line">    &#123;id:<span class="string">"A"</span>,html:<span class="string">"moduleA"</span>,delay:<span class="number">100</span>&#125;,</span><br><span class="line">    &#123;id:<span class="string">"B"</span>,html:<span class="string">"moduleB"</span>,delay:<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;id:<span class="string">"C"</span>,html:<span class="string">"moduleC"</span>,delay:<span class="number">2000</span>&#125;</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> taskNum = options.length;</span><br><span class="line">  <span class="keyword">var</span> exec = options.map(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;opt(item,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    taskNum --;</span><br><span class="line">    <span class="keyword">if</span>(taskNum === <span class="number">0</span>) &#123;</span><br><span class="line">      done();</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;)&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">opt</span>(<span class="params">item,callback</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      context.push(<span class="string">'&lt;script&gt;renderFlushCon("#'</span>+item.id+<span class="string">'","'</span>+item.html+<span class="string">'");&lt;/script&gt;'</span>);</span><br><span class="line">      callback();</span><br><span class="line">    &#125;, item.delay);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">done</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    context.push(<span class="string">'&lt;/body&gt;&lt;/html&gt;'</span>);</span><br><span class="line">      <span class="comment">// end the stream</span></span><br><span class="line">    context.push(<span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  co(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">yield</span> exec;</span><br><span class="line">  &#125;);  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = View;</span><br></pre></td></tr></table></figure>
<ul>
<li>yield array  并行执行数组内的任务。</li>
<li>为了不使用 promise  在数量可预知的情况 ，加了个计数器来判断是否已经结束，纯 co 实现还有更好的方式？</li>
<li>到这个时候，才发现生成器的特性并不能应运自如，需要补一补。</li>
</ul>
<h3 id="co-结合-promise"><a href="#co-结合-promise" class="headerlink" title="co 结合 promise"></a>co 结合 promise</h3><p>这个方法由@大果同学赞助提供，写起来优雅很多。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> options = [</span><br><span class="line">  &#123;id:<span class="string">"A"</span>,html:<span class="string">"moduleAA"</span>,delay:<span class="number">100</span>&#125;,</span><br><span class="line">  &#123;id:<span class="string">"B"</span>,html:<span class="string">"moduleBB"</span>,delay:<span class="number">0</span>&#125;,</span><br><span class="line">  &#123;id:<span class="string">"C"</span>,html:<span class="string">"moduleCC"</span>,delay:<span class="number">2000</span>&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> exec = options.map(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123; <span class="keyword">return</span> opt(item); &#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">opt</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      context.push(<span class="string">'&lt;script&gt;renderFlushCon("#'</span>+item.id+<span class="string">'","'</span>+item.html+<span class="string">'");&lt;/script&gt;'</span>);</span><br><span class="line">      resolve(item);</span><br><span class="line">    &#125;, item.delay);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">done</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  context.push(<span class="string">'&lt;/body&gt;&lt;/html&gt;'</span>);</span><br><span class="line">    <span class="comment">// end the stream</span></span><br><span class="line">  context.push(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">co(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">yield</span> exec;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  done();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="ES-7-async-wait"><a href="#ES-7-async-wait" class="headerlink" title="ES 7 async/wait"></a>ES 7 async/wait</h3><p>如果成为标准并开始引入，相信代码会更精简、可读性会更高，而且实现的思路会更清晰。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">flush</span>(<span class="params">Something</span>) </span>&#123;  </span><br><span class="line">	<span class="keyword">await</span> <span class="built_in">Promise</span>.all[moduleA.flush(), moduleB.flush(),moduleC.flush()]</span><br><span class="line">	context.push(<span class="string">'&lt;/body&gt;&lt;/html&gt;'</span>);</span><br><span class="line">      <span class="comment">// end the stream</span></span><br><span class="line">    context.push(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>此段代码未曾跑过验证，思路和代码摆在这里，ES 7 跑起来 ^_^。</li>
</ul>
<h2 id="Midway"><a href="#Midway" class="headerlink" title="Midway"></a>Midway</h2><p>写到这里太阳已经下山了，如果在这里来个“预知后事如何，请听下回分解”，那么前面的内容就变成一本没有主角的小说。</p>
<p>Midway 是好东西，是前后端分离的产物。分离不代表不往来，而是更紧密和流畅。因为职责清晰，前后端有时候可以达到“你懂的，懂！”，然后一个需求就可以明确了。用 Node.js 代替 Webx MVC 中的 View 层，给前端实施 Bigpipe 带来无限的方便。</p>
<p>&gt;<br>Midway 封装了 koa 的功能，屏蔽了一些复杂的元素，只暴露出最简单的 MVC 部分给前端使用，降低了很大一部分配置的成本。</p>
<h3 id="一些信息"><a href="#一些信息" class="headerlink" title="一些信息"></a>一些信息</h3><ul>
<li>Midway 其实支持 express 框架和 koa 框架，目前主流应该都是 koa，Midway 5.1 之后应该不会兼容双框架。</li>
<li>Midway 可以更好地支持 generators 特性</li>
<li>midway-render this.render（xtpl,data） 内容直接通过 this.body 输出到页面。</li>
</ul>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderView</span><span class="params">(basePath, viewName, data)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> me = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> filepath = path.join(basePath, viewName);</span><br><span class="line">  data = utils.assign(&#123;&#125;, me.state, data);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="function"><span class="keyword">function</span><span class="params">(resolve, reject)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">callback</span><span class="params">(err, ret)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(err);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 拼装后直接赋值this.body</span></span><br><span class="line">      me.body = ret;</span><br><span class="line">      resolve(ret);</span><br><span class="line">    &#125;</span><br><span class="line">    render(filepath, data, <span class="keyword">callback</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><ul>
<li>Midway 的专注点是做前后端分离，Model 层其实是对后端的 Model 做一层代理，数据依赖后端提供。</li>
<li>View 层 模板使用 xtpl 模板，前后端的模板统一。</li>
<li>Controller 把路由和视图完整的结合在了一起，通常在 Controller 中实现 this.render。</li>
</ul>
<h3 id="Bigpipe-的位置"><a href="#Bigpipe-的位置" class="headerlink" title="Bigpipe 的位置"></a>Bigpipe 的位置</h3><p>了解 Midway 这些信息，其实是为了弄清楚 Bigpipe 在 Midway 里面应该在哪里接入会比较合适：</p>
<ul>
<li>Bigpipe 方案需要实现对内容的分块传输，所以也是在 Controller 中使用。</li>
<li>拼装模板需要 midway-xtpl 实现拼装好字符串，然后通过 Bigpipe 分块输出。</li>
<li>Bigpipe 可以实现对各个模块进行取数据和拼装模块内容的功能。</li>
</ul>
<p><strong>建议在 Controller 中作为  Bigpipe 模块引入使用，取代原有 this.render 的方式进行内容分块输出</strong></p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>什么样的场景比较适合 Bigpipe，结合我们现有的东西和开发模式。</p>
<ul>
<li>类似于卖家中心，模块多，页面长，首屏又是用户核心内容。</li>
<li>每个模块的功能相对独立，模板和数据都相对独立。</li>
<li>非首屏模块还是建议用滚动加载，减少首屏传输量。</li>
<li>主框架输出 assets 和 bigpipe 需要的脚本，主要的是需要为模块预先占位。</li>
<li>首屏模块是可以固定或者通过计算确认。</li>
<li>模块除了分块输出，最好也支持异步加载渲染的方式。</li>
</ul>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>最后卖家中心的使用和 Bigpipe 的封装，我们围绕着前面核心实现的分块传输和并行执行，目前的封装是这样的：</p>
<p>由于 Midway  this.render 除了拼装模板会直接 将内容赋值到 this.body，这种时候回直接中断请求，无法实现我们分块传输的目标。所以做了一个小扩展：</p>
<p>midway-render 引擎里面 添加只拼装模板不输出的方法 this.Html</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// just output html no render;</span></span><br><span class="line"> app.context.Html = utils.partial(engine.renderViewText, <span class="built_in">config</span>.path);</span><br></pre></td></tr></table></figure>
<p><strong><em>renderViewText</em></strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderViewText</span>(<span class="params">basePath, viewName, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> me = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> filepath = path.join(basePath, viewName);</span><br><span class="line">  data = utils.assign(&#123;&#125;, me.state, data);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    render(filepath, data, <span class="function"><span class="keyword">function</span>(<span class="params">err, ret</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(err);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//此次 去掉了 me.body=ret</span></span><br><span class="line">      resolve(ret);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>midway-render/midway-xtpl 应该有扩展，但是没找到怎么使用，所以选择这样的方式。</li>
</ul>
<p><strong><em>View.js 模块</em></strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="keyword">var</span> <span class="keyword">async</span> = <span class="built_in">require</span>(<span class="string">'async'</span>);</span><br><span class="line"><span class="keyword">var</span> Readable = <span class="built_in">require</span>(<span class="string">'stream'</span>).Readable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> midway = <span class="built_in">require</span>(<span class="string">'midway'</span>);</span><br><span class="line"><span class="keyword">var</span> DataProxy = midway.getPlugin(<span class="string">'dataproxy'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认主体框架</span></span><br><span class="line"><span class="keyword">var</span> defaultLayout = <span class="string">'&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;'</span>;</span><br><span class="line"></span><br><span class="line">exports.createView = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">noop</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  util.inherits(View, Readable);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">View</span>(<span class="params">ctx, options</span>) </span>&#123;</span><br><span class="line">    Readable.call(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    ctx.type = <span class="string">'text/html; charset=utf-8'</span>;</span><br><span class="line">    ctx.body = <span class="keyword">this</span>;</span><br><span class="line">    ctx.options = options;</span><br><span class="line">    <span class="keyword">this</span>.context = ctx;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.layout = options.layout || defaultLayout;</span><br><span class="line">    <span class="keyword">this</span>.pagelets = options.pagelets || [];</span><br><span class="line">    <span class="keyword">this</span>.mod = options.mod || <span class="string">'bigpipe'</span>;</span><br><span class="line">    <span class="keyword">this</span>.endCB = options.endCB || noop;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   *</span><br><span class="line">   * @type &#123;noop&#125;</span><br><span class="line">   * @private</span><br><span class="line">   */</span></span><br><span class="line">  View.prototype._read = noop;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * flush 内容</span><br><span class="line">   */</span></span><br><span class="line">  View.prototype.flush = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// flush layout</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">this</span>.flushLayout();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// flush pagelets</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">this</span>.flushPagelets();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * flush主框架内容</span><br><span class="line">   */</span></span><br><span class="line">  View.prototype.flushLayout = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.push(<span class="keyword">this</span>.layout);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * flushpagelets的内容</span><br><span class="line">   */</span></span><br><span class="line">  View.prototype.flushPagelets = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> pagelets = <span class="keyword">this</span>.pagelets;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 并行执行</span></span><br><span class="line">    <span class="keyword">async</span>.each(pagelets, <span class="function"><span class="keyword">function</span>(<span class="params">pagelet, callback</span>) </span>&#123;</span><br><span class="line">      self.flushSinglePagelet(pagelet, callback);</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">      self.flushEnd();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * flush 单个pagelet</span><br><span class="line">   * @param pagelet</span><br><span class="line">   * @param callback</span><br><span class="line">   */</span></span><br><span class="line">  View.prototype.flushSinglePagelet = <span class="function"><span class="keyword">function</span>(<span class="params">pagelet, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>,</span><br><span class="line">      context = <span class="keyword">this</span>.context;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.getDataByDataProxy(pagelet,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> data = pagelet.formateData(data, pagelet) || data;</span><br><span class="line"></span><br><span class="line">      context.Html(pagelet.tpl, data).then(<span class="function"><span class="keyword">function</span>(<span class="params">html</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> selector = <span class="string">'#'</span> + pagelet.id;</span><br><span class="line">        <span class="keyword">var</span> js = pagelet.js;</span><br><span class="line"></span><br><span class="line">        self.arrive(selector,html,js);</span><br><span class="line"></span><br><span class="line">        callback();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 获取后端数据</span><br><span class="line">   * @param pagelet</span><br><span class="line">   * @param callback</span><br><span class="line">   */</span></span><br><span class="line">  View.prototype.getDataByDataProxy = <span class="function"><span class="keyword">function</span>(<span class="params">pagelet, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="keyword">this</span>.context;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pagelet.proxy) &#123;</span><br><span class="line">      <span class="keyword">var</span> proxy = DataProxy.create(&#123;</span><br><span class="line">        getData: pagelet.proxy</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      proxy.getData()</span><br><span class="line">        .withHeaders(context.request.headers)</span><br><span class="line">        .done(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">          callback &amp;&amp; callback(data);</span><br><span class="line">        &#125;)</span><br><span class="line">        .fail(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.error(err);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      callback&amp;&amp;callback(&#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 关闭html结束stream</span><br><span class="line">   */</span></span><br><span class="line">  View.prototype.flushEnd = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.push(<span class="string">'&lt;/html&gt;'</span>);</span><br><span class="line">    <span class="keyword">this</span>.push(<span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Replace the contents of `selector` with `html`.</span></span><br><span class="line">  <span class="comment">// Optionally execute the `js`.</span></span><br><span class="line">  View.prototype.arrive = <span class="function"><span class="keyword">function</span> (<span class="params">selector, html, js</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.push(wrapScript(</span><br><span class="line">          <span class="string">'BigPipe('</span> +</span><br><span class="line">              <span class="built_in">JSON</span>.stringify(selector) + <span class="string">', '</span> +</span><br><span class="line">              <span class="built_in">JSON</span>.stringify(html) +</span><br><span class="line">              (js ? <span class="string">', '</span> + <span class="built_in">JSON</span>.stringify(js) : <span class="string">''</span>) + <span class="string">')'</span></span><br><span class="line">      ))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">wrapScript</span>(<span class="params">js</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> id = <span class="string">'id_'</span> + <span class="built_in">Math</span>.random().toString(<span class="number">36</span>).slice(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;script id="'</span> + id + <span class="string">'"&gt;'</span></span><br><span class="line">      + js</span><br><span class="line">      + <span class="string">';remove(\'#'</span> + id + <span class="string">'\');&lt;/script&gt;'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> View;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>context.html 拼装各个 pagelet 的内容</li>
</ul>
<p><strong><em>Controller 调用</em></strong></p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> me = <span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">var</span> layoutHtml = <span class="keyword">yield</span> <span class="keyword">this</span>.Html(<span class="string">'p/seller_admin_b/index'</span>, data);</span><br><span class="line"></span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">new</span> View(me, &#123;</span><br><span class="line">  layout: layoutHtml, <span class="comment">// 拼装好layout模板</span></span><br><span class="line">  pagelets: pageletsConfig,</span><br><span class="line">  mod: <span class="string">'bigpie'</span>  <span class="comment">// 预留模式选择</span></span><br><span class="line">&#125;).flush();</span><br></pre></td></tr></table></figure>
<ul>
<li>layoutHtml 拼装好主框架模板</li>
<li>每个 pagelets 的配置</li>
</ul>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attribute">id</span>: <span class="string">'seller_info'</span>,<span class="comment">//该pagelet的唯一id</span></span><br><span class="line">    <span class="attribute">proxy</span>: <span class="string">'Seller.Module.Data.seller_info'</span>, <span class="comment">// 接口配置</span></span><br><span class="line">    <span class="attribute">tpl</span>: <span class="string">'sellerInfo.xtpl'</span>, <span class="comment">//需要的模板</span></span><br><span class="line">    <span class="attribute">js</span>: <span class="string">''</span> <span class="comment">//需要执行的js</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>proxy 和 tpl 获取数据和拼装模板需要并行执行</li>
<li>js 通常进行模块的初始化</li>
</ul>
<h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>思路和代码实现都基于现有的场景和技术背景，目前只有实现的思路和方案尝试，还没形成统一的解决方案，需要更多的场景来支持。目前有些点还可以改进的：</p>
<ul>
<li>代码可以采用 ES6/ES7 新特性进行改造会更优雅，时刻结合 Midway 的升级进行改进。</li>
<li>分块传输机制存在一些低版本浏览器不兼容的情况，最好实现异步加载模块的方案，分双路由，根据用户设备切换路由。</li>
<li>对于每个模块和内容进行异常处理，设置一个请求的时间限制，达到限制时间，关闭链接，不要让页面挂起。此时把本来需要进行分块传输的模块通过异步的方式引入。</li>
<li>并行的实现方案目前采用 async.each，需要从性能上进行各方案的对比</li>
</ul>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://github.com/bigpipe/bigpipe" target="_blank" rel="external">bigpipe</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93%E7%BC%96%E7%A0%81" target="_blank" rel="external">分块传输编码</a></li>
<li><a href="http://www.searchtb.com/2011/04/an-introduction-to-bigpipe.html" target="_blank" rel="external">BigPipe 学习研究</a></li>
<li><a href="https://strongloop.com/strongblog/streaming-chunked-html-node-js-data/" target="_blank" rel="external">Using Streaming Chunked HTML to Get Node.js to Deliver More Data</a></li>
<li><a href="http://wwsun.github.io/posts/evolution-of-javascript-async.html" target="_blank" rel="external">异步 JavaScript 的发展历程</a></li>
<li><a href="https://www.npmjs.com/package/async" target="_blank" rel="external"> async </a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://gtms04.alicdn.com/tps/i4/TB1w6tIMXXXXXcDaXXXlzJZ8pXX-900-500.jpg" alt="新版卖家中心 Bigpipe 实践（二）"></p>
<p>自从上次通过 <a href="htt]]>
    </summary>
    
      <category term="Bigpipe" scheme="http://taobaofed.org/tags/Bigpipe/"/>
    
      <category term="网页加载优化" scheme="http://taobaofed.org/tags/%E7%BD%91%E9%A1%B5%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="Node.js" scheme="http://taobaofed.org/categories/Node-js/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一个前端的自我修养]]></title>
    <link href="http://taobaofed.org/blog/2016/03/23/the-growth-of-front-end/"/>
    <id>http://taobaofed.org/blog/2016/03/23/the-growth-of-front-end/</id>
    <published>2016-03-23T04:30:27.000Z</published>
    <updated>2016-07-22T05:20:24.000Z</updated>
    <content type="html"><![CDATA[<p><img src="https://img.alicdn.com/tps/TB1x3hvMXXXXXcrXFXXXXXXXXXX-900-500.jpg" alt="一个前端的自我修养"></p>
<p>今天给大家分享的主题是前端的自我成长，这是一个关于成长的话题。</p>
<p>很多人都有这样的感觉：听了很多技术圈子的分享，有的有深度，有的循循善诱，深入浅出，但是呢，几年下来，到底哪些用上了，哪些对自己真的有帮助了?反而有些模糊。</p>
<p>2015 年我在不同的场合分享了很多内容：有移动端的性能、有适配、有 Web vs Native，也有 hybrid，但是其实我一直比较担心，真正有深度的内容，其实面向的是比较小众的群体，比如说 Hybrid，其实它在大部分公司里面，是只能用现成的。</p>
<p>所以我这一次尝试分享一个我认为可以帮助到所有前端的话题，关于前端的成长，如果说这个分享的内容，听众里面有那么几十个人拿到 BAT 的 offer，或者升职加薪，那么我觉得我就认为我取得了成功。</p>
<p>前端其实是个特别苦逼的职业，因为前端技术一直革命的特别快，新技术、新技巧在不断地被发明出来。之前我有一个朋友，他讲说他对自己的认知是了解前端、熟悉前端、精通前端、熟悉前端、不懂前端。为什么呢，他说当他觉得自己对前端所有的东西觉得无所不知，无所不能的时候，忽然看到了一段代码，他完全无法理解，于是整个世界就崩塌了，从此再也不敢说自己会前端。</p>
<p>我就跟他说，这里，缺少的是一种正确的方法，你觉得无所不知、无所不能的标准是什么，是工作中很久没遇到解决不了的问题么？他说还真是这样。我就又问他，那你系统学过前端么？他想了想，还真没学过，大学里不开这个课。的确如此，到目前为止，还没有任何一个大学会教前端，倒是有些培训班，会讲网页开发三剑客。</p>
<p>我这里讲的内容，希望带给大家的，就是该如何学习前端，实现自身成长。</p>
<p><a href="http://gw.alicdn.com/bao/uploaded/TB1CPRlMXXXXXafaXXXXXXXXXXX-826-222.png" target="_blank" rel="external"><img src="http://gw.alicdn.com/bao/uploaded/TB1CPRlMXXXXXafaXXXXXXXXXXX-826-222.png" alt="img"></a></p>
<p>关于成长，首先我得发一个免责声明，不是我对我讲的内容没有信心，而是成长是自己的事，英文有句话，在外企工作的人会经常听到，叫做：</p>
<p>You are the owner of your career.</p>
<p>你是你职业发展的责任人。这句话潜台词是，你（不是你老板，也不是你爸妈，也不是你女朋友）是你职业发展的责任人。</p>
<p>这句话我在我职业生涯的起点听说，一直指导我的职业发展，甚至在我带团队，培养团队的时候，也是中心的指导思想，之前我带的团队的同学，他们有不少人也在带团队，其实他们也在实践这句话，所以我这里，也把这句话、把这个道理分享给给大家。</p>
<p><a href="http://gw.alicdn.com/bao/uploaded/TB1L5FfMXXXXXXaapXXXXXXXXXX-1501-789.png" target="_blank" rel="external"><img src="http://gw.alicdn.com/bao/uploaded/TB1L5FfMXXXXXXaapXXXXXXXXXX-1501-789.png" alt="img"></a></p>
<p>我们讲前端成长，<strong>我认为，主要在两个方面，一部分是“能力”，一部分是“知识”</strong>。我个人的观点，能力占百分之八十，知识占百分之二十。</p>
<p>从这个图上，大家可以看到，其实我们认为变化快的东西，最新出来的 Angular、React、ES2015，其实都在知识里面，知识又分成两部分，一部分我把它叫做标准，它是相对而言比较稳定的，很少会出现一个标准被推翻的事情。另一部分则是技术，像是 jQ、React 这些框架啦，像是 MVC、FLUX 这些架构的东西，这些东西是由各个公司主导的，变化就非常快，你看 Grunt 发展了没多久，Gulp 就来挑战他了，然后又有 browserify、webpack 这些东西。</p>
<p>而我认为占重点的能力，则是非常稳定的，我认为能力是三大块：编程能力、架构能力、工程能力。</p>
<p><strong>编程能力</strong>，就是用代码解决问题的能力，你编程能力越强，就能解决越复杂的问题，细分又有调试、算法、数据结构、OS 原理等这些的支撑，你才能解决各种麻烦的问题。</p>
<p><strong>架构能力</strong>，则是解决代码规模的问题，当一个系统足够复杂，你会写每一块，能解决每一个问题，不等于你能搞定整个系统，这就需要架构能力，架构能力包含了一些意识，比如解耦、接口隔离，也包含认识业务建立抽象模型，也有一些常见的模式，比如经典的 MVC，还有设计层面，面向对象、设计模式等等。</p>
<p>最后<strong>工程能力</strong>，则是解决协作的问题，当系统规模更大，光靠一个人，是没办法完成的，如何保证几个高手互相能够配合好？如何保证项目里面水平最差的人不拖后腿？这个工程化建设，往往会跨越多个业务，以汇报关系上的团队为单位来做。包括前后端解耦，模块化，质量保证，代码风格，等等。</p>
<p>其实不难看出来，这三项，其实是有顺序的，低等级、小团队，编程能力一项就能应付，越资深的前端，越大的公司和团队，越是需要后面的技能，但是这里我要强调一点，其实资深前端，大团队，对能力的需求，是既要还要——不是说资深的前端，编程能力就可以变差。</p>
<p>社区总会有一些声音，对工程能力，对架构能力持有一种抵触的态度，觉得比较虚，觉得不需要。实际上以某些人所在的岗位来说，也没错，毕竟公司、团队的状态确实可能用不到，但是以个人成长的角度来看，就是大错特错。</p>
<p><a href="http://gw.alicdn.com/bao/uploaded/TB1L9VmMXXXXXc0XVXXXXXXXXXX-1729-990.png" target="_blank" rel="external"><img src="http://gw.alicdn.com/bao/uploaded/TB1L9VmMXXXXXc0XVXXXXXXXXXX-1729-990.png" alt="img"></a></p>
<p>下面我们来具体讲讲，关于知识的学习。</p>
<p>对知识，我一直有个观点，叫做宁缺毋滥，这个图片上写了一句好前端才分对错，是的，其实很多人，他学习东西的时候就喜欢挑，挑简单的学，书选择最”深入浅出”的，在这种心态下，没有任何一丝学好的可能性，</p>
<p>所以我对知识学习的目标，理解为亮点，一曰准确，二曰全面。当年学习一部分知识，如果你能做到这两点，那你将来在业务上做技术决策的时候，你面对面试官技术问题的时候，信心跟你只看过皮毛是完全不一样的。</p>
<p>怎么做到这两点呢？我想路子肯定有很多，而我的答案，我这里要分享的，是“建立自己的知识体系”。</p>
<p>如何建立自己的知识体系呢？我个人总结的经验，是下面几个步骤：</p>
<p><strong>第一步，寻找线索。</strong></p>
<p>你要了解一个知识，比如我想学 Web 平台的 API 了，当然可以先找一本书，看看别人都写了什么，但是我不喜欢这么干。</p>
<p>我大学里，学前端的东西，为了找个 id 和 name 的区别，曾经要借十几本书来，对比着看，那个时候，是真的没人告诉我，什么书比较好。所以我对别人总结好的知识，第一反应是质疑，不信。</p>
<p>所以我比较推荐，找一些比较准确的，你可以确定它真的足够全面的资料当作线索。对 Web 平台的 API，我就用反射：</p>
<p><a href="http://gw.alicdn.com/bao/uploaded/TB1COtpMXXXXXbwXVXXXXXXXXXX-1224-924.png" target="_blank" rel="external"><img src="http://gw.alicdn.com/bao/uploaded/TB1COtpMXXXXXbwXVXXXXXXXXXX-1224-924.png" alt="img"></a></p>
<p>浏览器里给出来的这个属性列表是不会骗人的，用这个东西作为线索，我就很有信心。</p>
<p>同样可能比较适合做的资料，还有一些标准文档的附录，和源代码里的结构定义。</p>
<p><strong>第二步，是建立联系。</strong></p>
<p>比如说，看下面几个 DOM 属性：</p>
<p><a href="http://gw.alicdn.com/bao/uploaded/TB1_AJIMXXXXXXeXXXXXXXXXXXX-1202-352.png" target="_blank" rel="external"><img src="http://gw.alicdn.com/bao/uploaded/TB1_AJIMXXXXXXeXXXXXXXXXXXX-1202-352.png" alt="img"></a></p>
<p>这里，左边一列是操作 Node 的，右边一列是操作 Element 的，它就存在一定的对应关系。</p>
<p>一般来说，我们找对应关系的方式有以下几个依据：</p>
<ul>
<li>美感</li>
<li>完备性</li>
<li>操作同一组数据</li>
</ul>
<p>特别提一下，操作同一组数据，正是面向对象的核心概念，对前端而言，有点不一样的是，所有的 API，根都是 window，所以，其实大部分的 API，可以依据面向对象的数据和操作的观点进行划分。</p>
<p><strong>第三步，是分类。</strong></p>
<p>这里我给出一个实际一些的例子，下图是我对 zepto(移动简化版jQuery)，的 API 分类</p>
<p><a href="http://gw.alicdn.com/mt/TB1DbJqMXXXXXbBXVXXXXXXXXXX-800-1173.png" target="_blank" rel="external"><img src="http://gw.alicdn.com/mt/TB1DbJqMXXXXXbBXVXXXXXXXXXX-800-1173.png" alt="img"></a></p>
<p>建立联系以后，我们依据知识之间的联系，进行分类，就可以得到一张图谱，在这个图里面，你就可以非常清楚地知道，哪些知识，是非常重要的，哪些，其实是可以互相替代的。</p>
<p>而一旦有你之前没见过的东西，你又能通过把它放到图谱里，来快速理解它，或者找出一些很好的替代方案。</p>
<p>比如说面试的时候，如果面试官问你 bind 和 unbind 怎么用，你还不会，这时候，如果你心里有这张图，你就不至于一脸懵了，你可以说，虽然我不知道 bind 和 unbind，但是我知道 live 和 die 啊，我又知道 on 和 off 啊。</p>
<p>这张图里我们就可以看出，collection 里面的东西，多半没什么用，而节点操作里，肯定就都很有用。</p>
<p>第四步，是追本溯源。</p>
<p>当我对一个知识体系的全貌有了概念以后，占了全面两个字，接下来需要确认它的准确性。很多知识，在社区，会有很多的争议，该相信谁呢，这是个问题。而我的答案，就是追本溯源，去找它最初的讨论和定义。</p>
<p>有一个真实的案例，就是闭包这个概念，曾经我们很多人的理解都是错的，把闭包和 scope 的概念给混淆起来，认为闭包是函数的执行环境上下文，但是有一个叫做 hax 的（很多人应该都认识他，哈哈），他就对此提出了质疑，认为闭包就是函数。于是我就去查证闭包的概念。</p>
<p>大家都知道，wiki 其实是不准确的，但是其中有一段，基本不会太有问题，就是历史。下图是 closure 这个词条的历史部分：</p>
<p><a href="http://gw.alicdn.com/bao/uploaded/TB1d1XsMXXXXXXBXVXXXXXXXXXX-2263-430.png" target="_blank" rel="external"><img src="http://gw.alicdn.com/bao/uploaded/TB1d1XsMXXXXXXBXVXXXXXXXXXX-2263-430.png" alt="img"></a></p>
<p>从这段历史里，我找到了一个名字， Peter J Landin，他是提出者，那么，我就去看看他到底是怎么说的，于是我去 google 学术搜索，找他的文章</p>
<p><a href="http://gw.alicdn.com/bao/uploaded/TB1lEdkMXXXXXXOaXXXXXXXXXXX-1388-551.png" target="_blank" rel="external"><img src="http://gw.alicdn.com/bao/uploaded/TB1lEdkMXXXXXXOaXXXXXXXXXXX-1388-551.png" alt="img"></a></p>
<p>果然找到了，于是我们看看原始的文件</p>
<p><a href="http://gw.alicdn.com/bao/uploaded/TB1S9XiMXXXXXaLaXXXXXXXXXXX-751-477.png" target="_blank" rel="external"><img src="http://gw.alicdn.com/bao/uploaded/TB1S9XiMXXXXXaLaXXXXXXXXXXX-751-477.png" alt="img"></a></p>
<p>这个定义，对应到我们今天 JS 里的闭包，是稍微有点区别的，但是它毫无疑问，是包含了两个部分环境部分和控制（代码）部分，所以其实，闭包就是对应着 JS 的函数，而之前，普遍的观点是认为闭包只包含环境。</p>
<p>所以这个追溯的过程，能够帮我们真正搞清楚对错。</p>
<p>除了 wiki-google 学术搜索的组合，还有一些邮件列表和 github 提交历史，也是非常适合去查证一些概念和技术的历史的。</p>
<p>最后说，我讲的这个建立知识体系的过程，是不断接受新知识，挑战、质疑原有的体系，推翻再重建，每一次循环，你的知识体系都变得更加坚固，更加强大。</p>
<p><a href="http://gw.alicdn.com/bao/uploaded/TB1wVBmMXXXXXX0aXXXXXXXXXXX-975-767.png" target="_blank" rel="external"><img src="http://gw.alicdn.com/bao/uploaded/TB1wVBmMXXXXXX0aXXXXXXXXXXX-975-767.png" alt="img"></a></p>
<p><a href="http://gw.alicdn.com/bao/uploaded/TB1KQhAMXXXXXXUXpXXXXXXXXXX-1732-973.png" target="_blank" rel="external"><img src="http://gw.alicdn.com/bao/uploaded/TB1KQhAMXXXXXXUXpXXXXXXXXXX-1732-973.png" alt="img"></a></p>
<p>下面分享的一部分，是关于能力培养。</p>
<p>能力培养其实重要性很高，但是其实说起来，内容却很少。只有两点: 教材、训练。</p>
<p>对知识学习，我是主张建立自己的体系，不要去相信书，但是对能力培养，我的观点就刚好相反，我觉得能力的体系，恰恰是难以自己建立的，需要教材去指导。这是由两者的复杂程度和变化速度决定的。</p>
<p>想培养能力，就要找经典的教材来学习，像算法导论，The C++ Programming Language这些经典，几十年都没有过时。</p>
<p>注意这里我用了教材，而不是书。</p>
<p>教材和书最大的区别，就是有没有习题。</p>
<p>在我看来，内容再难的书可以一星期读两本，但是教材一定不行，教材一定得花几个月的时间，一边读一边做习题。</p>
<p>于是谈到训练。</p>
<p>其实有个事实是，工作以后，只有极少数人仍然能够做到训练，比如我自己的编程能力，我自觉工作 7、8 年，几乎没有过进步。</p>
<p>训练应该是系统的（需要教材）、主动的，这两个特点不可或缺，有人会觉得，我真的工作很辛苦，每天都要加班，但是其实，任何被动的痛苦，都没法给人带来进步，你的痛苦倒是可能给老板带来更多收入。</p>
<p>如果面临困境，可以选择系统训练来提升自己，但是对大部分人来说，可能更乐于选择一个一个变通的办法: 养成习惯，让工作变得更有挑战。</p>
<p>这个事情其实有不少理论，比较有名的是 Noel Tichy 提出的心理舒适区、学习区和恐慌区。选择一份对自己来说具有挑战性的工作，正面解决问题。</p>
<p>技术圈里流行一个笑话，说的是一个人，工作了三年，却只有一年的经验，因为后面两年都在重复第一年的工作。</p>
<p>所以我们要做的事，就是永远不重复劳动，当你觉得现在的工作，越来越舒适，越来越缺少风险的时候，就应该引起警惕了。</p>
<p>而虽然训练是个很困难的事情，其实大家也不必过于担忧，虽然到处都是“一万小时训练”的言论，现在各大公司的招聘门槛，在我看来应该都卡在几百小时训练的程度。所以我想说，一万小时太久，只争朝夕。希望看到大家成为更好的前端，做更好的自己。</p>
<p>以上是我分享的所有内容。</p>
<p><a href="http://gw.alicdn.com/bao/uploaded/TB1CPJFMXXXXXbSXXXXXXXXXXXX-624-819.png" target="_blank" rel="external"><img src="http://gw.alicdn.com/bao/uploaded/TB1CPJFMXXXXXbSXXXXXXXXXXXX-624-819.png" alt="img"></a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="https://img.alicdn.com/tps/TB1x3hvMXXXXXcrXFXXXXXXXXXX-900-500.jpg" alt="一个前端的自我修养"></p>
<p>今天给大家分享的主题是前端的自我成长，这是一个关于成长的话题。</p>]]>
    </summary>
    
      <category term="鸡汤" scheme="http://taobaofed.org/tags/%E9%B8%A1%E6%B1%A4/"/>
    
      <category term="分享" scheme="http://taobaofed.org/tags/%E5%88%86%E4%BA%AB/"/>
    
      <category term="团队生活" scheme="http://taobaofed.org/categories/%E5%9B%A2%E9%98%9F%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[淘宝前端国际化方案探索]]></title>
    <link href="http://taobaofed.org/blog/2016/03/21/internationalization/"/>
    <id>http://taobaofed.org/blog/2016/03/21/internationalization/</id>
    <published>2016-03-21T07:42:13.000Z</published>
    <updated>2016-07-22T05:20:24.000Z</updated>
    <content type="html"><![CDATA[<p><img src="https://gw.alicdn.com/tps/TB1qZUTLVXXXXbMapXXXXXXXXXX-900-500.png" alt="淘宝前端国际化方案探索"></p>
<p>全球化、农村、云计算大数据是我们目前集团非常明确的未来战略。全球化会让我们服务更多的人，服务全球范围内的人。落实到我们前端这块就需要有一套国际化的方案，能为海外用户提供非常好的体验，推进集团全球化进展。</p>
<p>这段时间有幸交接了淘宝海外的业务，淘宝海外就是专门面向国外用户提供服务的，因此在国际化这边有一些尝试，但是还远远不够，之前主要面向的用户是海外华人和留学生等，所以国际化只是做了一些繁简体转换等。后面多语言还会面临更多更大的挑战。在这里我思考整理汇总一下国际化方案，希望与大家讨论完善，后续可以针对一些重要的点进行突破和落地，最终产出一整套国际化方案。</p>
<h2 id="国际化的目的"><a href="#国际化的目的" class="headerlink" title="国际化的目的"></a>国际化的目的</h2><p>简单的说一个国外网站被你打开却以为是国内公司开的，那么这个网站的国际化就做的非常成功。</p>
<p>所以国际化的目的就是：让各个地区的人都能感受到这个网站像本地的网站一样，亲切、易用。</p>
<p>然而这个目标很难实现，在做调研的时候，亚马逊属于国际化比较好的网站，开设分站并在主要几个国家都有专门的运营团队等，然而让普通人打开这个中国亚马逊，还是能感受到与淘宝、京东的不同。</p>
<p>即便是无法完全实现目标，我们仍然可以用技术以较低成本来尽可能改善体验，因此还是有一定的价值来探索这个。</p>
<h2 id="国际化的流程和步骤"><a href="#国际化的流程和步骤" class="headerlink" title="国际化的流程和步骤"></a>国际化的流程和步骤</h2><p>一个其他地区的人访问我们的网页，然后最终得到一个国际化友好的网页，这个过程发生了什么？这个过程有哪些问题和解决方案？下面就来整条链路的梳理一下。</p>
<h3 id="针对来源判断用户所属区域"><a href="#针对来源判断用户所属区域" class="headerlink" title="针对来源判断用户所属区域"></a>针对来源判断用户所属区域</h3><p>当这个用户访问的时候，我们要获取该用户所属地区，然后拿到相关语言和习惯然后才能进行下一步处理。因此可以有两种方法：</p>
<ul>
<li>入口 URL 附带相关参数。</li>
<li>通过 IP 地址进行判断。</li>
</ul>
<p>第一种方法适用于引导页进行跳转，使用范围比较小。初次访问的判断方法最好是 IP 判断的方式进行。我们已经有一套 IP 库：<a href="http://ip.taobao.com/" target="_blank" rel="external">http://ip.taobao.com/</a> ，后端也有相关接口，初次访问的人可以用这种方式进行粗略的定位，因为 IP 肯定会有误差。</p>
<h3 id="记录-Cookie-并提供用户切换地区、语言的功能"><a href="#记录-Cookie-并提供用户切换地区、语言的功能" class="headerlink" title="记录 Cookie 并提供用户切换地区、语言的功能"></a>记录 Cookie 并提供用户切换地区、语言的功能</h3><p>访问之后，我们可以粗略拿到该用户所在的地区，因此可以回写一个 Cookie 来保存当前用户的一些信息，通常比较重要的信息有：</p>
<ul>
<li>地区</li>
<li>语言</li>
<li>货币</li>
</ul>
<p>这几个信息组合就可以像 sku 那样，共同确定唯一的一个信息，所以我起了个名字叫<strong>『唯一地区语言定位串』</strong>。但是<strong>目前缺乏一套一致的数据规范</strong>，因此会产生一些问题：</p>
<ul>
<li>地区是按国家维度区分还是按区域？香港是表示为 HK 还是 CN？</li>
<li>语言按照什么维度区分？用什么表示？繁体和简体都属于中文，只用中文区分？chinese 和 zh-cn 用哪种表示？</li>
</ul>
<p><strong>这些信息如果没有一套规范和列表，很难进行统一和推广，如果没有在一开始就全集团统一确定下来，后期就会像 GBK、UTF-8 这样的编码问题一样，后患无穷。</strong></p>
<p>当确定了记录信息和 Cookie 键名之后，只要在集团域名下，大家都可以共享这些信息然后进行后续的国际化处理。</p>
<p>此外，由于 IP 的不准确性以及人口的流动，所以还需要提供用户自定义选择的功能，例如之前国际 UED 团队（之前维护淘宝海外）定制的吊顶：</p>
<p><img src="https://img.alicdn.com/tps/TB1.I7yLVXXXXX.XpXXXXXXXXXX-397-193.jpg" alt=""></p>
<p>上面这两步对于基于 Midway 开发的应用，可以以中间件的形式过滤处理直接变成『唯一地区语言定位串』，如果全集团铺开，甚至可以考虑在接入层做这个处理。</p>
<h3 id="针对特定区域进行国际化处理"><a href="#针对特定区域进行国际化处理" class="headerlink" title="针对特定区域进行国际化处理"></a>针对特定区域进行国际化处理</h3><p>获取信息只是第一步，下面轮到我们进行国际化处理了。</p>
<p>国际化的处理主要分为两部分：</p>
<ul>
<li>页面内容改变</li>
<li>页面交互样式改变</li>
</ul>
<p>按照当地的习惯设计视觉、展示当地的语言的内容等，基本就是国际化处理的核心。这块也是最复杂最有挑战性的部分。</p>
<h4 id="文本内容改变"><a href="#文本内容改变" class="headerlink" title="文本内容改变"></a>文本内容改变</h4><p>内容主要有固定文案和动态数据，比如购物车这里：</p>
<p><img src="https://img.alicdn.com/tps/TB1_lsqLVXXXXaFXFXXXXXXXXXX-1077-316.jpg" alt=""></p>
<p>固定文案的处理比较简单，最常见的方法就是创建一个映射表，用一个标记来表示该文案，然后不同区域下读取不同的文案内容即可。</p>
<p>现在市场上也有非常多类似的工具可以帮你简化这些操作，比如 <a href="http://i18next.com/" target="_blank" rel="external">i18next</a> 等。</p>
<p>比较麻烦的是动态数据这块，在淘宝这个场景下，就是各种商品数据，比如标题、sku 等信息。这些信息怎么进行本地化语言转换就是一个需要突破的问题。即便是看似最简单的繁简体转换，也没有那么简单。有些香港、台湾的惯用语等，并不是单个汉字转成繁体就可以的。<a href="http://www.fjt2.net/gate/gb/www.rnb.com.hk/is/difficult.htm" target="_blank" rel="external">更具体的细节可以点击这里</a>。</p>
<p>由于目前在考虑做英文站，需要大量英文数据，后端也有考虑批量翻译商品数据直接存入数据库的方式来处理。但这种翻译不够完善，最大的缺陷在于无法对图片的内容翻译。一个淘宝商品详情承载最大信息量的不是商品标题等，而是商品的图片。卖家往往通过在商品图片上打字来介绍这个商品，所以这种批量转换只能在搜索和 SEO 方面能有所价值。对于真实成交和本地化的体验可能没有非常大的效果。</p>
<p>既然商品信息都是卖家提交的，那国际化的内容，能否让卖家自行提交、编辑？这或许是一个最好的突破口，提供给卖家多语言的编辑入口，赋能想要发展国外业务的卖家，在搜索排名上也会更倾向于这些本地化做的好的商家。这样既解决了本地化内容的问题，又促进了卖家的成交，还带给了买家愉快的购物体验。</p>
<p>更进一步，让淘宝真的只是作为一个交易平台，在当地推广，让本地人开店把商品卖给本地人，建立本地商品库，那是更好的一种方案了。</p>
<p>除了商品数据之外，还有一个非常重要不可忽视的就是价格信息。包括货币表示符号、货币单位、价格映射，也是一块比较大的挑战。而稍有差池则会引起强烈的不满。比如类似人民币的这种货币符号，跟日元等比较像，如果没有表述清楚可能会产生一些误解。</p>
<h4 id="图片内容改变"><a href="#图片内容改变" class="headerlink" title="图片内容改变"></a>图片内容改变</h4><p>商品图片内容改变的挑战已经在在上面列出来了，所以不再赘述。本节所说的图片是由视觉做的，然后由我们进行控制的图片，比如首焦图：</p>
<p><img src="https://img.alicdn.com/tps/TB1BZ3lLVXXXXcfXVXXXXXXXXXX-992-400.jpg" alt=""></p>
<p>这种图片的多语言、国际化我们应该怎么处理呢？马上就可以想到：让视觉在做的时候，把相关文案、视觉换一下，做成多张图片就好了，然后由技术进行定向切换图片地址实现。</p>
<p>但跟淘海外支持视觉讨论了下，并没有这么简单。如果要做好一个国际化的突破，是需要非常细致的做，并不是简单的文案转换即可，视觉都要有变化。对于十分重要的场景（双十一等）这样的投入也是值得的。而日常的一些需求，如果这样做就会十分的浪费资源，投入跟产出比比较低。</p>
<p>他介绍了一种更方便实现的思路，希望可以通过技术手段来解决掉这个问题。顺着他描述的需求的原型，我补充了一些更细节的技术实现思路，在这里简单介绍下。</p>
<p>首先活动图片其实是有一些共性的，比如下图：</p>
<p><img src="https://img.alicdn.com/tps/TB19dcGLVXXXXXYXXXXXXXXXXXX-578-384.jpg" alt=""></p>
<p>基本元素就几个：宣传文案、利益点、辅助图片等。其实很容易形成规范固定下来，比如设计时就放这几个元素，然后基于这几个元素设计一张底图，约定好几个文案元素的位置、大小、字体等，然后由运营填写文案。我们的技术工具可以自动把文案翻译并合并到图片上生成多张多语言的图片。然后当请求这个图片时，会自动根据地区进行返回。实在不行也可以手动填写进去，进行定向投放。</p>
<p>再到后面，甚至都不需要视觉资源。运营想要一个活动，利用现有的模板，从高质量图片库中取出辅助图片，放上去定下位置，填下文案就可以了。</p>
<p>这样就可以减少人力资源的投入，也可以很好的实现图片的国际化处理，极大的提高了效率。</p>
<h4 id="交互样式改变"><a href="#交互样式改变" class="headerlink" title="交互样式改变"></a>交互样式改变</h4><p>国际化中这也是非常大一部分，正如中国亚马逊，商品内容是中文的，但是视觉和交互没有做好本地化，仍然给人感觉跟淘宝、京东不是一类网站。</p>
<p>对于样式、交互的国际化，马上想到的应该是通过给 body 加『唯一地区语言定位串』相关联的 class 来实现定制。这样也有问题，就是与浏览器强绑定，无法实现跨端复用。当你的内容用在 Native 或者没有 body 标签的地方，就没法用了。</p>
<p>如果用这样一套方案，有两个点需要着重考虑：</p>
<ul>
<li>根据语系和习惯来定制 class，而不是语言。比如英文和德语都是字母，他们的样式个性化就有共通性，而不需要定义多个 class 重复编写规则，产生冗余代码。</li>
<li>样式是用来适配内容而不是约束内容。中文内容翻译成英文，长度势必会增长，从而产生错位。这就需要在视觉时就要思考到溢出要怎么处理。可以像响应式布局那样流动起来，样式用来适配内容，而不是固定死约束内容展示。</li>
</ul>
<p>后端的处理在这里会有比较大的优势，就 Midway 而言，可以根据上面解析出来的『唯一地区语言定位串』直接映射到某个区域的 xtpl 模板，实现非常灵活的改变。</p>
<h3 id="国际化的部署服务器"><a href="#国际化的部署服务器" class="headerlink" title="国际化的部署服务器"></a>国际化的部署服务器</h3><p>终于到了最后一步，服务器部署国际化。国内的网络都变幻莫测，更别提国外连到国内服务器的网速了。所以我们的服务器也要进行国际化部署。这样就依靠阿里云多造（租）点机房了。</p>
<p>但并不是所有应用都能迁移到国外，有些核心数据还是要在国内机房。那么这么远距离的链接、数据沟通、应用部署又带来非常多的、不可预知的挑战。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>整个过程中，除了上面描述的那些问题和挑战，目前我能想到的还有两个：</p>
<ul>
<li>文件编码</li>
<li>内容不准确性的修正和个性化需要投入的人力成本</li>
</ul>
<p>目前淘宝由于历史原因还有一些应用是 GBK 编码，GBK 编码显然不能用于国际化、全球化，特殊语言的国家访问看下来全是『口口口口口口口口口口口口口口口口』。或许这也是一个契机，就像升级 HTTPS 那样，推动整个集团去 GBK。</p>
<p>内容和个性化始终需要人力，我们如何能利用技术进一步提高效率解决人力问题？这也是一个挑战。</p>
<p>欢迎你提出一些问题和见解，一起来继续完善下！</p>
<h2 id="附：国际化方案探索脑图"><a href="#附：国际化方案探索脑图" class="headerlink" title="附：国际化方案探索脑图"></a>附：国际化方案探索脑图</h2><p><img src="https://img.alicdn.com/tps/TB1EGQ8LVXXXXa9XVXXXXXXXXXX-1801-1692.jpg" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="https://gw.alicdn.com/tps/TB1qZUTLVXXXXbMapXXXXXXXXXX-900-500.png" alt="淘宝前端国际化方案探索"></p>
<p>全球化、农村、云计算大数据是我们目前集团非常明确的未来战略。全球化会]]>
    </summary>
    
      <category term="国际化" scheme="http://taobaofed.org/tags/%E5%9B%BD%E9%99%85%E5%8C%96/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何优雅的在 koa 中处理错误]]></title>
    <link href="http://taobaofed.org/blog/2016/03/18/error-handling-in-koa/"/>
    <id>http://taobaofed.org/blog/2016/03/18/error-handling-in-koa/</id>
    <published>2016-03-18T03:44:08.000Z</published>
    <updated>2016-07-22T05:20:24.000Z</updated>
    <content type="html"><![CDATA[<p><img src="https://img.alicdn.com/tps/TB1WJcvLVXXXXX5XFXXXXXXXXXX-900-500.jpg" alt="如何优雅的在 koa 中处理错误"></p>
<blockquote>
<p>软件开发时，有 80% 的代码在处理各种错误。<br> </p><p style="text-align:right">——某著名开发者</p><p></p>
</blockquote>
<p>想让自己的代码健壮，错误处理是必不可少的。这篇文章将主要介绍 koa 框架中错误处理的实现（其实主要是 co 的实现），使用 koa 框架开发 web 应用时进行错误处理的一些方法。</p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>在 Node.js 中，错误处理的方法主要有下面几种：</p>
<ul>
<li>和其他同步语言类似的 throw / try / catch 方法</li>
<li>callback(err, data) 回调形式</li>
<li>通过 EventEmitter 触发一个 error 事件</li>
</ul>
<p>第一种使用 catch 来捕获错误，十分易用，其他两种在捕获错误时多多少少都有些别扭。</p>
<p>但是 koa 通过十分巧妙的”黑魔法“让我们可以使用 catch 来捕获异步代码中的错误。比如下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">Promise</span> = <span class="built_in">require</span>(<span class="string">'bluebird'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> filename = <span class="string">'/nonexists'</span>;</span><br><span class="line"><span class="keyword">let</span> statAsync = <span class="built_in">Promise</span>.promisify(fs.stat);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">yield</span> statAsync(filename);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="comment">// error here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 koa 中，推荐统一使用 throw / try / catch 的方式来进行错误的触发和捕获，这会让代码更加易读，防止被绕晕。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>上面我们说了 koa 中可以使用 try / catch，我们就来分析下它是如何做到的。koa 基于 co，所以，我们其实主要是分析 co 的实现。（注：这一部分比较偏原理，不关心的可以跳过。）</p>
<p>首先，我们来看看什么是 generator。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="keyword">yield</span> <span class="string">'start'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  <span class="keyword">var</span> b = <span class="keyword">yield</span> <span class="string">'end'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'over'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> it = gen();</span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// &#123;value: 'start', done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next(<span class="number">22</span>)); <span class="comment">// 22 &#123;value: 'end', done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next(<span class="number">333</span>)); <span class="comment">// 333 &#123;value: 'over', done: true&#125;</span></span><br></pre></td></tr></table></figure>
<p>带有 <code>*</code> 的函数声明表示是一个 generator 函数，当执行 <code>gen()</code> 时，函数体内的代码并没有执行，而是返回了一个 generator 对象。</p>
<p>generator 函数通常和 yield 结合使用，函数执行到每个 yield 时都会暂停并返回 yield 的右值。下次调用 next 时，函数会从 yield 的下一个语句继续执行。等到整个函数执行完，next 方法返回的 done 字段会变成 true，并且将函数返回值作为 value 字段。</p>
<p>第一次执行 <code>next()</code> 时，走到 <code>yield &#39;start&#39;</code> 后暂停并返回 <code>yield</code> 的右值 <code>&#39;start&#39;</code>。注意，此时<code>var a =</code> 这个赋值语句其实还没有执行。</p>
<p>第二次执行 <code>next(22)</code> 时，从 <code>yield &#39;start&#39;</code> 下一个语句执行。于是执行 <code>var a =</code> 这个赋值语句，而表达式 <code>yield &#39;start&#39;</code> 的值就等于传递给 <code>next</code> 函数的参数值 <code>22</code>，所以，<code>a</code> 被赋值为 <code>22</code>。然后继续往下执行到 <code>yield &#39;end&#39;</code> 后暂停并返回 <code>yield</code> 的右值 <code>&#39;end&#39;</code>。</p>
<p>第三次执行 <code>next(333)</code> 时，从 <code>yield &#39;end&#39;</code> 下一个语句执行。此时执行 <code>var b =</code> 这个赋值语句，表达式 <code>yield &#39;end&#39;</code> 的值等于传递给 <code>next</code> 函数的参数 <code>333</code>，<code>b</code> 被赋值为 <code>333</code>。继续往下执行到 <code>return</code> 语句，将 <code>return</code> 语句的返回值作为 <code>value</code> 返回，因为函数已经执行完毕，<code>done</code> 字段标记为 <code>true</code>。</p>
<p>可以看到 generator 就是一种迭代机制，就像一只很懒的青蛙，戳一下（调用 <code>next</code>）动一下。</p>
<p>generator 对象还有一个 <code>throw</code> 方法，可以在 generator 函数外面抛出异常，然后在 generator 函数里面捕获异常。有点绕？我们来看一个实例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'a'</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'b'</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'inside：'</span>, e); <span class="comment">// inside： [Error: error from outside]</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = gen();</span><br><span class="line">it.next();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(it.throw(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error from outside'</span>))); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>
<p>我们执行一次 <code>next</code>，会运行到 <code>yield &#39;a&#39;</code> 这里然后暂停，这一句刚好在 try 的返回内，因此 <code>it.throw</code> 抛出的错误我们可以 catch 到。并且看到 <code>throw</code> 返回的 <code>done</code> 字段是 <code>true</code>，说明后面的 <code>yield &#39;b&#39;</code> 已经不会再执行了。</p>
<p>如果我们不调用 <code>next</code>，或者连续调用三次 <code>next</code>，<code>yield</code> 代码不在 <code>try</code> 返回里面，会导致报错。co 的错误处理其实正是利用了这个 <code>throw</code> 方法。</p>
<p>下面我们来看看 co 的核心代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">co</span>(<span class="params">gen</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> args = slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 统一返回一个整体的 promise</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果是函数，调用并取得 generator 对象</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> gen === <span class="string">'function'</span>) gen = gen.apply(ctx, args);</span><br><span class="line">    <span class="comment">// 如果根本不是 generator 对象（没有 next 方法），直接 resolve 掉并返回</span></span><br><span class="line">    <span class="keyword">if</span> (!gen || <span class="keyword">typeof</span> gen.next !== <span class="string">'function'</span>) <span class="keyword">return</span> resolve(gen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入口函数</span></span><br><span class="line">    onFulfilled();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onFulfilled</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> ret;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 拿到 yield 的返回值</span></span><br><span class="line">        ret = gen.next(res);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="comment">// 如果执行发生错误，直接将 promise reject 掉</span></span><br><span class="line">        <span class="keyword">return</span> reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 延续调用链</span></span><br><span class="line">      next(ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onRejected</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> ret;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 promise 被 reject 了就直接抛出错误</span></span><br><span class="line">        ret = gen.throw(err);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="comment">// 如果执行发生错误，直接将 promise reject 掉</span></span><br><span class="line">        <span class="keyword">return</span> reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 延续调用链</span></span><br><span class="line">      next(ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">ret</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// generator 函数执行完毕，resolve 掉 promise</span></span><br><span class="line">      <span class="keyword">if</span> (ret.done) <span class="keyword">return</span> resolve(ret.value);</span><br><span class="line">      <span class="comment">// 将 value 统一转换为 promise</span></span><br><span class="line">      <span class="keyword">var</span> value = toPromise.call(ctx, ret.value);</span><br><span class="line">      <span class="comment">// 将 promise 添加 onFulfilled、onRejected，这样当新的promise 状态变成成功或失败，就会调用对应的回调。整个 next 链路就执行下去了</span></span><br><span class="line">      <span class="keyword">if</span> (value &amp;&amp; isPromise(value)) <span class="keyword">return</span> value.then(onFulfilled, onRejected);</span><br><span class="line">      <span class="comment">// 没法转换为 promise，直接 reject 掉 promise</span></span><br><span class="line">      <span class="keyword">return</span> onRejected(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'You may only yield a function, promise, generator, array, or object, '</span></span><br><span class="line">        + <span class="string">'but the following object was passed: "'</span> + <span class="built_in">String</span>(ret.value) + <span class="string">'"'</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设有下面的代码，让我们一起推演下执行流程：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">co(<span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(<span class="string">'a 值'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="keyword">yield</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'b 错误'</span>));</span><br><span class="line">    <span class="keyword">var</span> c = <span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(<span class="string">'c 值'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(b, c);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'error'</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'over'</span>;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(err.stack);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>约定：<code>Promise.resolve(&#39;a 值&#39;)</code> 生成的是 promiseA；<code>Promise.reject(new Error(&#39;b 错误&#39;))</code> 生成的是 promiseB。</p>
<p>首先传入 co 的 gen 函数会被执行，获取到 generator 对象。对应代码：<code>if (typeof gen === &#39;function&#39;) gen = gen.apply(ctx, args);</code>。</p>
<p>然后调用 <code>onFulfilled</code> 函数。开启整个执行过程。</p>
<p>第一次执行 <code>ret = gen.next(res)</code>，走到 <code>yield Promise.resolve(&#39;a 值&#39;)</code> 后暂停并返回 <code>yield</code> 的右值，此时 <code>ret</code> 等于 <code>{value: PromiseA, done: false}</code>。</p>
<p>然后执行 <code>next(ret)</code>，将 <code>ret.value</code> 转换为 Promise，执行 <code>value.then(onFulfilled, onRejected)</code>，也就是 <code>PromiseA.then(onFulfilled, onRejected)</code>。当我们的 PromiseA 被 resolve 后，又再次执行 <code>onFulfilled</code>，并传入 resvole 的值，也就是：<code>onFulfilled(&#39;a 值&#39;)</code>。</p>
<p>于是第二次执行 <code>ret = gen.next(&#39;a 值&#39;)</code>（此时的 <code>res</code> 就等于 <code>a 值</code>），进入到 gen 函数，执行接下来的 <code>var a =</code> 赋值语句，<code>yield Promise.resolve(&#39;a 值&#39;)</code> 的返回值等于给 <code>next</code> 传递的参数 <code>&#39;a 值&#39;</code>，于是变量 <code>a</code> 被赋值为 <code>&#39;a 值&#39;</code>。继续执行到 <code>yield Promise.reject(new Error(&#39;b 错误&#39;))</code> 后暂停并返回 <code>yield</code> 的右值，此时 <code>ret</code> 等于 <code>{value: PromiseB, done: false}</code>。</p>
<p>继续执行 <code>next(ret)</code>，延续调用链。执行 <code>value.then(onFulfilled, onRejected)</code>，也就是 <code>PromiseB.then(onFulfilled, onRejected)</code>。这次 PromiseB 被 reject 掉了，于是执行 <code>onRejected</code>，并传人 reject 的错误原因，也就是：<code>onRejected(new Error(&#39;b 错误&#39;))</code>。</p>
<p>于是执行到 <code>ret = gen.throw(new Error(&#39;b 错误&#39;))</code>，而此时 <code>yield Promise.reject(new Error(&#39;b 错误&#39;))</code> 刚好在 try 的范围内，错误被 catch 住了！接着就执行 catch 里面的打印语句 <code>console.log(&#39;error&#39;, e);</code>，一路执行到函数结束（因为再也没有 <code>yield</code> 了），将返回值赋给 <code>value</code>。最后 <code>ret</code> 等于 <code>{value: &#39;over&#39;, done: true}</code>。</p>
<p>继续执行 <code>next(ret)</code>，延续调用链。执行到 <code>if (ret.done) return resolve(ret.value);</code>，于是整体的 promise 被 resolve 掉，执行 <code>then</code> 里面的打印语句，打印出 <code>ret.value</code> 的值 <code>&#39;over&#39;</code>。整个流程结束。</p>
<p>如果我们不 try / catch 会怎样？因为 <code>onRejected</code> 里面有是这样处理的：<code>try { ret = gen.throw(err); } catch (e) { return reject(e); }</code>。我们上面说如果 <code>yield</code> 没有在 <code>try</code>里会导致 <code>gen.throw</code> 报错，于是整体 promise 被 reject，执行其 <code>catch</code> 方法，打印出 <code>Error(&#39;b 错误&#39;)</code> 的堆栈。</p>
<p>这就是“黑魔法”的神秘面纱！对 TJ 大神真是一个大写的“服”字。</p>
<h2 id="什么错误该处理和怎么处理"><a href="#什么错误该处理和怎么处理" class="headerlink" title="什么错误该处理和怎么处理"></a>什么错误该处理和怎么处理</h2><p>接下来的问题是什么样的错误我们需要处理？怎么处理？我们可以将错误分个类：</p>
<ul>
<li>操作错误：不是程序 bug 导致的运行时错误。比如：连接数据库服务器失败、请求接口超时、系统内存用光等等。</li>
<li>程序错误：程序 bug 导致的错误，只要修改代码就可以避免。比如：尝试读取未定义对象的属性、语法错误等等。</li>
</ul>
<p>很显然，我们真正需要处理的是操作错误，程序错误应该马上进行修复。</p>
<p>那怎么处理操作错误呢？总结起来大概有下面这些方法：</p>
<ul>
<li>直接处理。这个简直是废话。举个例子：尝试向一个文件中写东西，但是这个文件不存在，那这个时候会报错吧？处理这个错误的方法就是先创建好要写入的文件。如果我们知道怎么处理错误，那直接处理就是。</li>
<li>重试。有时候某些错误可能是偶发的（比如：连接的服务不稳定等），我们可以尝试对当前操作进行重试。但是一定要设置重试的超时时间、次数，避免长时间的等待卡死应用。</li>
<li>直接将错误抛给调用方。如果我们不知道具体怎么处理错误，那最简单的就是将错误往上抛。比如：检查到用户没有权限访问某个资源，那我们直接 throw 一个 Error（并带上 status 是 403）比较好，上层代码可以 catch 这个错误，然后要么展示一个统一的无权限页面给用户，要么返回一个统一的错误 json 给调用方。</li>
<li>写日志然后将错误抛出。这种情况一般是发生了比较致命的错误，没法处理，也不能重试，那我们需要记下错误日志（方便以后定位问题），然后将错误往上抛（交给上层代码去进行统一错误展示）。</li>
</ul>
<h2 id="使用中间件统一处理错误"><a href="#使用中间件统一处理错误" class="headerlink" title="使用中间件统一处理错误"></a>使用中间件统一处理错误</h2><p>有了上面的说明，那现在我们就来看看在 koa 里面怎么优雅的实现统一错误处理。</p>
<p>答案就是使用强大的中间件！</p>
<p>我们可以在业务逻辑中间件（一般就是 MVC 中的 Controller）开始之前定义下面的中间件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="function"><span class="keyword">function</span>* (<span class="params">next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span>* next;</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="keyword">let</span> status = e.status || <span class="number">500</span>;</span><br><span class="line">    <span class="keyword">let</span> message = e.message || <span class="string">'服务器错误'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> JsonError) &#123; <span class="comment">// 错误是 json 错误</span></span><br><span class="line">      <span class="keyword">this</span>.body = &#123;</span><br><span class="line">        <span class="string">'status'</span>: status,</span><br><span class="line">        <span class="string">'message'</span>: message</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">if</span> (status == <span class="number">500</span>) &#123; </span><br><span class="line">        <span class="comment">// 触发 koa 统一错误事件，可以打印出详细的错误堆栈 log</span></span><br><span class="line">        <span class="keyword">this</span>.app.emit(<span class="string">'error'</span>, e, <span class="keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>.status = status;</span><br><span class="line">    <span class="comment">// 根据 status 渲染不同的页面</span></span><br><span class="line">    <span class="keyword">if</span> (status == <span class="number">403</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.body = <span class="keyword">yield</span> <span class="keyword">this</span>.render(<span class="string">'403.html'</span>, &#123;<span class="string">'err'</span>: e&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (status == <span class="number">404</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.body = <span class="keyword">yield</span> <span class="keyword">this</span>.render(<span class="string">'404.html'</span>, &#123;<span class="string">'err'</span>: e&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (status == <span class="number">500</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.body = <span class="keyword">yield</span> <span class="keyword">this</span>.render(<span class="string">'500.html'</span>, &#123;<span class="string">'err'</span>: e&#125;);</span><br><span class="line">      <span class="comment">// 触发 koa 统一错误事件，可以打印出详细的错误堆栈 log</span></span><br><span class="line">      <span class="keyword">this</span>.app.emit(<span class="string">'error'</span>, e, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>可以看到，我们直接执行 <code>yield* next</code>，然后 <code>catch</code> 执行过程中任何一个中间件的错误，然后根据错误的“特性”，分别进行不同的处理。</p>
<p>有了这个中间件，我们的业务逻辑 controller 中的代码就可以这样来触发错误：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> (<span class="built_in">require</span>(<span class="string">'koa-router'</span>));</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/some_page'</span>, <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 直接抛出错误，被中间件捕获后当成 500 错误</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> PageError(<span class="string">'发生了一个致命错误'</span>); </span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> JsonError(<span class="string">'发送了一个致命错误'</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 带 status 的错误，被中间件捕获后特殊处理</span></span><br><span class="line">  <span class="keyword">this</span>.throw(<span class="number">403</span>, <span class="keyword">new</span> PageError(<span class="string">'没有权限访问'</span>));</span><br><span class="line">  <span class="keyword">this</span>.throw(<span class="number">403</span>, <span class="keyword">new</span> JsonError(<span class="string">'没有权限访问'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="对-Error-分类"><a href="#对-Error-分类" class="headerlink" title="对 Error 分类"></a>对 Error 分类</h2><p>上面的代码里面出现的 <code>JsonError</code>、<code>PageError</code>，实际上是继承于 <code>Error</code> 的两个构造器。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"></span><br><span class="line">exports.JsonError = JsonError;</span><br><span class="line">exports.PageError = PageError;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">JsonError</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Error</span>.call(<span class="keyword">this</span>, message);</span><br><span class="line">&#125;</span><br><span class="line">util.inherits(JsonError, <span class="built_in">Error</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PageError</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Error</span>.call(<span class="keyword">this</span>, message);</span><br><span class="line">&#125;</span><br><span class="line">util.inherits(PageError, <span class="built_in">Error</span>);</span><br></pre></td></tr></table></figure>
<p>通过继承 <code>Error</code> 构造器，我们可以将错误进行细分，从而能更精细的对错误进行处理。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.joyent.com/developers/node/design/errors" target="_blank" rel="external">https://www.joyent.com/developers/node/design/errors</a></li>
<li><a href="https://github.com/koajs/koa/wiki/Error-Handling" target="_blank" rel="external">https://github.com/koajs/koa/wiki/Error-Handling</a></li>
<li><a href="https://imququ.com/post/generator-function-in-es6.html" target="_blank" rel="external">https://imququ.com/post/generator-function-in-es6.html</a></li>
<li><a href="http://purplebamboo.github.io/2014/05/24/koa-source-analytics-1/" target="_blank" rel="external">http://purplebamboo.github.io/2014/05/24/koa-source-analytics-1/</a></li>
<li><a href="http://purplebamboo.github.io/2015/01/16/koa-source-analytics-4/" target="_blank" rel="external">http://purplebamboo.github.io/2015/01/16/koa-source-analytics-4/</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="https://img.alicdn.com/tps/TB1WJcvLVXXXXX5XFXXXXXXXXXX-900-500.jpg" alt="如何优雅的在 koa 中处理错误"></p>
<blockquote>
<p>软件开发时，有 80% 的代码]]>
    </summary>
    
      <category term="node.js" scheme="http://taobaofed.org/tags/node-js/"/>
    
      <category term="co" scheme="http://taobaofed.org/tags/co/"/>
    
      <category term="koa" scheme="http://taobaofed.org/tags/koa/"/>
    
      <category term="Node.js" scheme="http://taobaofed.org/categories/Node-js/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[店铺 KISSY 版本大乱斗]]></title>
    <link href="http://taobaofed.org/blog/2016/03/17/kissy-version-solution/"/>
    <id>http://taobaofed.org/blog/2016/03/17/kissy-version-solution/</id>
    <published>2016-03-17T07:22:52.000Z</published>
    <updated>2016-07-22T05:20:24.000Z</updated>
    <content type="html"><![CDATA[<p><img src="https://gw.alicdn.com/tps/TB1nHczLVXXXXX2XXXXXXXXXXXX-900-500.jpg" alt="店铺 KISSY 版本大乱斗"></p>
<h2 id="店铺-KISSY-版本大乱斗"><a href="#店铺-KISSY-版本大乱斗" class="headerlink" title="店铺 KISSY 版本大乱斗"></a>店铺 KISSY 版本大乱斗</h2><p>可能你不知道，从去年（或者前年？）某个时候起，店铺开始着手将 KISSY 版本从 1.3 升级到 1.4, 期间因为业务或团队变动已经换了两波前端，然而还是没有升级彻底，即部分店铺是 1.4, 另一部分还停留在 1.3 上。不彻底的升级意味着根本就没有升级，因为所有的代码要同时兼容两个版本。</p>
<p>我从 15 年 10 月接手店铺业务，前不久学长找我商量店铺升级 KISSY 6.0 的事情，那一刻我的内心是崩溃的、拒绝的、惨不忍睹的……然而痛苦归痛苦，坑终究是要填的，跟各位大大讨论方案后做了一些尝试，最后终于在上周把这个问题解决掉了。本文就来向大家简单介绍下这段历史以及最终的解决方案，最后附带个人对于开放脚本的一些思考。</p>
<h3 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h3><blockquote>
<p>对于第三方代码，安全问题自不用去提，在此基础上，对于官方代码和三方代码一定要做技术方案的隔离，否则当未来官方代码需要升级技术方案的时候就会步履维艰。</p>
</blockquote>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在店铺体系里，装修系统是很重要的一部分，在整个体系建立之初，为了保证卖家可以在装修过程中有更多的选择，店铺开放了其模块体系：第三方开发者可以开发店铺的模块，然后上架到装修市场，然后卖家需要的时候去市场里订购。（第三方开放者开发的模块下文统一称为设计师模块）</p>
<p>开放模块意外着第三方开发者可以写 HTML, 写 CSS, 而且可以写 JavaScript, 在当时（2010？）的技术条件下，主要使用了两个库：</p>
<ul>
<li>Caja: 负责三方代码的安全问题，出自于谷歌</li>
<li>KISSY 1.3: 作用跟之于我们的业务类似，工具库</li>
</ul>
<p>KISSY 1.3 自不必多说，Caja 是什么呢，借用其官方介绍：</p>
<blockquote>
<p>Caja is a tool for safely embedding third party HTML, CSS and JavaScript in your website.</p>
</blockquote>
<p>值得一提的是，经过这套开发体系的编译，最终我们存储的设计师代码是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;  ___.loadModule(&#123;      </span><br><span class="line">  <span class="string">'instantiate'</span>: <span class="function"><span class="keyword">function</span> (<span class="params">___, IMPORTS___</span>) </span>&#123;        </span><br><span class="line">    <span class="keyword">return</span> ___.prepareModule(&#123;            </span><br><span class="line">      <span class="string">'instantiate'</span>: <span class="function"><span class="keyword">function</span> (<span class="params">___, IMPORTS___</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> dis___ = IMPORTS___;              </span><br><span class="line">        <span class="keyword">var</span> moduleResult___, x0___, x1___, x2___, x3___, x4___, x5___,              </span><br><span class="line">              x6___, x7___, x8___, x9___, x10___, x11___, x12___, x13___,              </span><br><span class="line">              x14___, x15___, x16___, x17___, x18___, x19___, x20___, x21___,              </span><br><span class="line">              x22___, x23___, x24___, x25___, x26___, x27___, x28___, x29___,              </span><br><span class="line">              x30___, x31___, x32___, x33___, x34___, x35___, x36___, x37___,              </span><br><span class="line">              x38___, x39___, x40___, x41___, x42___, x43___;              </span><br><span class="line">        moduleResult___ = ___.NO_RESULT;              </span><br><span class="line">        <span class="keyword">try</span> &#123;                </span><br><span class="line">          &#123;                  </span><br><span class="line">            &#123;                    </span><br><span class="line">              <span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">x</span>) </span>&#123;                      </span><br><span class="line">                <span class="keyword">var</span> x0___;</span><br><span class="line">                <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p><strong>压缩的、混淆的，同时更是不可控的。</strong></p>
<p>另一方面，基于 Caja 我们定制了自己的 shop-caja, 其中在初始化设计师模块时会对 KISSY 做一些改写，负责这部分的代码是 Caja-adapter，因此，我猜测，选择这套方案的同学一定是考虑到未来 KISSY 版本的升级问题，而对应的策略就是在 Caja-adapter 这一层做文章：<strong>无论是 KISSY 哪个版本，在 adapter 里总会让其 API 兼容 KISSY 1.3.</strong></p>
<p>以上只是个人猜测，因为人员的变动这些猜测很难去考证或者考证了也没什么意义。最终的结果就是：前任同学在接手了进行一半的升级工作之后，试图通过这样方式去实现，然而在一年之后还是把这个半成品交接到我这个现任手中。</p>
<h3 id="多版本引发的问题"><a href="#多版本引发的问题" class="headerlink" title="多版本引发的问题"></a>多版本引发的问题</h3><p>因为上文说的 KISSY 版本问题，引发了一些不良后果：</p>
<h4 id="1-凌晨的惊悚"><a href="#1-凌晨的惊悚" class="headerlink" title="1. 凌晨的惊悚"></a>1. 凌晨的惊悚</h4><p>大促活动有个超级顶通，各个业务方都要引入，店铺当然也不例外，之前作为日常需求接入，因为顶通开起来就是一个很简单的展示区块，因此和开发在预发上看了几个店铺没有什么问题于是就推到预发，然后这个顶通是凌晨才会推送上线的，因此这时候线上也自然不会有任何感知。</p>
<p>直到凌晨一点左右，之前的缓存基本失效，预发环境超级顶通生效，使用 KISSY 1.3 的店铺脚本无法执行，很多模块初始化失败，排查之后才发现超级顶通里没有兼容 1.3 的语法，其中最为严重的一点是 <code>use</code> io 模块失效，这里不得不提两个点：</p>
<ol>
<li>KISSY 臭名昭著的核心模块改名事件：ajax(1.3) -&gt; io(1.4)</li>
<li><code>KISSY.use</code> 失败之后会导致页面其他依赖 KISSY 的脚本都无法执行</li>
</ol>
<p>然后开发同学紧急下掉了超级顶通，我当时惊出了一身冷汗，然而负责超级顶通的然姐倒是很淡定 LOL…</p>
<p>所以出现这个问题可能是因为很多因素：<strong>测试的时候没有回归 1.3 的店铺、超级顶通没有兼容 1.3 语法、<code>KISSY.use</code> 的机制太过脆弱</strong>……但是原罪还是店铺里竟然还存在 KISSY 1.3 版本这一事实。</p>
<h4 id="2-难以升级的开发模式"><a href="#2-难以升级的开发模式" class="headerlink" title="2. 难以升级的开发模式"></a>2. 难以升级的开发模式</h4><p>店铺目前的整个开发模式很落后 + 繁琐：KISSY 1.3 的语法，自写的打包脚本 <code>Gruntfile</code>, 异常落后的模块组织体系……自我然不会将这些都归罪于 KISSY 版本，但是如果不解决 KISSY 版本的问题，我们未来无法升级到 KISSY 6.0, 无法升级到 cake, 无法重新梳理店铺的模块机制，无法切换到新版的发布系统，接下来就是一步一步的老死？NO!</p>
<h4 id="3-时不时的线上问题"><a href="#3-时不时的线上问题" class="headerlink" title="3. 时不时的线上问题"></a>3. 时不时的线上问题</h4><p>因为两种版本同时存在，导致了线上的情况会变复杂，进而就是时不时的线上问题。是的，每次线上问题花两到三个小时都可以解决，然而这些付出几乎是毫无意义的，每次排查类似的线上问题我都会很头疼：</p>
<ul>
<li>技术提升了吗？No</li>
<li>会更加了解业务吗？Maybe</li>
<li>会帮助到业务成长吗？Very little</li>
<li>所以，有意义吗？Who knows……</li>
</ul>
<p>所以，基于这些原因，必须要扛起担子解决问题，接着我们就来聊聊方案吧。</p>
<h3 id="解决方案的探索"><a href="#解决方案的探索" class="headerlink" title="解决方案的探索"></a>解决方案的探索</h3><p>在这个问题上，大致的解决思路有两个：</p>
<h4 id="1-利用-caja-adapter-保证-KISSY-代码兼容-1-3-的语法"><a href="#1-利用-caja-adapter-保证-KISSY-代码兼容-1-3-的语法" class="headerlink" title="1. 利用 caja-adapter 保证 KISSY 代码兼容 1.3 的语法"></a>1. 利用 caja-adapter 保证 KISSY 代码兼容 1.3 的语法</h4><p>这个方案，上文已经简单提过，并且店铺前任前端同学之前也有做一些尝试，但是因为 1.4 跟 1.3 的 <code>anim</code> 模块差别太大，一直没有进展，最终随着人员变动无疾而终。简单总结下优缺点：</p>
<ul>
<li>优点：比较优雅，始终只会加载一份 KISSY</li>
<li>缺点：<ul>
<li>可持续升级难度太大，1.4 到 1.3 的语法兼容已经停顿了一年多，更不用提 6.0 到 1.3</li>
<li>方案相对复杂，需要熟悉 shop-caja 的整个机制，然而熟悉了还不一定能搞定</li>
</ul>
</li>
</ul>
<h4 id="2-隔离设计师模块和官方代码所依赖的-KISSY-版本"><a href="#2-隔离设计师模块和官方代码所依赖的-KISSY-版本" class="headerlink" title="2. 隔离设计师模块和官方代码所依赖的 KISSY 版本"></a>2. 隔离设计师模块和官方代码所依赖的 KISSY 版本</h4><p>这个方案是之前跟@展炎、@释然、@乔福、@林谦一起讨论出来的结果，大体思路：有设计师模块的店铺引入两份 KISSY，一份供官方代码依赖，另一份供 shop-caja 和设计师模块使用。同样优缺点：</p>
<ul>
<li>优点：一劳永逸，未来店铺官方代码做技术升级时基本不会影响到设计师模块</li>
<li>缺点：稍稍有点粗暴，有设计师模块的页面会加载两份 KISSY 以及用到的核心模块，多多少少会影响性能</li>
</ul>
<p>对比了两种方案之后，最终选择了方案 2, 原因呢：一方面方案 1 已经有同学尝试未果，另一方面自身没有太多的精力去研究 shop-caja 以及 KISSY 的核心代码。 确定方案之后就是 step by step 的行动啦~</p>
<h3 id="Just-Do-IT"><a href="#Just-Do-IT" class="headerlink" title="Just Do IT"></a>Just Do IT</h3><p>整个方案实施起来并没有花费太多精力，大体的步骤如下：</p>
<ol>
<li>基于 KISSY 1.3 迁出一个 kissy-caja 的仓库，其中包括 KISSY 所有的核心模块</li>
<li>为了保证两个 KISSY 互不影响，将 kissy-caja 里所有的 KISSY 全局变量替换为 KISSY_CAJA</li>
<li><p>同时将 shop-caja 里所有用到 KISSY 的地方替换为 KISSY_CAJA, 其中较为重要的是初始化设计师模块的地方：</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">prepareEnv.run(&#123;</span><br><span class="line">  <span class="comment">// KISSY 就是从这里传进设计师模块脚本里的</span></span><br><span class="line">  KISSY: exposed_kissy,</span><br><span class="line">  GS: tameGlobalService,</span><br><span class="line">  onerror: onerror</span><br><span class="line"> &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">re, a</span>) </span>&#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>在页面中 shop-caja 之前引入 kissy-caja</p>
</li>
<li>测试：或许这一步花费时间最多了吧，找了 N 多个有设计师的模块在预发上测试，中间遇到了一些小问题下文会提及</li>
<li><p>线上验证：发布完成后，观察了 jstracker 的异常数据，每 PV 报错率跟之前差别不大，基本稳定在 10% 左右，基本确保问题解决。</p>
<p> <img src="https://img.alicdn.com/tps/TB1g0VwLpXXXXahXFXXXXXXXXXX-1666-418.png" alt=""></p>
</li>
</ol>
<h4 id="过程中遇到问题"><a href="#过程中遇到问题" class="headerlink" title="过程中遇到问题"></a>过程中遇到问题</h4><p>比较欣慰的是用了这个方案之后，预发上只出现了一个问题：<strong>jsonp 方法 callback 同名导致报错</strong>。KISSY 中 jsonp 的回调名是通过 <code>jsonp + S.guid()</code> 来生成的，而这个 guid 是挂载在 KISSY 下而非全局变量下，因此两个版本的 KISSY 很大几率会生成相同的 guid, 而多个 jsonp 回调名相同之后就会导致后面执行的方法出错，解决方案也很简单，因为 guid 是从 0 开始累加的，所以我直接将 kissy-caja 的 guid 基准值从 0 改为 12306, 别问我为什么是 12306, 任性！</p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>最后，虽然我对于开放第三方代码没有做过研究，但是因为这件事对开放三方代码有一点自己的认识：</p>
<p><strong>对于第三方代码，安全问题自不用去提，在此基础上，对于官方代码和三方代码一定要做技术方案的隔离，否则当未来官方代码需要升级技术方案的时候就会步履维艰。</strong></p>
<p>比如说，如果当时店铺的设计师模块直接基于 jQuery 某个指定版本去开发，现在也就不会遇到这些问题了，当然这只是个马后炮，希望对类似应用会有帮助吧。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="https://gw.alicdn.com/tps/TB1nHczLVXXXXX2XXXXXXXXXXXX-900-500.jpg" alt="店铺 KISSY 版本大乱斗"></p>
<h2 id="店铺-KISSY-版本大乱斗"><a href="#]]>
    </summary>
    
      <category term="第三方" scheme="http://taobaofed.org/tags/%E7%AC%AC%E4%B8%89%E6%96%B9/"/>
    
      <category term="代码安全" scheme="http://taobaofed.org/tags/%E4%BB%A3%E7%A0%81%E5%AE%89%E5%85%A8/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
</feed>
