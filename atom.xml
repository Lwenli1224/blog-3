<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Taobao FED | 淘宝前端团队]]></title>
  <subtitle><![CDATA[淘宝前端团队（FED）]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://taobaofed.org/"/>
  <updated>2016-12-21T02:40:37.000Z</updated>
  <id>http://taobaofed.org/</id>
  
  <author>
    <name><![CDATA[Taobao FED]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[QCon San Francisco 2016 前端参会总结]]></title>
    <link href="http://taobaofed.org/blog/2016/12/20/qconsf-2016/"/>
    <id>http://taobaofed.org/blog/2016/12/20/qconsf-2016/</id>
    <published>2016-12-20T12:10:14.000Z</published>
    <updated>2016-12-21T02:40:37.000Z</updated>
    <content type="html"><![CDATA[<p><img src="https://gw.alicdn.com/tps/TB1pOFzOVXXXXbhaXXXXXXXXXXX-900-500.jpg" alt="QCon San Francisco 2016 前端参会总结"></p>
<p>11 月初有幸参加了在美国旧金山举行的 Qcon 会议，会议之余在小伙伴们的各路关系中拜访了一些美国的科技公司。此行受益颇多，这里谈一下自己的所见、所闻以及自己的感受。</p>
<h2 id="会议内容"><a href="#会议内容" class="headerlink" title="会议内容"></a>会议内容</h2><p>会议内容覆盖了前端、设计、容器、微服务、devops、JAVA 等等，内容非常的丰富，这里选择几个前端相关的场做下分享。</p>
<p><img src="https://gw.alicdn.com/tps/TB1F5cMOFXXXXb3XVXXXXXXXXXX-1440-1920.jpg_790x10000.jpg" alt=""></p>
<h3 id="Webpack-The-One-Build-Step-To-Rule-Them-All"><a href="#Webpack-The-One-Build-Step-To-Rule-Them-All" class="headerlink" title="Webpack: The One Build Step To Rule Them All"></a>Webpack: The One Build Step To Rule Them All</h3><p>webpack 自诞生以来席卷全球，为我们的开发带来了无限可能，相信很多童鞋都在使用 webpack，webpack is great!</p>
<p>来自 webpack 核心团队的 <a href="https://twitter.com/thelarkinn" target="_blank" rel="external">@thelarkinn</a> 介绍了 webpack 的基本概念及使用方法，最后介绍了一些 webpack 2.0 的计划和未来的一些方向。</p>
<ol>
<li>webpack 的几个核心的概念：entry、output、loader、plugin：<ul>
<li>Entry 就是我们的源码入口文件，可以是一个，也可以是多个；</li>
<li>Output 是源码编译后的输出 bundle 文件，它根据你定义的 Entry 文件进行生成；</li>
<li>Loader 可以说是 webpack 最屌的地方了，它定义了你的文件通过什么样的规则进行转换，它目前已经拥有 N 种 loader，市场上你只要见过的类型它基本都支持。分享者给了一张目前的 Loader 图，当时也是被震惊到了：<br><img src="https://gw.alicdn.com/tps/TB1rtEIOFXXXXacaXXXXXXXXXXX-892-509.png" alt=""></li>
<li>Plugins 是 webpack 另一个易用的设计，你可以比较方便的开发使用自己的插件以实现特殊的效果。</li>
</ul>
</li>
<li>webpack 的一些主要功能：<ul>
<li>本地服务；</li>
<li>模块热替换；</li>
<li>模块懒加载；</li>
<li>Source Maps；</li>
</ul>
</li>
<li>webpack2 的新特性：<br> <img src="https://gw.alicdn.com/tps/TB15TwzOFXXXXcvaXXXXXXXXXXX-894-513.png" alt=""><ul>
<li>首先是它将会原生的支持 ES2015，这意味着未来我们无需先将代码转换为 CommonJS 格式了，同时也为 Tree Shaking 的优化提供了基础。</li>
<li>Tree Shaking 可以帮助我们移除未使用到的代码，以使我们的代码文件更小，这在寸土寸金的无线时代可能更实在。但是，Tree Shaking 能否发挥它的最大作用，还是取决于我们的编码习惯、规范，这也是我们需要去思考和改进的地方。<strong>特别对于公共的组件、模块，我们更需要关注其质量、规范。</strong>开发者关心的不应该只是代码是否能跑起来，同时更需要关心如何跑的更好。</li>
<li>其它的在编译速度、语法设计、配置校验等方面也做了一些改进。</li>
</ul>
</li>
<li>webpack 的未来：<br> <img src="https://gw.alicdn.com/tps/TB1xxwuOFXXXXbnapXXXXXXXXXX-897-518.png" alt=""><ul>
<li>webpack 在未来还会针对 HTTP2 的场景做特殊的优化支持，也会与浏览器厂商合作，在 DevTools 上提供更好的体验。另外还提到了会利用 Chrome 的 timeline 去做一些智能调整配置加载的事情，至于具体是什么，尚未查到资料，目前应该仅仅是 idea 阶段。</li>
</ul>
</li>
</ol>
<p>整场分享其实比较初级，基本是手把手教你用 webpack，帮你理清了 webpack 的一些思路，最后谈到了 webpack2 以及未来的一些计划，缺乏真正的实战分享。但 webpack 给我们带来的技术革新是巨大的，或许有一天，当所有的语言都可以通过 webpack 编译成 JavaScript，而 JavaScript 又可以运行在任意的平台上，那将会是一个怎样的世界？……</p>
<h3 id="Building-Robust-Web-Applications-With-RxJS"><a href="#Building-Robust-Web-Applications-With-RxJS" class="headerlink" title="Building Robust Web Applications With RxJS"></a>Building Robust Web Applications With RxJS</h3><blockquote>
<p>RxJS is an API for asynchronous programming<br>with observable streams。</p>
</blockquote>
<p>RxJS 5 的带头大哥、来自 Netflix 的 <a href="https://twitter.com/benlesh" target="_blank" rel="external">@BenLesh</a> 通过一个例子分享了 RxJS5 的一些新特性。</p>
<ul>
<li>RxJS is “Lodash for events”</li>
<li>RxJS is Observables</li>
</ul>
<p>在 RxJS 的世界里，一切都是流，你可以把任何的东西当成流，通过对这些流的创建、合并、过滤来解耦、分离自己的业务逻辑。</p>
<p>@BenLesh 通过一个 WebSocket 的例子讲解了 RxJS 的一些基本用法以及新的 RxJS5 带来了哪些新的改变，总体上其实就是在对 RxJS5 做一些宣传工作。</p>
<p>大家可以从这里下载 @BenLesh 演示的 Demo，自己亲自试一下上：<a href="https://github.com/blesh/robust-websocket-talk" target="_blank" rel="external">https://github.com/blesh/robust-websocket-talk</a></p>
<p>RxJS 巧妙的利用了观察者模式将一些状态、点击、事件抽象为一系列的流，通过对他们的过滤、组合来实现我们的业务逻辑，对于我们未来的一些实时互动产品，搭配这样的事件流，或许能够可以让我们的代码更清晰、相互之间更解耦。</p>
<h3 id="The-Strengths-of-Ember-Angular-amp-React-Explored"><a href="#The-Strengths-of-Ember-Angular-amp-React-Explored" class="headerlink" title="The Strengths of Ember, Angular &amp; React Explored"></a>The Strengths of Ember, Angular &amp; React Explored</h3><p>来自 Ember 团队的 @larasm、Angular 团队的 @robwormald（Google）、React 团队的 @leeb（Facebook） 分享了各自的库/框架，然后主持人跟三位分享者进行了一些互动。</p>
<p>先简单介绍一下这三个东东：</p>
<ol>
<li>React：<ul>
<li>React 并不是 MVC，它是基于 Component 的 UI；</li>
<li>React 不是为了构建 Web App，它是为了构建 UI，你可以把它类比为 DOM；<br>  <img src="https://gw.alicdn.com/tps/TB1GtU0OFXXXXXIXFXXXXXXXXXX-1072-334.jpg_790x10000.jpg" alt=""></li>
<li>你可以整个应用都使用 React，也可以像 Facebook 一样在部分模块里使用 React，你可以与其它任何的 framework 一起使用 React。<br><img src="https://gw.alicdn.com/tps/TB1XFZGOFXXXXbjXVXXXXXXXXXX-894-517.png" alt=""></li>
</ul>
</li>
<li>AngularJS： <ul>
<li>AngularJS 的组件由三部分组成：HTML、CSS、Class；<br><img src="https://gw.alicdn.com/tps/TB1OmIDOFXXXXbBaXXXXXXXXXXX-893-519.png" alt=""></li>
<li>它的模板就是 HTML，通过属性和事件来定义组件的行为；</li>
<li>它提供了 router 功能；</li>
<li>AngularJS 可以运行在任何的环境、平台；</li>
<li>因为 TypeScript 的类型检测、可读性、易用性以及强大的工具支持，AngularJS 使用 TypeScript；</li>
<li>AngularJS 2 通过预编译提升了不少性能；</li>
</ul>
</li>
<li>ember：<ul>
<li>ember 是为构建巨型应用而生的，而巨型应用具备几个条件：多人创建，长期维护，升级而不是重写；</li>
<li>ember 几乎包含了你可能用到的、在其它框架/库里看到的 NB 的特性，例如路由、组件、DOM diffing、单向/双向半丁、模板、服务端渲染等等……</li>
<li>ember 是一个大型的框架，它在为社区做出巨大的贡献，也在推进着社区技术的发展；</li>
<li>ember 发展了 5 年，有成熟的、完善的生态圈，Yahoo、LinkedIn 等公司都在为其贡献代码，目前已经有 3000+ 的插件，覆盖各种各样的交互场景；</li>
<li>ember 拥有最专业、最好用的工具集，可以帮助你更快、更好的入门、编码；</li>
</ul>
</li>
</ol>
<p>最后，主持人与三位分享者进行了一场小的讨论会。</p>
<p><img src="https://gw.alicdn.com/tps/TB1RSQnOFXXXXcuaFXXXXXXXXXX-896-508.png" alt=""></p>
<p>React 一再说明它不是 framework，而是一个 library，非常的轻量级，入门也比较简单，需要了解一下 babel，最主要的是 <a href="https://facebook.github.io/react/docs/thinking-in-react.html" target="_blank" rel="external">Think in React</a>！React 对于 Virtual DOM 的抽象及使用，使得它可以更好的应用在各个环境、语言层面，为各个平台提供了无限可能。React 有强大的社区支持，虽然 React 自身并无法完全覆盖你的任何需求、功能，但是社区里有大量的 library 可以配合 React 一起来使用，以满足你的任何需求和功能。</p>
<p>AngularJS 相对来说功能比 React 全，是一个轻量级的 framework，经历了从 1 到 2 的升华，现在逐渐找到了自己的核心并稳定下来。相比 React，它提供了更多的功能以及更完善的体系，你可以在不借助任何外部 library 的情况下基本满足所有的需求和功能，当然，你也同样可以使用外部 library 来弥补 AngularJS 的功能。AngularJS 跟 React 走着完全不同的两个路子，但是理念和思路却在相互的借鉴和学习。使用 AngularJS 2 你需要首先了解 TypeScript，然后根据其文档，理解 Component 等概念，学习成本稍高。</p>
<p>ember 相对于前两个，基本上就是巨无霸，所有你能想到的功能它都能包含，定位也是大型应用。相较于 AngularJS 被吐槽的升级问题，ember 有严格的升级步骤和规范，配合 ember 强大的 cli 工具及易读好用的文档，你可以轻松的入门、使用 ember。</p>
<p>总的来说，每一个 framework/library 都在进化，相互的学习、借鉴，都在不断的提升自身的质量和技术，也期望未来我们能够看到更精彩的一些 idea，路走对了就不怕远！没有最好的框架/库，只有更合适的。</p>
<h2 id="科技公司"><a href="#科技公司" class="headerlink" title="科技公司"></a>科技公司</h2><p>托各位牛逼的小伙们的福，在美期间拜访了一些不错的互联网公司，学到了一些不一样的东西，这里谈一下自己的感受。</p>
<blockquote>
<p>由于接待的人的岗位或者资历不同，我们从中了解到的内容跟真实的情况可能存在差异。</p>
</blockquote>
<h3 id="Yelp"><a href="#Yelp" class="headerlink" title="Yelp"></a>Yelp</h3><p>Yelp 是一个美国版的大众点评，但用下来你会发现这个大众点评完全不在一个量级，所以拜访之前以为这公司应该比较小，但其实蛮大的，在 downtown 能拥有十多层的办公楼也是够 NB 的。</p>
<p>Yelp 的办公室跟普通的办公室区别不大，每层会有个小厨房（里边有免费的饮料、小零食等），另外每几排办公桌的墙壁上会有一台电视，据带头大哥说平时无甚鸟用，偶尔会被一些同事连上放一下恶搞的照片、视频之类的。另外呢，员工可申请可升降的桌子用于办公（再也不用自己搞个高架子了……）</p>
<p>Yelp 的工作比较轻松，施行弹性工作制，公司提倡八小时工作制，我们是大概七点左右去的，基本上比较少的人在“加班”。据带头大哥说，有人竟然会花上两周时间去解决一个 bug！虽然这个问题可能一两个小时就可以通过其他方式修复，但依然坚持要找到问题的原因去修复，想想也是醉了……（刨根问底固然好，但总得先解决问题吧……）</p>
<p>Yelp 的主要流量入口还是在 PC，手机上可能只占二三十的量，这个让人大跌眼镜。</p>
<p>Yelp 使用 AWS。</p>
<h3 id="Airbnb"><a href="#Airbnb" class="headerlink" title="Airbnb"></a>Airbnb</h3><p>Airbnb 的办公室还是蛮有特色的，室内的设计很有艺术感和趣味感，空间很大，感觉工作起来应该很惬意，这里的所有员工桌子均为可升降桌子。</p>
<p>作为前端，对 Airbnb 最熟悉的莫过于其在 GitHub 上推出的前端规范，我们的规范很多内容也是参考他们来制订的。由于带头大哥并不是前端，问其 Airbnb 各个地方代码规范情况，反馈其实并没有那么的规范…… 少数部门在严格的执行编码规范，大多数部门还是有点散的。</p>
<p>跟 Yelp 类似，Airbnb 只有百分之三四十的流量在手机端。</p>
<p>Airbnb 使用 AWS。</p>
<p><img src="https://gw.alicdn.com/tps/TB17wMvOFXXXXc5apXXXXXXXXXX-1440-1920.jpg_790x10000.jpg" alt=""></p>
<p><img src="https://gw.alicdn.com/tps/TB1ap7sOFXXXXXTaFXXXXXXXXXX-1152-864.jpg_790x10000.jpg" alt=""></p>
<p><img src="https://gw.alicdn.com/tps/TB197gvOFXXXXc1apXXXXXXXXXX-1152-864.jpg_790x10000.jpg" alt=""></p>
<p><img src="https://gw.alicdn.com/tps/TB1nzEGOFXXXXavaXXXXXXXXXXX-1440-1920.jpg_790x10000.jpg" alt=""></p>
<p><img src="https://gw.alicdn.com/tps/TB1CboNOFXXXXakXVXXXXXXXXXX-1152-864.jpg_790x10000.jpg" alt=""></p>
<p><img src="https://gw.alicdn.com/tps/TB1p9UvOFXXXXXSapXXXXXXXXXX-1152-864.jpg_790x10000.jpg" alt=""></p>
<p>这是 3D 打印的作品。</p>
<h3 id="Twitter"><a href="#Twitter" class="headerlink" title="Twitter"></a>Twitter</h3><p>Twitter 同样位于 downtown，拥有十几层的办公楼，员工大约有 2000 多名，楼上还有一个露天的大阳台，能看到有些员工就懒洋洋的躺在阳台的草坪上办公…… 内部还有一个比较大的餐厅，平时还可以用来开 party、一些庆功会、活动之类的。</p>
<p>Twitter 的工作相对来说比较繁忙，时常也会出现加班的情况。</p>
<p>由于数据量巨大及自身的业务特殊原因，Twitter 并没有使用 AWS，而是通过自建服务来满足业务需求。同样，Twitter 也并没有使用 docker，而是在很早之前就开发了类似的容器来满足需求。</p>
<p><img src="https://gw.alicdn.com/tps/TB1gtJaOVXXXXa4XXXXXXXXXXXX-4608-3456.jpg_790x10000.jpg" alt=""></p>
<p>大大的阳台。</p>
<p><img src="https://gw.alicdn.com/tps/TB1K2IUOFXXXXbgXFXXXXXXXXXX-4608-3456.jpg_790x10000.jpg" alt=""></p>
<p>内部餐厅。</p>
<p><img src="https://gw.alicdn.com/tps/TB1UtQDOFXXXXbfaXXXXXXXXXXX-3456-4608.jpg_790x10000.jpg" alt=""></p>
<p>仔细看，这里边有一个 Twitter 的 logo。</p>
<h3 id="Google"><a href="#Google" class="headerlink" title="Google"></a>Google</h3><p>会议结束后，我们一行来到了硅谷，拜访了这里的 Google 和 Facebook，先来看看 Google。</p>
<p><img src="https://gw.alicdn.com/tps/TB1vntbOVXXXXX2XXXXXXXXXXXX-1440-1920.jpg_790x10000.jpg" alt=""></p>
<p>最先参观了 Google 的 Android 乐园，里边摆放着每个版本的 Android 代号标志：</p>
<p><img src="https://gw.alicdn.com/tps/TB1qX3LOFXXXXbQXVXXXXXXXXXX-4608-3456.jpg_790x10000.jpg" alt=""></p>
<p>先是来了 Google Vistor Center，在这里体验了一个还在试验的谷歌地球。这个系统由一圈竖着的屏幕以及一个操控台组成，输入想看的地点，屏幕上就会带你进入相应的地点（当然需要先建模的），画面非常的逼真、细腻，看了纽约曼哈顿、大峡谷、故宫等，感觉比较 NB，以后在家就可以欣赏到世界各地的美景了，还能自己操控来一场峡谷漂流……</p>
<p><img src="https://gw.alicdn.com/tps/TB1X7gCOFXXXXXmaXXXXXXXXXXX-1440-1920.jpg_790x10000.jpg" alt=""></p>
<p>Vistor Center 里还有一些 ChromeBook 的展览，在世界上第一台 ChromeBook 上访问了下我们的淘宝首页，运行良好……</p>
<p><img src="https://gw.alicdn.com/tps/TB1py3qOFXXXXb9aFXXXXXXXXXX-1440-1920.jpg_790x10000.jpg" alt=""></p>
<p>由于办公区域不能参观，Google 在这里设置了一个小的办公区供人参观，同样也都是可升降桌子。 另外提供睡觉的壳仓蛮有意思，躺进去后自己关上门，睡起来蛮惬意……</p>
<p><img src="https://gw.alicdn.com/tps/TB1TI7MOFXXXXbxXVXXXXXXXXXX-1440-1920.jpg_790x10000.jpg" alt=""></p>
<p>Vistor Center 里还有一组照片墙，据说这是一个 Google 的基层员工，每次有大人物来园区，这货都会想尽办法与其合照，然后照的多了就成为了“红人”，每个大人物来都会跟他合照，还有奥巴马…… Google 还专门在 Vistor Center 里给他搞了一堵照片墙…… 事实证明，不管是啥事儿，坚持就会有回报……</p>
<p><img src="https://gw.alicdn.com/tps/TB1jLQEOFXXXXXIaXXXXXXXXXXX-1152-864.jpg_790x10000.jpg" alt=""></p>
<p>随后去了 Google 早期的园区，这里是一个开放的区域，不算大，但也不小。有大大的餐厅、各种奇怪的设备、游戏厅、沙滩排球场、小小的静止游泳池、健身房等等，据带头大姐说，员工可以在任意一个喜欢的地方办公，上班时间有的打游戏、有的打球、有的游泳……</p>
<p><img src="https://gw.alicdn.com/tps/TB1cr._OFXXXXbXXXXXXXXXXXXX-4608-3456.jpg_790x10000.jpg" alt=""></p>
<h3 id="Facebook"><a href="#Facebook" class="headerlink" title="Facebook"></a>Facebook</h3><p>进入 FaceBook 的第一感觉就是，这里简直就像一个五彩斑斓的风情小镇，虽然不大，但是足够的温馨，商店、餐厅、电话亭、游戏厅、办公楼静静的立在街道两旁。</p>
<p>先是去参观了 Instgram，这里的一些员工桌上有气球挂着，据带头大哥说，是员工一年、两年、三年时会挂不同的气球，但由于人员流动性大，挂球的人其实并不多……</p>
<p>Facebook 的工程师文化比较浓，我们的厕所里贴的是各种广告，人家的厕所里直接贴的是代码、技术，让你尿尿的时候都能够在大脑中执行一次代码……</p>
<p><img src="https://gw.alicdn.com/tps/TB1ar.BOFXXXXbmaXXXXXXXXXXX-4608-3456.jpg_790x10000.jpg" alt=""></p>
<p><img src="https://gw.alicdn.com/tps/TB1NC.LOFXXXXc2XVXXXXXXXXXX-4608-3456.jpg_790x10000.jpg" alt=""></p>
<p><img src="https://gw.alicdn.com/tps/TB1WqEWOFXXXXabXFXXXXXXXXXX-3456-4608.jpg_790x10000.jpg" alt=""></p>
<p><img src="https://gw.alicdn.com/tps/TB1ZBZyOFXXXXcEaXXXXXXXXXXX-4608-3456.jpg_790x10000.jpg" alt=""></p>
<p>Facebook 的大 logo。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>先说 QCon，参会之前，根据主题先看了相关的一些资料，实际听的过程还是稍微有点小失望，前端方面的演讲普遍比较简单，基本是在较少框架、工具的基本使用方式，缺乏真正的实践和应用。如果放在两三年前，或许会是比较有意思的东西，但是今天，这些主题过于基础。相较之前的 QCon 上海，少了无线相关的主题，也少了真正的实践。当然，也并非毫无意义，更多的我们可以听到在被人眼里，这个技术是如何被使用，在这项技术的发展历程中，经历了哪些抉择，变革的思路是怎样的，其实这些对我们的指导意义还是蛮大的。另外，QCon 每天的开场 Keynote 非常的精彩。</p>
<p>再说下拜访各个公司的收获，从 QCon 到各个创业公司，基本都在使用 AWS，大家都是围绕这 AWS 去做相关的优化、工具来帮助自己的业务运行的更好。我们的阿里云前景广阔啊，如果能够圈住国内的中小创业者，这个市场也是巨大无比的…… 各个公司都各有特色，他们的市场、他们的用户，很多时候真的令你无法想象，跟国内的场景、用户完全是两个不同的景象。员工的工作环境普遍比较惬意，时间也相对比较自由，大多都没有 KPI 的压力。</p>
<p>再说下美国印象。如果说美国的刷卡业甩中国 100 条街的话，那么中国的移动互联网、移动支付可以甩美国 500 条街。在拜访过程中了解到，在美国，手机的流量套餐基本上是无限量的，但是各个产品的手机端用户并不多，很多人的手机里就装了少数几个 App，他们很少用手机做啥事儿…… 在国内都被用烂了的二维码，在美国几乎看不到，就连 Twitter 也仅仅是在最近才有了二维码功能…… 另外，这些人真是爱跑步啊，无论何时、无论何地，都能看到各种各样的人在跑步…… 很多人周末的活动一般也都是野营、打球、徒步等户外活动，感觉上比较健康。</p>
<p>美国人在创新上真的是秒杀我们，如高晓松所说，或许是因为美国的强大使美国人感觉到自信、骄傲，更容易创造出不一样的东西，从他们的技术、电影、动画等等我们都能看出美国人的脑洞大开，而我们基本是在其基础上去做增强、改造。在中国逐步的强大、崛起的时候，期望我们也能够更加的自信、骄傲，特别是我们的程序员们能够有自己的创新、自己的不一样的东西，一千个人脑中应该有一千幅不同的 HelloKitty！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="https://gw.alicdn.com/tps/TB1pOFzOVXXXXbhaXXXXXXXXXXX-900-500.jpg" alt="QCon San Francisco 2016 前端参会总结"></p>
<p>11 月初有幸参加了在美国旧金]]>
    </summary>
    
      <category term="React" scheme="http://taobaofed.org/tags/React/"/>
    
      <category term="框架" scheme="http://taobaofed.org/tags/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="QCon" scheme="http://taobaofed.org/tags/QCon/"/>
    
      <category term="Angular" scheme="http://taobaofed.org/tags/Angular/"/>
    
      <category term="webpack" scheme="http://taobaofed.org/tags/webpack/"/>
    
      <category term="RxJS" scheme="http://taobaofed.org/tags/RxJS/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[「八面玲珑的 Node.js」- Node 地下铁第三期广州站线下沙龙总结]]></title>
    <link href="http://taobaofed.org/blog/2016/12/14/node-subway-season-3-guangzhou/"/>
    <id>http://taobaofed.org/blog/2016/12/14/node-subway-season-3-guangzhou/</id>
    <published>2016-12-14T03:19:30.000Z</published>
    <updated>2016-12-21T02:40:37.000Z</updated>
    <content type="html"><![CDATA[<p><img src="https://img.alicdn.com/tfs/TB1BVZQOFXXXXa0XpXXXXXXXXXX-900-500.jpg" alt="「八面玲珑的 Node.js」- Node 地下铁第三期广州站线下沙龙总结"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>转眼 2016 年就要结束了，距上次地下铁沙龙已经过去了大半年，我们在这冬天来到温暖的广州，跟朋友们相聚一堂，一起学习探讨开发 Node.js 过程中的心得，以及探讨 Node.js 领域内的新动向。</p>
<p>本次活动受广州地主 UC 前端团队的大力支持，由 UC 提供了会场，博文视点、图灵、稀土掘金提供了本次活动的赞助。</p>
<p>广州的同学非常热情，会场里面座无虚席。</p>
<p><img src="https://img.alicdn.com/tfs/TB1sukYOFXXXXcXXXXXXXXXXXXX-1280-853.jpg" alt="IMG_0251.jpg"></p>
<p><img src="https://img.alicdn.com/tfs/TB1rfoCOFXXXXXQXVXXXXXXXXXX-1280-853.jpg" alt="IMG_0344.jpg"></p>
<h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><h2 id="Thrift-下的-Node-js-跨语言异构"><a href="#Thrift-下的-Node-js-跨语言异构" class="headerlink" title="Thrift 下的 Node.js 跨语言异构"></a>Thrift 下的 Node.js 跨语言异构</h2><p>Node.js 越来越成为主流选型，在实际工作和复杂的历史遗留问题中，往往需要使用 Node.js 和其它服务，组件进行各种通讯和相互调用，如何让 Node.js 和其它服务一起和谐相处，是我们越来越多所面临的局面。来自 UC 的前端工程师刘欣给我们介绍了他们如何在实际生产中使用 Thrift 做接口在异构系统之间做通讯，以及性能上有怎样的提升。</p>
<p><img src="https://img.alicdn.com/tfs/TB18XwcOFXXXXcvaFXXXXXXXXXX-1280-853.jpg" alt="IMG_0275.jpg"></p>
<p><a href="http://taobaofed.github.io/nodejs-club/slides/season-3/thrift-liuxin%40uc.pdf" target="_blank" rel="external">PPT</a></p>
<h2 id="Node-js-服务前端数据接口的演化"><a href="#Node-js-服务前端数据接口的演化" class="headerlink" title="Node.js 服务前端数据接口的演化"></a>Node.js 服务前端数据接口的演化</h2><p>九十为我们介绍了在淘宝前端团队中，Node.js 在数据接口服务上的演变。</p>
<p>从传统的半栈开始，逐步引入 BFF（Backend For Frontend），然后形成统一的 API 接入层。</p>
<p><img src="https://img.alicdn.com/tfs/TB1V1QROFXXXXXLXpXXXXXXXXXX-1280-853.jpg" alt="IMG_0302.jpg"></p>
<p><a href="http://v.youku.com/v_show/id_XMTg2MTI3NjMwNA==.html" target="_blank" rel="external">视频</a><br><a href="http://taobaofed.github.io/nodejs-club/slides/season-3/Node.js%20api%20serving%20frontend%20-%20wangguang%40taobaofed.pdf" target="_blank" rel="external">PPT</a></p>
<h2 id="TypeScript-简介"><a href="#TypeScript-简介" class="headerlink" title="TypeScript 简介"></a>TypeScript 简介</h2><p>UC 的小鲜肉 Randy 为我们简单介绍了 TypeScript 在实际开发中给我们带来的好处</p>
<p>他从写 JavaScript 常遇到的类型不匹配的问题开始，介绍了类型判断在 TypeScript 中如何为开发减少错误，还介绍了 TypeScript 的一些其他高级特性如 async/await, decorator 等。</p>
<p><img src="https://img.alicdn.com/tfs/TB1FIoTOFXXXXaeXpXXXXXXXXXX-1280-853.jpg" alt="IMG_0309.jpg"></p>
<p><a href="http://v.youku.com/v_show/id_XMTg2MTI4MzU0NA==.html" target="_blank" rel="external">视频</a><br><a href="http://slides.com/randylu/deck-3/" target="_blank" rel="external">PPT</a></p>
<h2 id="Node-js-直出套路"><a href="#Node-js-直出套路" class="headerlink" title="Node.js 直出套路"></a>Node.js 直出套路</h2><p>来自腾讯视频的前端 Leader 姚穗斌给我们带来了一种新的直出思路。直出其实并不算是新概念。只不过在 Web 2.0 单页应用流行的年代，一直被人遗忘在身后。直出能对首屏的渲染带来不错的性能提升。姚穗斌通过层层展开，给我们在提升直出的性能和扩展性上很多启发。</p>
<p><img src="https://img.alicdn.com/tfs/TB1fvknOFXXXXXyapXXXXXXXXXX-1280-853.jpg" alt="IMG_0339.jpg"></p>
<p><a href="http://v.youku.com/v_show/id_XMTg2MTI5MDI0NA==.html" target="_blank" rel="external">视频</a><br><a href="http://taobaofed.github.io/nodejs-club/slides/season-3/Nodejs%20patterns%20of%20directly%20rendering%20-%20vicyao%40tencent.pdf" target="_blank" rel="external">PPT</a></p>
<h2 id="辩论会"><a href="#辩论会" class="headerlink" title="辩论会"></a>辩论会</h2><p>此次活动最大的亮点在于试水了辩论会这种活动形式，程序员撕逼往往只是在键盘上，鲜有正儿八经的辩论，此次活动特地设置这个环节让大家能在台上友好的探讨一些问题</p>
<p>辩论的主题是“统一单语言构建系统” vs “混合多语言构建系统”哪个更好，由正方 叶倍宏、Randy、Leon、姚穗斌对阵反方 九十、刘欣、老雷和三圈。这些都是拥有丰富经验的工程师们。</p>
<p><img src="https://img.alicdn.com/tfs/TB1MCMuOFXXXXXxaXXXXXXXXXXX-1280-853.jpg" alt="IMG_0359.jpg"></p>
<p>辩论中双方辩友唇枪舌剑，你来我往，摆事实，讲道理，证据凿凿，场面非常激烈。双方从历史遗留现状，到架构，到成本，到商业价值等等，都展开了攻防辩论。最后由观众评选出正方“统一单语言构建系统”表现更好，三辩 Leon 被认为是最佳辩手。</p>
<p><a href="http://v.youku.com/v_show/id_XMTg2MTI5NDQzNg==.html" target="_blank" rel="external">视频</a></p>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>感谢各位同学的参与，我们下次再约！欢迎关注 Node.js 地下铁微信公共账号，随时关注下一次线下沙龙动态。</p>
<p><img src="https://img.alicdn.com/tfs/TB15lsyOFXXXXbMXVXXXXXXXXXX-1280-853.jpg" alt="IMG_0362.jpg"></p>
<p><img src="https://img.alicdn.com/tps/TB1roZoKVXXXXcWXFXXXXXXXXXX-86-86.jpg" alt="IMG_0362.jpg"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="https://img.alicdn.com/tfs/TB1BVZQOFXXXXa0XpXXXXXXXXXX-900-500.jpg" alt="「八面玲珑的 Node.js」- Node 地下铁第三期广州站线下沙龙总结"></p>
<h1 id="前言]]>
    </summary>
    
      <category term="nodejs" scheme="http://taobaofed.org/tags/nodejs/"/>
    
      <category term="地下铁" scheme="http://taobaofed.org/tags/%E5%9C%B0%E4%B8%8B%E9%93%81/"/>
    
      <category term="沙龙" scheme="http://taobaofed.org/tags/%E6%B2%99%E9%BE%99/"/>
    
      <category term="广州" scheme="http://taobaofed.org/tags/%E5%B9%BF%E5%B7%9E/"/>
    
      <category term="Node.js" scheme="http://taobaofed.org/categories/Node-js/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[happypack 原理解析]]></title>
    <link href="http://taobaofed.org/blog/2016/12/08/happypack-source-code-analysis/"/>
    <id>http://taobaofed.org/blog/2016/12/08/happypack-source-code-analysis/</id>
    <published>2016-12-08T07:54:38.000Z</published>
    <updated>2016-12-21T02:40:37.000Z</updated>
    <content type="html"><![CDATA[<p><img src="https://img.alicdn.com/tfs/TB15ZeJOFXXXXcYXVXXXXXXXXXX-900-500.jpg" alt="happypack 原理解析"></p>
<p>说起 <a href="https://www.npmjs.com/package/happypack" target="_blank" rel="external">happypack</a> 可能很多同学还比较陌生，其实 happypack 是 webpack 的一个插件，目的是通过多进程模型，来加速代码构建，目前我们的线上服务器已经上线这个插件功能，并做了一定适配，效果显著。这里有一些大致参考：</p>
<p><img src="http://gw.alicdn.com/tfs/TB1apiAOFXXXXcnXVXXXXXXXXXX-549-451.png" alt=""></p>
<p>这张图是 happypack 九月逐步全量上线后构建时间的的参考数据，线上构建服务器 16 核环境。</p>
<p>在上这个插件的过程中，我们也发现了这个单人维护的社区插件有一些问题，我们在解决这些问题的同时，也去修改了内部的代码，发布了自己维护的版本 @ali/happypack，那么内部是怎么跑起来的，这里做一个总结记录。</p>
<h2 id="webpack-加载配置"><a href="#webpack-加载配置" class="headerlink" title="webpack 加载配置"></a>webpack 加载配置</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> HappyPack = <span class="built_in">require</span>(<span class="string">'happypack'</span>);</span><br><span class="line"><span class="keyword">var</span> happyThreadPool = HappyPack.ThreadPool(&#123; size: os.cpus().length &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略其余配置</span></span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  loaders: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        loader: ExtractTextPlugin.extract(</span><br><span class="line">            <span class="string">'style'</span>,</span><br><span class="line">            path.resolve(__dirname, <span class="string">'./node_modules'</span>, <span class="string">'happypack/loader'</span>) + <span class="string">'?id=less'</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">      <span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">        id: <span class="string">'less'</span>,</span><br><span class="line">        loaders: [<span class="string">'css!less'</span>],</span><br><span class="line">        threadPool: happyThreadPool,</span><br><span class="line">        cache: <span class="literal">true</span>,</span><br><span class="line">        verbose: <span class="literal">true</span></span><br><span class="line">      &#125;)</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure>
<p>这个示例只单独抽取了配置 happypack 的部分。可以看到，类似 <a href="https://github.com/webpack/extract-text-webpack-plugin" target="_blank" rel="external">extract-text-webpack-plugin</a> 插件，happypack 也是通过 webpack 中 <a href="http://webpack.github.io/docs/using-loaders.html" target="_blank" rel="external">loader</a> 与 <a href="http://webpack.github.io/docs/using-plugins.html" target="_blank" rel="external">plugin</a> 的相互调用协作的方式来运作。</p>
<p>loader 配置直接指向 happypack 提供的 loader， 对于文件实际匹配的处理 loader ，则是通过配置在 plugin 属性来传递说明，这里 happypack 提供的 loader 与 plugin 的衔接匹配，则是通过 <code>id=less</code> 来完成。</p>
<h2 id="happypack-文件解析"><a href="#happypack-文件解析" class="headerlink" title="happypack 文件解析"></a>happypack 文件解析</h2><h3 id="HappyPlugin-js"><a href="#HappyPlugin-js" class="headerlink" title="HappyPlugin.js"></a>HappyPlugin.js</h3><p><img src="http://gw.alicdn.com/tfs/TB1svtKOFXXXXcAXpXXXXXXXXXX-767-269.png" alt=""></p>
<p>对于 webpack 来讲，plugin 是贯穿在整个构建流程，同样对于 happypack 配置的构建流程，首先进入逻辑的是 plugin 的部分，从初始化的部分查看 happypack 中与 plugin 关联的文件。 </p>
<p><strong>1. 基础参数设置</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HappyPlugin</span>(<span class="params">userConfig</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> HappyPlugin)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HappyPlugin(userConfig);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.id = <span class="built_in">String</span>(userConfig.id || ++uid);</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'HappyPack'</span>;</span><br><span class="line">  <span class="keyword">this</span>.state = &#123;</span><br><span class="line">    started: <span class="literal">false</span>,</span><br><span class="line">    loaders: [],</span><br><span class="line">    baseLoaderRequest: <span class="string">''</span>,</span><br><span class="line">    foregroundWorker: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 省略 config</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于基础参数的初始化，对应上文提到的配置，可以看到插件设置了两个标识</p>
<ul>
<li>id: 在配置文件中设置的与 loader 关联的 id 首先会设置到实例上，为了后续 loader 与 plugin 能进行一对一匹配</li>
<li>name: 标识插件类型为 <code>HappyPack</code>,方便快速在 loader 中定位对应 plugin，同时也可以避免其他插件中存在 id 属性引起错误的风险</li>
</ul>
<p>对于这两个属性的应用，可以看到 loader 文件中有这样一段代码 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isHappy</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">plugin</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> plugin.name === <span class="string">'HappyPack'</span> &amp;&amp; plugin.id === id;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">happyPlugin = <span class="keyword">this</span>.options.plugins.filter(isHappy(id))[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<p>其次声明 state 对象标识插件的运行状态之后，开始配置信息的处理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HappyPlugin</span>(<span class="params">userConfig</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 省略基础标识设置</span></span><br><span class="line">  <span class="keyword">this</span>.config = OptionParser(userConfig, &#123;</span><br><span class="line">    id:                       &#123; type: <span class="string">'string'</span> &#125;,</span><br><span class="line">    tempDir:                  &#123; type: <span class="string">'string'</span>, <span class="keyword">default</span>: <span class="string">'.happypack'</span> &#125;,</span><br><span class="line">    threads:                  &#123; type: <span class="string">'number'</span>, <span class="keyword">default</span>: <span class="number">3</span> &#125;,</span><br><span class="line">    threadPool:               &#123; type: <span class="string">'object'</span>, <span class="keyword">default</span>: <span class="literal">null</span> &#125;,</span><br><span class="line">    cache:                    &#123; type: <span class="string">'boolean'</span>, <span class="keyword">default</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    cachePath:                &#123; type: <span class="string">'string'</span> &#125;,</span><br><span class="line">    cacheContext:             &#123; type: <span class="string">'object'</span>, <span class="keyword">default</span>: &#123;&#125; &#125;,</span><br><span class="line">    cacheSignatureGenerator:  &#123; type: <span class="string">'function'</span> &#125;,</span><br><span class="line">    verbose:                  &#123; type: <span class="string">'boolean'</span>, <span class="keyword">default</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    debug:                    &#123; type: <span class="string">'boolean'</span>, <span class="keyword">default</span>: process.env.DEBUG === <span class="string">'1'</span> &#125;,</span><br><span class="line">    enabled:                  &#123; type: <span class="string">'boolean'</span>, <span class="keyword">default</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    loaders:                  &#123;</span><br><span class="line">      validate: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">          ...</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="string">"HappyPack["</span> + <span class="keyword">this</span>.id + <span class="string">"]"</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 省略 threadPool 、HappyFSCache 初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用 <code>OptionParser</code> 函数来进行插件过程中使用到的参数合并，在合并函数的参数对象中，提供了作为数据合并依据的一些属性，例如合并类型 <code>type</code>、默认值 <code>default</code> 以及还有设置校验函数的校验属性 <code>validate</code> 完成属性检查。</p>
<p>这里对一些运行过车中的重要属性进行解释:</p>
<ul>
<li>tmpDir: 存放打包缓存文件的位置</li>
<li>cache: 是否开启缓存，目前缓存如果开启，(注: 会以<strong>数量级的差异</strong>来缩短构建时间，很方便日常开发)</li>
<li>cachePath: 存放缓存文件映射配置的位置</li>
<li>verbose: 是否输出过程日志</li>
<li>loaders: 因为配置中文件的处理 loader 都指向了 happypack 提供的 loadr ,这里配置的对应文件实际需要运行的 loader</li>
</ul>
<p><strong>2. 线程池初始化</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HappyPlugin</span>(<span class="params">userConfig</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 省略基础参数设置</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">this</span>.threadPool = <span class="keyword">this</span>.config.threadPool || HappyThreadPool(&#123;</span><br><span class="line">    id: <span class="keyword">this</span>.id,</span><br><span class="line">    size: <span class="keyword">this</span>.config.threads,</span><br><span class="line">    verbose: <span class="keyword">this</span>.config.verbose,</span><br><span class="line">    debug: <span class="keyword">this</span>.config.debug,</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 省略 HappyFSCache 初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 thread 其实严格意义说是 process，应该是进程，猜测只是套用的传统软件的一个主进程多个线程的模型。这里不管是在配置中，配置的是 <code>threads</code> 属性还是 <code>threadPool</code> 属性，都会生成一个 <code>HappyThreadPool</code> 对象来管理生成的子进程对象。</p>
<p><strong>2.1. HappyThreadPool.js</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HappyThreadPool</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> happyRPCHandler = <span class="keyword">new</span> HappyRPCHandler();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> threads = createThreads(config.size, happyRPCHandler, &#123;</span><br><span class="line">   id: config.id,</span><br><span class="line">   verbose: config.verbose,</span><br><span class="line">   debug: config.debug,</span><br><span class="line"> &#125;);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 省略返回对象部分</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>在返回 <code>HappyThreadPool</code> 对象之前，会有两个操作:</p>
<p><strong>2.1.1. HappyRPCHandler.js</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HappyRPCHandler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.activeLoaders = &#123;&#125;;</span><br><span class="line">  <span class="keyword">this</span>.activeCompiler = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 <code>HappyRPCHandler</code> 实例，可以从构造函数看到，会绑定当前运行的 loader 与 compiler ，同时在文件中，针对 loader 与 compiler 定义调用接口:</p>
<ul>
<li>对应 compiler 会绑定查找解析路径的 reolve 方法: </li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">COMPILER_RPCs = &#123;</span><br><span class="line">  resolve: <span class="function"><span class="keyword">function</span>(<span class="params">compiler, payload, done</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> resolver = compiler.resolvers.normal;</span><br><span class="line">    <span class="keyword">var</span> resolve = compiler.resolvers.normal.resolve;</span><br><span class="line">    <span class="comment">// 省略部分判断</span></span><br><span class="line">    resolve.call(resolver, payload.context, payload.context, payload.resource, done);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>对应 loader 其中一些绑定: </li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">LOADER_RPCS = &#123;</span><br><span class="line">  emitWarning: <span class="function"><span class="keyword">function</span>(<span class="params">loader, payload</span>) </span>&#123;</span><br><span class="line">    loader.emitWarning(payload.message);</span><br><span class="line">  &#125;,</span><br><span class="line">  emitError: <span class="function"><span class="keyword">function</span>(<span class="params">loader, payload</span>) </span>&#123;</span><br><span class="line">      loader.emitError(payload.message);</span><br><span class="line">  &#125;,</span><br><span class="line">  addDependency: <span class="function"><span class="keyword">function</span>(<span class="params">loader, payload</span>) </span>&#123;</span><br><span class="line">      loader.addDependency(payload.file);</span><br><span class="line">  &#125;,</span><br><span class="line">  addContextDependency: <span class="function"><span class="keyword">function</span>(<span class="params">loader, payload</span>) </span>&#123;</span><br><span class="line">      loader.addContextDependency(payload.file);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过定义调用 webpack 流程过程中的 loader、compiler 的能力来完成功能，类似传统服务中的 RPC 过程。</p>
<p><strong>2.1.2. 创建子进程 (HappyThread.js)</strong></p>
<p>传递子进程数参数 <code>config.size</code> 以及之前生成的 HappyRPCHandler 对象，调用 <code>createThreads</code>  方法生成实际的子进程。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createThreads</span>(<span class="params">count, happyRPCHandler, config</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> set = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> threadId = <span class="number">0</span>; threadId &lt; count; ++threadId) &#123;</span><br><span class="line">    <span class="keyword">var</span> fullThreadId = config.id ? [ config.id, threadId ].join(<span class="string">':'</span>) : threadId;</span><br><span class="line">    set.push(HappyThread(fullThreadId, happyRPCHandler, config));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> set;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>fullThreadId</code> 生成之后，传入 <code>HappyThread</code> 方法，生成对应的子进程，然后放在 set 集合中返回。调用 <code>HappyThread</code> 返回的对象就是 <code>Happypack</code> 的编译 worker 的上层控制。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">HappyThread: </span><br><span class="line">&#123;</span><br><span class="line">    open: <span class="function"><span class="keyword">function</span>(<span class="params">onReady</span>) </span>&#123;</span><br><span class="line">      fd = fork(WORKER_BIN, [id], &#123;</span><br><span class="line">        execArgv: []</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">// 省略进程消息绑定处理</span></span><br><span class="line">    &#125;,</span><br><span class="line">    configure: <span class="function"><span class="keyword">function</span>(<span class="params">compilerOptions, done</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 省略具体过程</span></span><br><span class="line">    &#125;,</span><br><span class="line">    compile: <span class="function"><span class="keyword">function</span>(<span class="params">params, done</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 省略具体过程</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    isOpen: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> !!fd;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    close: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      fd.kill(<span class="string">'SIGINT'</span>);</span><br><span class="line">      fd = <span class="literal">null</span>;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>
<p>对象中包含了对应的进程状态控制 <code>open</code> 、<code>close</code>，以及通过子进程来实现编译的流程控制 <code>configure</code>、<code>compile</code>。</p>
<p><strong>2.1.2.1 子进程执行文件 HappyWorkerChannel.js</strong></p>
<p>上面还可以看到一个信息是，<code>fd</code> 子进程的运行文件路径变量 <code>WORKER_BIN</code>，这里对应的是相同目录下的 <code>HappyWorkerChannel.js</code> 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> HappyWorker = <span class="built_in">require</span>(<span class="string">'./HappyWorker'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (process.argv[<span class="number">1</span>] === __filename) &#123;</span><br><span class="line">  startAsWorker();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">startAsWorker</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  HappyWorkerChannel(<span class="built_in">String</span>(process.argv[<span class="number">2</span>]), process);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HappyWorkerChannel</span>(<span class="params">id, stream</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> worker = <span class="keyword">new</span> HappyWorker(&#123; compiler: fakeCompiler &#125;);</span><br><span class="line"></span><br><span class="line">  stream.on(<span class="string">'message'</span>, accept);</span><br><span class="line">  stream.send(&#123; name: <span class="string">'READY'</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">accept</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 省略函数内容</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>精简之后的代码可以看到 <code>fork</code> 子进程之后，最终执行的是 <code>HappyWorkerChannel</code> 函数，这里的 <code>stream</code> 参数对应的是子进程的 <code>process</code> 对象，用来与主进程进行通信。</p>
<p>函数的逻辑是通过 <code>stream.on(&#39;messgae&#39;)</code> 订阅消息，控制层 <code>HappyThread</code> 对象来传递消息进入子进程，通过 <code>accept()</code> 方法来路由消息进行对应编译操作。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">accept</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (message.name === <span class="string">'COMPILE'</span>) &#123;</span><br><span class="line">      worker.compile(message.data, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">        stream.send(&#123;</span><br><span class="line">          id: message.id,</span><br><span class="line">          name: <span class="string">'COMPILED'</span>,</span><br><span class="line">          sourcePath: result.sourcePath,</span><br><span class="line">          compiledPath: result.compiledPath,</span><br><span class="line">          success: result.success</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (message.name === <span class="string">'COMPILER_RESPONSE'</span>) &#123;</span><br><span class="line">      <span class="comment">// 省略具体流程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (message.name === <span class="string">'CONFIGURE'</span>) &#123;</span><br><span class="line">      <span class="comment">// 省略具体流程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 省略具体流程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于不同的上层消息进行不通的子进程处理。</p>
<p><strong>2.1.2.1.1 子进程编译逻辑文件 HappyWorker.js</strong></p>
<p>这里的核心方法 <code>compile</code> ，对应了一层 <code>worker</code> 抽象，包含 <code>Happypack</code> 的实际编译逻辑，这个对象的构造函数对应 <code>HappyWorker.js</code> 的代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">HappyWorker.js</span><br><span class="line"></span><br><span class="line">HappyWorker.prototype.compile = <span class="function"><span class="keyword">function</span>(<span class="params">params, done</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  applyLoaders(&#123;</span><br><span class="line">    compiler: <span class="keyword">this</span>._compiler,</span><br><span class="line">    loaders: params.loaders,</span><br><span class="line">    loaderContext: params.loaderContext,</span><br><span class="line">  &#125;, params.loaderContext.sourceCode, params.loaderContext.sourceMap, <span class="function"><span class="keyword">function</span>(<span class="params">err, source, sourceMap</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 省略部分判断</span></span><br><span class="line">    <span class="keyword">var</span> compiledPath = params.compiledPath;</span><br><span class="line">    <span class="keyword">var</span> success = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略错误处理</span></span><br><span class="line">    fs.writeFileSync(compiledPath, source);</span><br><span class="line">    fs.writeFileSync(compiledPath + <span class="string">'.map'</span>, SourceMapSerializer.serialize(sourceMap));</span><br><span class="line"></span><br><span class="line">    success = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    done(&#123;</span><br><span class="line">      sourcePath: params.loaderContext.resourcePath,</span><br><span class="line">      compiledPath: compiledPath,</span><br><span class="line">      success: success</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>从 <code>applyLoaders</code> 的参数看到，这里会把 webpack 编辑过程中的 <code>loaders</code>、<code>loaderContext</code> 通过最上层的 <code>HappyPlugin</code> 进行传递，来模拟实现 loader 的编译操作。</p>
<p>从回调函数中看到当编译完成时， <code>fs.writeFileSync(compiledPath, source);</code> 会将编译结果写入 <code>compilePath</code> 这个编译路径，并通过 <code>done</code> 回调返回编译结果给主进程。</p>
<p><strong>3. 编译缓存初始化</strong></p>
<p><code>happypack</code> 会将每一个文件的编译进行缓存，这里通过</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HappyPlugin</span>(<span class="params">userConfig</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 省略基础参数设置</span></span><br><span class="line">  <span class="comment">// 省略 threadPool 初始化</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">this</span>.cache = HappyFSCache(&#123;</span><br><span class="line">    id: <span class="keyword">this</span>.id,</span><br><span class="line">    path: <span class="keyword">this</span>.config.cachePath ?</span><br><span class="line">      path.resolve(<span class="keyword">this</span>.config.cachePath.replace(<span class="regexp">/\[id\]/g</span>, <span class="keyword">this</span>.id)) :</span><br><span class="line">      path.resolve(<span class="keyword">this</span>.config.tempDir, <span class="string">'cache--'</span> + <span class="keyword">this</span>.id + <span class="string">'.json'</span>),</span><br><span class="line">    verbose: <span class="keyword">this</span>.config.verbose,</span><br><span class="line">    generateSignature: <span class="keyword">this</span>.config.cacheSignatureGenerator</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  HappyUtils.mkdirSync(<span class="keyword">this</span>.config.tempDir); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 <code>cachePath</code> 默认会将 plugin 的 <code>tmpDir</code> 的目录作为生成缓存映射配置文件的目录路径。同时创建好 <code>config.tempDir</code> 目录。</p>
<p><strong>3.1 happypack 缓存控制 HappyFSCache.js</strong><br><code>HappyFSCache</code> 函数这里返回对应的 cache 对象，在编译的开始和 worker 编译完成时进行缓存加载、设置等操作。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HappyFSCache.js</span></span><br><span class="line"></span><br><span class="line">exports.load = <span class="function"><span class="keyword">function</span>(<span class="params">currentContext</span>) </span>&#123;&#125;;</span><br><span class="line">exports.save = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">exports.getCompiledSourceCodePath = <span class="function"><span class="keyword">function</span>(<span class="params">filePath</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> cache.mtimes[filePath] &amp;&amp; cache.mtimes[filePath].compiledPath;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">exports.updateMTimeFor = <span class="function"><span class="keyword">function</span>(<span class="params">filePath, compiledPath, error</span>) </span>&#123;</span><br><span class="line">    cache.mtimes[filePath] = &#123;</span><br><span class="line">      mtime: generateSignature(filePath),</span><br><span class="line">      compiledPath: compiledPath,</span><br><span class="line">      error: error</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">exports.getCompiledSourceMapPath = <span class="function"><span class="keyword">function</span>(<span class="params">filePath</span>) </span>&#123;&#125;;</span><br><span class="line">exports.hasChanged = <span class="function"><span class="keyword">function</span>(<span class="params">filePath</span>) </span>&#123;&#125;;</span><br><span class="line">exports.hasErrored = <span class="function"><span class="keyword">function</span>(<span class="params">filePath</span>) </span>&#123;&#125;;</span><br><span class="line">exports.invalidateEntryFor = <span class="function"><span class="keyword">function</span>(<span class="params">filePath</span>) </span>&#123;&#125;;</span><br><span class="line">exports.dump = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>对于编译过程中的单个文件，会通过 <code>getCompiledSourceCodePath</code> 函数来获取对应的缓存内容的文件物理路径，同时在新文件编译完整之后，会通过 <code>updateMTimeFor</code> 来进行缓存设置的更新。</p>
<h3 id="HappyLoader-js"><a href="#HappyLoader-js" class="headerlink" title="HappyLoader.js"></a>HappyLoader.js</h3><p>在 happypack 流程中，配置的对应 loader 都指向了 <code>happypack/loader.js</code> ，文件对应导出的是 <code>HappyLoader.js</code> 导出的对象 ，对应的 bundle 文件处理都通过 <code>happypack</code> 提供的 loader 来进行编译流程。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HappyLoader</span>(<span class="params">sourceCode, sourceMap</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> happyPlugin, happyRPCHandler;</span><br><span class="line">  <span class="keyword">var</span> callback = <span class="keyword">this</span>.async();</span><br><span class="line">  <span class="keyword">var</span> id = getId(<span class="keyword">this</span>.query);</span><br><span class="line">  </span><br><span class="line">  happyPlugin = <span class="keyword">this</span>.options.plugins.filter(isHappy(id))[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  happyPlugin.compile(&#123;</span><br><span class="line">    remoteLoaderId: remoteLoaderId,</span><br><span class="line">    sourceCode: sourceCode,</span><br><span class="line">    sourceMap: sourceMap,</span><br><span class="line">    useSourceMap: <span class="keyword">this</span>._module.useSourceMap,</span><br><span class="line">    context: <span class="keyword">this</span>.context,</span><br><span class="line">    request: happyPlugin.generateRequest(<span class="keyword">this</span>.resource),</span><br><span class="line">    resource: <span class="keyword">this</span>.resource,</span><br><span class="line">    resourcePath: <span class="keyword">this</span>.resourcePath,</span><br><span class="line">    resourceQuery: <span class="keyword">this</span>.resourceQuery,</span><br><span class="line">    target: <span class="keyword">this</span>.target,</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, outSourceCode, outSourceMap</span>) </span>&#123;</span><br><span class="line">    callback(<span class="literal">null</span>, outSourceCode, outSourceMap);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>省略了部分代码，<code>HappyLoader</code> 首先拿到配置 <code>id</code> ,然后对所有的 webpack plugin 进行遍历 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isHappy</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">plugin</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> plugin.name === <span class="string">'HappyPack'</span> &amp;&amp; plugin.id === id;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>找到 id 匹配的 <code>happypackPlugin</code>。传递原有 <code>webpack</code> 编译提供的 <code>loaderContext</code> (loader 处理函数中的 <code>this</code> 对象)中的参数，调用 <code>happypackPlugin</code> 的 <code>compile</code> 进行编译。</p>
<p>上面是 happypack 的主要文件，作者在项目介绍中也提供了一张图来进行结构化描述:</p>
<p><img src="http://gw.alicdn.com/tfs/TB12jI.OpXXXXcLaXXXXXXXXXXX-916-556.png" alt=""></p>
<h2 id="实际运行"><a href="#实际运行" class="headerlink" title="实际运行"></a>实际运行</h2><p>从前面的文件解析，已经把 <code>happypack</code> 的工程文件关联结构大致说明了一下，这下结合日常在构建工程的一个例子，将整个流程串起来说明。</p>
<h3 id="启动入口"><a href="#启动入口" class="headerlink" title="启动入口"></a>启动入口</h3><p><img src="http://gw.alicdn.com/tfs/TB1px8jOFXXXXbDaXXXXXXXXXXX-1022-487.png" alt=""></p>
<p>在 webpack 编译流程中，在完成了基础的配置之后，就开始进行编译流程，这里 webpack 中的 <code>compiler</code> 对象会去触发 <code>run</code> 事件，这边 <code>HappypackPlugin</code> 以这个事件作为流程入口，进行初始化。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HappyPlugin.prototype.apply = <span class="function"><span class="keyword">function</span>(<span class="params">compiler</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  compiler.plugin(<span class="string">'run'</span>, that.start.bind(that));</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 <code>run</code> 事件触发时，开始进行 <code>start</code> 整个流程</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HappyPlugin.prototype.start = <span class="function"><span class="keyword">function</span>(<span class="params">compiler, done</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">async</span>.series([</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">registerCompilerForRPCs</span>(<span class="params">callback</span>) </span>&#123;&#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">normalizeLoaders</span>(<span class="params">callback</span>) </span>&#123;&#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolveLoaders</span>(<span class="params">callback</span>) </span>&#123;&#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">loadCache</span>(<span class="params">callback</span>) </span>&#123;&#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">launchAndConfigureThreads</span>(<span class="params">callback</span>) </span>&#123;&#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">markStarted</span>(<span class="params">callback</span>) </span>&#123;&#125;</span><br><span class="line">  ], done);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>start</code>函数通过 <code>async.series</code> 将整个过程串联起来。</p>
<p><strong>1. registerCompilerForRPCs: <code>RPCHandler</code> 绑定 <code>compiler</code></strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">registerCompilerForRPCs</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  that.threadPool.getRPCHandler().registerActiveCompiler(compiler);</span><br><span class="line"></span><br><span class="line">  callback();</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>通过调用 plugin 初始化时生成的 handler 上的方法，完成对 <code>compiler</code> 对象的调用绑定。</p>
<p><strong>2. normalizeLoaders: loader 解析</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js: </span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">    id: <span class="string">'less'</span>,</span><br><span class="line">    loaders: [<span class="string">'css!less'</span>],</span><br><span class="line">    threadPool: happyThreadPool,</span><br><span class="line">    cache: <span class="literal">true</span>,</span><br><span class="line">    verbose: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>对应中的 <code>webpack</code> 中的 happypackPlugin 的 loaders 配置的处理: </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalizeLoaders</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> loaders = that.config.loaders;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 省略异常处理</span></span><br><span class="line">  </span><br><span class="line">  that.state.loaders = loaders.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">list, entry</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> list.concat(WebpackUtils.normalizeLoader(entry));</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  callback(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应配置的 loaders ，经过 <code>normalizeLoader</code> 的处理后，例如 <code>[css!less]</code> 会返回成一个 <code>loader</code> 数组 <code>[{path: &#39;css&#39;},{path: &#39;less&#39;}]</code>，复制到 plugin 的 <code>this.state</code> 属性上。</p>
<p><strong>3.resolveLoaders: loader 对应文件路径查询</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolveLoaders</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> loaderPaths = that.state.loaders.map(<span class="function"><span class="keyword">function</span>(<span class="params">loader</span>) </span>&#123; <span class="keyword">return</span> loader.path; &#125;);</span><br><span class="line"></span><br><span class="line">  WebpackUtils.resolveLoaders(compiler, loaderPaths, <span class="function"><span class="keyword">function</span>(<span class="params">err, loaders</span>) </span>&#123;</span><br><span class="line">    that.state.loaders = loaders;</span><br><span class="line">    that.state.baseLoaderRequest = loaders.map(<span class="function"><span class="keyword">function</span>(<span class="params">loader</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> loader.path + (loader.query || <span class="string">''</span>);</span><br><span class="line">    &#125;).join(<span class="string">'!'</span>);</span><br><span class="line">    callback();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了实际执行 loader 过程，这里将上一步 <strong>loader 解析</strong> 处理过后的 <code>loaders</code> 数组传递到 <code>resolveLoaders</code> 方法中，进行解析</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">exports.resolveLoaders = <span class="function"><span class="keyword">function</span>(<span class="params">compiler, loaders, done</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> resolve = compiler.resolvers.loader.resolve;</span><br><span class="line">  <span class="keyword">var</span> resolveContext = compiler.resolvers.loader;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span>.parallel(loaders.map(<span class="function"><span class="keyword">function</span>(<span class="params">loader</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> callArgs = [ compiler.context, loader, <span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">        callback(<span class="literal">null</span>, extractPathAndQueryFromString(result));</span><br><span class="line">      &#125;];</span><br><span class="line">      resolve.apply(resolveContext, callArgs);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;), done);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>而 <code>resolveLoaders</code> 方法采用的是借用原有 <code>webpack</code> 的 compiler 对象上的对应 <code>resolvers.loader</code> 这个 <code>Resolver</code> 实例的 <code>resolve</code> 方法进行解析，构造好解析参数后，通过 <code>async.parallel</code> 并行解析 loader 的路径</p>
<p><strong>4.loadCache: cache 加载</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadCache</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (that.config.cache) &#123;</span><br><span class="line">    that.cache.load(&#123;</span><br><span class="line">      loaders: that.state.loaders,</span><br><span class="line">      external: that.config.cacheContext</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  callback();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>cache 加载通过调用 <code>cache.load</code> 方法来加载上一次构建的缓存，快速提高构建速度。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">exports.load = <span class="function"><span class="keyword">function</span>(<span class="params">currentContext</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> oldCache, staleEntryCount;</span><br><span class="line">  cache.context = currentContext;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    oldCache = <span class="built_in">JSON</span>.parse(fs.readFileSync(cachePath, <span class="string">'utf-8'</span>));</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    oldCache = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cache.mtimes = oldCache.mtimes;</span><br><span class="line">  cache.context = currentContext;</span><br><span class="line"></span><br><span class="line">  staleEntryCount = removeStaleEntries(cache.mtimes, generateSignature);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>load</code> 方法会去读取 <code>cachePath</code> 这个路径的缓存配置文件，然后将内容设置到当前 <code>cache</code> 对象上的 <code>mtimes</code> 上。</p>
<p>在 happypack 设计的构建缓存中，存在一个上述的一个缓存映射文件，里面的配置会映射到一份编译生成的缓存文件。</p>
<p><strong>5.launchAndConfigureThreads: 线程池启动</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">launchAndConfigureThreads</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  that.threadPool.start(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 省略 thread congigure 过程</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>上面有提到，在加载完 <code>HappyPlugin</code> 时，会创建对应的 <code>HappyThreadPool</code> 对象以及设置数量的 <code>HappyThread</code>。但实际上一直没有创建真正的子进程实例，这里通过调用 <code>threadPool.start</code> 来进行子进程创建。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HappyThreadPool.js:</span><br><span class="line"></span><br><span class="line">    start: <span class="function"><span class="keyword">function</span>(<span class="params">done</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">async</span>.parallel(threads.filter(not(send(<span class="string">'isOpen'</span>))).map(get(<span class="string">'open'</span>)), done);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>start</code> 方法通过 <code>send</code> 、<code>not</code>、<code>get</code> 这三个方法来进行过滤、启动的串联。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">HappyThreadPool.js:</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">send</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">receiver</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> receiver[method].call(receiver);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">not</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !f(x);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">attr</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> object[attr];</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>传递 <code>&#39;isOpen&#39;</code> 到 <code>send</code> 返回函数中，<code>receiver</code> 对象绑定调用 <code>isOpen</code> 方法；再传递给 <code>not</code> 返回函数中，返回前面函数结构取反。传递给 <code>threads</code> 的 <code>filter</code> 方法进行筛选；最后通过 <code>get</code> 传递返回的 <code>open</code> 属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HappyThread.js </span><br><span class="line"></span><br><span class="line">    isOpen: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> !!fd;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>HappyThread</code> 对象中 <code>isOpen</code> 通过判断 <code>fd</code> 变量来判断是否创建子进程。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">open: <span class="function"><span class="keyword">function</span>(<span class="params">onReady</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> emitReady = Once(onReady);</span><br><span class="line"></span><br><span class="line">  fd = fork(WORKER_BIN, [id], &#123;</span><br><span class="line">    execArgv: []</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  fd.on(<span class="string">'error'</span>, throwError);</span><br><span class="line">  fd.on(<span class="string">'exit'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">exitCode</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (exitCode !== <span class="number">0</span>) &#123;</span><br><span class="line">      emitReady(<span class="string">'HappyPack: worker exited abnormally with code '</span> + exitCode);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  fd.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> <span class="title">acceptMessageFromWorker</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (message.name === <span class="string">'READY'</span>) &#123;</span><br><span class="line">      emitReady();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (message.name === <span class="string">'COMPILED'</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> filePath = message.sourcePath;</span><br><span class="line"></span><br><span class="line">      callbacks[message.id](message);</span><br><span class="line">      <span class="keyword">delete</span> callbacks[message.id];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>HappyThread</code> 对象的 <code>open</code> 方法首先将 <code>async.parallel</code> 传递过来的 <code>callback</code> 钩子通过 <code>Once</code> 方法封装，避免多次触发，返回成 <code>emitReady</code> 函数。</p>
<p>然后调用 <code>childProcess.fork</code> 传递 <code>HappyWorkerChannel.js</code> 作为子进程执行文件来创建一个子进程，绑定对应的 <code>error</code> 、<code>exit</code> 异常情况的处理，同时绑定最为重要的 <code>message</code> 事件，来接受子进程发来的处理消息。而这里 <code>COMPILED</code> 消息就是对应的子进程完成编译之后会发出的消息。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HappyWorkerChannel.js</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HappyWorkerChannel</span>(<span class="params">id, stream</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fakeCompiler = <span class="keyword">new</span> HappyFakeCompiler(id, stream.send.bind(stream));</span><br><span class="line">  <span class="keyword">var</span> worker = <span class="keyword">new</span> HappyWorker(&#123; compiler: fakeCompiler &#125;);</span><br><span class="line"></span><br><span class="line">  stream.on(<span class="string">'message'</span>, accept);</span><br><span class="line">  stream.send(&#123; name: <span class="string">'READY'</span> &#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 省略消息处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在子进程完成创建之后，会向主进程发送一个 <code>READY</code> 消息，表明已经完成创建，在主进程接受到 <code>READY</code> 消息后，会调用前面封装的 <code>emitReady</code> ，来反馈给 <code>async.parallel</code> 表示完成 <code>open</code> 流程。</p>
<p><strong>6.markStarted: 标记启动</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">markStarted</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  that.state.started = <span class="literal">true</span>;</span><br><span class="line">  callback();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后一步，在完成之前的步骤后，修改状态属性 <code>started</code> 为 <code>true</code>，完成整个插件的启动过程。</p>
<h3 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h3><p><img src="http://gw.alicdn.com/tfs/TB1qd5UOFXXXXXQXXXXXXXXXXXX-1141-720.png" alt=""></p>
<p><strong>1. loader 传递</strong><br>在 webpack 流程中，在源码文件完成内容读取之后，开始进入到 loader 的编译执行阶段，这时 <code>HappyLoader</code> 作为编译逻辑入口，开始进行编译流程。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HappyLoader</span>(<span class="params">sourceCode, sourceMap</span>) </span>&#123;</span><br><span class="line"> <span class="comment">// 省略 Plugin 查找</span></span><br><span class="line"></span><br><span class="line"> happyPlugin.compile(&#123;</span><br><span class="line">    remoteLoaderId: remoteLoaderId,</span><br><span class="line">    sourceCode: sourceCode,</span><br><span class="line">    sourceMap: sourceMap,</span><br><span class="line">    useSourceMap: <span class="keyword">this</span>._module.useSourceMap,</span><br><span class="line">    context: <span class="keyword">this</span>.context,</span><br><span class="line">    request: happyPlugin.generateRequest(<span class="keyword">this</span>.resource),</span><br><span class="line">    resource: <span class="keyword">this</span>.resource,</span><br><span class="line">    resourcePath: <span class="keyword">this</span>.resourcePath,</span><br><span class="line">    resourceQuery: <span class="keyword">this</span>.resourceQuery,</span><br><span class="line">    target: <span class="keyword">this</span>.target,</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, outSourceCode, outSourceMap</span>) </span>&#123;</span><br><span class="line">    callback(<span class="literal">null</span>, outSourceCode, outSourceMap);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>loader</code> 中将 webpack 原本的 <code>loaderContext(this指向)</code> 对象的一些参数例如 <code>this.resource</code>、<code>this.resourcePath</code>等透传到 <code>HappyPlugin.compile</code> 方法进行编译。</p>
<p><strong>2. plugin 编译逻辑运行</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">HappyPlugin.js: </span><br><span class="line"></span><br><span class="line">HappyPlugin.prototype.compile = <span class="function"><span class="keyword">function</span>(<span class="params">loaderContext, done</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 省略 foregroundWorker 情况</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.compileInBackground(loaderContext, done);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HappyPlugin.prototype.compileInBackground = <span class="function"><span class="keyword">function</span>(<span class="params">loaderContext, done</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cache = <span class="keyword">this</span>.cache;</span><br><span class="line">  <span class="keyword">var</span> filePath = loaderContext.resourcePath;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!cache.hasChanged(filePath) &amp;&amp; !cache.hasErrored(filePath)) &#123;</span><br><span class="line">    <span class="keyword">var</span> cached = <span class="keyword">this</span>.readFromCache(filePath);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> done(<span class="literal">null</span>, cached.sourceCode, cached.sourceMap);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>._performCompilationRequest(<span class="keyword">this</span>.threadPool.get(), loaderContext, done);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>HappyPlugin</code> 中的 <code>compile</code> 方法对应 build 过程，通过调用 <code>compileInBackground</code> 方法来完成调用。</p>
<p><strong>2.1 构建缓存判断 </strong></p>
<p>在 <code>compileInBackground</code> 中，首先会代用 cache 的 <code>hasChanged</code> 和 <code>hasErrored</code> 方法来判断是否可以从缓存中读取构建文件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HappyFSCache.js</span></span><br><span class="line">  exports.hasChanged = <span class="function"><span class="keyword">function</span>(<span class="params">filePath</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> nowMTime = generateSignature(filePath);</span><br><span class="line">    <span class="keyword">var</span> lastMTime = getSignatureAtCompilationTime(filePath);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nowMTime !== lastMTime;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  exports.hasErrored = <span class="function"><span class="keyword">function</span>(<span class="params">filePath</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cache.mtimes[filePath] &amp;&amp; cache.mtimes[filePath].error;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getSignatureAtCompilationTime</span>(<span class="params">filePath</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cache.mtimes[filePath]) &#123;</span><br><span class="line">      <span class="keyword">return</span> cache.mtimes[filePath].mtime;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><code>hasError</code> 判断的是更新缓存的时候的 <code>error</code> 属性是否存在。</p>
<p><code>hasChanged</code> 中会去比较 <code>nowMTime</code> 与 <code>lastMTime</code> 两个是否相等。实际上这里 <code>nowMTime</code> 通过调用 <code>generateSignature</code>（默认是 <code>getMTime</code>  函数） 返回的是文件目前的最后修改时间，<code>lastMTime</code> 返回的是编译完成时的修改时间。</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">getMTime</span>(filePath) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">fs.statSync(filePath).mtime.getTime()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 <code>nowMTime</code>、<code>lastMTime</code> 两个的最后修改时间相同且不存在错误，那么说明构建可以利用缓存</p>
<p><strong>2.1.1 缓存生效</strong></p>
<p>如果缓存判断生效，那么开始调用 <code>readFromCache</code> 方法，从缓存中读取构建对应文件内容。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HappyPlugin.js: </span></span><br><span class="line"></span><br><span class="line">HappyPlugin.prototype.readFromCache = <span class="function"><span class="keyword">function</span>(<span class="params">filePath</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cached = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> sourceCodeFilePath = <span class="keyword">this</span>.cache.getCompiledSourceCodePath(filePath);</span><br><span class="line">  <span class="keyword">var</span> sourceMapFilePath = <span class="keyword">this</span>.cache.getCompiledSourceMapPath(filePath);</span><br><span class="line"></span><br><span class="line">  cached.sourceCode = fs.readFileSync(sourceCodeFilePath, <span class="string">'utf-8'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (HappyUtils.isReadable(sourceMapFilePath)) &#123;</span><br><span class="line">    cached.sourceMap = SourceMapSerializer.deserialize(</span><br><span class="line">      fs.readFileSync(sourceMapFilePath, <span class="string">'utf-8'</span>)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> cached;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>函数的意图是通过 <code>cache</code> 对象的 <code>getCompiledSourceCodePath</code> 、<code>getCompiledSourceMapPath</code> 方法获取缓存的编译文件及 sourcemap 文件的存储路径，然后读取出来，完成从缓存中获取构建内容。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HappyFSCache.js</span></span><br><span class="line"></span><br><span class="line">  exports.getCompiledSourceCodePath = <span class="function"><span class="keyword">function</span>(<span class="params">filePath</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cache.mtimes[filePath] &amp;&amp; cache.mtimes[filePath].compiledPath;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  exports.getCompiledSourceMapPath = <span class="function"><span class="keyword">function</span>(<span class="params">filePath</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cache.mtimes[filePath] &amp;&amp; cache.mtimes[filePath].compiledPath + <span class="string">'.map'</span>;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>获取的路径是通过在完成编译时调用的 <code>updateMTimeFor</code> 进行存储的对象中的 <code>compiledPath</code> 编译路径属性。</p>
<p><strong>2.1.2 缓存失效</strong></p>
<p>在缓存判断失效的情况下，进入 <code>_performCompilationRequest</code> ，进行下一步 <code>happypack</code> 编译流程。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HappyPlugin.prototype.compileInBackground = <span class="function"><span class="keyword">function</span>(<span class="params">loaderContext, done</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>._performCompilationRequest(<span class="keyword">this</span>.threadPool.get(), loaderContext, done);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在调用 <code>_performCompilationRequest</code> 前， 还有一步是从 <code>ThreadPool</code> 获取对应的子进程封装对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HappyThreadPool.js</span></span><br><span class="line"></span><br><span class="line">get: RoundRobinThreadPool(threads),</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">RoundRobinThreadPool</span>(<span class="params">threads</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> lastThreadId = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">getThread</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> threadId = lastThreadId;</span><br><span class="line"></span><br><span class="line">    lastThreadId++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lastThreadId &gt;= threads.length) &#123;</span><br><span class="line">      lastThreadId = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> threads[threadId];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里按照递增返回的 <a href="https://zh.wikipedia.org/wiki/%E5%BE%AA%E7%92%B0%E5%88%B6" target="_blank" rel="external">round-robin</a>，这种在服务器进程控制中经常使用的简洁算法返回子进程封装对象。</p>
<p><strong>3. 编译开始</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">HappyPlugin.prototype._performCompilationRequest = <span class="function"><span class="keyword">function</span>(<span class="params">worker, loaderContext, done</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cache = <span class="keyword">this</span>.cache;</span><br><span class="line">  <span class="keyword">var</span> filePath = loaderContext.resourcePath;</span><br><span class="line"></span><br><span class="line">  cache.invalidateEntryFor(filePath);</span><br><span class="line"></span><br><span class="line">  worker.compile(&#123;</span><br><span class="line">    loaders: <span class="keyword">this</span>.state.loaders,</span><br><span class="line">    compiledPath: path.resolve(<span class="keyword">this</span>.config.tempDir,  </span><br><span class="line">    HappyUtils.generateCompiledPath(filePath)),</span><br><span class="line">    loaderContext: loaderContext,</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> contents = fs.readFileSync(result.compiledPath, <span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="keyword">var</span> compiledMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!result.success) &#123;</span><br><span class="line">      cache.updateMTimeFor(filePath, <span class="literal">null</span>, contents);</span><br><span class="line">      done(contents);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      cache.updateMTimeFor(filePath, result.compiledPath);</span><br><span class="line">      compiledMap = SourceMapSerializer.deserialize(</span><br><span class="line">        fs.readFileSync(cache.getCompiledSourceMapPath(filePath), <span class="string">'utf-8'</span>)</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      done(<span class="literal">null</span>, contents, compiledMap);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>首先对编译的文件，调用 <code>cache.invalidateEntryFor</code> 设置该文件路径的构建缓存失效。然后调用子进程封装对象的 compile 方法，触发子进程进行编译。</p>
<p>同时会生成衔接主进程、子进程、缓存的 <code>compiledPath</code>，当子进程完成编译后，会将编译后的代码写入 <code>compiledPath</code>，之后发送完成编译的消息回主进程，主进程也是通过 <code>compiledPath</code> 获取构建后的代码，同时传递 <code>compiledPath</code> 以及对应的编译前文件路径 <code>filePath</code>，更新缓存设置。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HappyThread.js</span></span><br><span class="line"></span><br><span class="line">    compile: <span class="function"><span class="keyword">function</span>(<span class="params">params, done</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> messageId = generateMessageId();</span><br><span class="line"></span><br><span class="line">      callbacks[messageId] = done;</span><br><span class="line"></span><br><span class="line">      fd.send(&#123;</span><br><span class="line">        id: messageId,</span><br><span class="line">        name: <span class="string">'COMPILE'</span>,</span><br><span class="line">        data: params,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里的 messageId 是个从 0 开始的递增数字，完成回调方法的存储注册，方便完成编译之后找到回调方法传递信息回主进程。同时在 <code>thread</code> 这一层，也是将参数透传给子进程执行编译。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HappyWorkerChannel.js</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">accept</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (message.name === <span class="string">'COMPILE'</span>) &#123;</span><br><span class="line">      worker.compile(message.data, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">        stream.send(&#123;</span><br><span class="line">          id: message.id,</span><br><span class="line">          name: <span class="string">'COMPILED'</span>,</span><br><span class="line">          sourcePath: result.sourcePath,</span><br><span class="line">          compiledPath: result.compiledPath,</span><br><span class="line">          success: result.success</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//省略其他操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子进程接到消息后，调用 <code>worker.compile</code> 方法 ,同时进一步传递构建参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HappyWorker.js</span></span><br><span class="line"></span><br><span class="line">HappyWorker.prototype.compile = <span class="function"><span class="keyword">function</span>(<span class="params">params, done</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  applyLoaders(&#123;</span><br><span class="line">    compiler: <span class="keyword">this</span>._compiler,</span><br><span class="line">    loaders: params.loaders,</span><br><span class="line">    loaderContext: params.loaderContext,</span><br><span class="line">  &#125;, params.loaderContext.sourceCode, params.loaderContext.sourceMap, <span class="function"><span class="keyword">function</span>(<span class="params">err, source, sourceMap</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> compiledPath = params.compiledPath;</span><br><span class="line">    <span class="keyword">var</span> success = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(err);</span><br><span class="line">      fs.writeFileSync(compiledPath, serializeError(err), <span class="string">'utf-8'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      fs.writeFileSync(compiledPath, source);</span><br><span class="line">      fs.writeFileSync(compiledPath + <span class="string">'.map'</span>, SourceMapSerializer.serialize(sourceMap));</span><br><span class="line"></span><br><span class="line">      success = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    done(&#123;</span><br><span class="line">      sourcePath: params.loaderContext.resourcePath,</span><br><span class="line">      compiledPath: compiledPath,</span><br><span class="line">      success: success</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在 HappyWorker.js 中的 <code>compile</code> 方法中，调用 <code>applyLoaders</code> 进行 loader 方法执行。<code>applyLoaders</code> 是 <code>happypack</code> 中对 <code>webpack</code> 中 loader 执行过程进行模拟，对应 NormalModuleMixin.js 中的 <a href="https://github.com/webpack/core/blob/master/lib/NormalModuleMixin.js#L49" target="_blank" rel="external"><code>doBuild</code></a> 方法。完成对文件的字符串处理编译。</p>
<p>根据 <code>err</code> 判断是否成功。如果判断成功，则将对应文件的编译后内容写入之前传递进来的 <code>compiledPath</code>,反之，则会把错误内容写入。</p>
<p>在子进程完成编译流程后，会调用传递进来的回调方法，在回调方法中将编译信息返回到主进程，主进程根据 <code>compiledPath</code> 来获取子进程的编译内容。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HappyPlugin.js</span></span><br><span class="line"></span><br><span class="line">HappyPlugin.prototype._performCompilationRequest = <span class="function"><span class="keyword">function</span>(<span class="params">worker, loaderContext, done</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> contents = fs.readFileSync(result.compiledPath, <span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="keyword">var</span> compiledMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!result.success) &#123;</span><br><span class="line">      cache.updateMTimeFor(filePath, <span class="literal">null</span>, contents);</span><br><span class="line">      done(contents);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      cache.updateMTimeFor(filePath, result.compiledPath);</span><br><span class="line">      compiledMap = SourceMapSerializer.deserialize(</span><br><span class="line">        fs.readFileSync(cache.getCompiledSourceMapPath(filePath), <span class="string">'utf-8'</span>)</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      done(<span class="literal">null</span>, contents, compiledMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取子进程的编译内容 <code>contents</code> 后，根据 <code>result.success</code> 属性来判断是否编译成功，如果失败的话，会将 <code>contents</code> 作为错误传递进去。</p>
<p>在完成调用 <code>updateMTimeFor</code> 缓存更新后，最后将内容返回到 HappyLoader.js 中的回调中，返回到 webpack 的原本流程。</p>
<p><strong>4. 编译结束</strong></p>
<p>当 webpack 整体编译流程结束后， <code>happypack</code> 开始进行一些善后工作 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HappyPlugin.js</span></span><br><span class="line"></span><br><span class="line">compiler.plugin(<span class="string">'done'</span>, that.stop.bind(that));</span><br><span class="line"></span><br><span class="line">HappyPlugin.prototype.stop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.config.cache) &#123;</span><br><span class="line">    <span class="keyword">this</span>.cache.save();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.threadPool.stop();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>4.1. 存储缓存配置</strong></p>
<p>首先调用 <code>cache.save()</code> 存储下这个缓存的映射设置。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HappyFSCache.js</span></span><br><span class="line"></span><br><span class="line">  exports.save = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    fs.writeFileSync(cachePath, <span class="built_in">JSON</span>.stringify(cache));</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>cache 对象的处理是会将这个文件直接写入 <code>cachePath</code> ，这样就能供下一次 <code>cache.load</code> 方法装载配置，利用缓存。</p>
<p><strong>4.2. 终止子进程 </strong></p>
<p>其次调用 <code>threadPool.stop</code> 来终止掉进程</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HappyThreadPool.js</span></span><br><span class="line"></span><br><span class="line">   stop: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      threads.filter(send(<span class="string">'isOpen'</span>)).map(send(<span class="string">'close'</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>类似前面提到的 <code>start</code> 方法，这里是筛选出来正在运行的 <code>HappyThread</code> 对象，调用 <code>close</code> 方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HappyThread.js</span></span><br><span class="line"></span><br><span class="line">    close: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      fd.kill(<span class="string">'SIGINT'</span>);</span><br><span class="line">      fd = <span class="literal">null</span>;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>
<p>在 <code>HappyThread</code> 中，则是调用 <code>kill</code> 方法，完成子进程的释放。</p>
<h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><p>happypack 的处理思路是将原有的 webpack 对 loader 的执行过程从单一进程的形式扩展多进程模式，原本的流程保持不变。整个流程代码结构上还是比较清晰，在使用过程中，也确实有明显提升，有兴趣的同学可以一起下来交流~</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="https://img.alicdn.com/tfs/TB15ZeJOFXXXXcYXVXXXXXXXXXX-900-500.jpg" alt="happypack 原理解析"></p>
<p>说起 <a href="https://www.npmjs.]]>
    </summary>
    
      <category term="happypack" scheme="http://taobaofed.org/tags/happypack/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[React 组件间通讯]]></title>
    <link href="http://taobaofed.org/blog/2016/11/17/react-components-communication/"/>
    <id>http://taobaofed.org/blog/2016/11/17/react-components-communication/</id>
    <published>2016-11-17T06:54:48.000Z</published>
    <updated>2016-12-21T02:40:37.000Z</updated>
    <content type="html"><![CDATA[<p><img src="//img.alicdn.com/tfs/TB1KBJsOpXXXXaeXFXXXXXXXXXX-900-500.jpg" alt="React 组件间通讯"></p>
<h2 id="React-组件间通讯"><a href="#React-组件间通讯" class="headerlink" title="React 组件间通讯"></a>React 组件间通讯</h2><p>说 React 组件间通讯之前，我们先来讨论一下 React 组件究竟有多少种层级间的关系。假设我们开发的项目是一个纯 React 的项目，那我们项目应该有如下类似的关系：</p>
<p><img src="http://img.alicdn.com/tfs/TB19qddNVXXXXcbXVXXXXXXXXXX-1712-910.png" alt=""></p>
<p>父子：Parent 与 Child_1、Child_2、Child_1_1、Child_1_2、Child_2_1</p>
<p>兄弟：Child_1 与 Child_2、Child_1_1 与 Child_2、etc.</p>
<p>针对这些关系，我们将来好好讨论一下这些关系间的通讯方式。</p>
<p>（在 React 中，React 组件之间的关系为从属关系，与 DOM 元素之间的父子关系有所不同，下面只是为了说明方便，将 React 组件的关系类比成父子关系进行阐述）</p>
<h3 id="父组件向子组件通讯"><a href="#父组件向子组件通讯" class="headerlink" title="父组件向子组件通讯"></a>父组件向子组件通讯</h3><p>通讯是单向的，数据必须是由一方传到另一方。在 React 中，父组件可以向子组件通过传 props 的方式，向子组件进行通讯。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    msg: <span class="string">'start'</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        msg: <span class="string">'end'</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Child_1</span> <span class="attr">msg</span>=<span class="string">&#123;this.state.msg&#125;</span> /&gt;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child_1 extends Component&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;this.props.msg&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>如果父组件与子组件之间不止一个层级，如 Parent 与 Child_1_1 这样的关系，可通过 <code>... 运算符</code>（Object 剩余和展开属性），将父组件的信息，以更简洁的方式传递给更深层级的子组件。通过这种方式，不用考虑性能的问题，通过 babel 转义后的  <code>... 运算符</code> 性能和原生的一致，且上级组件 props 与 state 的改变，会导致组件本身及其子组件的生命周期改变，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 ... 运算符 向 Child_1_1 传递 Parent 组件的信息</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child_1</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;this.props.msg&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Child_1_1</span> &#123;<span class="attr">...this.props</span>&#125;/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child_1_1 extends Component&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;this.props.msg&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="子组件向父组件通讯"><a href="#子组件向父组件通讯" class="headerlink" title="子组件向父组件通讯"></a>子组件向父组件通讯</h3><p>在上一个例子中，父组件可以通过传递 props 的方式，自顶而下向子组件进行通讯。而子组件向父组件通讯，同样也需要父组件向子组件传递 props 进行通讯，只是父组件传递的，是作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信息，作为参数，传递到父组件的作用域中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    msg: <span class="string">'start'</span></span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  transferMsg(msg) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      msg</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>child msg: &#123;this.state.msg&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Child_1</span> <span class="attr">transferMsg</span> = <span class="string">&#123;msg</span> =&gt;</span> this.transferMsg(msg)&#125; /&gt;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child_1 extends Component&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      this.props.transferMsg('end')</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>child_1 component<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，我们使用了 <code>箭头函数</code>，将父组件的 transferMsg 函数通过 props 传递给子组件，得益于箭头函数，保证子组件在调用 transferMsg 函数时，其内部 <code>this</code> 仍指向父组件。</p>
<p>当然，对于层级比较深的子组件与父组件之间的通讯，仍可使用  <code>... 运算符</code>，将父组件的调用函数传递给子组件，具体方法和上面的例子类似。</p>
<h3 id="兄弟组件间通讯"><a href="#兄弟组件间通讯" class="headerlink" title="兄弟组件间通讯"></a>兄弟组件间通讯</h3><p>对于没有直接关联关系的两个节点，就如 Child_1 与 Child_2 之间的关系，他们唯一的关联点，就是拥有相同的父组件。参考之前介绍的两种关系的通讯方式，如果我们向由 Child_1 向 Child_2 进行通讯，我们可以先通过 Child_1 向 Parent 组件进行通讯，再由 Parent 向 Child_2 组件进行通讯，所以有以下代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    msg: <span class="string">'start'</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  transferMsg(msg) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      msg</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Parent update'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Child_1 transferMsg = &#123;msg =&gt; this.transferMsg(msg)&#125; /&gt;</span><br><span class="line">        &lt;Child_2 msg = &#123;this.state.msg&#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child_1 extends Component&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      this.props.transferMsg('end')</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate() &#123;</span><br><span class="line">    console.log('Child_1 update');</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">      &lt;p&gt;child_1 component&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child_2 extends Component&#123;</span><br><span class="line">  componentDidUpdate() &#123;</span><br><span class="line">    console.log('Child_2 update');</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">      &lt;p&gt;child_2 component: &#123;this.props.msg&#125;&lt;/p&gt;</span><br><span class="line">      &lt;Child_2_1 /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child_2_1 extends Component&#123;</span><br><span class="line">  componentDidUpdate() &#123;</span><br><span class="line">    console.log('Child_2_1 update');</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">      &lt;p&gt;child_2_1 component&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而，这个方法有一个问题，由于 Parent 的 state 发生变化，会触发 Parent 及从属于 Parent 的子组件的生命周期，所以我们在控制台中可以看到，在各个组件中的 componentDidUpdate 方法均被触发。</p>
<p><img src="https://img.alicdn.com/tfs/TB1VjpZNVXXXXcIXXXXXXXXXXXX-268-152.png" alt=""></p>
<p>有没有更好的解决方式来进行兄弟组件间的通讯，甚至是父子组件层级较深的通讯的呢？</p>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>在传统的前端解耦方面，观察者模式作为比较常见一种设计模式，大量使用在各种框架类库的设计当中。即使我们在写 React，在写 JSX，我们核心的部分还是 JavaScript。</p>
<p>观察者模式也叫 <code>发布者-订阅者模式</code>，发布者发布事件，订阅者监听事件并做出反应，对于上面的代码，我们引入一个小模块，使用观察者模式进行改造。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> eventProxy <span class="keyword">from</span> <span class="string">'../eventProxy'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Child_1</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Child_2</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// componentDidUpdate 与 render 方法与上例一致</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child_1</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      <span class="comment">// 发布 msg 事件</span></span><br><span class="line">      eventProxy.trigger(<span class="string">'msg'</span>, <span class="string">'end'</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// componentDidUpdate 方法与上例一致</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child_2</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    msg: <span class="string">'start'</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">  	<span class="comment">// 监听 msg 事件</span></span><br><span class="line">    eventProxy.on(<span class="string">'msg'</span>, (msg) =&gt; &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        msg</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>child_2 component: &#123;this.state.msg&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Child_2_1</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在 child_2 组件的 componentDidMount 中订阅了 <code>msg</code> 事件，并在 child_1 componentDidMount 中，在 1s 后发布了 <code>msg</code> 事件，child_2 组件对 <code>msg</code> 事件做出相应，更新了自身的 state，我们可以看到，由于在整个通讯过程中，只改变了 child_2 的 state，因而只有 child_2 和 child_2_1 出发了一次更新的生命周期。</p>
<p><img src="https://img.alicdn.com/tfs/TB1WLJFNVXXXXaeXVXXXXXXXXXX-322-82.png" alt=""></p>
<p>而上面代码中，神奇的 eventProxy.js 究竟是怎样的一回事呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eventProxy.js</span></span><br><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">const</span> eventProxy = &#123;</span><br><span class="line">  onObj: &#123;&#125;,</span><br><span class="line">  oneObj: &#123;&#125;,</span><br><span class="line">  on: <span class="function"><span class="keyword">function</span>(<span class="params">key, fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.onObj[key] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.onObj[key] = [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.onObj[key].push(fn);</span><br><span class="line">  &#125;,</span><br><span class="line">  one: <span class="function"><span class="keyword">function</span>(<span class="params">key, fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.oneObj[key] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.oneObj[key] = [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.oneObj[key].push(fn);</span><br><span class="line">  &#125;,</span><br><span class="line">  off: <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.onObj[key] = [];</span><br><span class="line">    <span class="keyword">this</span>.oneObj[key] = [];</span><br><span class="line">  &#125;,</span><br><span class="line">  trigger: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> key, args;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">arguments</span>.length == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    key = <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">    args = [].concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.onObj[key] !== <span class="literal">undefined</span></span><br><span class="line">      &amp;&amp; <span class="keyword">this</span>.onObj[key].length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> <span class="keyword">this</span>.onObj[key]) &#123;</span><br><span class="line">        <span class="keyword">this</span>.onObj[key][i].apply(<span class="literal">null</span>, args);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.oneObj[key] !== <span class="literal">undefined</span></span><br><span class="line">      &amp;&amp; <span class="keyword">this</span>.oneObj[key].length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> <span class="keyword">this</span>.oneObj[key]) &#123;</span><br><span class="line">        <span class="keyword">this</span>.oneObj[key][i].apply(<span class="literal">null</span>, args);</span><br><span class="line">        <span class="keyword">this</span>.oneObj[key][i] = <span class="literal">undefined</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.oneObj[key] = [];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> eventProxy;</span><br></pre></td></tr></table></figure>
<p>eventProxy 中，总共有 on、one、off、trigger 这 4 个函数：</p>
<ul>
<li><strong>on、one：</strong>on 与 one 函数用于订阅者监听相应的事件，并将事件响应时的函数作为参数，on 与 one 的唯一区别就是，使用 one 进行订阅的函数，只会触发一次，而 使用 on 进行订阅的函数，每次事件发生相应时都会被触发。</li>
<li><strong>trigger：</strong>trigger 用于发布者发布事件，将除第一参数（事件名）的其他参数，作为新的参数，触发使用 one 与 on 进行订阅的函数。</li>
<li><strong>off：</strong>用于解除所有订阅了某个事件的所有函数。</li>
</ul>
<h3 id="Flux-与-Redux"><a href="#Flux-与-Redux" class="headerlink" title="Flux 与 Redux"></a>Flux 与 Redux</h3><p>Flux 作为 Facebook 发布的一种应用架构，他本身是一种模式，而不是一种框架，基于这个应用架构模式，在开源社区上产生了众多框架，其中最受欢迎的就是我们即将要说的 Redux。更多关于 Flux 和 Redux 的介绍这里就不一一展开，有兴趣的同学可以好好看看 <a href="https://facebook.github.io/flux/docs/overview.html" target="_blank" rel="external">Flux 官方介绍</a>、<a href="http://www.ruanyifeng.com/blog/2016/01/flux.html" target="_blank" rel="external">Flux 架构入门教程–阮一峰</a>等相关资料。<br>下面将来好好聊聊 Redux 在组件间通讯的方式。</p>
<p>Flux 需要四大部分组成：Dispatcher、Stores、Views/Controller-Views、Actions，其中的 Views/Controller-Views 可以理解为我们上面所说的 Parent 组件，其作用是从 state 当中获取到相应的数据，并将其传递给他的子组件（descendants）。而另外 3 个部分，则是由 Redux 来提供了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该例子主要对各组件的 componentDidMount 进行改造，其余部分一致</span></span><br><span class="line"><span class="keyword">import</span> &#123;createStore&#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state = &#123;&#125;, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> action;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> store = createStore(reducer);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child_1</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      store.dispatch(&#123;</span><br><span class="line">        type: <span class="string">'child_2'</span>,</span><br><span class="line">        data: <span class="string">'hello'</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      store.dispatch(&#123;</span><br><span class="line">        type: <span class="string">'child_2_1'</span>,</span><br><span class="line">        data: <span class="string">'bye'</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child_2</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    msg: <span class="string">'start'</span></span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  componentDidUpdate() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Child_2 update'</span>, store.getState());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    store.subscribe(() =&gt; &#123;</span><br><span class="line">      <span class="keyword">let</span> state = store.getState();</span><br><span class="line">      <span class="keyword">if</span> (state.type === <span class="string">'child_2'</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">          msg: state.data</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child_2_1</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    msg: <span class="string">'start'</span></span><br><span class="line">  &#125;;</span><br><span class="line">	</span><br><span class="line">  componentDidUpdate() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Child_2_1 update'</span>, store.getState());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    store.subscribe(() =&gt; &#123;</span><br><span class="line">      <span class="keyword">let</span> state = store.getState();</span><br><span class="line">      <span class="keyword">if</span> (state.type === <span class="string">'child_2_1'</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">          msg: state.data</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>child_2_1 component: &#123;this.state.msg&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，我们将一个名为 <code>reducer</code> 的函数作为参数，生成我们所需要的 store，reducer 接受两个参数，一个是存储在 store 里面的 state，另一个是每一次调用 dispatch 所传进来的 action。reducer 的作用，就是对 dispatch 传进来的 action 进行处理，并将结果返回。而里面的 state 可以通过 store 里面的 getState 方法进行获得，其结果与最后一次通过 reducer 处理后的结果保持一致。</p>
<p>在 child_1 组件中，我们每隔 1s 通过 store 的 dispatch 方法，向 store 传入包含有 type 字段的 action，reducer 直接将 action 进行返回。</p>
<p>而在 child_2 与 child_2_1 组件中，通过 store 的 subscribe 方法，监听 store 的变化，触发 dispatch 后，所有通过 subscribe 进行监听的函数都会作出相应，根据当前通过 store.getState() 获取到的结果进行处理，对当前组件的 state 进行设置。所以我们可以在控制台上看到各个组件更新及存储在 store 中 state 的情况：</p>
<p><img src="https://img.alicdn.com/tfs/TB1lP8FNVXXXXaEapXXXXXXXXXX-884-122.png" alt=""></p>
<p>在 Redux 中，store 的作用，与 MVC 中的 Model 类似，可以将我们项目中的数据传递给 store，交给 store 进行处理，并可以实时通过 store.getState() 获取到存储在 store 中的数据。我们对上面例子的 reducer 及各个组件的 componentDidMount 做点小修改，看看 store 的这一个特性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createStore&#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state = &#123;&#125;, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'child_2'</span>:</span><br><span class="line">      state.child_2 = action.data + <span class="string">' child_2'</span>;</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'child_2_1'</span>:</span><br><span class="line">      state.child_2_1 = action.data + <span class="string">' child_2_1'</span>;</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> store = createStore(reducer);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child_1</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      store.dispatch(&#123;</span><br><span class="line">        type: <span class="string">'child_2'</span>,</span><br><span class="line">        data: <span class="string">'hello'</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      store.dispatch(&#123;</span><br><span class="line">        type: <span class="string">'child_2_1'</span>,</span><br><span class="line">        data: <span class="string">'bye'</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child_2</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    store.subscribe(() =&gt; &#123;</span><br><span class="line">      <span class="keyword">let</span> state = store.getState();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (state.hasOwnProperty(<span class="string">'child_2'</span>)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">          msg: state.child_2</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child_2_1</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    store.subscribe(() =&gt; &#123;</span><br><span class="line">      <span class="keyword">let</span> state = store.getState();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (state.hasOwnProperty(<span class="string">'child_2_1'</span>)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">          msg: state.child_2_1</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们对创建 store 时所传进去的 reducer 进行修改。reducer 中，其参数 state 为当前 store 的值，我们对不同的 action 进行处理，并将处理后的结果存储在 state 中并进行返回。此时，通过 store.getState() 获取到的，就是我们处理完成后的 state。</p>
<p><img src="https://img.alicdn.com/tfs/TB1tsBQNVXXXXaGaXXXXXXXXXXX-1190-216.png" alt=""></p>
<p>Redux 内部的实现，其实也是基于观察者模式的，reducer 的调用结果，存储在 store 内部的 state 中，并在每一次 reducer 的调用中并作为参数传入。所以在 child_1 组件第 2s 的 dispatch 后，child_2 与 child_2_1 组件通过 subscribe 监听的函数，其通过 getState 获得的值，都包含有 child_2 与 child_2_1 字段的，这就是为什么第 2s 后的响应，child_2 也进行了一次生命周期。所以在对 subscribe 响应后的处理，最好还是先校对通过 getState() 获取到的 state 与当前组件的 state 是否相同。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// child_2</span></span><br><span class="line"> componentDidMount() &#123;</span><br><span class="line">    store.subscribe(() =&gt; &#123;</span><br><span class="line">      <span class="keyword">let</span> state = store.getState();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (state.hasOwnProperty(<span class="string">'child_2'</span>)</span><br><span class="line">        &amp;&amp; state.child_2 !== <span class="keyword">this</span>.state.msg) &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">          msg: state.child_2</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>加上这样的校验，各个组件的生命周期的触发就符合我们的预期了。</p>
<p><img src="https://img.alicdn.com/tfs/TB1vH8PNVXXXXaYaXXXXXXXXXXX-1254-132.png" alt=""></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Redux 对于组件间的解耦提供了很大的便利，如果你在考虑该不该使用 Redux 的时候，社区里有一句话说，“当你不知道该不该使用 Redux 的时候，那就是不需要的”。Redux 用起来一时爽，重构或者将项目留给后人的时候，就是个大坑，Redux 中的 dispatch 和 subscribe 方法遍布代码的每一个角落。刚刚的例子不是最好的，Flux 设计中的 Controller-Views 概念就是为了解决这个问题出发的，将所有的 subscribe 都置于 Parent 组件（Controller-Views），由最上层组件控制下层组件的表现，然而，这不就是我们所说的 <code>子组件向父组件通讯</code> 这种方式了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="//img.alicdn.com/tfs/TB1KBJsOpXXXXaeXFXXXXXXXXXX-900-500.jpg" alt="React 组件间通讯"></p>
<h2 id="React-组件间通讯"><a href="#React-组件间通讯]]>
    </summary>
    
      <category term="React" scheme="http://taobaofed.org/tags/React/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[聊一聊 JavaScript 中的错误隔离]]></title>
    <link href="http://taobaofed.org/blog/2016/11/10/prevent-prop-access-error-in-js/"/>
    <id>http://taobaofed.org/blog/2016/11/10/prevent-prop-access-error-in-js/</id>
    <published>2016-11-10T07:52:27.000Z</published>
    <updated>2016-12-21T02:40:37.000Z</updated>
    <content type="html"><![CDATA[<p><img src="//img.alicdn.com/tfs/TB1FOzEOXXXXXcjXFXXXXXXXXXX-900-500.jpg" alt="聊一聊 JavaScript 中的错误隔离"></p>
<p>接口请求失败、接口中部分数据缺失、运营数据不符合预期… 当我们的应用发布上线后，就开始面临这些风险。</p>
<p>而一旦这些问题导致了 JavaScript 报错（如空指针异常），并且没有被有效地隔离，就有可能引发页面的白屏、无法交互等线上问题。</p>
<p>在双 11 准备期间，我们收集了过往一年前端相关的线上问题，在收集的 21 个案例中，竟有一半的问题都与「数据异常触发页面显示异常」这个原因有些相关。</p>
<p>如何将错误的影响隔离在一定范围内，显得尤为重要。</p>
<p>这篇文章就和大家一起来聊一聊我们尝试过的一些方案，及遇到的问题。</p>
<h3 id="从空指针异常说起"><a href="#从空指针异常说起" class="headerlink" title="从空指针异常说起"></a>从空指针异常说起</h3><p>数据引发的最常见的问题就是空指针异常。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="literal">result</span> = a.b.c.d;</span><br></pre></td></tr></table></figure>
<p>这样的代码如同地雷，一旦 <code>a</code> 是一个动态数据，那么问题一触即发。</p>
<p>封装一个 get 的方法来取值，当数据不存在时，返回 <code>undefined</code>，可以快速避免此类问题。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="keyword">get</span>(a, <span class="string">'b.c.d'</span>);</span><br></pre></td></tr></table></figure>
<p>但如同我们期望大家在取值前，都先做判断一样，并不能保证所有人都这么用了，用不用全靠自觉。</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="comment">(a &amp;&amp; a.b &amp;&amp; a.b.c)</span> &#123;</span><br><span class="line">	var result = a.b.c.d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，有了以下的一些方案：</p>
<h3 id="异步数据校验"><a href="#异步数据校验" class="headerlink" title="异步数据校验"></a>异步数据校验</h3><p>对异步数据校验的想法是，在数据获取后、使用前，先做一遍schema校验，检测重要数据缺失、类型不对等异常情况。</p>
<p>与此方案对应的，我们在 <code>fetch</code> 的基础上封装了 <code>fetch-checker</code><sup>注1</sup> 组件。</p>
<p><code>fetch-checker</code> 强制要求用户在请求数据的同时，提供数据对应的 schema：</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">schema</span> = &#123;</span><br><span class="line">    <span class="string">"rule"</span>: &#123;</span><br><span class="line">      <span class="string">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"banner"</span>: &#123;</span><br><span class="line">      <span class="string">"type"</span>: <span class="string">"object"</span>,</span><br><span class="line">      <span class="string">"required"</span>: true,</span><br><span class="line">      <span class="string">"default"</span>: &#123;</span><br><span class="line">        <span class="string">"url"</span>: <span class="string">"https://item.taobao.com/item.htm?id=527331762117"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这份 schema 需要描述：</p>
<ul>
<li>每个字段的类型</li>
<li>字段是否 required</li>
<li>当 required 的字段缺失时，是否需要打底数据</li>
</ul>
<p><code>fetch-checker</code> 在拿到数据后，先做一层校验，如有需要的话，补上缺失的数据，然后再返回给调用者。这样，使用者拿到的数据就一定是符合预期的。</p>
<p>然而，这个方案面临的挑战是：</p>
<ol>
<li>如何确保调用者提供了完整的 schema 描述。不想写 schema，完全可以提供一个粗略的 schema 描述，来通过校验。</li>
<li>schema 如何精简。即不会对 bundle 大小造成太大影响，又能满足校验的功能。</li>
</ol>
<h3 id="代码编译"><a href="#代码编译" class="headerlink" title="代码编译"></a>代码编译</h3><p>受 babel 的启发，这个方案是对存在 NPE 隐患的代码，在编译阶段，将其转换成等价的安全代码。如下所示：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// input</span></span><br><span class="line"><span class="keyword">var</span> result = a.b.c;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="keyword">var</span> result = (_object2 = (_object3 = a) == <span class="literal">null</span> ? <span class="literal">null</span> : _object3.b) == <span class="literal">null</span> ? <span class="literal">null</span> : _object2.c;</span><br></pre></td></tr></table></figure>
<p>当 <code>a</code> 为空对象时，执行编译后的代码会返回 <code>null</code>，从而避免因为代码抛错，阻断后续进程。</p>
<p>在 <code>babel-plugin-safe-member-expression</code><sup>注2</sup> 这个 Babel 插件中，我们做了上述的尝试。目前，cake项目中，已经可以通过 <code>enableSafeMemberExpression</code> 这个配置，选择性的启用该功能。</p>
<p>这个方案相比来说接入成本较低，开发者无需对现有的代码做出调整，但同样存在挑战：</p>
<ul>
<li>开发阶段问题不易暴露，明明应该报错的场景，却没有任何反馈。理想的状态是：开发调试阶段尽可能多的暴露问题，线上则尽可能的减少报错。</li>
<li>隐患的代码如何界定。目前所有的 <code>a.b</code> 的调用方式都会按上述方案进行编译，虽然测试过程中还没有发现问题，但只处理有隐患的代码才更安全。</li>
</ul>
<h3 id="静态校验"><a href="#静态校验" class="headerlink" title="静态校验"></a>静态校验</h3><p>以 <a href="https://flowtype.org/" target="_blank" rel="external">flow</a> 为代表的静态校验工具，可以在一定程度上检测出 NPE 隐患。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> res = &#123;</span><br><span class="line">	<span class="keyword">data</span> ?: Object</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let <span class="keyword">name</span> = res.<span class="keyword">data</span>.<span class="keyword">name</span>;</span><br><span class="line">// property `<span class="keyword">name</span>`. Propery cannot be accessed on possibly undefined <span class="keyword">value</span></span><br></pre></td></tr></table></figure>
<p>如上面的代码所描述的，使用者需要首先理清自己的数据是否允许为空值，当 data 被允许为空值时，通过 flow 检测，<code>data.name</code> 类似这样调用便会被检测出错误。</p>
<p>然而，如何来推进所有的业务都接入静态校验，接入后，又如何保证开发者描述了所有的类型，却同样是个难点。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>总结以上几种方案，各有优缺点，都还不能算做最理想的解决方案。</p>
<table>
<thead>
<tr>
<th>方案名称</th>
<th style="text-align:center">优势</th>
<th style="text-align:right">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>提前判断</td>
<td style="text-align:center">实行简单</td>
<td style="text-align:right">全靠自觉</td>
</tr>
<tr>
<td>异步数据校验</td>
<td style="text-align:center">可确保所使用的数据是满足预期的</td>
<td style="text-align:right">schema 描述成本高</td>
</tr>
<tr>
<td>代码编译</td>
<td style="text-align:center">接入成本低，易执行</td>
<td style="text-align:right">开发阶段不易暴露问题</td>
</tr>
<tr>
<td>静态校验</td>
<td style="text-align:center">对现有代码逻辑侵入少</td>
<td style="text-align:right">落地成本高</td>
</tr>
</tbody>
</table>
<p>对于业务来说，最愿意使用和有效的方案一定是：</p>
<ul>
<li>能将线上问题隔离在一个小范围内，同时不影响开发调试阶段的问题暴露</li>
<li>能提前暴露出隐患</li>
<li>接入成本低，不需要大量修改现有业务代码</li>
</ul>
<p>关于空指针异常和错误隔离，机智的你又有哪些方案，一起来讨论吧。</p>
<h6 id="编者注-本文提到的所有工具如未提供链接，可能是内部代码，暂未对外公布。"><a href="#编者注-本文提到的所有工具如未提供链接，可能是内部代码，暂未对外公布。" class="headerlink" title="编者注: 本文提到的所有工具如未提供链接，可能是内部代码，暂未对外公布。"></a>编者注: 本文提到的所有工具如未提供链接，可能是内部代码，暂未对外公布。</h6>]]></content>
    <summary type="html">
    <![CDATA[<p><img src="//img.alicdn.com/tfs/TB1FOzEOXXXXXcjXFXXXXXXXXXX-900-500.jpg" alt="聊一聊 JavaScript 中的错误隔离"></p>
<p>接口请求失败、接口中部分数据缺失、运营数据不符合预期… 当]]>
    </summary>
    
      <category term="错误隔离" scheme="http://taobaofed.org/tags/%E9%94%99%E8%AF%AF%E9%9A%94%E7%A6%BB/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ES6 你可能不知道的事 - 进阶篇]]></title>
    <link href="http://taobaofed.org/blog/2016/11/03/es6-advanced/"/>
    <id>http://taobaofed.org/blog/2016/11/03/es6-advanced/</id>
    <published>2016-11-03T05:11:51.000Z</published>
    <updated>2016-12-21T02:40:37.000Z</updated>
    <content type="html"><![CDATA[<p><img src="https://img.alicdn.com/tfs/TB1xlp2OXXXXXaXXVXXXXXXXXXX-900-500.jpg" alt="ES6 你可能不知道的事 - 进阶篇"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章主要会针对上篇未涉及到的进阶特性展开；而与<a href="http://taobaofed.org/blog/2016/07/22/es6-basics/">前一篇文章</a>相同，本文主要介绍这些特性的一些容易忽略的部分，希望能对大家正确认识和使用 ES6 有帮助。</p>
<p>还是那句话，时间和能力有限，针对文章中的问题或不同意见，欢迎随时拍砖、指正！</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h4 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h4><p>模块化是个进行了很久的话题，发展历程中出现过很多模式，例如 AMD, CommonJS 等等。</p>
<p><code>Module</code> 是 ES6 的新特性，是语言层面对模块化的支持。</p>
<blockquote>
<p>与之前模块加载机制不同，Module 是动态的加载，导入的是变量的 <strong>只读引用</strong> ，而不是拷贝</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. export default 可以做默认导出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="number">5</span>;      <span class="comment">// 默认导出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">import</span> b, &#123;a&#125; <span class="keyword">from</span> <span class="string">'./a.js'</span>;    <span class="comment">// 默认导入，不需要加花括号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 动态的加载机制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  a = <span class="number">15</span>;</span><br><span class="line">  b = <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;a, b, add&#125; <span class="keyword">from</span> <span class="string">'./a.js'</span>;</span><br><span class="line">a+b;    <span class="comment">// 20</span></span><br><span class="line">add();  <span class="comment">// 35</span></span><br><span class="line">a+b;    <span class="comment">// 35</span></span><br></pre></td></tr></table></figure>
<h4 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h4><p><code>symbol</code> 是 ES6 的一个新特性，他有如下特点：</p>
<ul>
<li><code>symbol</code> 是一个 “新” 的 <strong>基础数据类型</strong> ；从 ES6 起，JavaScript 的 <strong>基础数据类型</strong> 变为 6 个：<code>string</code>, <code>number</code>, <code>boolean</code>, <code>null</code>, <code>undefined</code>, <code>symbol</code></li>
<li><code>symbol</code> 可以用作 <code>Object</code> 的 key</li>
<li><code>symbol</code> 存在全局作用域，利用 <code>Symbol.for(key)</code> 方法，可以创建（全局作用域无指定键）或获取全局作用域内的 <code>symbol</code> ；利用 <code>Symbol.keyFor(sym)</code> 方法，可以获取指定 <code>symbol</code> 的键</li>
<li>JavaScript 内部使用了很多内置 <code>symbol</code> ，作为特殊的键，来实现一些内部功能；例如 <code>Symbol.iterator</code> 用于标示对象的<a href="#Iterators + For..Of">迭代器</a></li>
</ul>
<blockquote>
<p>“新” 仅仅是针对前端开发人员来说的，其实 Symbol 概念本身已经在 JavaScript 语言内部长时间使用了</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. "Symbol(desc)" 方法用于创建一个新的 symbol，参数 "desc" 仅用做 symbol 的描述，并不用于唯一标示 symbol</span></span><br><span class="line"><span class="built_in">Symbol</span>(<span class="string">'abc'</span>) === <span class="built_in">Symbol</span>(<span class="string">'abc'</span>);    <span class="comment">// false，'abc'仅作为两个 symbol 的描述信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. "Symbol.for(key)" 方法，参数 "key" 是用于在全局作用域中标示 symbol 的唯一键，同时也作为该 symbol 的描述信息</span></span><br><span class="line"><span class="built_in">Symbol</span>.for(<span class="string">'abc'</span>) === <span class="built_in">Symbol</span>.for(<span class="string">'abc'</span>);    <span class="comment">// true，左侧为创建，右侧为获取</span></span><br><span class="line"><span class="built_in">Symbol</span>.for(<span class="string">'abc'</span>) === <span class="built_in">Symbol</span>(<span class="string">'abc'</span>);        <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. symbol 无法被 for...in 遍历到 (不可枚举)，可以利用 Object.getOwnPropertySymbols 获取</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">'abc'</span>)]: <span class="string">'abc'</span>,</span><br><span class="line">  <span class="string">'abc'</span>: <span class="string">'abc'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> obj)&#123;  <span class="comment">// abc</span></span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertySymbols(obj);    <span class="comment">// [Symbol(abc)]</span></span><br></pre></td></tr></table></figure>
<h4 id="Iterator-For-Of"><a href="#Iterator-For-Of" class="headerlink" title="Iterator + For..Of"></a>Iterator + For..Of</h4><p>ES6 中除了新特性外，还有一个新的规范，那就是关于迭代的规范，他包括两部分分别是 “可迭代规范（iterable protocol）” 和 “迭代器规范（iterator protocol）”。任何实现了前者的对象，都可以进行 <code>for…of</code> 循环。</p>
<p><code>String</code>, <code>Array</code>, <code>Map</code>, <code>Set</code>等是原生可迭代对象，因为他们都在原型（prototype）对象中实现了 Symbol.iterator 键对应的方法</p>
<blockquote>
<p><code>for…of</code> 是对象迭代器的遍历，而 <code>for…in</code> 是对象中 可枚举 值的遍历</p>
</blockquote>
<p>下面用代码来解释一下两个规范：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 迭代器规范</span></span><br><span class="line"><span class="keyword">const</span> iter = &#123;</span><br><span class="line">  counter: <span class="number">0</span>,</span><br><span class="line">  next()&#123;    <span class="comment">// 迭代器是实现了 "next()" 函数的对象</span></span><br><span class="line">    <span class="keyword">if</span>(++<span class="keyword">this</span>.counter &lt; <span class="number">10</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;    <span class="comment">// 返回一个含有两个键值对的对象，Object &#123;done =&gt; boolean, value =&gt; any&#125;</span></span><br><span class="line">        done: <span class="literal">false</span>,</span><br><span class="line">        value: <span class="keyword">this</span>.counter</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.counter = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span> &#123;    <span class="comment">// done = true 时，value非必须</span></span><br><span class="line">        done: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 可迭代规范，实现 "Symbol.iterator =&gt; func()" 键值对；而 "func()" 返回一个 迭代器对象</span></span><br><span class="line"><span class="keyword">const</span> iterObj = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">of</span> iterObj)&#123;&#125;;    <span class="comment">// TypeError: iterObj is not iterable</span></span><br><span class="line">iterObj[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> iter;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">of</span> iterObj)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);    <span class="comment">// 1,2,3,4,5,6,7,8,9</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="关于集合"><a href="#关于集合" class="headerlink" title="关于集合"></a>关于集合</h3><p>原来我们使用集合，多数情况下会直接用 <code>Object</code> 代替，ES6新增了两个特性，<code>Map</code> 和 <code>Set</code>，他们是对 JavaScript 关于集合概念的补充。</p>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>刚刚看到这个概念的同学会有几个常见的疑问，为什么我们需要 <code>Map</code> 这种数据结构？直接用 <code>Object</code> 不好么？ 是不是 <code>Map</code> 可以完全取代 <code>Object</code> 用于数据存取？</p>
<p><code>Map</code> 与 <code>Object</code> 的区别</p>
<ul>
<li><code>Map</code> 与 <code>Object</code> 都可以存取数据，<code>Map</code> 适用于存储需要 <strong>常需要变化（增减键值对）或遍历</strong> 的数据集，而 <code>Object</code> 适用于存储 <strong>静态</strong> （例如配置信息）数据集</li>
<li><code>Object</code> 的 key 必须是 <code>String</code> 或 <code>Symbol</code> 类型的，而 <code>Map</code> 无此限制，可以是任何值</li>
<li><code>Map</code> 可以很方便的取到键值对数量，而 <code>Object</code> 需要用额外途径</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. Map 的构造函数可以传入一个 “可迭代的对象（例如数组）”，其中包含键值对数组</span></span><br><span class="line"><span class="keyword">const</span> first = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'a'</span>, <span class="number">1</span>], [&#123;<span class="string">'b'</span>: <span class="number">1</span>&#125;, <span class="number">2</span>]]);    <span class="comment">// Map &#123;"a" =&gt; 1, Object &#123;b: 1&#125; =&gt; 2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Map 的键可以是任何值，甚至是 undefined 或 null</span></span><br><span class="line">first.set(<span class="literal">null</span>, <span class="number">1</span>).set(<span class="literal">undefined</span>, <span class="number">0</span>);    <span class="comment">// Map &#123;"a" =&gt; 1, Object &#123;b: 1&#125; =&gt; 2, null =&gt; 1, undefined =&gt; 0&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p><code>Set</code> 作为最简单的集合，有着如下几个特点：</p>
<ul>
<li><code>Set</code> 可以存储任何类型的值，遍历顺序与 <strong>插入顺序相同</strong></li>
<li><code>Set</code> 内无重复的值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. Set 的构造函数可以传入一个 “可迭代的对象（例如数组）”，其中包含任意值</span></span><br><span class="line"><span class="keyword">const</span> first = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'a'</span>, <span class="number">1</span>, &#123;<span class="string">'b'</span>: <span class="number">1</span>&#125;, <span class="literal">null</span>]);    <span class="comment">// Set &#123;"a", 1, Object &#123;b: 1&#125;, null&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Set 无法插入重复的值</span></span><br><span class="line">first.add(<span class="number">1</span>);    <span class="comment">// Set &#123;"a", 1, Object &#123;b: 1&#125;, null&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="WeakMap-WeakSet"><a href="#WeakMap-WeakSet" class="headerlink" title="WeakMap + WeakSet"></a>WeakMap + WeakSet</h4><p><code>WeakMap</code> 与 <code>WeakSet</code> 作为一个比较新颖的概念，其主要特点在于弱引用。</p>
<p>相比于 <code>Map</code> 与 <code>Set</code> 的强引用，弱引用可以令对象在 “适当” 情况下正确被 GC 回收，减少内存资源浪费。</p>
<p><strong>但由于不是强引用，所以无法进行遍历或取得值数量，只能用于值的存取（WeakMap）或是否存在值得判断（WeakSet）</strong></p>
<blockquote>
<p>在弱引用的情况下，GC 回收时，不会把其视作一个引用；如果没有其他强引用存在，那这个对象将被回收</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. WeakMap 键必须是对象</span></span><br><span class="line"><span class="keyword">const</span> err = <span class="keyword">new</span> <span class="built_in">WeakMap</span>([[<span class="string">'a'</span>,<span class="number">1</span>]]);    <span class="comment">// TypeError: Invalid value used as weak map key</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. WeakMap/WeakSet 的弱引用</span></span><br><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>([[&#123;<span class="string">'a'</span>:<span class="number">1</span>&#125;,<span class="number">1</span>]]);    <span class="comment">// Object &#123;'a': 1&#125; 会正常被 GC 回收</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>(); </span><br><span class="line">ws.add(&#123;<span class="string">'a'</span>:<span class="number">1</span>&#125;);    <span class="comment">// Object &#123;'a': 1&#125; 会正常被 GC 回收</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;<span class="string">'b'</span>: <span class="number">1</span>&#125;;</span><br><span class="line">ws.add(obj);        <span class="comment">// Object &#123;'b': 1&#125; 不会被正常 GC 回收，因为存在一个强引用</span></span><br><span class="line">obj = <span class="literal">undefined</span>;    <span class="comment">// Object &#123;'b': 1&#125; 会正常被 GC 回收</span></span><br></pre></td></tr></table></figure>
<h3 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h3><p>在 ES6 之前，JavaScript 的异步编程都跳不出回调函数这个方式。回调函数方式使用非常简单，在简单异步任务调用时候没有任何问题，但如果出现复杂的异步任务场景时，就显得力不从心了，最主要的问题就是多层回调函数的嵌套会导致代码的横向发展，难以维护；ES6 带来了两个新特性来解决异步编程的难题。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个简单的多层嵌套回调函数的例子 (Node.js)</span></span><br><span class="line"><span class="keyword">const</span> git = <span class="built_in">require</span>(<span class="string">'shell'</span>).git;</span><br><span class="line"><span class="keyword">const</span> commitMsg = <span class="string">'...'</span>;</span><br><span class="line"></span><br><span class="line">git.add(<span class="string">'pattern/for/some/files/*'</span>, (err) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">    git.commit(commitMsg, (err) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">        git.push(pushOption);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><p><code>Promise</code> 是 ES6 的一个新特性，同为异步编程方式，它主要有如下几个特点：</p>
<ul>
<li>本质还是回调函数</li>
<li>区分成功和失败的回调，省去嵌套在内层的判断逻辑</li>
<li>可以很轻松的完成回调函数模式到 Promise 模式的转化</li>
<li>代码由回调函数嵌套的横向扩展，变为链式调用的纵向扩展，易于理解和维护</li>
</ul>
<p><code>Promise</code> 虽然优势颇多，但是代码结构仍与同步代码区别较大</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上例用 Promise 实现</span></span><br><span class="line"><span class="comment">// 假定 git.add, git.commit, git.push 均做了 Promise 封装，返回一个 Promise 对象</span></span><br><span class="line"><span class="keyword">const</span> git = <span class="built_in">require</span>(<span class="string">'shell'</span>).git;</span><br><span class="line"><span class="keyword">const</span> commitMsg = <span class="string">'...'</span>;</span><br><span class="line"></span><br><span class="line">git.add(<span class="string">'pattern/for/some/files/*'</span>)</span><br><span class="line">  .then(() =&gt; git.commit(commitMsg))</span><br><span class="line">  .then(git.push)</span><br><span class="line">  .catch((err) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<h4 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h4><p><code>Generator</code> 作为 ES6 的新特性，是一个语言层面的升级。它有以下几个特点：</p>
<ul>
<li>可以通过 <code>yield</code> 关键字，终止执行并返回（内到外）</li>
<li>可以通过 <code>next(val)</code> 方法调用重新唤醒，继续执行（外回内）</li>
<li>运行时（包括挂起态），共享局部变量</li>
<li><code>Generator</code> 执行会返回一个结果对象，结果对象本身既是迭代器，同时也是可迭代对象（同时满足<a href="#Iterator + For..Of">两个迭代规范</a>），所以 <code>Generator</code> 可以直接用于 <strong>自定义对象迭代器</strong></li>
</ul>
<p>由于具备以上特点（第四点除外），<code>Generator</code> 也是 JavaScript 对 协程（coroutine）的实现，协程可以理解为 “可由开发人员控制调度的多线程”</p>
<blockquote>
<p>协程按照调度机制来区分，可以分为对称式和非对称式</p>
<p>非对称式：被调用者（协程）挂起时，必须将控制权返还调用者（协程）</p>
<p>对称式：被调用者（协程）挂起时，可将控制权转给 “任意” 其他协程</p>
<p>JavaScript 实现的是 非对称式协程（semi-coroutine）；非对称式协程相比于对称式协程，代码逻辑更清晰，易于理解和维护</p>
</blockquote>
<p>协程给 JavaScript 提供了一个新的方式去完成异步编程；由于 <code>Generator</code> 的执行会返回一个迭代器，需要手动去遍历，所以如果要达到自动执行的目的，除了本身语法外，还需要实现一个执行器，例如 <strong>TJ 大神的 co</strong> 框架。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上例用 Generator 实现</span></span><br><span class="line"><span class="comment">// 假定 git.add, git.commit, git.push 均做了 Promise 封装，返回一个 Promise 对象</span></span><br><span class="line"><span class="keyword">const</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>);</span><br><span class="line"><span class="keyword">const</span> git = <span class="built_in">require</span>(<span class="string">'shell'</span>).git;</span><br><span class="line"></span><br><span class="line">co(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> commitMsg = <span class="string">'...'</span>;      <span class="comment">// 共享的局部变量</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">yield</span> git.add(<span class="string">'pattern/for/some/files/*'</span>);</span><br><span class="line">  <span class="keyword">yield</span> git.commit(commitMsg);</span><br><span class="line">  <span class="keyword">yield</span> git.push();</span><br><span class="line">&#125;).catch((err) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>Generator</code> 是一个 ES6 最佳的异步编程选择么？显然不是，因为除了基本语法外，我们还要额外去实现执行器来达到执行的目的，但是它整体的代码结构是优于回调函数嵌套和 <code>Promise</code> 模式的。</p>
<h4 id="Async-Await"><a href="#Async-Await" class="headerlink" title="Async-Await"></a>Async-Await</h4><p>这并不是一个 ES6 新特性，而是 ES7 的语法，放在这里是因为它将是 JavaScript 目前支持异步编程最好的方式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上例用 async-await 实现</span></span><br><span class="line"><span class="comment">// 假定 git.add, git.commit, git.push 均做了 Promise 封装，返回一个 Promise 对象</span></span><br><span class="line"><span class="keyword">const</span> git = <span class="built_in">require</span>(<span class="string">'shell'</span>).git;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> commitMsg = <span class="string">'...'</span>;      <span class="comment">// 共享的局部变量</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">await</span> git.add(<span class="string">'pattern/for/some/files/*'</span>);</span><br><span class="line">    <span class="keyword">await</span> git.commit(commitMsg);</span><br><span class="line">    <span class="keyword">await</span> git.push();</span><br><span class="line">  &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<h3 id="元编程"><a href="#元编程" class="headerlink" title="元编程"></a>元编程</h3><p>元编程是指的是开发人员对 “语言本身进行编程”。一般是编程语言暴露了一些 API，供开发人员来操作语言本身的某些特性。ES6 两个新特性 <code>Proxy</code> 和 <code>Reflect</code> 是 JavaScript 关于对象元编程能力的扩展。</p>
<h4 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h4><p><code>Proxy</code> 是 ES6 加入的一个新特性，它可以 “代理” 对象的原生行为，替换为执行自定义行为。</p>
<p>这样的元编程能力使得我们可以更轻松的扩展出一些特殊对象。</p>
<ul>
<li>任何对象都可以被 “代理”</li>
<li>利用 <code>Proxy.revocable(target, handler)</code> 可以创建出一个可逆的 “被代理” 对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单 element 选择控制工具的实现</span></span><br><span class="line"><span class="keyword">const</span> cacheElement = <span class="function"><span class="keyword">function</span>(<span class="params">target, prop</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(target.hasOwnProperty(prop))&#123;</span><br><span class="line">      <span class="keyword">return</span> target[prop];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> target[prop] = <span class="built_in">document</span>.getElementById(prop);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> elControl = <span class="keyword">new</span> <span class="built_in">Proxy</span>(cacheElement, &#123;</span><br><span class="line">  get: (target, prop) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> cacheElement(target, prop);</span><br><span class="line">  &#125;,</span><br><span class="line">  set: (target, prop, val) =&gt; &#123;</span><br><span class="line">    cacheElement(target, prop).textContent = val;</span><br><span class="line">  &#125;,</span><br><span class="line">  apply: (target, thisArg, args) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.ownKeys(target);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">elControl.first;     <span class="comment">// div#first</span></span><br><span class="line">elControl.second;    <span class="comment">// div#second</span></span><br><span class="line">elControl.first = <span class="number">5</span>;    <span class="comment">// div#first =&gt; 5</span></span><br><span class="line">elControl.second = <span class="number">10</span>;  <span class="comment">// div#second =&gt; 10</span></span><br><span class="line">elControl();    <span class="comment">// ['first', 'second']</span></span><br></pre></td></tr></table></figure>
<h4 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h4><p>ES6 中引入的 <code>Reflect</code> 是另一个元编程的特性，它使得我们可以直接操纵对象的原生行为。<code>Reflect</code> 可操纵的行为与 <code>Proxy</code> 可代理的行为是一一对应的，这使得可以在 <code>Proxy</code> 的自定义方法中方便的使用 <code>Reflect</code> 调起原生行为。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. Proxy 的自定义方法中，通过 Reflect 调用原生行为</span></span><br><span class="line"><span class="keyword">const</span> customProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;</span><br><span class="line">  <span class="string">'custom'</span>: <span class="number">1</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">  get: (target, prop) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`get <span class="subst">$&#123;prop&#125;</span> !`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, <span class="literal">undefined</span>, prop);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">customProxy.custom;  <span class="comment">// get custom, 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 与 Object 对象上已经开放的操作原生行为方法相比，语法更加清晰易用（例如：Object.hasOwnProperty 与 Reflect.has）</span></span><br><span class="line"><span class="keyword">const</span> symb = <span class="built_in">Symbol</span>(<span class="string">'b'</span>);</span><br><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">  [symb]: <span class="number">1</span>,</span><br><span class="line">  <span class="string">'b'</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">Reflect</span>.has(a, symb) &amp;&amp; <span class="built_in">Reflect</span>.has(a, <span class="string">'b'</span>))&#123;  <span class="comment">// good</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'good'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys(a);  <span class="comment">// ["b", Symbol(b)]</span></span><br></pre></td></tr></table></figure>
<h2 id="进阶阅读"><a href="#进阶阅读" class="headerlink" title="进阶阅读"></a>进阶阅读</h2><p>篇幅有限，无法面面俱到，还想再最后推荐给大家一些想进阶了解 ES6 的必看内容</p>
<ul>
<li>如果你关注兼容性，推荐看：<a href="https://kangax.github.io/compat-table/es6/" target="_blank" rel="external">https://kangax.github.io/compat-table/es6/</a>，这里介绍了从 ES5 到 ES2016+ 的所有特性（包括仍未定稿的特性）及其在各环境的兼容性</li>
<li>如果你关注性能，推荐看：<a href="http://kpdecker.github.io/six-speed/" target="_blank" rel="external">http://kpdecker.github.io/six-speed/</a>，这里通过性能测试，将 ES6 特性的原生实现与 ES5 polyfill 版本进行对比，覆盖了各主流环境；同时也可以侧面对比出各环境在原生实现上的性能优劣</li>
<li>如果你想全面了解特性，推荐看：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/Web/JavaScript</a>，覆盖特性的各方面，包括全面的 API（包括不推荐和废弃的）和基础用法</li>
<li>如果你想看特性更多的使用示例和对应的 polyfill 实现，推荐看：<a href="http://es6-features.org/#Constants" target="_blank" rel="external">http://es6-features.org/#Constants</a>，这里对各个特性都给出了使用丰富的例子和一个 polyfill 实现，简单明了</li>
<li>如果想了解 ECMA Script 最多最全面的细节，英语又比较过硬，推荐在需要时看：<a href="http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf" target="_blank" rel="external">http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf</a>，（或者直接看最新的：<a href="https://tc39.github.io/ecma262/" target="_blank" rel="external">https://tc39.github.io/ecma262/</a>）</li>
</ul>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>基础篇+进阶篇基本介绍完了 ES6 的主要特性，但 ES6 仅仅是现在时，后续如果大家觉得这个系列有意思，可以再写一写 ES 2016+ 的相关内容，来拥抱一下更新的变化。</p>
<p>最后，希望文章中的部分内容可以对大家理解和使用 ES6 有所帮助，感谢支持~</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/Web/JavaScript</a></li>
<li><a href="https://babeljs.io/docs/learn-es2015/" target="_blank" rel="external">https://babeljs.io/docs/learn-es2015/</a></li>
<li><a href="https://www.stackoverflow.com/" target="_blank" rel="external">https://www.stackoverflow.com</a></li>
<li><a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">http://es6.ruanyifeng.com/</a></li>
<li><a href="https://kangax.github.io/compat-table/esnext/" target="_blank" rel="external">https://kangax.github.io/compat-table/esnext/</a></li>
<li><a href="http://www.ecma-international.org/ecma-262/6.0/" target="_blank" rel="external">http://www.ecma-international.org/ecma-262/6.0/</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="https://img.alicdn.com/tfs/TB1xlp2OXXXXXaXXVXXXXXXXXXX-900-500.jpg" alt="ES6 你可能不知道的事 - 进阶篇"></p>
<h2 id="前言"><a href="#前言" cla]]>
    </summary>
    
      <category term="ES6" scheme="http://taobaofed.org/tags/ES6/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何 hack Node.js 模块？]]></title>
    <link href="http://taobaofed.org/blog/2016/10/27/how-to-hack-nodejs-modules/"/>
    <id>http://taobaofed.org/blog/2016/10/27/how-to-hack-nodejs-modules/</id>
    <published>2016-10-27T08:16:05.000Z</published>
    <updated>2016-12-21T02:40:37.000Z</updated>
    <content type="html"><![CDATA[<p><img src="//img.alicdn.com/tfs/TB1SJkrNVXXXXXsXVXXXXXXXXXX-900-500.jpg" alt="如何 hack Node.js 模块？"></p>
<h2 id="为何要去-hack？"><a href="#为何要去-hack？" class="headerlink" title="为何要去 hack？"></a>为何要去 hack？</h2><p>在业务开发过程中，往往会依赖一些 Node.js 模块，hack 这些 Node.js 模块的主要目的是在不修改工具源码的情况下，篡改一些特定的功能。可能会是出于以下几种情况的考虑：</p>
<ol>
<li>总是存在一些特殊的本地需求，不一定能作为工具的通用需求来暴露正常的 API 给更多的用户。</li>
<li>临时且紧急的需求，提 PR 已经来不及了。</li>
<li>为什么不直接去改源码？考虑到工具会不定期升级，想使用工具的最新特性，改源码可维护性太差。</li>
</ol>
<h2 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h2><p>举个栗子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  dosomething();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// b.js </span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">require</span>(a);</span><br><span class="line"><span class="comment">// c.js </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">require</span>(b));</span><br></pre></td></tr></table></figure>
<p>b 是项目 c 依赖的一个工具模块，b 依赖 a。希望只在项目 c 中，b 调用 a 时，a 的函数里能注入一些方法 <code>injectSomething()</code></p>
<ul>
<li>hack 之前 c 的输出</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  dosomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>期望：hack 之后 c 的输出</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  injectSomething();</span><br><span class="line">  dosomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><b>具体案例比如：在做个人自动化工具时，需要 mock 一些工具的手动输入；在本地构建时，需要修改通用的构建流程</b>（后面案例部分会详细说）</p>
<h2 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h2><h3 id="利用模块-cache-篡改模块对象属性"><a href="#利用模块-cache-篡改模块对象属性" class="headerlink" title="利用模块 cache 篡改模块对象属性"></a>利用模块 cache 篡改模块对象属性</h3><p>这是我最早使用的方法，在模块 a 的类型是 object 的时候，可以在自己的项目 c 中提早 require 模块 a，按照你的需求修改一些属性，这样当模块 b 再去 require 模块 a 时，从缓存中取出的模块 a 已经是被修改过的了。</p>
<p>模块 a、b、c 栗子如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  p</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="built_in">require</span>(a);</span><br><span class="line">a.p();</span><br><span class="line"><span class="comment">// c.js</span></span><br><span class="line"><span class="built_in">require</span>(b);</span><br></pre></td></tr></table></figure></p>
<p>我想修改 a 的方法 p，在 c 中进行如下修改即可，而无需直接去修改工具 a、b 的源码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c.js</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="built_in">require</span>(a);</span><br><span class="line"><span class="keyword">let</span> oldp = a.p; </span><br><span class="line">a.p = <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">   injectSomething();</span><br><span class="line">   oldp.apply(<span class="keyword">this</span>, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">require</span>(b);</span><br></pre></td></tr></table></figure>
<p>缺陷：在某些模块属性是动态加载的情况，不是那么灵敏，而且只能篡改引用对象。但大部分情况下还是能够满足需求的。</p>
<h3 id="修改require-cache"><a href="#修改require-cache" class="headerlink" title="修改require.cache"></a>修改require.cache</h3><p>在遇到模块暴露的是非对象的情况，就需要直接去修改 require 的 cache 对象了。关于修改 <code>require.cache</code> 的有效性，会在后面的原理部分详细说，先来简单的说下操作：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.js 暴露的非对象,而是函数</span></span><br><span class="line">module.exports = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">   doSomething();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//c.js</span></span><br><span class="line"><span class="keyword">const</span> aOld = require(a); </span><br><span class="line">let aId = require.resolve(aPath);</span><br><span class="line">require.cache[aId] = <span class="function"><span class="keyword">function</span><span class="params">(<span class="rest_arg">...args</span>)</span></span>&#123;</span><br><span class="line">   injectSomething();</span><br><span class="line">   aOld.apply(<span class="keyword">this</span>, args);</span><br><span class="line">&#125;</span><br><span class="line">require(b);</span><br></pre></td></tr></table></figure>
<p>缺陷：可能后续调用链路会有人手动去修改 <code>require.cache</code>，例如热加载。</p>
<h3 id="修改-require"><a href="#修改-require" class="headerlink" title="修改 require"></a>修改 require</h3><p>这种方法是直接去代理 <code>require</code> ，是最稳妥的方法，但是侵入性相对来说比较强。Node.js 文件中的 require 其实是在 Module 的原型方法上，即 <code>Module.prototype.require</code>。后面会详细说，先简单说下操作：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Module = <span class="built_in">require</span>(<span class="string">'module'</span>);</span><br><span class="line"><span class="keyword">const</span> _require = Module.prototype.require;</span><br><span class="line">Module.prototype.require = <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = _require.apply(<span class="keyword">this</span>, args);</span><br><span class="line">    <span class="keyword">if</span>(args[<span class="number">0</span>] === <span class="string">'a'</span>) &#123; <span class="comment">// 只修改a模块内容</span></span><br><span class="line">        injectSomething();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>缺陷：对整个 Node.js 进程的 require 操作都具有侵入性。</p>
<h2 id="相关原理"><a href="#相关原理" class="headerlink" title="相关原理"></a>相关原理</h2><h3 id="node的启动过程"><a href="#node的启动过程" class="headerlink" title="node的启动过程"></a>node的启动过程</h3><p>我们先来看看在运行 <strong><code>node a.js</code></strong> 时发生些什么？<a href="https://github.com/nodejs/node/tree/master" target="_blank" rel="external">node源码</a><br><img src="https://img.alicdn.com/tfs/TB1QtALNVXXXXbCXXXXXXXXXXXX-720-297.png" alt="node_main"></p>
<p>上图是node运行 <code>a.js</code> 的一个核心流程，Node.js 的启动程序 <code>bootstrap_node.js</code> 是在 <code>node::LoadEnvironment</code> 中被立即执行的，<code>bootstrap_node.js</code> 中的 <code>startup()</code> 是包裹在一个匿名函数里面的，所以在一次执行 <code>node</code> 的行为中 <code>startup()</code> 只会被调用了一次，来保证 <code>bootstrap_node.js</code> 的所执行的所有依赖只会被加载一次。<code>C++</code> 语言部分中：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//node_main.cc 如果在win环境执行wmain()，unix则执行main()，函数最后都执行了node::Start(argc, argv)  </span><br><span class="line">#ifdef _WIN32</span><br><span class="line">  int wmain()</span><br><span class="line">#else</span><br><span class="line">  int main()</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">//node::Start(argc, argv) 提供载入 Node.js 进程的 V8 环境</span><br><span class="line">Environment::AsyncCallbackScope callback_scope(&amp;env);</span><br><span class="line">LoadEnvironment(&amp;env);</span><br><span class="line"></span><br><span class="line">//node::LoadEnvironment(Environment* env) 加载 Node.js 环境</span><br><span class="line">Local&lt;String&gt; script_name = FIXED_ONE_BYTE_STRING(env-&gt;isolate()," bootstrap_node.js");</span><br><span class="line">Local&lt;Value&gt; f_value = ExecuteString(env, MainSource(env), script_name);</span><br></pre></td></tr></table></figure>
<p>  在 <code>bootstrap_node.js</code> 中，会去执行 Module 的静态方法 <code>runMain</code>，而 <code>runMain</code> 中则去执行了 <code>Module._load</code>，也就是模块加载的过程。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bootstrap_node.js</span></span><br><span class="line"><span class="keyword">const</span> Module = NativeModule.require(<span class="string">'module'</span>);</span><br><span class="line">……</span><br><span class="line">run(Module.runMain);</span><br><span class="line"><span class="comment">// Module.js</span></span><br><span class="line">Module.runMain = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Module._load(process.argv[<span class="number">1</span>], <span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">    process._tickCallback();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="一个进程只存在一个-cache-对象？"><a href="#一个进程只存在一个-cache-对象？" class="headerlink" title="一个进程只存在一个 cache 对象？"></a>一个进程只存在一个 cache 对象？</h3><p>先来看看 <code>module._load</code> 干了什么？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Module._load = <span class="function"><span class="keyword">function</span>(<span class="params">request, parent, isMain</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> filename = Module._resolveFilename(request, parent, isMain);</span><br><span class="line">  <span class="keyword">var</span> cachedModule = Module._cache[filename]; <span class="comment">// get cache</span></span><br><span class="line">  <span class="keyword">if</span> (cachedModule) &#123;</span><br><span class="line">    <span class="keyword">return</span> cachedModule.exports; </span><br><span class="line">  &#125;</span><br><span class="line">  ……</span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">module</span> = <span class="keyword">new</span> Module(filename, parent);</span><br><span class="line">  ……</span><br><span class="line">  Module._cache[filename] = <span class="built_in">module</span>; <span class="comment">// set cache</span></span><br><span class="line">  tryModuleLoad(<span class="built_in">module</span>, filename);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，在 load 的一个模块时，会先读缓存 <code>Module._cache</code>，如果没有就会去 new 一个 Module 的实例,<br>然后再把实例放到缓存里。由前面的 Node.js 启动过程可以知道， <code>bootstrap_node.js</code> 中的 <code>startup()</code> 只会执行了一次，其中产生的 Module 对象在整个node进程调用链路中只会存在一个，进而 <code>Module._cache</code> 只有一个。</p>
<h3 id="Module-cache-和-require-cache-的关系"><a href="#Module-cache-和-require-cache-的关系" class="headerlink" title="Module._cache 和 require.cache 的关系"></a><code>Module._cache</code> 和 <code>require.cache</code> 的关系</h3><p>可以看下 <code>Module.prototype._compile</code> 这个方法，这里面会对大家写的 Node.js 文件进行一个包装，注入一些上下文，包括 <code>require</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">require</span> = internalModule.makeRequireFunction.call(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">var</span> args = [<span class="keyword">this</span>.exports, <span class="built_in">require</span>, <span class="keyword">this</span>, filename, dirname];</span><br><span class="line"><span class="keyword">var</span> depth = internalModule.requireDepth;</span><br><span class="line"><span class="keyword">var</span> result = compiledWrapper.apply(<span class="keyword">this</span>.exports, args);</span><br></pre></td></tr></table></figure>
<p>而在 <code>internalModule.makeRequireFunction</code> 中我们会发现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 makeRequireFunction 中</span></span><br><span class="line"><span class="built_in">require</span>.cache = Module._cache;</span><br></pre></td></tr></table></figure>
<p>所以，<code>Module._cache</code> 和 <code>require.cache</code> 是一样的，那么我们直接修改 <code>require.cache</code> 的缓存内容，在一个 Node.js 进程里都是有效的。</p>
<h3 id="require-不同场景的挂载"><a href="#require-不同场景的挂载" class="headerlink" title="require 不同场景的挂载"></a><code>require</code> 不同场景的挂载</h3><p>最开始我以为 require 是挂载在 global 上的，为了图省事，一般用 Node.js repl 来测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ node</span><br><span class="line">&gt; global.require</span><br><span class="line">&#123; [Function: require]</span><br><span class="line">  resolve: [Function: resolve],</span><br><span class="line">  main: undefined,</span><br><span class="line">  extensions: &#123; <span class="string">'.js'</span>: [Function], <span class="string">'.json'</span>: [Function], <span class="string">'.node'</span>: [Function] &#125;,</span><br><span class="line">  cache: &#123;&#125; &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，repl 下，global.require 是存在的，如果以为可以直接在 Node.js 文件中代理 <code>global.require</code> 那就踩坑了，因为如果在 Node.js 文件中使用会发现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(global.require);</span><br><span class="line"><span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>从上文可知，Node.js 文件中的 require 其实是来自于 <code>Module.prototype._compile</code> 中注入的 <code>Module.prototype.require</code>, 而最终的指向其实是 <code>Module._load</code>，并没有挂载到 module 上下文环境中的 global 对象上。</p>
<p>而 repl 中也是有 module 实例，于是我尝试在 repl 中打印：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ node</span><br><span class="line">&gt; global.require === module.require</span><br><span class="line">  <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>结果有点奇怪，于是我继续探究了下。在 <code>bootstrap_node.js</code> 中找到 repl 的调用文件 <code>repl.js</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">require</span> = internalModule.makeRequireFunction.call(<span class="built_in">module</span>);</span><br><span class="line">context.module = <span class="built_in">module</span>;</span><br><span class="line">context.require = <span class="built_in">require</span>;</span><br></pre></td></tr></table></figure>
<p>得到结论：在 repl 中，<code>module.require</code> 和 <code>global.require</code> 最终的调用方法是一样的，只是函数指向不同而已。</p>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><h3 id="path路径"><a href="#path路径" class="headerlink" title="path路径"></a>path路径</h3><p><code>require.cache</code> 是一个 key、value 的 map，key 看上去是模块所在的绝对路径，然而是不能用绝对路径直接去用的，需要 <code>require.resolve</code> 来解析路径，解析后才是 cache 中正确的 key 格式。</p>
<p>下面对比下区别：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模块的绝对路径</span></span><br><span class="line"><span class="regexp">/Users/</span>kino<span class="regexp">/.def/</span>def_modules<span class="regexp">/.builders/</span><span class="meta">@ali</span><span class="regexp">/builder-cake-kpm/</span>node_modules<span class="regexp">/@ali/</span>builder-cake-kpm<span class="regexp">/node_modules/</span><span class="meta">@ali</span><span class="regexp">/cake-webpack-config/</span>index.js</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 require.resolve 转义后的结果</span></span><br><span class="line"><span class="regexp">/Users/</span>kino<span class="regexp">/.def/</span>def_modules<span class="regexp">/.builders/</span><span class="meta">@ali</span><span class="regexp">/builder-cake-kpm/</span>node_modules<span class="regexp">/.0.16.23@@ali/</span>cake-webpack-config/index.js</span><br></pre></td></tr></table></figure>
<h3 id="多进程的情况"><a href="#多进程的情况" class="headerlink" title="多进程的情况"></a>多进程的情况</h3><p>模块间调用的链路比较长，有可能会新建子进程，需要考虑你项目中的入口文件和你需要代理的文件是否在一个进程中，简单的方法就是在入口文件和你需要代理的文件打印 pid：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(process.pid)</span><br></pre></td></tr></table></figure>
<p>如果一致，那么直接在入口调用前代理即可，否则情况会更复杂点，需要找到相应的进程调用处进行代理。</p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>DEF 是淘宝前端的集成开发环境，支持前端模块创建、构建打包、发布等一系列流程。 在以下案例中，主要 hack 的 Node.js 项目便是 DEF。</p>
<h3 id="篡改输入-prompt"><a href="#篡改输入-prompt" class="headerlink" title="篡改输入(prompt)"></a>篡改输入(prompt)</h3><p>场景：使用 DEF 创建模块 or 发布模块时</p>
<p>原因：想一键完成批量创建 or 批量发布，不想手动输入。</p>
<p>解决过程：以创建模块为例</p>
<ul>
<li><p>首先找到 DEF 的入口文件，即一个 bin 目录下的路径，可以通过这个入口文件不断追溯下去，发现创建模块的 generator 用的是 yeoman-generator 的方法。对 prompt 的方法进行代理，可以将该基础库提前 require，更改掉其 prompt 的方法即可。</p>
</li>
<li><p>附上示例代码（示例只篡改 <code>def add</code> 模块的创建类型，其他输入的篡改方法类似）：</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br><span class="line"><span class="meta"></span><br><span class="line">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'shelljs/global'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> HOME = process.env.HOME;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> yeomanRouter = <span class="built_in">require</span>(path.join(HOME, <span class="string">'.def/def_modules/.generators/@ali/generator-abs-router/node_modules/@ali/generator-abs-router/node_modules/yeoman-generator'</span>));</span><br><span class="line"></span><br><span class="line">yeomanRouter.generators.Base.prototype.prompt = <span class="function"><span class="keyword">function</span>(<span class="params">list, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> item = list[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">let</span> prop = &#123;&#125;;</span><br><span class="line">  prop[item.name] = <span class="string">'kissy-pc'</span>; <span class="comment">// 让模块类型输入自动为pc</span></span><br><span class="line">  callback(prop);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//require real def path</span></span><br><span class="line"><span class="keyword">const</span> defPath = which(<span class="string">'def'</span>).stdout;</span><br><span class="line"><span class="built_in">require</span>(defPath);</span><br></pre></td></tr></table></figure>
<h3 id="篡改构建流程（webpackconfig）"><a href="#篡改构建流程（webpackconfig）" class="headerlink" title="篡改构建流程（webpackconfig）"></a>篡改构建流程（webpackconfig）</h3><p>场景：一个淘宝的前端组件，需要在使用def本地调试时提前更改一个文件内容。（淘宝组件的构建会按照组件类型统一构建器，并不是每个组件单独去配置）</p>
<p>原因：一般来说，这种情况可以选择注释代码大法，本地调试时打开注释，发布前干掉。但这样造成代码很不美观，也容易引起误操作。不妨在本地调试的 reflect 过程中动态更换掉就好了。</p>
<p>解决过程：</p>
<ul>
<li><p>追溯 <code>def dev</code> 调用链路，找到最终reflect的文件, 在这个构建器 <code>@ali/builder-cake-kpm</code> 项目里。所使用的webpack的配置项在 <code>@ali/cake-webpack-config</code> 下。</p>
</li>
<li><p>现在就是往 webpack 配置项里动态注入一个 webpack loader 的过程了，我需要的 loader 是一个 preLoader，代码非常简单，我把它放在业务项目的文件里:</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">content</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> content.replace(<span class="string">'require\(\'\.\/plugin\'\)'</span>, <span class="string">"require('./localPlugin')"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>@ali/cake-webpack-config</code> 暴露的是个函数而非对象，所以必须从 require 下手了，最后附上案例的代理过程：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'shelljs/global'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> HOME = process.env.HOME;</span><br><span class="line"><span class="keyword">const</span> CWD = process.cwd();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cakeWcPath = path.join(HOME, <span class="string">'.def/def_modules/.builders/@ali/builder-cake-kpm/node_modules/@ali/builder-cake-kpm/node_modules/@ali/cake-webpack-config'</span>);</span><br><span class="line"><span class="keyword">const</span> preLoaderPath = path.join(CWD, <span class="string">'debug/plugin_compile.js'</span>); <span class="comment">// 注入的loader路径</span></span><br><span class="line"><span class="keyword">const</span> cakeWebpackConfig = <span class="built_in">require</span>(cakeWcPath);</span><br><span class="line"><span class="keyword">const</span> requireId = <span class="built_in">require</span>.resolve(cakeWcPath);</span><br><span class="line"><span class="built_in">require</span>.cache[requireId].exports = (options) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (options.callback) &#123;</span><br><span class="line">    <span class="keyword">let</span> oldCb = options.callback;</span><br><span class="line">    options.callback = <span class="function"><span class="keyword">function</span>(<span class="params">err, obj</span>) </span>&#123;</span><br><span class="line">      obj.module.preLoaders = [&#123;</span><br><span class="line">        <span class="string">'test'</span>: <span class="regexp">/index\.js$/</span>,</span><br><span class="line">        <span class="string">'loader'</span>: preLoaderPath</span><br><span class="line">      &#125;];</span><br><span class="line">      oldCb(err, obj);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cakeWebpackConfig(options);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//require real def path</span></span><br><span class="line"><span class="keyword">const</span> defPath = which(<span class="string">'def'</span>).stdout;</span><br><span class="line"><span class="built_in">require</span>(defPath);</span><br></pre></td></tr></table></figure>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>去 hack 一个 Node.js 模块，需要对该 Node.js 模块的调用链路有一定的了解，在很多情况下，不一定是最优的方法，但也不失为一种解决方案。有趣的是，Node.js 源码中其实有一行这样的注释：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hello, and welcome to hacking node.js!</span></span><br><span class="line"><span class="comment">// some descriptions</span></span><br></pre></td></tr></table></figure>
<p>So, just hacking for fun! </p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="//img.alicdn.com/tfs/TB1SJkrNVXXXXXsXVXXXXXXXXXX-900-500.jpg" alt="如何 hack Node.js 模块？"></p>
<h2 id="为何要去-hack？"><a href="#为何要去]]>
    </summary>
    
      <category term="hack" scheme="http://taobaofed.org/tags/hack/"/>
    
      <category term="Node.js" scheme="http://taobaofed.org/categories/Node-js/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[揭秘浏览器远程调试技术]]></title>
    <link href="http://taobaofed.org/blog/2016/10/19/chrome-remote-debugging-technics/"/>
    <id>http://taobaofed.org/blog/2016/10/19/chrome-remote-debugging-technics/</id>
    <published>2016-10-19T07:15:15.000Z</published>
    <updated>2016-12-21T02:40:37.000Z</updated>
    <content type="html"><![CDATA[<p><img src="https://img.alicdn.com/tfs/TB1MZ9aNVXXXXaQXFXXXXXXXXXX-900-500.jpg" alt="揭秘浏览器远程调试技术"></p>
<h2 id="调试技术的起源"><a href="#调试技术的起源" class="headerlink" title="调试技术的起源"></a>调试技术的起源</h2><p>1947 年 9 月 9 日，一名美国的科学家格蕾丝.霍普和她的同伴在对 Mark II 计算机进行研究的时候发现，一只飞蛾粘在一个继电器上，导致计算机无法正常工作，当他们把飞蛾移除之后，计算机又恢复了正常运转。于是他们将这只飞蛾贴在了他们当时记录的日志上，对这件事情进行了详细的记录，并在日志最后写了这样一句话：First actual case of bug being found。这是他们发现的第一个真正意义上的 bug，这也是人类计算机软件历史上，发现的第一个 bug，而他们找到飞蛾的方法和过程，就是 debugging 调试技术。</p>
<p><img src="https://img.alicdn.com/tps/TB1f_n8NpXXXXXBXpXXXXXXXXXX-740-583.jpg" alt="History of Debug"></p>
<p>从格蕾丝调试第一个 bug 到现在，69 年的时间里，在计算机领域，硬件、软件各种调试技术都在不断的发展和演进。那么对于日新月异的前端来说，调试技术也尤其显得重要。淘宝前端团队也正在使用一些创新的技术和手段来解决无线页面调试的问题。今天先跟大家分享下浏览器远程调试技术，本文将用 Chrome/Webview 来作为案例。</p>
<h2 id="调试原理"><a href="#调试原理" class="headerlink" title="调试原理"></a>调试原理</h2><h3 id="调试方式与权限管理"><a href="#调试方式与权限管理" class="headerlink" title="调试方式与权限管理"></a>调试方式与权限管理</h3><p><img src="https://img.alicdn.com/tps/TB1KA.XNpXXXXbFXFXXXXXXXXXX-1021-336.png" alt="-"></p>
<p>目前常规浏览器调试目标分为两种：Chrome PC 浏览器和 Chrome Mobile（Android 4.4 以后，Android WebView 其实就是 Chromium WebView）。</p>
<h4 id="Chrome-PC-浏览器"><a href="#Chrome-PC-浏览器" class="headerlink" title="Chrome PC 浏览器"></a>Chrome PC 浏览器</h4><p>对于调试 Chrome PC 浏览器，可能大家经常使用的是用鼠标右键或者快捷方式（mac:option + command + J），唤起 Chrome 的控制台，来对当前页面进行调试。其实还有另外一种方法，就是使用一个 Chrome 浏览器调试另一个 Chrome 浏览器。Chrome 启动的时候，默认是关闭了调试端口的，如果要对一个目标 Chrome PC 浏览器进行调试，那么启动的时候，可以通过传递参数来开启 Chrome 的调试开关：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># for mac</span></span><br><span class="line">sudo /Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome --remote-debugging-port=9222</span><br></pre></td></tr></table></figure>
<h4 id="Chrome-Android-浏览器"><a href="#Chrome-Android-浏览器" class="headerlink" title="Chrome Android 浏览器"></a>Chrome Android 浏览器</h4><p>对于调试 Android 上的 Chrome 或者 WebView 需要连接 USB 线。打开调试端口的方法如下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb forward tcp:9222 localabstract:chrome_devtools_remote</span><br></pre></td></tr></table></figure></p>
<p>跟 Chrome PC 浏览器不同的是，对于 Chrome Android 浏览器，由于数据传输是通过 USB 线而不是 WIFI，实际上 Chrome Android 创建的一个 chrome_devtools_remote 这个 path 的 domain socket。所以，上面一条命令则是通过 Android 的 adb 将 PC 的端口 9222 通过 USB 线与 chrome_devtools_remote 这个 domain socket 建立了一个端口映射。</p>
<h4 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h4><p>Google 为了限制调试端口的接入范围，对于 Chrome PC 浏览器，调试端口只接受来自 <code>127.0.0.1</code> 或者 <code>localhost</code> 的数据请求，所以，你无法通过你的本地机器 IP 来调试 Chrome。对于 Android Chrome/WebView，调试端口只接受来自于 <code>shell</code> 这个用户数据请求，也就是说只能通过 USB 进行调试，而不能通过 WIFI。</p>
<h3 id="开始调试"><a href="#开始调试" class="headerlink" title="开始调试"></a>开始调试</h3><p>通过以上的调试方式的接入以及调试端口的打开，这个时候在浏览器中输入：<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span><span class="comment">//127.0.0.1:9222/json</span></span><br></pre></td></tr></table></figure></p>
<p>将会看到类似下面的内容：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"description"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"devtoolsFrontendUrl"</span>: <span class="string">"/devtools/inspector.html?ws=127.0.0.1:9222/devtools/page/ebdace60-d482-4340-b622-a6198e7aad6e"</span>,</span><br><span class="line">    <span class="attr">"id"</span>: <span class="string">"ebdace60-d482-4340-b622-a6198e7aad6e"</span>,</span><br><span class="line">    <span class="attr">"title"</span>: <span class="string">"揭秘浏览器远程调试技术.mdown—/Users/harlen/Documents"</span>,</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"page"</span>,</span><br><span class="line">    <span class="attr">"url"</span>: <span class="string">"http://127.0.0.1:51004/view/61"</span>,</span><br><span class="line">    <span class="attr">"webSocketDebuggerUrl"</span>: <span class="string">"ws://127.0.0.1:9222/devtools/page/ebdace60-d482-4340-b622-a6198e7aad6e"</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>其中，最重要的 2 个参数分别是 id 和 webSocketDebuggerUrl。Chrome 会为每个页面分配一个唯一的 id，作为该页面的唯一标识符。几乎对目标浏览器的所有操作都是需要带上这个 id。</p>
<p>Chrome 提供了以下这些 http 接口控制目标浏览器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取当前所有可调式页面信息</span></span><br><span class="line">http://127.0.0.1:9222/json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取调试目标 WebView/blink 的版本号</span></span><br><span class="line">http://127.0.0.1:9222/json/version</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建新的 tab，并加载 url</span></span><br><span class="line">http://127.0.0.1:9222/json/new?url</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭 id 对应的 tab</span></span><br><span class="line">http://127.0.0.1:9222/json/close/id</span><br></pre></td></tr></table></figure></p>
<p>webSocketDebuggerUrl 则在调试该页面需要用到的一个 WebSocket 连接。chrome 的 devtool 的所有调试功能，都是基于 <a href="https://chromedevtools.github.io/debugger-protocol-viewer/1-1/Debugger/" target="_blank" rel="external">Remote Debugging Protocol</a> 使用 WebSocket 来进行数据传输的。那么这个 WebSocket，就是上面我们从 <code>http://127.0.0.1:9222/json</code> 获取的 <code>webSocketDebuggerUrl</code>，每一个页面都有自己不同的 <code>webSocketDebuggerUrl</code>。这个 <code>webSocketDebuggerUrl</code>是通过 url 的 query 参数传递给 chrome devtool 的。</p>
<p>chrome 的 devtool 可以从 Chrome 浏览器中进行提取 devtool 源码或者从 blink 源码中获取。在部署好自己的 chrome devtool 代码之后，下面既可以开始对 Chrome 进行调试, 浏览器输入一下内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://path_to_your_devtool/devtool.html?ws=127.0.0.1:9222/devtools/page/ebdace60<span class="_">-d</span>482-4340-b622<span class="_">-a</span>6198e7aad6e</span><br></pre></td></tr></table></figure></p>
<p>其中 ws 这个参数的值就是上面出现的 webSocketDebuggerUrl。Chrome 的 devtool 会使用这个 url 创建 WebSocket 对该页面进行调试。</p>
<h3 id="如何实现-JavaScript-调试"><a href="#如何实现-JavaScript-调试" class="headerlink" title="如何实现 JavaScript 调试"></a>如何实现 JavaScript 调试</h3><p>在进入 Chrome 的 devtool 之后，我们可以调出控制台，来查看 devtool 的 WebSocket 数据。这个里面有很多数据，我这里只讲跟 JavaScript 调试相关的。<br><img src="https://img.alicdn.com/tps/TB1.H3kNpXXXXalXVXXXXXXXXXX-740-191.png" alt="-"></p>
<p>图中，对于 JavaScript 调试，有一条非常重要的消息，我蓝色选中的那条消息：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"id"</span>:<span class="number">6</span>,<span class="attr">"method"</span>:<span class="string">"Debugger.enable"</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后选中要调试的 JavaScript 文件，然后设置一个断点，我们再来看看 WebSocket 消息：<br><img src="https://img.alicdn.com/tps/TB1h2UANpXXXXaYXpXXXXXXXXXX-912-214.png" alt="-"></p>
<p>devtool 像目标 Chrome 发送了 2 条消息<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"id"</span>: <span class="number">23</span>,</span><br><span class="line">  <span class="attr">"method"</span>: <span class="string">"Debugger.getScriptSource"</span>,</span><br><span class="line">  <span class="attr">"params"</span>: &#123;</span><br><span class="line">    <span class="attr">"scriptId"</span>: <span class="string">"103"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"id"</span>: <span class="number">24</span>,</span><br><span class="line">  <span class="attr">"method"</span>: <span class="string">"Debugger.setBreakpointByUrl"</span>,</span><br><span class="line">  <span class="attr">"params"</span>: &#123;</span><br><span class="line">    <span class="attr">"lineNumber"</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">"url"</span>: <span class="string">"https://g.alicdn.com/alilog/wlog/0.2.10/??aplus_wap.js,spm_wap.js,spmact_wap.js"</span>,</span><br><span class="line">    <span class="attr">"columnNumber"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"condition"</span>: <span class="string">""</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么收到这几条消息之后，V8 做了些什么呢？<br>我们先来简单的看下 V8 里面的一小段源码片段：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// V8 Debugger.cpp</span></span><br><span class="line">DispatcherImpl(FrontendChannel* frontendChannel, Backend* backend) : DispatcherBase(frontendChannel), m_backend(backend) &#123;</span><br><span class="line">    m_dispatchMap[<span class="string">"Debugger.enable"</span>] = &amp;DispatcherImpl::enable;</span><br><span class="line">    m_dispatchMap[<span class="string">"Debugger.disable"</span>] = &amp;DispatcherImpl::disable;</span><br><span class="line">    m_dispatchMap[<span class="string">"Debugger.setBreakpointsActive"</span>] = &amp;DispatcherImpl::setBreakpointsActive;</span><br><span class="line">    m_dispatchMap[<span class="string">"Debugger.setSkipAllPauses"</span>] = &amp;DispatcherImpl::setSkipAllPauses;</span><br><span class="line">    m_dispatchMap[<span class="string">"Debugger.setBreakpointByUrl"</span>] = &amp;DispatcherImpl::setBreakpointByUrl;</span><br><span class="line">    m_dispatchMap[<span class="string">"Debugger.setBreakpoint"</span>] = &amp;DispatcherImpl::setBreakpoint;</span><br><span class="line">    m_dispatchMap[<span class="string">"Debugger.removeBreakpoint"</span>] = &amp;DispatcherImpl::removeBreakpoint;</span><br><span class="line">    m_dispatchMap[<span class="string">"Debugger.continueToLocation"</span>] = &amp;DispatcherImpl::continueToLocation;</span><br><span class="line">    m_dispatchMap[<span class="string">"Debugger.stepOver"</span>] = &amp;DispatcherImpl::stepOver;</span><br><span class="line">    m_dispatchMap[<span class="string">"Debugger.stepInto"</span>] = &amp;DispatcherImpl::stepInto;</span><br><span class="line">    m_dispatchMap[<span class="string">"Debugger.stepOut"</span>] = &amp;DispatcherImpl::stepOut;</span><br><span class="line">    m_dispatchMap[<span class="string">"Debugger.pause"</span>] = &amp;DispatcherImpl::pause;</span><br><span class="line">    m_dispatchMap[<span class="string">"Debugger.resume"</span>] = &amp;DispatcherImpl::resume;</span><br><span class="line">    m_dispatchMap[<span class="string">"Debugger.searchInContent"</span>] = &amp;DispatcherImpl::searchInContent;</span><br><span class="line">    m_dispatchMap[<span class="string">"Debugger.setScriptSource"</span>] = &amp;DispatcherImpl::setScriptSource;</span><br><span class="line">    m_dispatchMap[<span class="string">"Debugger.restartFrame"</span>] = &amp;DispatcherImpl::restartFrame;</span><br><span class="line">    m_dispatchMap[<span class="string">"Debugger.getScriptSource"</span>] = &amp;DispatcherImpl::getScriptSource;</span><br><span class="line">    m_dispatchMap[<span class="string">"Debugger.setPauseOnExceptions"</span>] = &amp;DispatcherImpl::setPauseOnExceptions;</span><br><span class="line">    m_dispatchMap[<span class="string">"Debugger.evaluateOnCallFrame"</span>] = &amp;DispatcherImpl::evaluateOnCallFrame;</span><br><span class="line">    m_dispatchMap[<span class="string">"Debugger.setVariableValue"</span>] = &amp;DispatcherImpl::setVariableValue;</span><br><span class="line">    m_dispatchMap[<span class="string">"Debugger.setAsyncCallStackDepth"</span>] = &amp;DispatcherImpl::setAsyncCallStackDepth;</span><br><span class="line">    m_dispatchMap[<span class="string">"Debugger.setBlackboxPatterns"</span>] = &amp;DispatcherImpl::setBlackboxPatterns;</span><br><span class="line">    m_dispatchMap[<span class="string">"Debugger.setBlackboxedRanges"</span>] = &amp;DispatcherImpl::setBlackboxedRanges;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你会发现，V8 有 <code>m_dispatchMap</code> 这样一个 Map。专门用来处理所有 JavaScript 调试相关的处理。<br>其中就有本文即将重点讲述的:</p>
<ul>
<li>Debuggger.enable</li>
<li>Debugger.getScriptSource</li>
<li>setBreakpointByUrl</li>
</ul>
<p>这些都需要在 V8 的源码中找到答案。顺便给大家推荐一个查看 Chromium/V8 最正确的方式是使用 <a href="https://cs.chromium.org/" target="_blank" rel="external">https://cs.chromium.org</a>，比 SourceInsight 还要方便。</p>
<h4 id="Debugger-enable"><a href="#Debugger-enable" class="headerlink" title="Debugger.enable"></a>Debugger.enable</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> V8Debugger::enable() &#123;</span><br><span class="line">    <span class="keyword">if</span> (m_enableCount++) <span class="keyword">return</span>;</span><br><span class="line">    DCHECK(!enabled());</span><br><span class="line">    v8::<span class="function">HandleScope <span class="title">scope</span><span class="params">(m_isolate)</span></span>;</span><br><span class="line">    v8::Debug::SetDebugEventListener(m_isolate, &amp;V8Debugger::v8DebugEventCallback,</span><br><span class="line">    v8::External::New(m_isolate, <span class="keyword">this</span>));</span><br><span class="line">    m_debuggerContext.Reset(m_isolate, v8::Debug::GetDebugContext(m_isolate));</span><br><span class="line">    compileDebuggerScript();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个接口的名称叫 <code>Debugger.enable</code>，但是收到这条消息，V8 其实就干了两件事情事情：</p>
<ul>
<li><p>SetDebugEventListener：<br>给 JavaScript 调试安装监听器，并设置 <code>v8DebugEventCallback</code> 这个回调函数。JavaScript 所有的调试事件，都会被这个监听器捕获，包括：JavaScript 异常停止，断点停止，单步调试等等。</p>
</li>
<li><p>compileDebuggerScript:<br>编译 V8 内置的 JavaScript 文件 <a href="https://cs.chromium.org/chromium/src/v8/src/inspector/debugger-script.js?q=debugger-script.js&amp;sq=package:chromium&amp;dr" target="_blank" rel="external">debugger-script.js</a>。由于这文件比较长，我这里就不贴出来了，感兴趣的同学点击这个链接进行查看源码。<code>debugger-script.js</code> 主要是定义了一些针对 JavaScript 断点进行操作的函数，例如设置断点、查找断点以及单步调试相关的函数。那么这个 <code>debugger-script.js</code> 文件，被 V8 进行编译之后，保存在 global 对象上，等待对 JavaScript 进行调试的时候，被调用。</p>
<h4 id="Debugger-getScriptSource"><a href="#Debugger-getScriptSource" class="headerlink" title="Debugger.getScriptSource"></a>Debugger.getScriptSource</h4><p>在 Chrome 解析引擎解析到 <code>&lt;script&gt;</code> 标签之后，Chrome 将会把 script 标签对应的 JavaScript 源码扔给 V8 编译执行。同时，V8 将会对所有的 JavaScript 源码片段进行编号并保存。所以，当 chrome devtool 需要获取要调试的 JavaScript 文件的时候，只需要通过 <code>Debugger.getScriptSource</code>，给 V8 传递一个 scriptId，V8 将会把 JavaScript 源码返回。我们再回头看看这个图中的消息：<br><img src="https://img.alicdn.com/tps/TB1h2UANpXXXXaYXpXXXXXXXXXX-912-214.png" alt="-"><br>上面 id 为 23 的 <code>scriptSource</code> 就是 V8 返回的 JavaScript 源码，如此以来，我们就可以在 devtool 中看到我们要调试的 JavaScript 源码了。</p>
</li>
</ul>
<h4 id="Debugger-setBreakpointByUrl"><a href="#Debugger-setBreakpointByUrl" class="headerlink" title="Debugger.setBreakpointByUrl"></a>Debugger.setBreakpointByUrl</h4><p>所有准备工作都做好了，现在就可以开始设置断点了。从上面的几个图中，已经可以很清楚的看到，<code>Debugger.setBreakpointByUrl</code> 给目标 Chrome 传递了一个 JavaScript 的 url 和断点的行号。</p>
<p>首先，V8 会去找，是否已经存在了该 URL 对应的 JavaScript 源码了：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; script : m_scripts) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!matches(m_inspector, script.second-&gt;sourceURL(), url, isRegex))</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;protocol::Debugger::Location&gt; location = resolveBreakpoint(</span><br><span class="line">    breakpointId, script.first, breakpoint, UserBreakpointSource);</span><br><span class="line">  <span class="keyword">if</span> (location) (*locations)-&gt;addItem(<span class="built_in">std</span>::move(location));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*outBreakpointId = breakpointId;</span><br></pre></td></tr></table></figure></p>
<p>V8 给所有的断点，创建一个 breakpointObject。并将这些 braekpointObject 以 <key, value=""> 的形式存放在一个 Map 里面，而这个 Key，就是这个 JavaScript 文件的 URL。看到这里，已经可以解释很多同学在调试 JavaScript 遇到的一个问题：</key,></p>
<blockquote>
<p>有些同学为了防止页面的 JavaScript 文件不更新，对于一些重要的 JavaScript 文件的 URL 添加访问时间戳，对于这些添加了访问时间戳的 JavaScript 文件进行设置断点然后刷新调试的时候，Chrome 会打印一个 warnning，告诉你断点丢失。</p>
</blockquote>
<p>原因很简单，在调试的时候，V8 发现这个 breakpointMap 里面找不到对应的 breakpointObject，因为 URL 发生了变化，这个 brakpointObject 就丢失了，所以 V8 就找不到了，无法进行断点调试。</p>
<p>根据我们的正常思维，你可能会认为 V8 会将断点设置在 C++ 中，其实一开始我也是这么认为。随着对 V8 的探索，让我看到了我时曾相识的一些函数名：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">v8::Local&lt;v8::Function&gt; setBreakpointFunction = v8::Local&lt;v8::Function&gt;::Cast(</span><br><span class="line">    m_debuggerScript.Get(m_isolate)</span><br><span class="line">    -&gt;Get(context, toV8StringInternalized(m_isolate, <span class="string">"setBreakpoint"</span>))</span><br><span class="line">      .ToLocalChecked());</span><br><span class="line">v8::Local&lt;v8::Value&gt; breakpointId =</span><br><span class="line">  v8::Debug::Call(debuggerContext(), setBreakpointFunction, info)</span><br><span class="line">    .ToLocalChecked();</span><br></pre></td></tr></table></figure></p>
<p>其中，<code>m_debuggerScript</code>，就是我前面提到的 <code>debugger-script.js</code>。随着对 V8 Debugger 的进一步探索，我发现，V8 实际上对这个对这个 breakpointObject 设置了 2 次。一次是通过在 C++ 中调用 m_debuggerScript 的 setBreakpoint 设置到 JavaScript 的 context 里面，也就是上面这段 C++ 逻辑做的事情。另一次是，<code>m_debuggerScript</code> 反过来将断点信息设置到了 V8 的 C++ Runtime 中，为要调试的 JavaScript 的某一行设置一个 JavaScript 的回调函数。</p>
<h4 id="断点命中"><a href="#断点命中" class="headerlink" title="断点命中"></a>断点命中</h4><p>由于 V8 对 JavaScript 是及时编译执行的，没有生成 bytecode，而是直接生成的 machine code 执行的，所以这个断点回调函数也会被设置到这个 machine code 里面。</p>
<p>最终触发断点事件，也是 V8 的 C++ Runtime。当用户刷新或者直接执行 JavaScript 的逻辑的时候，实际上是 V8 C++ Runtime 在运行 JavaScript 片段产生的 machine code，这个 machine code 已经包含了断点回调函数了。一旦这个 machine code 里面的回调函数被触发，接着就会触发之前 Debugger.enable 设置的调试事件监听器 DebugEventListener 的回调函数。并返回一条消息给 Chrome 的 devtool，告诉 Chrome devtool，当前 JavaScript 被 pause 的行号。到此为止，一个断点就被命中了。</p>
<p>关于 JavaScript 断点命中，其实是一个很复杂的过程。后面有时间的话，会专门讲讲 JavaScript 断点命中的详细逻辑。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>浏览器的调试，最终都落脚到引擎：渲染引擎和 JavaScipt 引擎。那么对于 JavaScript 调试来说，难点就在于 V8 如何给 JavaScript 某一行进行标记然后进行断点，这需要有一点 V8 的知识。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="https://img.alicdn.com/tfs/TB1MZ9aNVXXXXaQXFXXXXXXXXXX-900-500.jpg" alt="揭秘浏览器远程调试技术"></p>
<h2 id="调试技术的起源"><a href="#调试技术的起源" ]]>
    </summary>
    
      <category term="远程调试" scheme="http://taobaofed.org/tags/%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Velocity NYC 2016 参会总结]]></title>
    <link href="http://taobaofed.org/blog/2016/10/11/thinking-in-velocity-nyc-2016/"/>
    <id>http://taobaofed.org/blog/2016/10/11/thinking-in-velocity-nyc-2016/</id>
    <published>2016-10-11T10:38:34.000Z</published>
    <updated>2016-12-21T02:40:37.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img.alicdn.com/tfs/TB1H9LFNFXXXXb_aXXXXXXXXXXX-900-500.jpg" alt="Velocity NYC 2016 参会总结"></p>
<p>就在刚刚过去的九月，作为 FED 团队的代表有幸参加了美国纽约的 Velocity Web 性能和敏捷运维大会。在大约一周的行程中，会议团队组织了十分丰富的行程，会议团队也在内部对于 Velocity 的演讲内容做了多次讨论。整个行程在我看来是十分圆满的。</p>
<h1 id="Velocity-NYC"><a href="#Velocity-NYC" class="headerlink" title="Velocity @ NYC"></a>Velocity @ NYC</h1><p>Velocity 作为 <a href="http://www.oreilly.com/conferences/" target="_blank" rel="external">O’Reilly</a> 旗下的老牌会议品牌，从 2008 年开始专著 Web 性能、DevOps（运维或开发自运维）等领域。在会议组织、开发者关系和商业运作等方面都十分老道。国内的开发者社区方兴未艾，也有诸如 SegmentFault D-Day、JSConf、D2 等类似定位的会议，但从各方面来讲都与 Velocity 有云泥之别。这也是为何在汇报中把会议组织本身感想放在了最前面。</p>
<p>会议组织方固定在圣克拉拉（美国加州）、纽约（美国纽约州）、阿姆斯特丹（荷兰）、北京（中国）四个城市巡回举办，可见其国际化程度之高。正是如此的多元化的组织形式，不仅吸引了全球不同国家的参会者，对于赞助商和讲师来说，也让自己的思想和意志传播到得更广。另一方面，由于有固定的巡回议程，举办方在现场把控上容易积累更多的经验。这是体现在各种细节上的，例如：</p>
<ul>
<li>会场位于纽约中央公园旁边，对于第一次来纽约的人来说，太好找了；另外由于地处曼哈顿中心，即使当日会议日程安排的很晚，也不用担心治安问题；</li>
<li>会议前夕，收到邮件告知参会信息以及领取胸牌的操作指南，并且提供了一个会议伴侣 App，方便当天查询会日日程；</li>
<li>茶歇区即赞助商展位，互利互惠；作为参会者，还是很有激情一边吃吃喝喝一边参观摊位的；</li>
<li>赞助商的展位都有非常专业的一对一讲解、游戏、抽奖等各类活动；</li>
<li>赞助商参与的演讲均有明显标示，参会者可以自行选择；</li>
<li>…</li>
</ul>
<p>当然，国内的技术会议也办的的越来越好了。</p>
<p>补充下没有论据的一家之言：健康良好的开发者社区不应该只是默默的搞开源项目，而是应该包括线上和线下；如今开发者 BBS、博客、微博大V、公众号等富媒体已经产生了大量的技术内容，但是还以搬运国外原创内容和互相捧臭脚为主；而线下的会议和其他形式活动（编程马拉松、培训等）缺乏成熟稳健的商业模式，导致要么昙花一现，要么沦为大厂的宣传和招聘工具。</p>
<p>根据 <a href="https://www.infoq.com/news/2014/01/IDC-software-developers" target="_blank" rel="external">IDC 数据</a>，国内 2014 年开发者人群约有 185 万，相信随着互联网的火爆发展，近几年这个数据只会增长的更快。阿里作为国内首屈一指的互联网综合体，拥有丰富的开发者资源、良好品牌效应，理应在这个领域发出更大的声音。</p>
<h1 id="Keynote-心得：意料之外，情理之中"><a href="#Keynote-心得：意料之外，情理之中" class="headerlink" title="Keynote 心得：意料之外，情理之中"></a>Keynote 心得：意料之外，情理之中</h1><p>Velocity 的主题限定了 Web 性能和 DevOps 两个领域，但实际上这两个领域又都非常宽泛，所以导致一次会议中演讲的具体内容并没有非常清晰的关联关系。本次的会议有一个宴会厅和五个会议室，每个会议室至多一天分为五场演讲顺序进行。作为参与者，是不可能全部全部听完的。但整体上还是有有不少热门主题被多次提到，所以后文还是以这些较为聚焦的话题进行归纳总结。</p>
<h2 id="微服务趋于理性"><a href="#微服务趋于理性" class="headerlink" title="微服务趋于理性"></a>微服务趋于理性</h2><p>微服务架构至少被个大厂商（Google、Facebook、Twitter、Netflix）布道有两年有余，那些能够接受的公司早已改造完毕。如今甜蜜期已过，新架构带来的各种问题也接踵而来。</p>
<p>这次直接和微服务有关的演讲有：</p>
<ul>
<li><a href="http://conferences.oreilly.com/velocity/devops-web-performance-ny/public/schedule/detail/51097" target="_blank" rel="external">Mitigating sprawl with microservices and containerization</a></li>
<li><a href="http://conferences.oreilly.com/velocity/devops-web-performance-ny/public/schedule/detail/51220" target="_blank" rel="external">Running Consul at scale: Service discovery in the cloud</a></li>
<li><a href="http://conferences.oreilly.com/velocity/devops-web-performance-ny/public/schedule/detail/51313" target="_blank" rel="external">Distributed tracing: How to do latency analysis for microservices-based applications</a></li>
<li><a href="http://conferences.oreilly.com/velocity/devops-web-performance-ny/public/schedule/detail/51230" target="_blank" rel="external">The once and future layer 5: Resilient, Twitter-style microservices</a></li>
</ul>
<p>这些话题（包括其他的话题）大多有一个特征——它们聚焦一个问题，给出一个思路，结合一个解决方案，最后给出实践成果。被各位演讲者提到的问题：</p>
<ol>
<li>编码成本提高：代码越来越复杂，一个是在代码行数上，另外就是服务组件越来越多</li>
<li>人员成本提高：团队越来越复杂，细化后的组件总会依赖至少一个团队去负责维护</li>
<li>调试成本提高：新架构下的会话跟踪、重放、日志以及自动测试等中间件都要改造以及积累经验</li>
<li>稳定性成本提高：监控、容灾和资源调度也都出现了新的问题</li>
</ol>
<p><img src="https://img.alicdn.com/tps/TB17.vVNFXXXXcVXFXXXXXXXXXX-668-384.png" alt="2"></p>
<p>社区里针对这些问题给了不少开源方案，例如 <a href="https://www.consul.io/" target="_blank" rel="external">Consul</a>、<a href="https://twitter.github.io/finagle/" target="_blank" rel="external">Finage</a>、<a href="https://github.com/openzipkin/zipkin" target="_blank" rel="external">Zipkin</a>。</p>
<p>阿里内部由于有一个强大的中间件团队，所以这些基础设施均为自建。虽然实现不一样，其实大家的理论都基本类似。集团的 HSF 服务出现的很早，如今也是 PandoraBoot 的实现基础；EagleEye 也是老牌的 Tracer，基本能适配到任何应用场景了。</p>
<p>除了在部分细节不如开源方案来得好。例如，HSF 对超时处理、分布式事物等处理欠缺、容灾方案常常只有机房热冷备诸如此类的问题。但阿里的中间件实际表现是十分出色的，并且经过了时间的考验。</p>
<p>反过来想也有些后怕，在中小型企业对极为积极的采纳这些开源方案并玩的正欢的时候，集团的技术人员由于没有实际的应用场景，其实并不是很热衷于去了解这些东西，是否会和外界社区脱节呢？当然大厂留着各种私货是很正常的事情（包括 Google、Facebook）。</p>
<h2 id="DevOps-全家桶越来越大：Serverless、CloudNative、Infrastructure-as-Code…"><a href="#DevOps-全家桶越来越大：Serverless、CloudNative、Infrastructure-as-Code…" class="headerlink" title="DevOps 全家桶越来越大：Serverless、CloudNative、Infrastructure as Code…"></a>DevOps 全家桶越来越大：Serverless、CloudNative、Infrastructure as Code…</h2><p>今年围绕 DevOps 的新名词 Serverless、CloudNative、Infrastructure as Code 等新名词如数出现在了演讲的标题中。</p>
<p>对技术人员来讲，是大家开始从吹捧 DevOps 概念，到了各种实践和解决方案，然后并进入下一轮概念炒作的过程了（注意此处炒作并不是贬义）。</p>
<p>Serverless 是一种和微服务有关的开发和部署形式（即 DevOps 的一种实践方案）。Serverless 的模式下，开发者不再关注计算资源（集群、服务器等）、不再关心虚拟化（VM、Docker 等）、不再关心进程模型（进程启动、停止、重启等），只需利用各种云计算资源（对象存储、消息服务、离线任务等）提供实现业务逻辑的函数或方法。Amazon 的 AWS 最近提供的一种新的服务类型 <a href="https://aws.amazon.com/cn/documentation/lambda/" target="_blank" rel="external">Lambda</a> 所掀起的新一轮浪潮，预计其他云服务厂商会迅速跟进。这种模式也非常适合在集团内部推广，为业务开发减负，同时提高整体资源利用率。当然，目前 AWS 推的还是动态语言的服务类型，诸如 Node.js、Python，预计 Scala 也快了，也许这也是让多语言在业务层面得到支持的一个好机会。</p>
<p>Serverless 的主题演讲有：</p>
<ul>
<li><a href="http://conferences.oreilly.com/velocity/devops-web-performance-ny/public/schedule/detail/51002" target="_blank" rel="external">Managing serverless: Ops for NoOps</a></li>
<li><a href="http://conferences.oreilly.com/velocity/devops-web-performance-ny/public/schedule/detail/53601" target="_blank" rel="external">Ops in the time of serverless containerized webscale</a></li>
</ul>
<p>由于时间关系我只去了第二个，但比较失望的是一个多人对话形式的访谈，并没有什么逻辑可言。多为介绍自己公司的在 Docker、Serverless（沾了点边）方面的实践。透过第一个演讲的 Keynote 可以判断内容还是有很高价值的，讲的是第一轮 Serverless 实践中遇到的各种问题，主要集中在监控方法、编程模式、安全模型的变化，并且讽刺的是其内容透出的担忧标示 Serverless 并不能让开发者完全不关心服务器。</p>
<p><a href="http://conferences.oreilly.com/velocity/devops-web-performance-ny/public/schedule/detail/51192" target="_blank" rel="external">Implementing infrastructure as code</a> 是一个布道性质的演讲，从零开始介绍了其概念、组成部分（以及顺便推销了自己的书）。</p>
<p>Infrastructure as Code 也不是什么全新的概念，是指利用软件工程的工具和方法来管理基础设施的一种思路。近几年 Docker 火的的一塌糊涂，其一大特性就是所有资源都可以通过 API 操控，这也是 Infrastructure as Code 在实践上成为可能的一大支柱。在此之上的 <a href="http://kubernetes.io/" target="_blank" rel="external">kubernetes</a> 等开源项目又在集群纬度提供了可编程的编排能力。这样开发者是能够面向集群编程管理的，这才是真正意义上的 DevOps。题外话，这里也期望明年的 Docker 改造中起码能把 DockerCompose 的能力开放出来。</p>
<p><img src="https://img.alicdn.com/tps/TB1tGweNFXXXXa7XXXXXXXXXXXX-1017-576.png" alt="4.png"></p>
<p>最后，CloudNative 是一套包括 CD（持续交付）、Microservice（微服务）、DevOps、容器思想的集合，所以这次会议的演讲中不会直接将其作为主题，但都命中 CloudNative 这个关键字。再说几个厂商的名字 Pivotal、Cloud Foundry，都是这些概念的布道者，也是此次 Velocity 会议的演讲者和赞助商。</p>
<h2 id="Web-相关"><a href="#Web-相关" class="headerlink" title="Web 相关"></a>Web 相关</h2><h3 id="MobileWeb-性能优化和趋势"><a href="#MobileWeb-性能优化和趋势" class="headerlink" title="MobileWeb 性能优化和趋势"></a>MobileWeb 性能优化和趋势</h3><p>这次来自 Google 的两场演讲分别介绍了 PWA、AMP</p>
<ul>
<li><a href="http://conferences.oreilly.com/velocity/devops-web-performance-ny/public/schedule/detail/50799" target="_blank" rel="external">The future of the mobile Web</a></li>
<li><a href="http://conferences.oreilly.com/velocity/devops-web-performance-ny/public/schedule/detail/50798" target="_blank" rel="external">The Accelerated Mobile Pages (AMP) Project: What lies ahead?</a></li>
</ul>
<p>总的来讲，Google 作为 Chrome、ChormeOS、V8、Blink 等 Web 技术产品的维护者，自然对 MobileWeb 的前景相当看好，因此每年都会推出一些新的技术来增强 Web 平台的能力。AMP推广的时间很长了，其本质是一套前端优化的最佳实践。PWA 是今年的新技术，也为未来的 MobileWeb 注入了新的活力，但基于 H5 的 MobileWeb 的颓势是不会改变的。</p>
<p>此次也有演讲对 Web 和 App 重新做了对比和思考：<a href="http://conferences.oreilly.com/velocity/devops-web-performance-ny/public/schedule/detail/54229" target="_blank" rel="external"> Web versus apps revisited</a>。里面的数据是血淋淋的，只有 13% 的用户时间花在 MobileWeb 上。</p>
<p>个人观点是，虽然以 HTML5 页面再也不可能成为入口或主要产品，但在碎片场景下是有巨大发挥空间的。例如微信公众号、微信微应用等场景，均是以 HTML5 技术为基础的。</p>
<p>当然 Web 和 App 的竞争还在继续，<a href="https://developer.android.com/topic/instant-apps/index.html" target="_blank" rel="external">Android Instant Apps</a> 这样的技术出现意味着原声应用正在挑战 Web 应用的易传播性这样的优势。而 ReactNative 这样的技术，则在结合 Web 技术和 App 技术来挑战传统 App 的开发成本问题。</p>
<p>阿里旗下产品都有自己的航母应用，所以更多考虑的在闭环生态下增强用户体验的技术改进，Weex、ZCache 这类技术从实际效果来讲远超 Google 给的任何方案，但是 Google 的这些方案是通用方案，我们的是限于 App 内的方案。</p>
<h3 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h3><p>正如上文指出的，大多数演讲都是围绕某个开源项目或自家公司产品进行的，很少有讲解基础技术或原理的。由于时间排期，我听到的数量有限的演讲中，只有 <a href="http://conferences.oreilly.com/velocity/devops-web-performance-ny/public/schedule/detail/51303" target="_blank" rel="external">HTTP/2: What no one is telling you</a> 是讲解 HTTP2 原理和应用的。碍于 40 分钟的时长限制，演讲者也大多在讲时间过程中遇到的问题和一些关键数据。</p>
<p>目前来看 HTTP2 最大的问题就是它并没有想象中的那么好。头压缩、socket 复用等技术在效果上并没有各大浏览器厂商优化了多年的 HTTP1.1 效果好，反而在弱网环境下，简单粗暴占用多连接的 HTTP1.1 效果更好。</p>
<p>HTTP2 在草案期间就广受开发者追捧，可如今标准确定，却罕见实质改变。也许 HTTP2 会让 HTTP 技术在一些 RPC 场景中会有明显优势，但在传统页面浏览方面，并不会得到非常迅速的应用。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Velocity 的会议总的来说，在演讲内容上是中规中矩的，毕竟也不是专门的学术会议或事领域论坛。但正是成熟稳定的运作，让厂商和开发者有持续的交流机会。DevOps 相关话题依然热门，微服务和容器必然成为互联网公司的必备武器。新技术在国内都是慢热的，但最终结果会保持和社区同步，可预见集团在未来也会在这些领域有所沉淀和输出。</p>
<p><img src="https://img.alicdn.com/tps/TB1jK3cNFXXXXbZXXXXXXXXXXXX-800-600.jpg" alt="5.png"></p>
<p>多元化的社会和多元化的会议组成，让我们对于此次美国之行十分充实。行程的最后我们短暂的参观了谷歌位于纽约的分公司。几位华人研发的同事接待了我们，听了他们讲的经历和工作，也感受到在多元化冲击下对于企业和员工的种种机遇是巨大的。也很是期待，阿里集团能拓展更多的国际业务，成为在国际上更具影响力的跨国企业。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img.alicdn.com/tfs/TB1H9LFNFXXXXb_aXXXXXXXXXXX-900-500.jpg" alt="Velocity NYC 2016 参会总结"></p>
<p>就在刚刚过去的九月，作为 FED 团队的代表有]]>
    </summary>
    
      <category term="Velocity" scheme="http://taobaofed.org/tags/Velocity/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[理解 Babel 插件]]></title>
    <link href="http://taobaofed.org/blog/2016/09/29/babel-plugins/"/>
    <id>http://taobaofed.org/blog/2016/09/29/babel-plugins/</id>
    <published>2016-09-29T10:58:03.000Z</published>
    <updated>2016-12-21T02:40:37.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img.alicdn.com/tfs/TB1cVgDNpXXXXb2XFXXXXXXXXXX-900-500.jpg" alt="理解 Babel 插件"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>相信目前常与 ES6 代码打交道的同学对 Babel 应该不会陌生，在 ES6 代码被编译转化为 ES5 代码的过程中，Babel 插件显得尤为重要，我们最后经由 Babel 生成的代码取决于插件在这一层中做了什么事，在探索这其中的过程之前，我们先来了解下一些所需的基础知识。</p>
<h2 id="抽象语法树"><a href="#抽象语法树" class="headerlink" title="抽象语法树"></a>抽象语法树</h2><p>Babel 的工作流可以用下面一张图来表示，代码首先经由 <code>babylon</code> 解析成<a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" target="_blank" rel="external">抽象语法树</a>（AST），后经一些遍历和分析转换（主要过程），最后根据转换后的 AST 生成新的常规代码。</p>
<p><img src="https://img.alicdn.com/tps/TB1nP2ONpXXXXb_XpXXXXXXXXXX-1958-812.png" alt=""></p>
<p>在这其中，理解清楚 AST 十分重要，我们之所以需要将代码转换为 AST 也是为了让计算机能够更好地进行理解。我们可以来看看下面这段代码被解析成 AST 后对应的结构图：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abs</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (number &gt;= <span class="number">0</span>) &#123;  <span class="comment">// test</span></span><br><span class="line">    <span class="keyword">return</span> number;  <span class="comment">// consequent</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> -number; <span class="comment">// alternate</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img.alicdn.com/tps/TB1NnDQNpXXXXXmXFXXXXXXXXXX-1015-756.png" alt=""></p>
<p>所有的 AST 根节点都是 Program 节点，从上图中我们可以看到解析生成的 AST 的结构的各个 Node 节点都很细微，<a href="https://github.com/babel/babylon/blob/master/ast/spec.md" target="_blank" rel="external">Babylon AST</a> 有个文档对每个节点类型都做了详细的说明，你可以对照各个节点类型在这查找到所需要的信息。在这个例子中，我们主要关注函数声明里的内容， <code>IfStatement</code> 对应代码中的 <code>if...else</code> 区块的内容，我们先对条件（<code>test</code>）进行判断，这里是个简单的二进制表达式，我们的分支也会从这个条件继续进行下去，<code>consequent</code> 代表条件值为 true 的分支，<code>alternate</code> 代表条件值为 false 的分支，最后两条分支各自在 <code>ReturnStatement</code> 节点进行返回。</p>
<p>了解 AST 各个节点的类型是后续编写插件的关紧，AST 通常情况下都是比较复杂的，上述一段简单的函数定义也生成了比较大的 AST，对于一些复杂的程序，我们可以借助 <a href="https://astexplorer.net/" target="_blank" rel="external">astexplorer</a> 来帮我们分析 AST 的结构。</p>
<h2 id="遍历节点"><a href="#遍历节点" class="headerlink" title="遍历节点"></a>遍历节点</h2><p>在插件里进行节点遍历需要先了解 visitor 和 path 的概念，前者相当于从众多节点类型中选择开发者所需要的节点，后者相当于对节点之间的关系的访问。</p>
<h3 id="visitor"><a href="#visitor" class="headerlink" title="visitor"></a>visitor</h3><p>Babel 使用 <code>babel-traverse</code> 进行树状的遍历，对于 AST 树上的每一个分支我们都会先向下遍历走到尽头，然后向上遍历退出遍历过的节点寻找下一个分支。Babel 提供我们一个 <a href="https://en.wikipedia.org/wiki/Visitor_pattern" target="_blank" rel="external">visitor</a> 对象供我们获取 AST 里所需的具体节点来进行访问，比如我只想访问 <code>if...else</code> 生成的节点，我们可以在 visitor 里指定获取它所对应的节点：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> visitor = &#123;</span><br><span class="line">  IfStatement() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'get if'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>继续上述所说的遍历，其实这种遍历会让每个节点都会被访问两次，一次是向下遍历代表进入（enter），一次是向上退出（exit）。因此实际上每个节点都会有 <code>enter</code> 和 <code>exit</code> 方法，在实际操作的时候需要注意这种遍历方式可能会引起的一些问题，上述例子是省略掉 <code>enter</code> 的简写。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> visitor = &#123;</span><br><span class="line">  IfStatement: &#123;</span><br><span class="line">    enter() &#123;&#125;,</span><br><span class="line">    exit() &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="path"><a href="#path" class="headerlink" title="path"></a>path</h3><p>visitor 模式中我们对节点的访问实际上是对节点路径的访问，在这个模式中我们一般把 <code>path</code> 当作参数传入节点选择器中。<code>path</code> 表示两个节点之间的连接，通过这个对象我们可以访问到节点、父节点以及进行一系列跟节点操作相关的方法（类似 DOM 的操作）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> babel = <span class="built_in">require</span>(<span class="string">'babel-core'</span>);</span><br><span class="line"><span class="keyword">var</span> t = <span class="built_in">require</span>(<span class="string">'babel-types'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> code = <span class="string">`d = a + b + c`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> visitor = &#123;</span><br><span class="line">	Identifier(path) &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(path.node.name);  <span class="comment">// d a b c</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = babel.transform(code, &#123;</span><br><span class="line">	plugins: [&#123;</span><br><span class="line">		visitor: visitor</span><br><span class="line">	&#125;]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="替换节点"><a href="#替换节点" class="headerlink" title="替换节点"></a>替换节点</h2><p>具备了 AST 相关知识和了解 visitor、path 后，就可以编写一个简单的 Babel 插件了。我们要把上述的 <code>abs</code> 函数换成原生支持的 <code>Math.abs</code> 来进行调用 。</p>
<p>首先我们先解析下 <code>abs(-8)</code> 的 AST 结构，直接从表达式语句（ExpressionStatement）开始：</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="symbol">  type:</span> <span class="string">"ExpressionStatement"</span>,</span><br><span class="line"><span class="symbol">  expression:</span> &#123;</span><br><span class="line"><span class="symbol">    type:</span> <span class="string">"CallExpression"</span>,</span><br><span class="line"><span class="symbol">    callee:</span> &#123;</span><br><span class="line"><span class="symbol">      type:</span> <span class="string">"Identifier"</span>,</span><br><span class="line"><span class="symbol">      name:</span> <span class="string">"abs"</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="symbol">    arguments:</span> [&#123;</span><br><span class="line"><span class="symbol">      type:</span> <span class="string">"UnaryExpression"</span>,</span><br><span class="line"><span class="symbol">      operator:</span> <span class="string">"-"</span>,</span><br><span class="line"><span class="symbol">      prefix:</span> true,</span><br><span class="line"><span class="symbol">      arguments:</span> &#123;</span><br><span class="line"><span class="symbol">        type:</span> <span class="string">"NumericLiteral"</span>,</span><br><span class="line"><span class="symbol">        value:</span> <span class="number">8</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到表达式语句下面的 <code>expression</code> 主要是函数调用表达式（<code>CallExpression</code>），因此我们也需要创建一个函数调用表达式，此外，<code>Math.abs</code> 是一个二元操作表达式，属于 <code>MemberExpression</code> 类型。上述两个 AST 节点我们可以借助 <a href="https://github.com/babel/babel/tree/master/packages/babel-types" target="_blank" rel="external">babel-types</a> 里提供的一些方法帮我们快速创建。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建函数调用表达式</span></span><br><span class="line">t.CallExpression(</span><br><span class="line">  <span class="comment">// 创建对象属性引用</span></span><br><span class="line">	t.MemberExpression(t.identifier(<span class="string">'Math'</span>), t.identifier(<span class="string">'abs'</span>)), </span><br><span class="line">	<span class="comment">// 原始节点函数调用参数</span></span><br><span class="line">	path.node.arguments </span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>最后我们需要对此次函数调用不符合的节点进行过滤，过滤掉名字不等于 abs 的函数调用，因为 Babel 在遍历的过程是递归的，如果不过滤做限制的话，程序将会一直运行最终报调用栈超过阈值的错误。</p>
<p><code>RangeError: unknown: Maximum call stack size exceeded</code></p>
<p>最终代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> babel = <span class="built_in">require</span>(<span class="string">'babel-core'</span>);</span><br><span class="line"><span class="keyword">var</span> t = <span class="built_in">require</span>(<span class="string">'babel-types'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> code = <span class="string">`abs(-8);`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> visitor = &#123;</span><br><span class="line">	CallExpression(path) &#123;</span><br><span class="line">		<span class="keyword">if</span> (path.node.callee.name !== <span class="string">'abs'</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">		path.replaceWith(t.CallExpression(</span><br><span class="line">			t.MemberExpression(t.identifier(<span class="string">'Math'</span>), t.identifier(<span class="string">'abs'</span>)),</span><br><span class="line">			path.node.arguments</span><br><span class="line">		));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = babel.transform(code, &#123;</span><br><span class="line">	plugins: [&#123;</span><br><span class="line">		visitor: visitor</span><br><span class="line">	&#125;]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Math.abs(-8)</span></span><br><span class="line"><span class="built_in">console</span>.log(result.code);</span><br></pre></td></tr></table></figure>
<p>上述例子使用了 <code>transform</code> api 直接解析转换生成了新的代码，另外在单独编写 Babel 插件的时候，暴露的参数里一般都含有常用的 <code>babel-types</code> 对象供使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">&#123; types: t &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    visitor: &#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过编写 Babel 插件我们能对 AST 有一定的了解，另外，我认为现阶段 Babel 插件不仅仅止于对 ES6 代码的转换上，<a href="https://www.npmjs.com/search?q=babel-plugin" target="_blank" rel="external">npm</a> 上有一系列的插件覆盖了许多适合的应用场景，后续具有一定的探索性。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://github.com/babel/babylon/blob/master/ast/spec.md" target="_blank" rel="external">babylon-spec</a></li>
<li><a href="https://github.com/babel/babel/tree/master/packages/babel-types" target="_blank" rel="external">babel-types</a></li>
<li><a href="https://www.h5jun.com/post/babel-for-es6-and-beyond.html" target="_blank" rel="external">babel-for-es6-and-beyond</a></li>
<li><a href="https://www.sitepoint.com/understanding-asts-building-babel-plugin/" target="_blank" rel="external">understanding-asts-building-babel-plugin</a></li>
<li><a href="https://github.com/thejameskyle/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#toc-visitors" target="_blank" rel="external">babel-handbook</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img.alicdn.com/tfs/TB1cVgDNpXXXXb2XFXXXXXXXXXX-900-500.jpg" alt="理解 Babel 插件"></p>
<h2 id="前言"><a href="#前言" class="head]]>
    </summary>
    
      <category term="Babel" scheme="http://taobaofed.org/tags/Babel/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Node.js 和 C++ 之间的类型转换]]></title>
    <link href="http://taobaofed.org/blog/2016/09/20/type-casts-between-node-and-cpp/"/>
    <id>http://taobaofed.org/blog/2016/09/20/type-casts-between-node-and-cpp/</id>
    <published>2016-09-20T03:18:23.000Z</published>
    <updated>2016-12-21T02:40:37.000Z</updated>
    <content type="html"><![CDATA[<p><img src="//img.alicdn.com/tfs/TB1h_SoNpXXXXcMXXXXXXXXXXXX-900-500.jpg" alt="Node.js 和 C++ 之间的类型转换"></p>
<p>我非常喜欢使用 Node.js，但是当涉及到计算密集型的场景时 Node.js 就不能够很好地胜任了。而在这样的情况下 C++  是一个很好的选择，非常幸运 Node.js 官方提供了 <a href="https://nodejs.org/dist/latest-v6.x/docs/api/addons.html" target="_blank" rel="external">C/C++ Addons</a> 的机制让我们能够使用 V8 API 把 Node.js 和 C++ 结合起来。</p>
<p>虽然在 Node.js 官方网站有很多的关于怎么使用这些 API 的文档，但是在 JavaScript 和 C++ 之间传递数据是一件非常麻烦的事情，C++ 是强类型语言（”1024” 是字符串类型而不是整数类型），而 JavaScript 却总是默认的帮我们做一些类型转换。</p>
<p>JavaScript 的基本类型包括 String，Number，Boolean，null，undefined，V8 使用类继承的方式来定义这类型，这些类型都继承了 <code>Primitive</code> 类，而 <code>Primitive</code> 继承了 <code>Value</code>，v8 也支持整型（包括 <code>Int32</code> 和 <code>Uint32</code>），而所有的类型定义都可以从 V8 <a href="https://v8docs.nodesource.com/node-6.0/d0/d4a/classv8_1_1_primitive.html" target="_blank" rel="external">类型文档</a>中看到，除了基本的类型，还有 Object，Array，Map 等类型的定义。</p>
<p>基本类型的继承关系如下图：<br><img src="https://img.alicdn.com/tfs/TB1JspRNpXXXXajapXXXXXXXXXX-804-860.png" alt="primitive"></p>
<p>在 V8 中所有 JavaScript 值都是被放在 <code>Local</code> 对象中，通过这个对象指定了 JavaScript 运行时的内存单元。</p>
<p>下面这段代定义了一个 <code>Number</code> 类型的值，其中 Test 函数中声明的 isolate 变量代表着 V8 虚拟机中的堆内存，当创建新变量的时候就需要用到它，接下来的一行代码就通过 isolate 声明了一个 <code>Number</code> 类型的变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;node.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;v8.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> v8;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">const</span> v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">    Isolate* isolate = args.GetIsolate();</span><br><span class="line">    <span class="comment">// 声明变量</span></span><br><span class="line">    Local&lt;Number&gt; retval = v8::Number::New(isolate, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Local &lt;Object&gt; exports, Local&lt;Object&gt; module)</span> </span>&#123;</span><br><span class="line">    NODE_SET_METHOD(exports, <span class="string">"getTestValue"</span>, Test);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NODE_MODULE(returnValue, init)</span><br></pre></td></tr></table></figure>
<p>看了 V8 <a href="https://v8docs.nodesource.com/node-6.0/d0/d4a/classv8_1_1_primitive.html" target="_blank" rel="external">类型 API 文档</a> 你会发现对于基本的 JavaScript 类型，只有变量的声明而没有变量的赋值。最初想可能觉得这个非常的奇怪，可是仔细想一想后发现这个是合理的。主要由以下几点原因：</p>
<ul>
<li>JavaScript 的基本类型是不可变类型，变量都是指向一个不可变的内存单元，var a = 10，则 a 指向的内存单元中包含的值为 5，重新赋值 a = 100，没有改变这个内存单元的值，而是使得 a 指向了另外一个内存单元，其中的值为 100。如果声明两个变量 x，y 的值都为 10，则他们指向的是同一个内存单元。</li>
<li>函数的传参都是传值，而不是传引用，当在 JavaScript 中调用 C++ 的函数时，如果参数是基本类型则每次都是把这个值拷贝过去，改变参数的值不会影响原来的值。</li>
<li>使用 <code>Local&lt;Value&gt;</code> 声明基本类型的变量都是对内存单元的引用，因为第一条原因不可能改变引用的值使其指向另外一个内存单元，因此不存在变量的重新赋值。</li>
</ul>
<h3 id="数据流向-C-gt-JavaScript"><a href="#数据流向-C-gt-JavaScript" class="headerlink" title="数据流向 C++ -&gt; JavaScript"></a>数据流向 C++ -&gt; JavaScript</h3><p>下面 demo 定义了一些常用的 JavaScript 类型，包括基本类型的以及 Object, Array, Fuction。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;node.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;v8.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> v8;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyFunction</span><span class="params">(<span class="keyword">const</span> v8::FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">    Isolate* isolate = args.GetIsolate();</span><br><span class="line">    args.GetReturnValue().Set(String::NewFromUtf8(isolate, <span class="string">"Hello World!"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">const</span> v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">    Isolate* isolate = args.GetIsolate();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Number 类型的声明</span></span><br><span class="line">    Local&lt;Number&gt; retval = v8::Number::New(isolate, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// String 类型的声明</span></span><br><span class="line">    Local&lt;String&gt; str = v8::String::NewFromUtf8(isolate, <span class="string">"Hello World!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Object 类型的声明</span></span><br><span class="line">    Local&lt;Object&gt; obj = v8::Object::New(isolate);</span><br><span class="line">    <span class="comment">// 对象的赋值</span></span><br><span class="line">    obj-&gt;Set(v8::String::NewFromUtf8(isolate, <span class="string">"arg1"</span>), str);</span><br><span class="line">    obj-&gt;Set(v8::String::NewFromUtf8(isolate, <span class="string">"arg2"</span>), retval);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Function 类型的声明并赋值</span></span><br><span class="line">    Local&lt;FunctionTemplate&gt; tpl = v8::FunctionTemplate::New(isolate, MyFunction);</span><br><span class="line">    Local&lt;Function&gt; fn = tpl-&gt;GetFunction();</span><br><span class="line">    <span class="comment">// 函数名字</span></span><br><span class="line">    fn-&gt;SetName(String::NewFromUtf8(isolate, <span class="string">"theFunction"</span>));</span><br><span class="line">    obj-&gt;Set(v8::String::NewFromUtf8(isolate, <span class="string">"arg3"</span>), fn);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Boolean 类型的声明</span></span><br><span class="line">    Local&lt;Boolean&gt; flag = Boolean::New(isolate, <span class="literal">true</span>);</span><br><span class="line">    obj-&gt;Set(String::NewFromUtf8(isolate, <span class="string">"arg4"</span>), flag);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Array 类型的声明</span></span><br><span class="line">    Local&lt;Array&gt; arr = Array::New(isolate);</span><br><span class="line">    <span class="comment">// Array 赋值</span></span><br><span class="line">    arr-&gt;Set(<span class="number">0</span>, Number::New(isolate, <span class="number">1</span>));</span><br><span class="line">    arr-&gt;Set(<span class="number">1</span>, Number::New(isolate, <span class="number">10</span>));</span><br><span class="line">    arr-&gt;Set(<span class="number">2</span>, Number::New(isolate, <span class="number">100</span>));</span><br><span class="line">    arr-&gt;Set(<span class="number">3</span>, Number::New(isolate, <span class="number">1000</span>));</span><br><span class="line">    obj-&gt;Set(String::NewFromUtf8(isolate, <span class="string">"arg5"</span>), arr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Undefined 类型的声明</span></span><br><span class="line">    Local&lt;Value&gt; und = Undefined(isolate);</span><br><span class="line">    obj-&gt;Set(String::NewFromUtf8(isolate, <span class="string">"arg6"</span>), und);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// null 类型的声明</span></span><br><span class="line">    Local&lt;Value&gt; null = Null(isolate);</span><br><span class="line">    obj-&gt;Set(String::NewFromUtf8(isolate, <span class="string">"arg7"</span>), null);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回给 JavaScript 调用时的返回值</span></span><br><span class="line">    args.GetReturnValue().Set(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Local &lt;Object&gt; exports, Local&lt;Object&gt; module)</span> </span>&#123;</span><br><span class="line">    NODE_SET_METHOD(exports, <span class="string">"getTestValue"</span>, Test);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NODE_MODULE(returnValue, init)</span><br></pre></td></tr></table></figure>
<p>所有的 addon 都需要一个初始化的函数，如下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Initialize</span><span class="params">(Local&lt;Object&gt; exports)</span></span>;</span><br><span class="line">NODE_MODULE(module_name, Initialize)</span><br></pre></td></tr></table></figure>
<p><code>Initialize</code> 是初始化的函数，<code>module_name</code> 是编译后产生的二进制文件名，上述代码的模块名为 <code>returnValue</code>。</p>
<p>上述代码通过 node-gyp 编译后（编译过程官方文档 <a href="https://nodejs.org/dist/latest-v6.x/docs/api/addons.html" target="_blank" rel="external">C/C++ Addons</a> 有详细的介绍），可以通过如下的方式调用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// returnValue.node 这个文件就是编译后产生的文件，通过 NODE_MODULE(returnValue, init) 决定的文件名</span></span><br><span class="line"><span class="keyword">const</span> returnValue = <span class="built_in">require</span>(<span class="string">'./build/Release/returnValue.node'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(returnValue.getTestValue());</span><br></pre></td></tr></table></figure>
<p>运行结果如下:<br><img src="https://img.alicdn.com/tfs/TB1jb80NpXXXXXYaXXXXXXXXXXX-840-324.png" alt="returnValue"></p>
<h3 id="数据流向-javaScript-gt-C"><a href="#数据流向-javaScript-gt-C" class="headerlink" title="数据流向 javaScript -&gt; C++"></a>数据流向 javaScript -&gt; C++</h3><p>上面的 demo 展示了怎样在在 C++ 定义 JavaScript 类型，数据的是从 C++ 流向 JavaScript，反过来数据也需要从 javaScript 流向 C++，也就是调用 C++ 函数的时候需要传入一些参数。</p>
<p>下面的代码展示了参数个数判断，参数类型判断，以及参数类型装换成 V8 类型的过程，包括基本类型以及 Object, Array, Fuction。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;node.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;v8.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> v8;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetArgument</span><span class="params">(<span class="keyword">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">    Isolate* isolate = args.GetIsolate();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数长度判断</span></span><br><span class="line">    <span class="keyword">if</span> (args.Length() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        isolate-&gt;ThrowException(Exception::TypeError(</span><br><span class="line">            String::NewFromUtf8(isolate, <span class="string">"Wrong number of arguments"</span>)));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数类型判断</span></span><br><span class="line">    <span class="keyword">if</span> (!args[<span class="number">0</span>]-&gt;IsNumber() || !args[<span class="number">1</span>]-&gt;IsNumber()) &#123;</span><br><span class="line">        <span class="comment">//抛出错误</span></span><br><span class="line">        isolate-&gt;ThrowException(Exception::TypeError(</span><br><span class="line">            String::NewFromUtf8(isolate, <span class="string">"argumnets must be number"</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!args[<span class="number">0</span>]-&gt;IsObject()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I am not Object\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!args[<span class="number">0</span>]-&gt;IsBoolean()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I am not Boolean\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!args[<span class="number">0</span>]-&gt;IsArray()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I am not Array\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!args[<span class="number">0</span>]-&gt;IsString()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I am not String\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!args[<span class="number">0</span>]-&gt;IsFunction()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I am not Function\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!args[<span class="number">0</span>]-&gt;IsNull()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I am not Null\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!args[<span class="number">0</span>]-&gt;IsUndefined()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I am not Undefined\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// js Number 类型转换成 v8 Number 类型</span></span><br><span class="line">    Local&lt;Number&gt; value1 = Local&lt;Number&gt;::Cast(args[<span class="number">0</span>]);</span><br><span class="line">    Local&lt;Number&gt; value2 = Local&lt;Number&gt;::Cast(args[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">double</span> value = value1-&gt;NumberValue() + value2-&gt;NumberValue();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// js String 类型转换成 v8 String 类型</span></span><br><span class="line">    Local&lt;String&gt; str = Local&lt;String&gt;::Cast(args[<span class="number">2</span>]);</span><br><span class="line">    String::<span class="function">Utf8Value <span class="title">utfValue</span><span class="params">(str)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">string</span>(*utfValue)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// js Array 类型转换成 v8 Array 类型</span></span><br><span class="line">    Local&lt;Array&gt; input_array = Local&lt;Array&gt;::Cast(args[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d, %f %f\n"</span>, input_array-&gt;Length(), input_array-&gt;Get(<span class="number">0</span>)-&gt;NumberValue(), input_array-&gt;Get(<span class="number">1</span>)-&gt;NumberValue());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// js Object 类型转换成 v8 Object 类型</span></span><br><span class="line">    Local&lt;Object&gt; obj = Local&lt;Object&gt;::Cast(args[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 key 获取对象中的值</span></span><br><span class="line">    Local&lt;Value&gt; a = obj-&gt;Get(String::NewFromUtf8(isolate, <span class="string">"a"</span>));</span><br><span class="line">    Local&lt;Value&gt; b = obj-&gt;Get(String::NewFromUtf8(isolate, <span class="string">"b"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// js Array 类型转换成 v8 Array 类型</span></span><br><span class="line">    Local&lt;Array&gt; c = Local&lt;Array&gt;::Cast(obj-&gt;Get(String::NewFromUtf8(isolate, <span class="string">"c"</span>)));</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a-&gt;NumberValue()&lt;&lt;<span class="string">"   "</span>&lt;&lt;b-&gt;NumberValue()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d, %f %f\n"</span>, c-&gt;Length(), c-&gt;Get(<span class="number">0</span>)-&gt;NumberValue(), c-&gt;Get(<span class="number">1</span>)-&gt;NumberValue());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// js String 类型转换成 v8 String 类型</span></span><br><span class="line">    Local&lt;String&gt; cString = Local&lt;String&gt;::Cast(c-&gt;Get(<span class="number">2</span>));</span><br><span class="line">    String::<span class="function">Utf8Value <span class="title">utfValueD</span><span class="params">(cString)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">string</span>(*utfValueD)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 key 获取对象中的值</span></span><br><span class="line">    Local&lt;Object&gt; d = Local&lt;Object&gt;::Cast(obj-&gt;Get(String::NewFromUtf8(isolate, <span class="string">"d"</span>)));</span><br><span class="line">    Local&lt;String&gt; dString1 = Local&lt;String&gt;::Cast(d-&gt;Get(String::NewFromUtf8(isolate, <span class="string">"m"</span>)));</span><br><span class="line">    String::<span class="function">Utf8Value <span class="title">utfValued1</span><span class="params">(dString1)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">string</span>(*utfValued1)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 key 获取对象中的值</span></span><br><span class="line">    Local&lt;String&gt; dString2 = Local&lt;String&gt;::Cast(d-&gt;Get(String::NewFromUtf8(isolate, <span class="string">"n"</span>)));</span><br><span class="line">    String::<span class="function">Utf8Value <span class="title">utfValued2</span><span class="params">(dString2)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">string</span>(*utfValued2)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// js Booelan 类型转换成 v8 Boolean 类型</span></span><br><span class="line">    Local&lt;Boolean&gt; FlagTrue = Local&lt;Boolean&gt;::Cast(args[<span class="number">5</span>]);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Flag: "</span>&lt;&lt;FlagTrue-&gt;BooleanValue()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// js Function 类型转换成 v8 Function 类型</span></span><br><span class="line">    Local&lt;Function&gt; cb = Local&lt;Function&gt;::Cast(args[<span class="number">8</span>]);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> argc = <span class="number">2</span>;</span><br><span class="line">    Local&lt;Value&gt; argv[<span class="number">2</span>];</span><br><span class="line">    argv[<span class="number">0</span>] = a;</span><br><span class="line">    argv[<span class="number">1</span>] = b;</span><br><span class="line">    cb-&gt;Call(Null(isolate), argc, argv);</span><br><span class="line"></span><br><span class="line">    args.GetReturnValue().Set(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(Local &lt;Object&gt; exports, Local &lt;Object&gt; module)</span> </span>&#123;</span><br><span class="line">    NODE_SET_METHOD(module, <span class="string">"exports"</span>, GetArgument);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NODE_MODULE(argumentss, Init)</span><br></pre></td></tr></table></figure>
<p>通过 node-gyp 编译后，可以通过如下的方式调用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getArguments = <span class="built_in">require</span>(<span class="string">'./build/Release/arguments'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getArguments(<span class="number">2</span>, <span class="number">3</span>, <span class="string">'Hello Arguments'</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], &#123;</span><br><span class="line">        a: <span class="number">10</span>,</span><br><span class="line">        b: <span class="number">100</span>,</span><br><span class="line">        c: [<span class="number">23</span>, <span class="number">22</span>, <span class="string">"我是33"</span>],</span><br><span class="line">        d: &#123; m: <span class="string">'我是22'</span>, n: <span class="string">'我是23'</span> &#125;</span><br><span class="line">    &#125;, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">undefined</span>,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'I am Function!'</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(...args);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'I am Function!'</span>);</span><br><span class="line">    &#125;));</span><br></pre></td></tr></table></figure>
<p>运行结果如下:</p>
<p><img src="https://img.alicdn.com/tfs/TB11tB4NpXXXXaLXVXXXXXXXXXX-796-796.png" alt="argument"></p>
<p>关于其他的类型，我这里就就不一一介绍，V8 文档里面都有对应的 API。</p>
<h3 id="NAN"><a href="#NAN" class="headerlink" title="NAN"></a>NAN</h3><p>由于 V8 的 API 还没有彻底稳定下来，所以对于不同版本的 Node.js 类型相关的 API 会发生变化，而 <a href="https://github.com/nodejs/nan" target="_blank" rel="external">NAN</a> 帮我们做了封装，在编码的时候不需要关心版本问题，只需要引入相应的头文件即可。</p>
<p>引入头文件后，可以如下使用方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v8::Local&lt;v8::Primitive&gt; Nan::Undefined()</span><br><span class="line">v8::Local&lt;v8::Primitive&gt; Nan::Null()</span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="http://blog.scottfrees.com/type-conversions-from-javascript-to-c-in-v8" target="_blank" rel="external">Type conversions from JavaScript to C++ in V8</a></li>
<li><a href="https://nodejs.org/dist/latest-v6.x/docs/api/addons.html" target="_blank" rel="external">node addon</a></li>
<li><a href="https://v8docs.nodesource.com/node-6.0/d0/d4a/classv8_1_1_primitive.html" target="_blank" rel="external">v8 types documentation</a></li>
<li><a href="https://github.com/nodejs/node-gyp" target="_blank" rel="external">node-gyp</a></li>
<li><a href="https://gyp.gsrc.io/docs/UserDocumentation.md" target="_blank" rel="external">gyp user documentation</a></li>
<li><a href="https://github.com/nodejs/nan" target="_blank" rel="external">nan</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="//img.alicdn.com/tfs/TB1h_SoNpXXXXcMXXXXXXXXXXXX-900-500.jpg" alt="Node.js 和 C++ 之间的类型转换"></p>
<p>我非常喜欢使用 Node.js，但是当涉及到计算密集型的场]]>
    </summary>
    
      <category term="类型转换" scheme="http://taobaofed.org/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    
      <category term="addons" scheme="http://taobaofed.org/tags/addons/"/>
    
      <category term="Node.js" scheme="http://taobaofed.org/categories/Node-js/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[细说 webpack 之流程篇]]></title>
    <link href="http://taobaofed.org/blog/2016/09/09/webpack-flow/"/>
    <id>http://taobaofed.org/blog/2016/09/09/webpack-flow/</id>
    <published>2016-09-09T04:02:58.000Z</published>
    <updated>2016-12-21T02:40:37.000Z</updated>
    <content type="html"><![CDATA[<p><img src="//img.alicdn.com/tfs/TB1_ZnHNXXXXXXBXpXXXXXXXXXX-900-500.jpg" alt="细说 webpack 之流程篇"></p>
<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>目前，几乎所有业务的开发构建都会用到 webpack 。的确，作为模块加载和打包神器，只需配置几个文件，加载各种 loader 就可以享受无痛流程化开发。但对于 webpack 这样一个复杂度较高的插件集合，它的整体流程及思想对我们来说还是很透明的。那么接下来我会带你了解 webpack 这样一个构建黑盒，首先来谈谈它的流程。</p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h5 id="1-webstorm-中配置-webpack-webstorm-debugger-script"><a href="#1-webstorm-中配置-webpack-webstorm-debugger-script" class="headerlink" title="1. webstorm 中配置 webpack-webstorm-debugger-script"></a>1. webstorm 中配置 webpack-webstorm-debugger-script</h5><p>在开始了解之前，必须要能对 webpack 整个流程进行 debug ，配置过程比较简单。</p>
<p>先将 <a href="https://www.npmjs.com/package/webpack-webstorm-debugger-script" target="_blank" rel="external">webpack-webstorm-debugger-script</a> 中的 <code>webstorm-debugger.js</code> 置于 <code>webpack.config.js</code> 的同一目录下，搭建好你的脚手架后就可以直接 Debug 这个 webstorm-debugger.js 文件了。</p>
<h5 id="2-webpack-config-js-配置"><a href="#2-webpack-config-js-配置" class="headerlink" title="2. webpack.config.js 配置"></a>2. webpack.config.js 配置</h5><p>估计大家对 webpack.config.js 的配置也尝试过不少次了，这里就大致对这个配置文件进行个分析。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">var</span> node_modules = path.resolve(__dirname, <span class="string">'node_modules'</span>);</span><br><span class="line"><span class="keyword">var</span> pathToReact = path.resolve(node_modules, <span class="string">'react/dist/react.min.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 入口文件，是模块构建的起点，同时每一个入口文件对应最后生成的一个 chunk。</span></span><br><span class="line">  entry: &#123;</span><br><span class="line">    bundle: [</span><br><span class="line">      <span class="string">'webpack/hot/dev-server'</span>,</span><br><span class="line">      <span class="string">'webpack-dev-server/client?http://localhost:8080'</span>,</span><br><span class="line">      path.resolve(__dirname, <span class="string">'app/app.js'</span>)</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 文件路径指向(可加快打包过程)。</span></span><br><span class="line">  resolve: &#123;</span><br><span class="line">    alias: &#123;</span><br><span class="line">      <span class="string">'react'</span>: pathToReact</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 生成文件，是模块构建的终点，包括输出文件与输出路径。</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'build'</span>),</span><br><span class="line">    filename: <span class="string">'[name].js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 这里配置了处理各模块的 loader ，包括 css 预处理 loader ，es6 编译 loader，图片处理 loader。</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    loaders: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        loader: <span class="string">'babel'</span>,</span><br><span class="line">        query: &#123;</span><br><span class="line">          presets: [<span class="string">'es2015'</span>, <span class="string">'react'</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    noParse: [pathToReact]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// webpack 各插件对象，在 webpack 的事件流中执行对应的方法。</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>除此之外再大致介绍下 webpack 的一些核心概念：</p>
<ul>
<li>loader：能转换各类资源，并处理成对应模块的加载器。loader 间可以串行使用。</li>
<li>chunk：code splitting 后的产物，也就是按需加载的分块，装载了不同的 module。</li>
</ul>
<p>对于 module 和 chunk 的关系可以参照 webpack 官方的这张图：</p>
<p><img src="https://img.alicdn.com/tps/TB1B0DXNXXXXXXdXFXXXXXXXXXX-368-522.jpg" alt=""></p>
<ul>
<li><p>plugin：webpack 的插件实体，这里以 UglifyJsPlugin 为例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UglifyJsPlugin</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.options = options;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = UglifyJsPlugin;</span><br><span class="line"></span><br><span class="line">UglifyJsPlugin.prototype.apply = <span class="function"><span class="keyword">function</span>(<span class="params">compiler</span>) </span>&#123;</span><br><span class="line">  compiler.plugin(<span class="string">"compilation"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">compilation</span>) </span>&#123;</span><br><span class="line">    compilation.plugin(<span class="string">"build-module"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">module</span>) </span>&#123;</span><br><span class="line">    &#125;);</span><br><span class="line">    compilation.plugin(<span class="string">"optimize-chunk-assets"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunks, callback</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// Uglify 逻辑</span></span><br><span class="line">    &#125;);</span><br><span class="line">    compilation.plugin(<span class="string">"normal-module-loader"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在 webpack 中你经常可以看到 compilation.plugin(‘xxx’, callback) ，你可以把它当作是一个事件的绑定，这些事件在打包时由 webpack 来触发。</p>
</li>
</ul>
<h5 id="3-流程总览"><a href="#3-流程总览" class="headerlink" title="3. 流程总览"></a>3. 流程总览</h5><p>在具体流程学习前，可以先通过这幅 <a href="https://img.alicdn.com/tps/TB1GVGFNXXXXXaTapXXXXXXXXXX-4436-4244.jpg" target="_blank" rel="external">webpack 整体流程图</a> 了解一下大致流程（建议保存下来查看）。</p>
<p><img src="https://img.alicdn.com/tps/TB1GVGFNXXXXXaTapXXXXXXXXXX-4436-4244.jpg" alt=""></p>
<h3 id="shell-与-config-解析"><a href="#shell-与-config-解析" class="headerlink" title="shell 与 config 解析"></a>shell 与 config 解析</h3><p>每次在命令行输入 webpack 后，操作系统都会去调用 <code>./node_modules/.bin/webpack</code> 这个 shell 脚本。这个脚本会去调用 <code>./node_modules/webpack/bin/webpack.js</code> 并追加输入的参数，如 -p , -w 。(图中 webpack.js 是 webpack 的启动文件，而 $@ 是后缀参数)</p>
<p><img src="https://img.alicdn.com/tps/TB1kvfbNXXXXXarXpXXXXXXXXXX-500-111.jpg" alt=""></p>
<p>在 webpack.js 这个文件中 webpack 通过 optimist 将用户配置的 webpack.config.js 和 shell 脚本传过来的参数整合成 options 对象传到了下一个流程的控制对象中。</p>
<h5 id="1-optimist"><a href="#1-optimist" class="headerlink" title="1. optimist"></a>1. optimist</h5><p>和 commander 一样，<a href="https://github.com/substack/node-optimist" target="_blank" rel="external">optimist</a> 实现了 node 命令行的解析，其 API 调用非常方便。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> optimist = <span class="built_in">require</span>(<span class="string">"optimist"</span>);</span><br><span class="line"></span><br><span class="line">optimist</span><br><span class="line">  .boolean(<span class="string">"json"</span>).alias(<span class="string">"json"</span>, <span class="string">"j"</span>).describe(<span class="string">"json"</span>)</span><br><span class="line">  .boolean(<span class="string">"colors"</span>).alias(<span class="string">"colors"</span>, <span class="string">"c"</span>).describe(<span class="string">"colors"</span>)</span><br><span class="line">  .boolean(<span class="string">"watch"</span>).alias(<span class="string">"watch"</span>, <span class="string">"w"</span>).describe(<span class="string">"watch"</span>)</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>获取到后缀参数后，optimist 分析参数并以键值对的形式把参数对象保存在 optimist.argv 中，来看看 argv 究竟有什么？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// webpack --hot -w</span><br><span class="line">&#123;</span><br><span class="line">  hot: true,</span><br><span class="line">  profile: false,</span><br><span class="line">  watch: true,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-config-合并与插件加载"><a href="#2-config-合并与插件加载" class="headerlink" title="2. config 合并与插件加载"></a>2. config 合并与插件加载</h5><p>在加载插件之前，webpack 将 webpack.config.js 中的各个配置项拷贝到 options 对象中，并加载用户配置在 webpack.config.js 的 plugins 。接着 optimist.argv 会被传入到 <code>./node_modules/webpack/bin/convert-argv.js</code> 中，通过判断 argv 中参数的值决定是否去加载对应插件。(至于 webpack 插件运行机制，在之后的运行机制篇会提到)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ifBooleanArg(<span class="string">"hot"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ensureArray(options, <span class="string">"plugins"</span>);</span><br><span class="line">  <span class="keyword">var</span> HotModuleReplacementPlugin = <span class="built_in">require</span>(<span class="string">"../lib/HotModuleReplacementPlugin"</span>);</span><br><span class="line">  options.plugins.push(<span class="keyword">new</span> HotModuleReplacementPlugin());</span><br><span class="line">&#125;);</span><br><span class="line">...</span><br><span class="line">return options;</span><br></pre></td></tr></table></figure>
<p><code>options</code> 作为最后返回结果，包含了之后构建阶段所需的重要信息。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  entry: &#123;&#125;,//入口配置</span><br><span class="line">  output: &#123;&#125;, //输出配置</span><br><span class="line">  plugins: [], //插件集合(配置文件 + shell指令) </span><br><span class="line">  module: &#123; loaders: [ [Object] ] &#125;, //模块配置</span><br><span class="line">  context: //工程路径</span><br><span class="line">  ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这和 webpack.config.js 的配置非常相似，只是多了一些经 shell 传入的插件对象。插件对象一初始化完毕， options 也就传入到了下个流程中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">"../lib/webpack.js"</span>);</span><br><span class="line"><span class="keyword">var</span> compiler = webpack(options);</span><br></pre></td></tr></table></figure>
<h3 id="编译与构建流程"><a href="#编译与构建流程" class="headerlink" title="编译与构建流程"></a>编译与构建流程</h3><p>在加载配置文件和 shell 后缀参数申明的插件，并传入构建信息 options 对象后，开始整个 webpack 打包最漫长的一步。而这个时候，真正的 webpack 对象才刚被初始化，具体的初始化逻辑在 <code>lib/webpack.js</code> 中，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">webpack</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> compiler = <span class="keyword">new</span> Compiler();</span><br><span class="line">  ...<span class="comment">// 检查options,若watch字段为true,则开启watch线程</span></span><br><span class="line">  <span class="keyword">return</span> compiler;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>webpack 的实际入口是 Compiler 中的 run 方法，run 一旦执行后，就开始了编译和构建流程 ，其中有几个比较关键的 webpack 事件节点。</p>
<ul>
<li><code>compile</code>    开始编译</li>
<li><code>make</code>    从入口点分析模块及其依赖的模块，创建这些模块对象</li>
<li><code>build-module</code>    构建模块</li>
<li><code>after-compile</code>     完成构建</li>
<li><code>seal</code>     封装构建结果</li>
<li><code>emit</code>     把各个chunk输出到结果文件</li>
<li><code>after-emit</code>     完成输出</li>
</ul>
<h5 id="1-核心对象-Compilation"><a href="#1-核心对象-Compilation" class="headerlink" title="1. 核心对象 Compilation"></a>1. 核心对象 Compilation</h5><p>compiler.run 后首先会触发 compile ，这一步会构建出 Compilation 对象：</p>
<p><img src="https://img.alicdn.com/tps/TB1UgS4NXXXXXXZXVXXXXXXXXXX-693-940.png" alt="compilation类图"></p>
<p>这个对象有两个作用，一是负责组织整个打包过程，包含了每个构建环节及输出环节所对应的方法，可以从图中看到比较关键的步骤，如 <code>addEntry()</code> ,  <code>_addModuleChain()</code> ,  <code>buildModule()</code> ,  <code>seal()</code> ,  <code>createChunkAssets()</code>  (在每一个节点都会触发 webpack 事件去调用各插件)。二是该对象内部存放着所有 module ，chunk，生成的 asset 以及用来生成最后打包文件的 template 的信息。</p>
<h5 id="2-编译与构建主流程"><a href="#2-编译与构建主流程" class="headerlink" title="2. 编译与构建主流程"></a>2. 编译与构建主流程</h5><p>在创建 module 之前，Compiler 会触发 make，并调用 <code>Compilation.addEntry</code> 方法，通过 options 对象的 entry 字段找到我们的入口js文件。之后，在 addEntry 中调用私有方法 <code>_addModuleChain</code> ，这个方法主要做了两件事情。一是根据模块的类型获取对应的模块工厂并创建模块，二是构建模块。</p>
<p>而构建模块作为最耗时的一步，又可细化为三步：</p>
<ul>
<li><p>调用各 loader 处理模块之间的依赖</p>
<p>webpack 提供的一个很大的便利就是能将所有资源都整合成模块，不仅仅是 js 文件。所以需要一些 loader ，比如 <code>url-loader</code> ， <code>jsx-loader</code> ， <code>css-loader</code> 等等来让我们可以直接在源文件中引用各类资源。webpack 调用 <code>doBuild()</code> ，对每一个 require() 用对应的 loader 进行加工，最后生成一个 js module。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Compilation.prototype._addModuleChain = <span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">context, dependency, onModule, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> start = <span class="keyword">this</span>.profile &amp;&amp; +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 根据模块的类型获取对应的模块工厂并创建模块</span></span><br><span class="line">  <span class="keyword">var</span> moduleFactory = <span class="keyword">this</span>.dependencyFactories.get(dependency.constructor);</span><br><span class="line">  ...</span><br><span class="line">  moduleFactory.create(context, dependency, <span class="function"><span class="keyword">function</span>(<span class="params">err, module</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">this</span>.addModule(<span class="built_in">module</span>);</span><br><span class="line">    ...</span><br><span class="line">    this.buildModule(<span class="built_in">module</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">// 构建模块，添加依赖模块</span></span><br><span class="line">    &#125;.bind(<span class="keyword">this</span>));</span><br><span class="line">  &#125;.bind(<span class="keyword">this</span>));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用 <a href="https://github.com/ternjs/acorn" target="_blank" rel="external">acorn</a> 解析经 loader 处理后的源文件生成抽象语法树 AST</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> Parser.prototype.parse = <span class="function"><span class="keyword">function</span> <span class="title">parse</span>(<span class="params">source, initialState</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ast;</span><br><span class="line">  <span class="keyword">if</span> (!ast) &#123;</span><br><span class="line">    <span class="comment">// acorn以es6的语法进行解析</span></span><br><span class="line">    ast = acorn.parse(source, &#123;</span><br><span class="line">      ranges: <span class="literal">true</span>,</span><br><span class="line">      locations: <span class="literal">true</span>,</span><br><span class="line">      ecmaVersion: <span class="number">6</span>,</span><br><span class="line">      sourceType: <span class="string">"module"</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历 AST，构建该模块所依赖的模块</p>
<p>对于当前模块，或许存在着多个依赖模块。当前模块会开辟一个依赖模块的数组，在遍历 AST 时，将 require() 中的模块通过 <code>addDependency()</code> 添加到数组中。当前模块构建完成后，webpack 调用 <code>processModuleDependencies</code> 开始递归处理依赖的 module，接着就会重复之前的构建步骤。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> Compilation.prototype.addModuleDependencies = <span class="function"><span class="keyword">function</span>(<span class="params">module, dependencies, bail, cacheGroup, recursive, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 根据依赖数组(dependencies)创建依赖模块对象</span></span><br><span class="line">  <span class="keyword">var</span> factories = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; dependencies.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> factory = _this.dependencyFactories.get(dependencies[i][<span class="number">0</span>].constructor);</span><br><span class="line">    factories[i] = [factory, dependencies[i]];</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 与当前模块构建步骤相同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="3-构建细节"><a href="#3-构建细节" class="headerlink" title="3. 构建细节"></a>3. 构建细节</h5><p>module 是 webpack 构建的核心实体，也是所有 module 的 父类，它有几种不同子类：<code>NormalModule</code> ,  <code>MultiModule</code> ,  <code>ContextModule</code> , <code>DelegatedModule</code>  等。但这些核心实体都是在构建中都会去调用对应方法，也就是 <code>build()</code> 。来看看其中具体做了什么：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化module信息，如context,id,chunks,dependencies等。</span></span><br><span class="line">NormalModule.prototype.build = <span class="function"><span class="keyword">function</span> <span class="title">build</span>(<span class="params">options, compilation, resolver, fs, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.buildTimestamp = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime(); <span class="comment">// 构建计时</span></span><br><span class="line">  <span class="keyword">this</span>.built = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.doBuild(options, compilation, resolver, fs, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 指定模块引用，不经acorn解析</span></span><br><span class="line">    <span class="keyword">if</span> (options.module &amp;&amp; options.module.noParse) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(options.module.noParse)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (options.module.noParse.some(<span class="function"><span class="keyword">function</span>(<span class="params">regExp</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">typeof</span> regExp === <span class="string">"string"</span> ?</span><br><span class="line">            <span class="keyword">this</span>.request.indexOf(regExp) === <span class="number">0</span> :</span><br><span class="line">              regExp.test(<span class="keyword">this</span>.request);</span><br><span class="line">          &#125;, <span class="keyword">this</span>)) &#123;</span><br><span class="line">          <span class="keyword">return</span> callback();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> options.module.noParse === <span class="string">"string"</span> ?</span><br><span class="line">        <span class="keyword">this</span>.request.indexOf(options.module.noParse) === <span class="number">0</span> :</span><br><span class="line">          options.module.noParse.test(<span class="keyword">this</span>.request)) &#123;</span><br><span class="line">        <span class="keyword">return</span> callback();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 由acorn解析生成ast</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.parser.parse(<span class="keyword">this</span>._source.source(), &#123;</span><br><span class="line">        current: <span class="keyword">this</span>,</span><br><span class="line">        <span class="built_in">module</span>: <span class="keyword">this</span>,</span><br><span class="line">        compilation: compilation,</span><br><span class="line">        options: options</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">var</span> source = <span class="keyword">this</span>._source.source();</span><br><span class="line">      <span class="keyword">this</span>._source = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">return</span> callback(<span class="keyword">new</span> ModuleParseError(<span class="keyword">this</span>, source, e));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> callback();</span><br><span class="line">  &#125;.bind(<span class="keyword">this</span>));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于每一个 module ，它都会有这样一个构建方法。当然，它还包括了从构建到输出的一系列的有关 module 生命周期的函数，我们通过 module 父类类图其子类类图(这里以 NormalModule 为例)来观察其真实形态：</p>
<p><img src="https://img.alicdn.com/tps/TB1WOiRNXXXXXcJaXXXXXXXXXXX-445-1228.png" alt="module类图"></p>
<p>可以看到无论是构建流程，处理依赖流程，包括后面的封装流程都是与 module 密切相关的。</p>
<h3 id="打包输出"><a href="#打包输出" class="headerlink" title="打包输出"></a>打包输出</h3><p>在所有模块及其依赖模块 build 完成后，webpack 会监听 <code>seal</code> 事件调用各插件对构建后的结果进行封装，要逐次对每个 module 和 chunk 进行整理，生成编译后的源码，合并，拆分，生成 hash 。 同时这是我们在开发时进行代码优化和功能添加的关键环节。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Compilation.prototype.seal = <span class="function"><span class="keyword">function</span> <span class="title">seal</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.applyPlugins(<span class="string">"seal"</span>); <span class="comment">// 触发插件的seal事件</span></span><br><span class="line">  <span class="keyword">this</span>.preparedChunks.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.name &lt; b.name) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a.name &gt; b.name) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">this</span>.preparedChunks.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">preparedChunk</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">module</span> = preparedChunk.module;</span><br><span class="line">    <span class="keyword">var</span> chunk = <span class="keyword">this</span>.addChunk(preparedChunk.name, <span class="built_in">module</span>);</span><br><span class="line">    chunk.initial = chunk.entry = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 整理每个Module和chunk，每个chunk对应一个输出文件。</span></span><br><span class="line">    chunk.addModule(<span class="built_in">module</span>);</span><br><span class="line">    <span class="built_in">module</span>.addChunk(chunk);</span><br><span class="line">  &#125;, <span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.applyPluginsAsync(<span class="string">"optimize-tree"</span>, <span class="keyword">this</span>.chunks, <span class="keyword">this</span>.modules, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span> callback(err);</span><br><span class="line">    &#125;</span><br><span class="line">    ... <span class="comment">// 触发插件的事件</span></span><br><span class="line">    <span class="keyword">this</span>.createChunkAssets(); <span class="comment">// 生成最终assets</span></span><br><span class="line">    ... <span class="comment">// 触发插件的事件</span></span><br><span class="line">  &#125;.bind(<span class="keyword">this</span>));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="1-生成最终-assets"><a href="#1-生成最终-assets" class="headerlink" title="1. 生成最终 assets"></a>1. 生成最终 assets</h5><p>在封装过程中，webpack 会调用 Compilation 中的 <code>createChunkAssets</code> 方法进行打包后代码的生成。 createChunkAssets 流程如下：</p>
<p><img src="https://img.alicdn.com/tps/TB1cz5.NXXXXXc7XpXXXXXXXXXX-959-807.png" alt="createChunkAssets流程"></p>
<ul>
<li><p>不同的 Template</p>
<p>从上图可以看出通过判断是入口 js 还是需要异步加载的 js 来选择不同的模板对象进行封装，入口 js 会采用 webpack 事件流的 render 事件来触发 <code>Template类</code> 中的 <code>renderChunkModules()</code> (异步加载的 js 会调用 chunkTemplate 中的 render 方法)。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(chunk.entry) &#123;</span><br><span class="line">  source = <span class="keyword">this</span>.mainTemplate.render(<span class="keyword">this</span>.hash, chunk, <span class="keyword">this</span>.moduleTemplate, <span class="keyword">this</span>.dependencyTemplates);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  source = <span class="keyword">this</span>.chunkTemplate.render(chunk, <span class="keyword">this</span>.moduleTemplate, <span class="keyword">this</span>.dependencyTemplates);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 webpack 中有四个 Template 的子类，分别是 <code>MainTemplate.js</code>  ， <code>ChunkTemplate.js</code> ，<code>ModuleTemplate.js</code> ， <code>HotUpdateChunkTemplate.js</code> ，前两者先前已大致有介绍，而 ModuleTemplate 是对所有模块进行一个代码生成，HotUpdateChunkTemplate 是对热替换模块的一个处理。</p>
</li>
<li><p>模块封装</p>
<p>模块在封装的时候和它在构建时一样，都是调用各模块类中的方法。封装通过调用 <code>module.source()</code> 来进行各操作，比如说 require() 的替换。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MainTemplate.prototype.requireFn = <span class="string">"__webpack_require__"</span>;</span><br><span class="line">MainTemplate.prototype.render = <span class="function"><span class="keyword">function</span>(<span class="params">hash, chunk, moduleTemplate, dependencyTemplates</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> buf = [];</span><br><span class="line">    <span class="comment">// 每一个module都有一个moduleId,在最后会替换。</span></span><br><span class="line">    buf.push(<span class="string">"function "</span> + <span class="keyword">this</span>.requireFn + <span class="string">"(moduleId) &#123;"</span>);</span><br><span class="line">    buf.push(<span class="keyword">this</span>.indent(<span class="keyword">this</span>.applyPluginsWaterfall(<span class="string">"require"</span>, <span class="string">""</span>, chunk, hash)));</span><br><span class="line">    buf.push(<span class="string">"&#125;"</span>);</span><br><span class="line">    buf.push(<span class="string">""</span>);</span><br><span class="line">    ... <span class="comment">// 其余封装操作</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成 assets</p>
<p>各模块进行 doBlock 后，把 module 的最终代码循环添加到 source 中。一个 source 对应着一个 asset 对象，该对象保存了单个文件的文件名( name )和最终代码( value )。</p>
</li>
</ul>
<h5 id="2-输出"><a href="#2-输出" class="headerlink" title="2. 输出"></a>2. 输出</h5><p>最后一步，webpack 调用 Compiler 中的 <code>emitAssets()</code> ，按照 output 中的配置项将文件输出到了对应的 path 中，从而 webpack 整个打包过程结束。要注意的是，若想对结果进行处理，则需要在 <code>emit</code> 触发后对自定义插件进行扩展。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>webpack 的整体流程主要还是依赖于 <code>compilation</code> 和 <code>module</code> 这两个对象，但其思想远不止这么简单。最开始也说过，webpack 本质是个插件集合，并且由 <code>tapable</code> 控制各插件在 webpack 事件流上运行，至于具体的思想和细节，将会在后一篇文章中提到。同时，在业务开发中，无论是为了提升构建效率，或是减小打包文件大小，我们都可以通过编写 webpack 插件来进行流程上的控制，这个也会在之后提到。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="//img.alicdn.com/tfs/TB1_ZnHNXXXXXXBXpXXXXXXXXXX-900-500.jpg" alt="细说 webpack 之流程篇"></p>
<h3 id="引言"><a href="#引言" class="heade]]>
    </summary>
    
      <category term="webpack" scheme="http://taobaofed.org/tags/webpack/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[React 实践心得：key 属性的原理和用法]]></title>
    <link href="http://taobaofed.org/blog/2016/08/24/react-key/"/>
    <id>http://taobaofed.org/blog/2016/08/24/react-key/</id>
    <published>2016-08-24T11:38:35.000Z</published>
    <updated>2016-12-21T02:40:37.000Z</updated>
    <content type="html"><![CDATA[<p><img src="//img.alicdn.com/tfs/TB1sJ2wMVXXXXbyaXXXXXXXXXXX-900-500.jpg" alt="React 实践心得：key 属性的原理和用法"></p>
<p>我们知道，React 元素可以具有一个特殊的属性 key，这个属性不是给用户自己用的，而是给 React 自己用的。如果我们动态地创建 React 元素，而且 React 元素内包含数量或顺序不确定的子元素时，我们就需要提供 key 这个特殊的属性。</p>
<p>如果你有下面这样的代码：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> UserList = props =&gt; (</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>用户列表<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    &#123;props.users.map(u =&gt; <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;u.id&#125;:&#123;u.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>)&#125;  // 没有提供 key</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>React 会在控制台打印出报警信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Warning: Each child <span class="keyword">in</span> an array or iterator should have a unique <span class="string">"key"</span> prop. Check the render method of `App`. See https://fb.me/react-warning-keys <span class="keyword">for</span> more information.</span><br></pre></td></tr></table></figure></p>
<p>你必须为数组中的元素提供唯一的 <code>key</code> 属性，就像下面这样：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> UserList = props =&gt; (</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>用户列表<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    &#123;props.users.map(u =&gt; <span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&#123;u.id&#125;</span>&gt;</span>&#123;u.id&#125;:&#123;u.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>)&#125;  // 提供了 key</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>为什么呢？我们知道当组件的属性发生了变化，其 render 方法会被重新调用，组件会被重新渲染。比如 UserList 组件的 users 属性改变了，就得重新渲染 UserList 组件，包括外部的 <code>&lt;div&gt;</code>（容器），内部的一个 <code>&lt;h3&gt;</code> 和若干个 <code>&lt;div&gt;</code>（每一个描述一个用户）。</p>
<p>对后一种 <code>&lt;div&gt;</code>（表示用户的），由于其处在一个长度不确定的数组中，React 需要判断，对数组中的每一项，到底是新建一个元素加入到页面中，还是更新原来的元素。比如以下几种情况：</p>
<ul>
<li><code>[{name: &#39;张三&#39;, age: 20}]</code> =&gt; <code>[{name: &#39;张三&#39;, age: 21}]</code>：这种情况明显只需要更新元素，没有必要重新创建元素。因为人还是那个人，除了 age，其他信息没有变，显示用户姓名的那个（更小的）元素，是不需要更新（被 ReactDOM 操作到）的。</li>
<li><code>[{name: &#39;张三&#39;}]</code> =&gt; <code>[{name: &#39;张三&#39;}, {name: &#39;李四&#39;}]</code> 这种情况，显然需要添加一个新元素来表示李四，这个新元素对应的 DOM 元素会被插入到页面中。</li>
<li><code>[{name: &#39;张三&#39;}]</code> =&gt; <code>[{name: &#39;李四&#39;}]</code>：这种情况就有点复杂了，似乎两种方案都可以。可以把表示张三的元素删掉，为李四新建一个，当然是非常合理的选择。但是直接把张三的元素换成李四，似乎也无不可。</li>
</ul>
<p>实际上，如果真的认为上述第3种的后一种方案也无不可，那可是大错特错了。为什么呢：</p>
<ul>
<li>考虑这种情况：<code>[{name: &#39;张三&#39;}, {name: &#39;李四&#39;}]</code> =&gt; <code>[{name: &#39;李四&#39;}, {name: &#39;张三&#39;}]</code>，难道也需要把张三的元素更新成李四的，李四的元素更新成张三的吗？</li>
</ul>
<p>那么，为数组中的元素传一个唯一的 key（比如用户的 ID），就很好地解决了这个问题。React 比较更新前后的元素 key 值，如果相同则更新，如果不同则销毁之前的，重新创建一个元素。</p>
<p>那么，为什么只有数组中的元素需要有唯一的 key，而其他的元素（比如上面的<code>&lt;h3&gt;用户列表&lt;/h3&gt;</code>）则不需要呢？答案是：React 有能力辨别出，更新前后元素的对应关系。这一点，也许直接看 JSX 不够明显，看 Babel 转换后的 React.createElement 则清晰很多：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转换前</span></span><br><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>example<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    &#123;[<span class="tag">&lt;<span class="name">p</span> <span class="attr">key</span>=<span class="string">&#123;1&#125;</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span>, <span class="tag">&lt;<span class="name">p</span> <span class="attr">key</span>=<span class="string">&#123;2&#125;</span>&gt;</span>world<span class="tag">&lt;/<span class="name">p</span>&gt;</span>]&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换后</span></span><br><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> element = React.createElement(</span><br><span class="line">  <span class="string">"div"</span>,</span><br><span class="line">  <span class="literal">null</span>,</span><br><span class="line">  React.createElement(<span class="string">"h3"</span>,<span class="literal">null</span>,<span class="string">"example"</span>),</span><br><span class="line">  [</span><br><span class="line">    React.createElement(<span class="string">"p"</span>,&#123; key: <span class="number">1</span> &#125;,<span class="string">"hello"</span>), </span><br><span class="line">    React.createElement(<span class="string">"p"</span>,&#123; key: <span class="number">2</span> &#125;,<span class="string">"world"</span>)</span><br><span class="line">  ]</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>不管 props 如何变化，数组外的每个元素始终出现在 React.createElement() 参数列表中的固定位置，这个位置就是天然的 key。</p>
<blockquote>
<p>题外话</p>
<p>初学 React 时还容易产生另一个困惑，那就是为什么 JSX 不支持 if 表达式来有选择地输出（不能这样：<code>{if(yes){ &lt;div {...props}/&gt; }}</code>），而必须采用三元运算符来完成这项工作（必须这样：<code>{yes ? &lt;div {...props}/&gt;} : null</code>）。那是因为，React 需要一个 null 去占住那个元素本来的位置。</p>
</blockquote>
<p>曾经，我天真的以为 <code>key</code> 这个元素只应在数组中使用。直到我在一个复杂的项目中写出了及其恶心的 <code>componentWillReceiveProps</code>方法。我尝试寻找销毁和重建组件，触发 <code>componentDidMount</code> 方法，重置 <code>state</code>，然后才突然发现 <code>key</code> 这个属性已经在那里了。</p>
<p>举个例子，我们有一个展示用户信息的 <code>UserDashboard</code> 组件。传给组件的 <code>props</code> 只有用户的 基本信息（ID，姓名等），而有关用户的详细信息（比如当前是否在线等）是需要请求过来的。组件内的一些操作（比如尝试与该用户聊天）也会使用请求，组件本身也有各种状态（比如是否显示聊天框）。</p>
<p>整个界面上最多只有一个 <code>UserDashboard</code>，但某些操作（比如点击旁边的 <code>UserList</code>）可能会切换 <code>UserDashboard</code> 的目标用户，那么问题就来了：当目标用户切换的时候，<code>UserDashboard</code> 仅仅是一个普通的<strong>更新</strong>操作，触发的是 <code>componentWillReceiveProps</code>，<code>shouldComponentUpdate</code>，<code>componentWillUpdate</code>，<code>componentDidUpdate</code> 这一套方法。我们需要在 <code>componentWillReceiveProps</code> 中做太多的事情：检测这次 props 的更新是否改变了用户的 ID，如果是的话，我们需要检查 <code>UserDashboard</code> 发出去的请求是否都得到了响应，对还未收到响应的请求注销其响应函数（否则上一个用户的在线状态有可能显示在这一个用户上）；我们还要更新 <code>UserDashboard</code> 上的几乎所有状态（切换用户的时候总要把聊天框关闭吧）；如果我们还不幸地用的 <code>ref</code> 做了一些神奇的 hack，那么你还要去手动把之前做的事情复原回来，这简直要成一团乱麻了！当 <code>UserDashborad</code> 的逻辑，你的 <code>componentWillReceiveProps</code> 方法里会充斥着晦涩难懂的只有你能看懂的代码（两周后你自己也看不懂了）。</p>
<p>解决方案是什么？就是用 <code>key</code> 属性。在 JSX 中使用 <code>UserDashboard</code> 的时候，不仅把 <code>userInfo</code> 传入，把 <code>userInfo.id</code> 作为名为 <code>key</code> 的 <code>props</code> 传入（尽管 <code>UserDashboard</code> 不是数组中的组件）。这样切换目标用户的时候，<code>key</code> 属性也变了，React 会自动销毁之前的组件，用一个全新的组件来渲染新的用户：我们可以从容地在 <code>componentWillUnmount</code> 里作清理工作（注销请求的响应函数，防止其更新一个 unmounted component），至于重置 <code>state</code> 这些工作已经不需要做了，由于组件不再是更新，而是销毁和重建，已经是天然完成的。</p>
<p>当然，你可以质疑这样做是否会影响性能。我认为，只要目标用户的切换不够频繁，对性能的影响是很小的。如果不使用 <code>key</code> 触发组件的销毁和重建，任由组件自行「更新」，每次切换时更新的内容也是很多的。这时，我们使用 <code>key</code> 带来的性能损耗是完全可以接受的，而带来的收益却非常大。</p>
<p>所以，我想说的结论是：为了组件内部逻辑的清晰，你几乎应该在任何复杂的有状态组件（尤其是有具体<strong>对应</strong>对象的）上使用<code>key</code>属性（只要 <code>key</code> 属性的改变不是很频繁），这样做，才能在合适的时候触发组件的销毁与重建，组件才能有一个健康的生命周期。</p>
<blockquote>
<p>题外话</p>
<p>配合 react-router 时，通常要为 route 组件赋 key，但通常情况下我们是没法传 props 给 route 组件的。解决的方案是 <code>createElement</code> 方法，如下所示。</p>
</blockquote>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">class App extends Component </span><span class="template-variable">&#123;</span><br><span class="line">  static createElement = (Component, ownProps) =&gt; &#123;</span><br><span class="line">    const &#123;userId&#125;</span><span class="xml"> = ownProps.params;</span><br><span class="line">    switch (Component) </span><span class="template-variable">&#123;</span><br><span class="line">      case UserDashboard:</span><br><span class="line">        return &lt;Component key=&#123;userId&#125;</span><span class="xml"> </span><span class="template-variable">&#123;...ownProps&#125;</span><span class="xml">/&gt;;</span><br><span class="line">      default:</span><br><span class="line">        return <span class="tag">&lt;<span class="name">Component</span> </span></span><span class="template-variable">&#123;...ownProps&#125;</span><span class="xml"><span class="tag">/&gt;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  render() </span><span class="template-variable">&#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;Provider store=&#123;store&#125;</span><span class="xml">&gt;</span><br><span class="line">        <span class="tag">&lt;<span class="name">Router</span> <span class="attr">createElement</span>=</span></span><span class="template-variable">&#123;App.createElement&#125;</span><span class="xml"><span class="tag"> </span><br><span class="line">                <span class="attr">history</span>=</span></span><span class="template-variable">&#123;syncHistoryWithStore(hashHistory, store)&#125;</span><span class="xml"><span class="tag">&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">"/"</span> <span class="attr">component</span>=</span></span><span class="template-variable">&#123;Home&#125;</span><span class="xml"><span class="tag">&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">IndexRoute</span> <span class="attr">component</span>=</span></span><span class="template-variable">&#123;Index&#125;</span><span class="xml"><span class="tag">/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">"users/:userId"</span> <span class="attr">component</span>=</span></span><span class="template-variable">&#123;UserDashboard&#125;</span><span class="xml"><span class="tag">/&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Router</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>（完）</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="//img.alicdn.com/tfs/TB1sJ2wMVXXXXbyaXXXXXXXXXXX-900-500.jpg" alt="React 实践心得：key 属性的原理和用法"></p>
<p>我们知道，React 元素可以具有一个特殊的属性 ke]]>
    </summary>
    
      <category term="React" scheme="http://taobaofed.org/tags/React/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[React 实践心得：react-redux 之 connect 方法详解]]></title>
    <link href="http://taobaofed.org/blog/2016/08/18/react-redux-connect/"/>
    <id>http://taobaofed.org/blog/2016/08/18/react-redux-connect/</id>
    <published>2016-08-18T07:15:12.000Z</published>
    <updated>2016-12-21T02:40:37.000Z</updated>
    <content type="html"><![CDATA[<p><img src="//img.alicdn.com/tfs/TB1fYYeLpXXXXbtXFXXXXXXXXXX-900-500.jpg" alt="React 实践心得：react-redux 之 connect 方法详解"></p>
<p>Redux 是「React 全家桶」中极为重要的一员，它试图为 React 应用提供「可预测化的状态管理」机制。Redux 本身足够简单，除了 React，它还能够支持其他界面框架。所以如果要将 Redux 和 React 结合起来使用，就还需要一些额外的工具，其中最重要的莫过于 react-redux 了。</p>
<p>react-redux 提供了两个重要的对象，<code>Provider</code> 和 <code>connect</code>，前者使 React 组件可被连接（connectable），后者把 React 组件和 Redux 的 store 真正连接起来。react-redux 的文档中，对 <code>connect</code> 的描述是一段晦涩难懂的英文，在初学 redux 的时候，我对着这段文档阅读了很久，都没有全部弄明白其中的意思（大概就是，单词我都认识，连起来啥意思就不明白了的感觉吧）。</p>
<p>在使用了一段时间 redux 后，本文尝试再次回到这里，给<a href="https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options" target="_blank" rel="external">这段文档</a>（同时摘抄在附录中）一个靠谱的解读。</p>
<h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>首先回顾一下 redux 的基本用法。如果你还没有阅读过 redux 的文档，你一定要先去<a href="https://github.com/reactjs/redux/blob/master/docs/README.md" target="_blank" rel="external">阅读一下</a>。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reducer = (state = &#123;count: <span class="number">0</span>&#125;, action) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'INCREASE'</span>: <span class="keyword">return</span> &#123;count: state.count + <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'DECREASE'</span>: <span class="keyword">return</span> &#123;count: state.count - <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">  increase: () =&gt; (&#123;type: <span class="string">'INCREASE'</span>&#125;),</span><br><span class="line">  decrease: () =&gt; (&#123;type: <span class="string">'DECREASE'</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer);</span><br><span class="line"></span><br><span class="line">store.subscribe(() =&gt;</span><br><span class="line">  <span class="built_in">console</span>.log(store.getState())</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">store.dispatch(actions.increase()) <span class="comment">// &#123;count: 1&#125;</span></span><br><span class="line">store.dispatch(actions.increase()) <span class="comment">// &#123;count: 2&#125;</span></span><br><span class="line">store.dispatch(actions.increase()) <span class="comment">// &#123;count: 3&#125;</span></span><br></pre></td></tr></table></figure>
<p>通过 <code>reducer</code> 创建一个 <code>store</code>，每当我们在 <code>store</code> 上 <code>dispatch</code> 一个 <code>action</code>，<code>store</code> 内的数据就会相应地发生变化。</p>
<p>我们当然可以<strong>直接</strong>在 React 中使用 Redux：在最外层容器组件中初始化 <code>store</code>，然后将 <code>state</code> 上的属性作为 <code>props</code> 层层传递下去。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  componentWillMount()&#123;</span><br><span class="line">    store.subscribe((state)=&gt;<span class="keyword">this</span>.setState(state))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Comp</span> <span class="attr">state</span>=<span class="string">&#123;this.state&#125;</span></span><br><span class="line">                 <span class="attr">onIncrease</span>=<span class="string">&#123;()</span>=&gt;</span>store.dispatch(actions.increase())&#125;</span><br><span class="line">                 onDecrease=&#123;()=&gt;store.dispatch(actions.decrease())&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>但这并不是最佳的方式。最佳的方式是使用 react-redux 提供的 <code>Provider</code> 和 <code>connect</code> 方法。</p>
<h2 id="使用-react-redux"><a href="#使用-react-redux" class="headerlink" title="使用 react-redux"></a>使用 react-redux</h2><p>首先在最外层容器中，把所有内容包裹在 <code>Provider</code> 组件中，将之前创建的 <code>store</code> 作为 <code>prop</code> 传给 <code>Provider</code>。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> App = () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Comp</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>Provider</code> 内的任何一个组件（比如这里的 <code>Comp</code>），如果需要使用 <code>state</code> 中的数据，就必须是「被 connect 过的」组件——使用 <code>connect</code> 方法对「你编写的组件（<code>MyComp</code>）」进行包装后的产物。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComp</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// content...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Comp = connect(...args)(MyComp);</span><br></pre></td></tr></table></figure>
<p>可见，<code>connect</code> 方法是重中之重。</p>
<h2 id="connect-详解"><a href="#connect-详解" class="headerlink" title="connect 详解"></a><code>connect</code> 详解</h2><p>究竟 <code>connect</code> 方法到底做了什么，我们来一探究竟。</p>
<p>首先看下函数的签名：</p>
<blockquote>
<p>connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])</p>
</blockquote>
<p><code>connect()</code> 接收四个参数，它们分别是 <code>mapStateToProps</code>，<code>mapDispatchToProps</code>，<code>mergeProps</code>和<code>options</code>。</p>
<h3 id="mapStateToProps-state-ownProps-stateProps"><a href="#mapStateToProps-state-ownProps-stateProps" class="headerlink" title="mapStateToProps(state, ownProps) : stateProps"></a><code>mapStateToProps(state, ownProps) : stateProps</code></h3><p>这个函数允许我们将 <code>store</code> 中的数据作为 <code>props</code> 绑定到组件上。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapStateToProps = (state) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    count: state.count</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的第一个参数就是 Redux 的 <code>store</code>，我们从中摘取了 <code>count</code> 属性。因为返回了具有 <code>count</code> 属性的对象，所以 <code>MyComp</code> 会有名为 <code>count</code> 的 <code>props</code> 字段。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComp</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>计数：&#123;this.props.count&#125;次<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Comp = connect(...args)(MyComp);</span><br></pre></td></tr></table></figure>
<p>当然，你不必将 <code>state</code> 中的数据原封不动地传入组件，可以根据 <code>state</code> 中的数据，动态地输出组件需要的（最小）属性。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapStateToProps = (state) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    greaterThanFive: state.count &gt; <span class="number">5</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数的第二个参数 <code>ownProps</code>，是 <code>MyComp</code> 自己的 <code>props</code>。有的时候，<code>ownProps</code> 也会对其产生影响。比如，当你在 <code>store</code> 中维护了一个用户列表，而你的组件 <code>MyComp</code> 只关心一个用户（通过 <code>props</code> 中的 <code>userId</code> 体现）。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapStateToProps = (state, ownProps) =&gt; &#123;</span><br><span class="line">  <span class="comment">// state 是 &#123;userList: [&#123;id: 0, name: '王二'&#125;]&#125;</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    user: _.find(state.userList, &#123;id: ownProps.userId&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComp</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> PropTypes = &#123;</span><br><span class="line">    userId: PropTypes.string.isRequired,</span><br><span class="line">    user: PropTypes.object</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>用户名：&#123;this.props.user.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Comp = connect(mapStateToProps)(MyComp);</span><br></pre></td></tr></table></figure>
<p>当 <code>state</code> 变化，或者 <code>ownProps</code> 变化的时候，<code>mapStateToProps</code> 都会被调用，计算出一个新的 <code>stateProps</code>，（在与 <code>ownProps</code> merge 后）更新给 <code>MyComp</code>。</p>
<p>这就是将 Redux <code>store</code> 中的数据连接到组件的基本方式。</p>
<h3 id="mapDispatchToProps-dispatch-ownProps-dispatchProps"><a href="#mapDispatchToProps-dispatch-ownProps-dispatchProps" class="headerlink" title="mapDispatchToProps(dispatch, ownProps): dispatchProps"></a><code>mapDispatchToProps(dispatch, ownProps): dispatchProps</code></h3><p><code>connect</code> 的第二个参数是 <code>mapDispatchToProps</code>，它的功能是，将 action 作为 <code>props</code> 绑定到 <code>MyComp</code> 上。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapDispatchToProps = (dispatch, ownProps) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    increase: (...args) =&gt; dispatch(actions.increase(...args)),</span><br><span class="line">    decrease: (...args) =&gt; dispatch(actions.decrease(...args))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComp</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;count, increase, decrease&#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>计数：&#123;this.props.count&#125;次<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;increase&#125;</span>&gt;</span>增加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;decrease&#125;</span>&gt;</span>减少<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Comp = connect(mapStateToProps， mapDispatchToProps)(MyComp);</span><br></pre></td></tr></table></figure>
<p>由于 <code>mapDispatchToProps</code> 方法返回了具有 <code>increase</code> 属性和 <code>decrease</code> 属性的对象，这两个属性也会成为 <code>MyComp</code> 的 <code>props</code>。</p>
<p>如上所示，调用 <code>actions.increase()</code> 只能得到一个 <code>action</code> 对象 <code>{type:&#39;INCREASE&#39;}</code>，要触发这个 <code>action</code> 必须在 <code>store</code> 上调用 <code>dispatch</code> 方法。<code>diapatch</code> 正是 <code>mapDispatchToProps</code> 的第一个参数。但是，为了不让 <code>MyComp</code> 组件感知到 <code>dispatch</code> 的存在，我们需要将 <code>increase</code> 和 <code>decrease</code> 两个函数包装一下，使之成为直接可被调用的函数（即，调用该方法就会触发 <code>dispatch</code>）。</p>
<p>Redux 本身提供了 <code>bindActionCreators</code> 函数，来将 action 包装成直接可被调用的函数。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;bindActionCreators&#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps = (dispatch, ownProps) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> bindActionCreators(&#123;</span><br><span class="line">    increase: action.increase,</span><br><span class="line">    decrease: action.decrease</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样，当 <code>ownProps</code> 变化的时候，该函数也会被调用，生成一个新的 <code>dispatchProps</code>，（在与 <code>statePrope</code> 和 <code>ownProps</code> merge 后）更新给 <code>MyComp</code>。注意，<code>action</code> 的变化不会引起上述过程，默认 <code>action</code> 在组件的生命周期中是固定的。</p>
<h3 id="mergeProps-stateProps-dispatchProps-ownProps-props"><a href="#mergeProps-stateProps-dispatchProps-ownProps-props" class="headerlink" title="[mergeProps(stateProps, dispatchProps, ownProps): props]"></a><code>[mergeProps(stateProps, dispatchProps, ownProps): props]</code></h3><p>之前说过，不管是 <code>stateProps</code> 还是 <code>dispatchProps</code>，都需要和 <code>ownProps</code> merge 之后才会被赋给 <code>MyComp</code>。<code>connect</code> 的第三个参数就是用来做这件事。通常情况下，你可以不传这个参数，<code>connect</code> 就会使用 <code>Object.assign</code> 替代该方法。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>最后还有一个 <code>options</code> 选项，比较简单，基本上也不大会用到（尤其是你遵循了其他的一些 React 的「最佳实践」的时候），本文就略过了。希望了解的同学可以直接看文档。</p>
<p>（完）</p>
<h2 id="附：connect-方法的官方英文文档"><a href="#附：connect-方法的官方英文文档" class="headerlink" title="附：connect 方法的官方英文文档"></a>附：connect 方法的官方英文文档</h2><blockquote>
<h4 id="connect-mapStateToProps-mapDispatchToProps-mergeProps-options"><a href="#connect-mapStateToProps-mapDispatchToProps-mergeProps-options" class="headerlink" title="connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])"></a><code>connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])</code></h4><p>Connects a React component to a Redux store.</p>
<p>It does not modify the component class passed to it. Instead, it returns a new, connected component class, for you to use.</p>
<h4 id="Arguments"><a href="#Arguments" class="headerlink" title="Arguments"></a>Arguments</h4><ul>
<li><p>[mapStateToProps(state, [ownProps]): stateProps] (Function): If specified, the component will subscribe to Redux store updates. Any time it updates, mapStateToProps will be called. Its result must be a plain object*, and it will be merged into the component’s props. If you omit it, the component will not be subscribed to the Redux store. If ownProps is specified as a second argument, its value will be the props passed to your component, and mapStateToProps will be additionally re-invoked whenever the component receives new props (e.g. if props received from a parent component have shallowly changed, and you use the ownProps argument, mapStateToProps is re-evaluated).</p>
</li>
<li><p>[mapDispatchToProps(dispatch, [ownProps]): dispatchProps] (Object or Function): If an object is passed, each function inside it will be assumed to be a Redux action creator. An object with the same function names, but with every action creator wrapped into a dispatch call so they may be invoked directly, will be merged into the component’s props. If a function is passed, it will be given dispatch. It’s up to you to return an object that somehow uses dispatch to bind action creators in your own way. (Tip: you may use the bindActionCreators() helper from Redux.) If you omit it, the default implementation just injects dispatch into your component’s props. If ownProps is specified as a second argument, its value will be the props passed to your component, and mapDispatchToProps will be re-invoked whenever the component receives new props.</p>
</li>
<li><p>[mergeProps(stateProps, dispatchProps, ownProps): props] (Function): If specified, it is passed the result of mapStateToProps(), mapDispatchToProps(), and the parent props. The plain object you return from it will be passed as props to the wrapped component. You may specify this function to select a slice of the state based on props, or to bind action creators to a particular variable from props. If you omit it, Object.assign({}, ownProps, stateProps, dispatchProps) is used by default.</p>
</li>
<li><p>[options] (Object) If specified, further customizes the behavior of the connector.</p>
<ul>
<li>[pure = true] (Boolean): If true, implements shouldComponentUpdate and shallowly compares the result of mergeProps, preventing unnecessary updates, assuming that the component is a “pure” component and does not rely on any input or state other than its props and the selected Redux store’s state. Defaults to true.</li>
<li>[withRef = false] (Boolean): If true, stores a ref to the wrapped component instance and makes it available via getWrappedInstance() method. Defaults to false.</li>
</ul>
</li>
</ul>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="//img.alicdn.com/tfs/TB1fYYeLpXXXXbtXFXXXXXXXXXX-900-500.jpg" alt="React 实践心得：react-redux 之 connect 方法详解"></p>
<p>Redux 是「React]]>
    </summary>
    
      <category term="React" scheme="http://taobaofed.org/tags/React/"/>
    
      <category term="Redux" scheme="http://taobaofed.org/tags/Redux/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[高性能 React 组件]]></title>
    <link href="http://taobaofed.org/blog/2016/08/12/optimized-react-components/"/>
    <id>http://taobaofed.org/blog/2016/08/12/optimized-react-components/</id>
    <published>2016-08-12T02:44:11.000Z</published>
    <updated>2016-12-21T02:40:37.000Z</updated>
    <content type="html"><![CDATA[<p><img src="//img.alicdn.com/tfs/TB1P4h_LpXXXXbGXpXXXXXXXXXX-900-500.jpg" alt="高性能 React 组件"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="组件的重新渲染"><a href="#组件的重新渲染" class="headerlink" title="组件的重新渲染"></a>组件的重新渲染</h2><p>说到 React 组件，肯定离不开组件的 props 和 state，我们可以在 props 和 state 存放任何类型的数据，通过改变 props 和 state，去控制整个组件的状态。当 props 和 state 发生变化时，React 会重新渲染整个组件，组件重新渲染的过程可简化如下图：</p>
<p><img src="http://img1.tbcdn.cn/L1/461/1/c3c7f7f478d86c40530967b5b0fc12037bc71d22" alt="1"></p>
<p>当组件的 props 或 state 变化，React 将会构建新的 virtual DOM，使用 diff 算法把新老的 virtual DOM 进行比较，如果新老 virtual DOM 树不相等则重新渲染，相等则不重新渲染。DOM 操作是非常耗时的，这导致重新渲染也非常的耗时，因此要提高组件的性能就应该尽一切可能的减少组件的重新渲染。</p>
<p>假设有一个渲染完成的组件，如下图：</p>
<p><img src="http://img3.tbcdn.cn/L1/461/1/c9a9e30223ef6188a4a498a8cfd92e346ba5c17d" alt="2"></p>
<p>接下来因为状态改变，需要重新渲染下图的绿色的节点，如下图：</p>
<p><img src="http://img4.tbcdn.cn/L1/461/1/7a8b26b7b14319ae4bfedf385fcb092ac33927a4" alt="3"></p>
<p>一般的想法是只需要更新下面的三个绿色节点就能够完成组件的更新，如下图：</p>
<p><img src="http://img4.tbcdn.cn/L1/461/1/5519a489525ef4b43ca636c2d05890f4cdbb8c94" alt="4"></p>
<p>事实上根据 React 的更新规则，只要组件的 props 或 state 发生了变化就会重新渲染整个组件，因此除了上述的三个绿色节点以外，还需要重新渲染所有的黄色的节点，如下图：</p>
<p><img src="http://img3.tbcdn.cn/L1/461/1/ca1f450b3816ce5fa3411be1710ecc76d7552765" alt="5"></p>
<p>除了必要渲染的三个节点外，还渲染了其他不必要渲染的节点，这对性能是一个很大的浪费。如果对于复杂的页面，这将导致页面的整体体验效果非常差。因此要提高组件的性能，就应该想尽一切方法减少不必要的渲染。</p>
<h1 id="组件优化"><a href="#组件优化" class="headerlink" title="组件优化"></a>组件优化</h1><h2 id="Pure-Component"><a href="#Pure-Component" class="headerlink" title="Pure Component"></a>Pure Component</h2><p>如果一个组件只和 props 和 state 有关系，给定相同的 props 和 state 就会渲染出相同的结果，那么这个组件就叫做纯组件，换一句话说纯组件只依赖于组件的 props 和 state，下面的代码表示的就是一个纯组件。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">render</span>() &#123;</span><br><span class="line">     <span class="selector-tag">return</span> (</span><br><span class="line">         &lt;div style=&#123;&#123;<span class="attribute">width</span>: this.props.width&#125;&#125;&gt;</span><br><span class="line">                  &#123;this<span class="selector-class">.state</span><span class="selector-class">.rows</span>&#125;</span><br><span class="line">         &lt;/div&gt;</span><br><span class="line">     );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h2><p><code>shouldComponentUpdate</code> 这个函数会在组件重新渲染之前调用，函数的返回值确定了组件是否需要重新渲染。函数默认的返回值是 <code>true</code>，意思就是只要组件的 props 或者 state 发生了变化，就会重新构建 virtual DOM，然后使用 diff 算法进行比较，再接着根据比较结果决定是否重新渲染整个组件。函数的返回值为 <code>false</code> 表示不需要重新渲染。 <code>shouldComponentUpdate</code> 在组件的重新渲染的过程中的位置如下图：</p>
<p><img src="http://img1.tbcdn.cn/L1/461/1/354dc8a5e804e06986dae35a92309ec7685499d9" alt="6"></p>
<p>函数默认返回为 <code>true</code>，表示在任何情况下都进行重新渲染的操作，要减少重新渲染，只需要在一些不必要重新渲染的时候，使得函数的返回结果为 <code>false</code>。如果使得函数的结果一直为 <code>false</code>，这样不管组件的状态怎么变化，组件都不会重新渲染，当然一般情况下没有人会这样干。</p>
<h2 id="PureRenderMixin"><a href="#PureRenderMixin" class="headerlink" title="PureRenderMixin"></a>PureRenderMixin</h2><p>React 官方提供了 PureRenderMixin 插件，插件的功能就是在不必要的情况下让函数 <code>shouldComponentUpdate</code> 返回 <code>false</code>, 使用这个插件就能够减少不必要的重新渲染，得到一定程度上的性能提升，其使用方法如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="type">PureRenderMixin</span> from <span class="symbol">'react</span>-addons-pure-render-mixin';</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.shouldComponentUpdate = <span class="type">PureRenderMixin</span>.shouldComponentUpdate.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;div className=&#123;<span class="keyword">this</span>.props.className&#125;&gt;foo&lt;/div&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看源码后发现这个插件其实就是重写了 <code>shouldComponentUpdate</code> 方法。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">	<span class="keyword">return</span> shallowCompare(<span class="keyword">this</span>, nextProps, nextState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重写的方法里面根据组件的目前的状态和组件接下来的状态进行<code>浅比较</code>，如果组件的状态发生变化则返回结果为 <code>false</code>，状态没有发生变化则返回结果为 <code>true</code>，把这个函数进行进一步的分解其实现如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">	<span class="keyword">return</span> !shallowEqual(<span class="keyword">this</span>.props, nextProps) ||</span><br><span class="line">			!shallowEqual(<span class="keyword">this</span>.state, nextState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是分别去比较了函数的 props 和 state 的变化情况。</p>
<p>在 React 的最新版本里面，提供了 <code>React.PureComponent</code> 的基础类，而不需要使用这个插件。</p>
<h2 id="状态比较"><a href="#状态比较" class="headerlink" title="状态比较"></a>状态比较</h2><p>假设在每一个组件中都使用 PureRenderMixin 这个插件，我们来看一下使用这个插件后的状态的比较过程。假设我们有一个组件如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Input</span> <span class="attr">size</span>=<span class="string">&#123;100&#125;</span> <span class="attr">color</span>=<span class="string">'red'</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们想要去改变这个组件的颜色，使其变为 <code>blue</code>，</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Input</span> <span class="attr">size</span>=<span class="string">&#123;100&#125;</span> <span class="attr">color</span>=<span class="string">'blue'</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>则状态的比较就是下面的对象的比较。</p>
<p><img src="http://img4.tbcdn.cn/L1/461/1/72ca4706b371e37deaa3d63a3427c992b6b6911d" alt="7"></p>
<p>上图的比较是简单对象的比较，比较过程非常简单而且快速。但是如果是比较复杂的对象的比较，比如日期、函数或者一些复杂的嵌套许多层的对象，这些会比较耗时，甚至没法进行比较。</p>
<p>其实我们自己可以重写 <code>shouldComponentUpdate</code> 这个函数，使得其能够对任何事物进行比较，也就是<code>深比较</code>（通过一层一层的递归进行比较），深比较是很耗时的，一般不推荐这么干，因为要保证比较所花的时间少于重新渲染的整个组件所花的时间，同时为了减少比较所花的时间我们应该保证 props 和 state 尽量简单，不要把不必要的属性放入 state，能够由其他属性计算出来的属性也不要放入 state 中。</p>
<h2 id="Immutable-js"><a href="#Immutable-js" class="headerlink" title="Immutable.js"></a>Immutable.js</h2><p>对于复杂的数据的比较是非常耗时的，而且可能无法比较，通过使用 Immutable.js  能够很好地解决这个问题，Immutable.js 的基本原则是对于不变的对象返回相同的引用，而对于变化的对象，返回新的引用。因此对于状态的比较只需要使用如下代码即可：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate() &#123;</span><br><span class="line">	<span class="keyword">return</span> ref1 !== ref2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这类比较是非常快速的。</p>
<h2 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h2><p>假设我们有一个下面这样的组件：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ScrollTable</span><br><span class="line">	<span class="attribute">width</span>=&#123;<span class="number">300</span>&#125;</span><br><span class="line">	<span class="attribute">color</span>=<span class="string">'blue'</span></span><br><span class="line">	scrollTop=&#123;this<span class="selector-class">.props</span><span class="selector-class">.offsetTop</span>&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>
<p>这是一个可以滚动的表格，<code>offsetTop</code> 代表着可视区距离浏览器的的上边界的距离，随着鼠标的滚动，这个值将会不断的发生变化，导致组件的 props 不断地发生变化，组件也将会不断的重新渲染。如果使用下面的这种写法：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">OuterScroll</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">InnerTable</span> <span class="attr">width</span>=<span class="string">&#123;300&#125;</span> <span class="attr">color</span>=<span class="string">'blue'</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">OuterScroll</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>因为 <code>InnerTable</code> 这个组件的 props 是固定的不会发生变化，在这个组件里面使用 <code>pureRenderMixin</code> 插件，能够保证 <code>shouldComponentUpdate</code> 的返回一直为 <code>false</code>， 因此不管组件的父组件也就是 <code>OuterScroll</code> 组件的状态是怎么变化，组件 <code>InnerTable</code> 都不会重新渲染。也就是子组件隔离了父组件的状态变化。</p>
<p>通过把变化的属性和不变的属性进行分离，减少了重新渲染，获得了性能的提升，同时这样做也能够让组件更容易进行分离，更好的被复用。</p>
<h2 id="Children"><a href="#Children" class="headerlink" title="Children"></a>Children</h2><p>对于嵌套多层、复杂的组件，组件的子节点很多，组件的更新的时间也将花费更多，并且难于维护，信息流从上往下由父组件传递到子组件单向流动，这可能会导致组件失去我们的控制。</p>
<h3 id="children-change-over-time"><a href="#children-change-over-time" class="headerlink" title="children change over time"></a>children change over time</h3><p>有如下的一个组件（现实中没人会这样写，这只是一个 demo），组件每 1 秒渲染一次。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    shouldComponentUpdate(nextProps) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.props.children != nextProps.children;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> &lt;div&gt;&#123;<span class="keyword">this</span>.props.children&#125;&lt;/div&gt;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setInterval(() =&gt; &#123;</span><br><span class="line">    <span class="type">ReactDOM</span>.render(</span><br><span class="line">        &lt;<span class="type">Parent</span>&gt;</span><br><span class="line">            &lt;div&gt;child&lt;/div&gt;</span><br><span class="line">        &lt;/<span class="type">Parent</span>&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>通过在 <code>shouldComponentUpdate</code> 函数里面判断组件的 children 是否相等决定是否重新进行渲染，由于 children 是 props 的一个属性，应该每次都是一样的，组件应该不会重新渲染，可是事实上组件每次都会重新渲染。</p>
<p>让我们来看一下，children 的具体结构，如下图：</p>
<p><img src="http://img4.tbcdn.cn/L1/461/1/63cb24b655ca5fd9cec7168d0716fd0be7a7f854" alt="8"></p>
<p>children 是一个比较复杂的对象，每次组件更新的时候都会重新构造，也就是说 children 是动态构建的，因此每次更新的时候都是不相等的。所以 <code>shouldComponentUpdate</code> 每次都会返回 <code>true</code>，因此组件每次都会重新渲染。可以用一个变量来代替 children，这样每次构造的也会是相同的对象。</p>
<h3 id="Independent-children"><a href="#Independent-children" class="headerlink" title="Independent children"></a>Independent children</h3><p>再来看一个比较费力的做法，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoColumnSplit</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    shouldComponentUpdate() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">FloatLeft</span>&gt;</span>&#123;this.props.children[0]&#125;<span class="tag">&lt;/<span class="name">FloatLeft</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">FloatRight</span>&gt;</span>&#123;this.props.children[1]&#125;<span class="tag">&lt;/<span class="name">FloatRight</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;TwoColumnSplit&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">TargetContainer</span>/&gt;</span></span></span><br><span class="line">    &lt;BudgetContainer/&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">TwoColumnSplit</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>通过在 <code>shouldComponentUpdate</code> 中返回 <code>false</code>，组件将不会因为外界的状态变化而发生改变，我们这样做是因为组件 <code>TargetContainer</code> 和 <code>BudgetContainer</code> 没有从它们的父元素获取任何信息，这样就不需要管外界的变化，把 children 和父组件进行了隔离，其实 <code>TwoColumnSplit</code> 就是起了隔离的作用。对于不需要从外界获取数据的组件，可以通过返回 <code>false</code> 来隔离外界的变化，减少重新渲染。</p>
<h2 id="Container-and-Component"><a href="#Container-and-Component" class="headerlink" title="Container and Component"></a>Container and Component</h2><p>我们也可以通过组件的容器来隔离外界的变化。容器就是一个数据层，而组件就是专门负责渲染，不进行任何数据交互，只根据得到的数据渲染相应的组件，下面就是一个容器以及他的组件。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BudgetContainer</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.shouldComponentUpdate = <span class="type">PureRenderMixin</span>.shouldComponentUpdate.bind(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    computeState() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">BudgetStore</span>.getStore()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> &lt;<span class="type">Budget</span> &#123;...<span class="keyword">this</span>.state&#125;/&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>容器不应该有 props 和 children，这样就能够把容器自己和父组件进行隔离，不会因为外界因素去重新渲染，也没有必要重新渲染。</p>
<p>设想一下，如果设计师觉得这个组件需要移动位置，你不需要做任何的更改只需要把组件放到对应的位置即可，我们可以把它移到任何地方，可以放在不同的应用中，同时也可以应用于测试，我们只需要关心容器的内部的数据的来源即可，在不同的环境中编写不同的容器。</p>
<p><img src="http://img1.tbcdn.cn/L1/461/1/c74de69b05661a277c6e9ad2ab12775b706af4d6" alt="9"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li><p>Purity =&gt; Use shouldComponentUpdate &amp; PureRenderMixin</p>
</li>
<li><p>Data Comparability =&gt; Use highly comparable data (immutability)</p>
</li>
<li><p>Loose coupling =&gt; Use for maintainability and performance</p>
</li>
<li><p>Children =&gt; Be careful of children, children create deep update,</p>
<pre><code>children are always change,  we should  insulate them from parent
</code></pre></li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><p><a href="https://www.youtube.com/watch?v=KYzlpRvWZ6c&amp;feature=youtu.be&amp;t=1372" target="_blank" rel="external">Making your app fast with high-performance components</a></p>
</li>
<li><p><a href="https://facebook.github.io/react/docs/advanced-performance.html" target="_blank" rel="external">React advanced-performance</a></p>
</li>
<li><a href="http://gold.xitu.io/entry/57621f7980dda4005f7332f3" target="_blank" rel="external">React 应用的性能优化</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="//img.alicdn.com/tfs/TB1P4h_LpXXXXbGXpXXXXXXXXXX-900-500.jpg" alt="高性能 React 组件"></p>
<h1 id="前言"><a href="#前言" class="headerli]]>
    </summary>
    
      <category term="React" scheme="http://taobaofed.org/tags/React/"/>
    
      <category term="性能优化" scheme="http://taobaofed.org/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[论版本号的正确打开方式]]></title>
    <link href="http://taobaofed.org/blog/2016/08/04/instructions-of-semver/"/>
    <id>http://taobaofed.org/blog/2016/08/04/instructions-of-semver/</id>
    <published>2016-08-04T09:48:27.000Z</published>
    <updated>2016-12-21T02:40:37.000Z</updated>
    <content type="html"><![CDATA[<p><img src="https://img.alicdn.com/tps/TB18IDkLXXXXXbeXpXXXXXXXXXX-900-500.png" alt="论版本号的正确打开方式"></p>
<p>版本号广泛运用于开发的各种场景：NPM 包的版本定义、对 NPM 包的特定版本的依赖指定、git 的 daily 版本号分支……</p>
<p>面对如此多的场景，版本号的命名却存在很大问题。举些例子：</p>
<ul>
<li>开始写一个新项目 / 模块时，不管三七二十一，都从 <code>0.0.1</code> 起版本，直到项目不再维护时，版本还停留在 <code>0.0.48</code>，前两位永远都是 0。</li>
<li>API 变化巨大，而版本号雷打不动一步一个脚印。一个二方包从 <code>0.0.8</code> 升级到 <code>0.0.9</code> 就引起了整个项目的崩溃。</li>
<li>依赖二方 / 三方包时，不知道该依赖哪个版本，有时随便指定了一个，有时则直接依赖了 <code>*</code>。</li>
</ul>
<hr>
<h2 id="版本号的命名"><a href="#版本号的命名" class="headerlink" title="版本号的命名"></a>版本号的命名</h2><h3 id="SemVer"><a href="#SemVer" class="headerlink" title="SemVer"></a>SemVer</h3><p>根据国际主流的惯例，我们使用「语义化版本（<a href="http://semver.org/" target="_blank" rel="external">Semantic Versioning</a>）」的命名方式，有时简称 SemVer。</p>
<p>语义化版本号（以下简称「版本号」）的格式是：<code>&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;</code>。即使用三位非负整数，以点号 <code>.</code> 连接。</p>
<p>如：<code>1.4.15</code>、<code>6.2.0</code>。</p>
<h3 id="每一位版本号的含义"><a href="#每一位版本号的含义" class="headerlink" title="每一位版本号的含义"></a>每一位版本号的含义</h3><ol>
<li><code>&lt;major&gt;</code> 即主版本号，俗称大版本升级。改动到主版本号时，标志着 API 发生了巨大变化，包括但不限于新增特性、修改机制、删除功能， <strong>一般不兼容上一个主版本号</strong>。</li>
<li><code>&lt;minor&gt;</code> 即次版本号，俗称小版本升级。当我们进行常规的新增或修改功能时，改动次版本号，但是 <strong>必须是向前兼容的</strong>。这也意味着我们 <strong>不能直接删除某个功能</strong>。如若必要，我们可以在 <a href="http://guide.taobao.net/6.changelog.php" target="_blank" rel="external">changelog</a> 中标记某项功能为「即将删除（Deprecated）」，然后在下一个大版本中将其彻底删除。</li>
<li><code>&lt;patch&gt;</code> 即修订号，俗称 bug 修复。顾名思义，如果仅仅为了修复或调整一些小问题，我们就只改动修订号。</li>
</ol>
<p>所以，当我们明确了每一位的含义和作用后，就不会陷入「每次只改最末位」的尴尬中了。</p>
<p>那如何判断一个修改应该是改动修订号还是次版本号呢？视情况而定。比如对于「修改了 app 图标」这件事来说，如果只是调整了图标的间距位置，那么可以认作问题修复；如果把整个图标换了，配上了不同的标语，那么这应该是一次功能改动。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>版本号前不要加 <code>v</code>。</li>
<li>不要在数字前补 <code>0</code>。错误示例：<code>01.12.03</code>。</li>
<li>每一位版本号按照 +1 的速度递增，不要在版本号之间跳跃。</li>
<li>主版本号停留在 <code>0</code> 的版本号，即 <code>0.x.x</code> 应当视作还在内部开发阶段的代码。如果代码有公共 API，此时不宜对外公开。</li>
<li><code>1.0.0</code> 的版本号用于界定公共 API 的形成。</li>
<li>当次版本号递增时，修订号归零；当主版本号递增时，次版本号、修订号归零。</li>
<li>进行新的开发时，版本号从 <code>0.1.0</code> 开始。</li>
<li>如果不小心把一个不兼容的改版当成了次版本号发行，应当发行一个新的次版本号来更正这个问题并且恢复向下兼容。注意 <strong>不能去修改已发行的版本</strong>。</li>
</ul>
<h3 id="一个典型的版本号发展示例"><a href="#一个典型的版本号发展示例" class="headerlink" title="一个典型的版本号发展示例"></a>一个典型的版本号发展示例</h3><ol>
<li><code>0.1.0</code></li>
<li><code>0.1.1</code></li>
<li><code>0.1.2</code></li>
<li><code>0.2.0</code></li>
<li><code>1.0.0</code></li>
<li><code>1.1.0</code></li>
<li><code>1.1.1</code></li>
<li>……</li>
</ol>
<h3 id="快速修改版本号"><a href="#快速修改版本号" class="headerlink" title="快速修改版本号"></a>快速修改版本号</h3><p>如果一个包发布在 NPM / TNPM 中，可以快速修改其版本号。会自动触发一个 git 提交。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 递增一个修订号</span><br><span class="line">npm version patch</span><br><span class="line"></span><br><span class="line"># 递增一个次版本号</span><br><span class="line">npm version minor</span><br><span class="line"></span><br><span class="line"># 递增一个主版本号</span><br><span class="line">npm version major</span><br></pre></td></tr></table></figure>
<h2 id="预发版本号"><a href="#预发版本号" class="headerlink" title="预发版本号"></a>预发版本号</h2><p>在常规的版本号命名之上还有一个特殊类别，叫做预发版本号（prerelease version）。它表示当前版本是一个不稳定的版本，使用它时需要注意风险。</p>
<p>预发版本号的格式是 <code>&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;-&lt;tag&gt;</code>，即前半部分和常规版本号相同，然后跟上连接符 <code>-</code>，后面再跟上字母数字点号连接符（[0-9A-Za-z-.]）。</p>
<p>一个典型的预发版本号形如 <code>1.0.0-beta.1</code>。建议使用这种 <code>&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;-&lt;stage&gt;.&lt;num&gt;</code> 的形式。其中 <code>&lt;stage&gt;</code> 一般选用：<code>alpha</code>、<code>beta</code>、<code>rc</code>。</p>
<p>预发版本号是常规版本号的附属，因此在版本的大小比较上，仍然先比较常规版本号部分；对于预发标记部分的比较，则是根据 ASCII 字母表中的顺序来进行。</p>
<h3 id="一个典型的预发版本号发展示例"><a href="#一个典型的预发版本号发展示例" class="headerlink" title="一个典型的预发版本号发展示例"></a>一个典型的预发版本号发展示例</h3><ol>
<li><code>0.9.0</code></li>
<li><code>1.0.0-alpha.1</code></li>
<li><code>1.0.0-alpha.2</code></li>
<li><code>1.0.0-beta.1</code></li>
<li><code>1.0.0-rc.1</code></li>
<li><code>1.0.0</code></li>
<li><code>1.0.1</code></li>
<li>……</li>
</ol>
<h2 id="依赖的版本号标记法"><a href="#依赖的版本号标记法" class="headerlink" title="依赖的版本号标记法"></a>依赖的版本号标记法</h2><p>我们广泛使用的 NPM 本身也遵从 SemVer 版本号命名，除了包版本本身的定义之外，最重要的是对三方包依赖的版本号的定义，不当的写法将导致一系列潜在的问题。</p>
<h3 id="指定可用的版本号范围"><a href="#指定可用的版本号范围" class="headerlink" title="指定可用的版本号范围"></a>指定可用的版本号范围</h3><p>在 NPM 包的 deps 系列字段中，经常出现形如 <code>~1.0.4</code>、<code>^2.1.1</code> 这样的标记法，这种标记法标记的是「版本号范围（version range）」，它表示依赖的三方包其版本号只要落在定义版本号范围内，即算合法。另外，当运行 <code>npm update</code> 时，依赖的包将升级到版本号范围支持的最高版本。</p>
<p>版本号范围的标记符号有很多种，诸如比较符号 <code>&gt;=</code>、<code>&lt;</code> 等；连接符 <code>-</code>；通配符 <code>x</code>、<code>*</code>；模糊符 <code>^</code>、<code>~</code>。具体的用法可参考 <a href="https://docs.npmjs.com/misc/semver" target="_blank" rel="external">NPM 官方文档</a>，这里仅给出常用的标记方式。</p>
<table>
<thead>
<tr>
<th>含义</th>
<th>最简写法</th>
<th>使用通配符的写法</th>
<th>使用模糊符的写法</th>
<th>表达的版本号范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>仅跟进修复版本</td>
<td><code>1.0</code></td>
<td><code>1.0.x</code></td>
<td><code>~1.0.4</code></td>
<td><code>&gt;=1.0.4 &lt;1.1.0</code></td>
</tr>
<tr>
<td>跟进每个小版本更新</td>
<td><code>1</code></td>
<td><code>1.x</code>、<code>1.x.x</code></td>
<td><code>^1.0.4</code></td>
<td><code>&gt;=1.0.4 &lt;2.0.0</code></td>
</tr>
<tr>
<td>始终升级到最新版</td>
<td><code>*</code></td>
<td><code>*</code></td>
<td><code>*</code></td>
<td><code>&gt;=0.0.0</code></td>
</tr>
</tbody>
</table>
<p>我们建议在写法上采用 <strong>「使用通配符的写法」</strong>，并且一般情况下 <strong>「跟进每个小版本更新」</strong>，但 <strong>不「始终升级到最新版」</strong>，即书写为 <code>1.x</code>。由于 <code>&lt;major&gt;</code> 位版本是不向下兼容的，所以在大版本的控制上，仍然采用人为干预以保证安全。</p>
<h3 id="不同的-deps-字段"><a href="#不同的-deps-字段" class="headerlink" title="不同的 deps 字段"></a>不同的 deps 字段</h3><p>NPM 包中的依赖有几种形式的字段：<code>dependencies</code>、<code>devDependencies</code>、<code>peerDependencies</code>。以下简要介绍下各字段的不同含义，以及使用场景。</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
<th>依赖被安装的时机</th>
<th>使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>dependencies</code></td>
<td>运行时依赖，包的调用者需要使用到的依赖</td>
<td>执行 <code>npm install</code> 后会把当前包的 <code>dependencies</code> 字段中的所有依赖项安装到 <code>./node_modules</code> 目录。<br> 执行 <code>npm install xxx</code> 后会把 xxx 安装到 <code>./node_modules</code> 下，同时会安装 xxx 的 <code>dependencies</code> 字段依赖项到 <code>./node_modules/xxx/node_modules</code> 目录。  <br> 执行 <code>npm install xxx --save</code> 后会额外把 xxx 作为依赖存到当前包的 <code>dependencies</code> 字段中。</td>
<td>所有程序运行需要用到的依赖代码，如 lodash 等。</td>
</tr>
<tr>
<td><code>devDependencies</code></td>
<td>开发时依赖，包的开发维护者需要使用到的依赖</td>
<td>执行 <code>npm install</code> 后也会把当前包的 <code>devDependencies</code> 字段中的所有依赖项安装到 <code>./node_modules</code> 目录。<br> 执行 <code>npm install xxx</code> 后会把 xxx 安装到 <code>./node_modules</code> 下，但不会安装 xxx 的 <code>devDependencies</code> 字段依赖项。 <br> 执行 <code>npm install xxx --save-dev</code> 后会额外把 xxx 作为开发时依赖存到当前包的 <code>devDependencies</code> 字段中。</td>
<td>一般是一些开发调试的辅助工具，如测试工具 mocha、构建工具 gulp 等。</td>
</tr>
<tr>
<td><code>peerDependencies</code></td>
<td>略</td>
<td>略</td>
<td>仅在 <a href="https://nodejs.org/en/blog/npm/peer-dependencies/" target="_blank" rel="external">特定场景</a> 下有用，默认不使用此字段。</td>
</tr>
</tbody>
</table>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol>
<li><a href="http://semver.org/" target="_blank" rel="external">Semantic Versioning</a></li>
<li><a href="https://docs.npmjs.com/misc/semver" target="_blank" rel="external">NPM SemVer</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="https://img.alicdn.com/tps/TB18IDkLXXXXXbeXpXXXXXXXXXX-900-500.png" alt="论版本号的正确打开方式"></p>
<p>版本号广泛运用于开发的各种场景：NPM 包的版本定义、对 NPM ]]>
    </summary>
    
      <category term="版本号" scheme="http://taobaofed.org/tags/%E7%89%88%E6%9C%AC%E5%8F%B7/"/>
    
      <category term="SemVer" scheme="http://taobaofed.org/tags/SemVer/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[纠结的链接：ln、ln -s、fs.symlink、require]]></title>
    <link href="http://taobaofed.org/blog/2016/07/29/puzzled-by-link/"/>
    <id>http://taobaofed.org/blog/2016/07/29/puzzled-by-link/</id>
    <published>2016-07-29T03:50:30.000Z</published>
    <updated>2016-12-21T02:40:37.000Z</updated>
    <content type="html"><![CDATA[<p><img src="//img.alicdn.com/tfs/TB1eKetLXXXXXalXVXXXXXXXXXX-900-500.jpg" alt="纠结的链接：ln、ln -s、fs.symlink、require"></p>
<p>最近在使用 <code>fs.symlink</code> 实现软链时，发现<a href="https://nodejs.org/api/fs.html#fs_fs_symlink_target_path_type_callback" target="_blank" rel="external">文档</a>里面写的是：<code>fs.symlink(target, path)</code>；然而 <code>man ln</code> 的时候显示的是：<code>ln source_file target_file</code>；而且，<code>require</code> 模块的时候其实还会处理软链但是处理的又不是想象中那样。于是，我彻底被相关东西绕晕。这篇文章算是我的学习笔记，希望对你有帮助。</p>
<a id="more"></a>
<h2 id="inode"><a href="#inode" class="headerlink" title="inode"></a>inode</h2><p>我们首先来看看 Linux 系统里面的一个重要概念：inode。</p>
<p>我们知道，文件存储在硬盘上，硬盘存储的最小单位是扇区（sector，每个扇区 512 B）。而操作系统读取文件时，按块读取（连续的多个扇区），也就是说文件存取的最小单位是块（block，块通常是 4 KB）。</p>
<p>除了文件数据，我们还必须存储文件的元信息（如：文件大小、文件创建者、文件数据的块位置、文件读/写/执行权限、文件时间戳等等），这种存储文件元信息的结构就称为 inode。我们可以使用 <code>stat</code> 命令查看文件的 inode 信息。在 Node.js 中，调用 <code>fs.stat</code> 后返回的结果中也有相关信息</p>
<p><img src="http://img.alicdn.com/tps/TB1IUOkKXXXXXX2aXXXXXXXXXXX-1126-980.png" alt="stat"></p>
<p>每个 inode 都有一个唯一的号码标志，Linux 系统内部使用 inode 的号码来识别文件，并不使用文件名。我们打开一个文件时，系统首先找到文件名对应的 inode 号码，然后通过 inode 号码获取 inode 信息，最后根据 inode 信息中的文件数据所在的 block 读出数据。</p>
<p>实际上，在 Linux 系统中，目录也是一种文件。目录文件包含一系列目录项，每个目录项由两部分组成：所包含文件的文件名，以及该文件名对应的 inode 号码。我们可以使用 <code>ls -i</code> 来列出目录中的文件以及它们的 inode 号码。这其实也解释了仅更改目录的读权限，并不能实现读取目录下所有文件内容的原因，通常需要 <code>chmod -R</code> 来进行递归更改。</p>
<p>总结下：</p>
<ul>
<li>硬盘存取的最小单位是扇区，文件存取的最小单位是块（连续的扇区）</li>
<li>存储文件元信息（文件大小、创建者、块位置、时间戳、权限等非数据信息）的结构称为 inode</li>
<li>每个 inode 拥有一个唯一号码，系统内部通过它来识别文件</li>
<li>目录也是一种文件，其内容包含一系列目录项（每个目录项由文件的文件名和文件对应的 inode 号码组成）</li>
</ul>
<h2 id="硬链接和软链接"><a href="#硬链接和软链接" class="headerlink" title="硬链接和软链接"></a>硬链接和软链接</h2><h3 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h3><p>一般情况，一个文件名“唯一”对应一个 inode。但是，Linux 允许多个文件名都指向同一个 inode。这表示我们可以使用不同的文件名访问同样的内容；对文件内容进行修改将“反映”到所有文件；删除一个文件不影响另一个文件的访问  。这种机制就被称为“硬链接”。</p>
<p>我们可以使用 <code>ln source target</code> 来建立硬链接（注意：<code>source</code> 是本身已存在的文件，<code>target</code> 是将要建立的链接）。</p>
<p><img src="http://img.alicdn.com/tps/TB1Q31gKXXXXXbLaXXXXXXXXXXX-912-438.png" alt="hard link"></p>
<p>形象化的表示为下图：</p>
<p><img src="http://img.alicdn.com/tps/TB1mYuqKXXXXXbGXVXXXXXXXXXX-300-361.png" alt="hard link graph"></p>
<p>需要注意的是，只能给文件建立硬链接，而不能给目录建立硬链接。另外，<code>source</code> 文件必须存在，否则将会报错。</p>
<p>删除一个文件为什么不影响另一个文件的访问呢？实际上，文件 inode 中还有一个链接数的信息，每多一个文件指向这个 inode，该数字就会加 1，每少一个文件指向这个 inode，该数字就会减 1，当值减到 0，系统就自动回收 inode 及其对应的 block 区域。很像是一种引用计数的垃圾回收机制。</p>
<p>当我们对某个文件建立了硬链接后，对应的 inode 的链接数会是 2（原文件本身已经有一个指向），当删除一个文件时，链接数变成 1，并没达到回收的条件，所以我们还是可以访问文件。</p>
<h3 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h3><p>软链接类似于 Windows 中的”快捷方式“。两个文件虽然 inode 号码不一样，但是文件 A 内部会指向文件 B 的 inode。当我们读取文件 A 时，系统就自动导向文件 B，文件 A 就是文件 B 的软链接（或者叫符号链接）。这表示我们同样可以使用不同的文件名访问同样的内容；对文件内容修改将”反映“到所有文件。但是当我们删除掉源文件 B 时，再访问文件 A 时会报错 “No such file or directory”。</p>
<p>我们可以使用 <code>ln -s source target</code> 来建立软链接（注意：表示让 <code>target</code> “指向” <code>source</code>）。</p>
<p><img src="http://img.alicdn.com/tps/TB1xOeTKXXXXXabXXXXXXXXXXXX-994-488.png" alt="soft link"></p>
<p>形象化的表示为下图：</p>
<p><img src="http://img.alicdn.com/tps/TB1PhakKXXXXXaSaXXXXXXXXXXX-300-366.png" alt="soft link graph"></p>
<p>和硬链接不同，我们可以给目录建立软链接，这带来许多便利。比如我们有一个模块有很多个版本，分别存放在 1.0.0、2.0.0 这样的目录下面，当更新模块时，只需要建立一个软链接指向最新版本号的目录就能很方便的切换版本。</p>
<p>另外，建立软链接时，<code>source</code> 是可以不存在的。这很像一种”运行时“机制，而不是“编译时”机制，建立的时候不报错，等执行的时候发现找不到就报错了。</p>
<p><img src="http://img.alicdn.com/tps/TB1UrifKXXXXXXjapXXXXXXXXXX-994-618.png" alt="danggling soft link"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>使用 <code>ln source target</code> 建立硬链接；使用 <code>ln -s source target</code> 建立软链接</li>
<li>硬链接不会创建额外 inode，和源文件共用同一个 inode；软链接会创建额外一个文件（额外 inode），指向源文件的 inode</li>
<li>建立硬链接时，<code>source</code> 必须存在且只能是文件；建立软链接时，<code>source</code> 可以不存在而且可以是目录</li>
<li>删除源文件不会影响硬链接文件的访问（因为 inode 还在）；删除源文件会影响软链接文件的访问（因为指向的 inode 已经不存在了）</li>
<li>对于已经建立的同名链接，不能再次建立，除非删掉或者使用 <code>-f</code> 参数</li>
</ul>
<h3 id="关于软链接的补充"><a href="#关于软链接的补充" class="headerlink" title="关于软链接的补充"></a>关于软链接的补充</h3><p>上面的例子 <code>ln -s file file-soft</code> 给我们的感觉像是 <code>file-soft</code> 是“凭空”出现的。当我们跨目录来创建软链接时，可能会“幻想”这样的命令也是可以生效的：<code>ln -s ~/development/mod ~/production/dir-not-exits/mod</code>。</p>
<p>这里并没有 <code>~/production/dir-not-exits/</code> 这个目录，而软链接本质上是一个新的“文件”，所以，我们不可能正确建立软链接（会报错说 “no such file or directory”）。</p>
<p>如果我们先通过 <code>mkdir</code> 建立好目录 <code>~/production/dir-not-exits/</code>，再进行软链接，即可达到预期效果。</p>
<h2 id="fs-symlink"><a href="#fs-symlink" class="headerlink" title="fs.symlink"></a>fs.symlink</h2><p>在 Node.js 中，我们可以使用方法 <code>fs.symink(target, path)</code> 建立软链接（符号链接），没有直接的方法建立硬链接（就算通过子进程的方式直接指向 shell 命令也不能跨平台）。</p>
<p>如果是对目录建立链接，请总是传递第三个参数 <code>dir</code>（虽然第三个参数只在 Windows 下生效，这可以保证代码跨平台）：<code>fs.symlink(target, path, &#39;dir&#39;)</code>。</p>
<p>为啥这个接口的参数会是 <code>target</code> 和 <code>path</code>。实际上这是一个 Linux 的 API，<a href="http://man7.org/linux/man-pages/man2/symlink.2.html" target="_blank" rel="external">symlink(target, linkpath)</a>。它是这样描述的：建立一个名为 <code>linkpath</code> 的符号链接并且含有内容 <code>target</code>。其实就是让 <code>linkpath</code> 指向 <code>target</code>，和 <code>ln -s source target</code> 功能一样，让 <code>target</code> 指向 <code>source</code>。</p>
<p>是不是有点晕？其实我们只需要明白 <code>ln -s</code> 和 <code>fs.symlink</code> 后面传递的两个参数顺序是一致的，只是叫法不一样，使用起来也就没那么纠结了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln <span class="_">-s</span> file file-soft <span class="comment"># file-soft -&gt; file</span></span><br><span class="line">ln <span class="_">-s</span> dir dir-soft <span class="comment"># dir-soft -&gt; dir</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fs.symlinkSync(<span class="string">'file'</span>, <span class="string">'file-soft'</span>); <span class="comment">// file-soft -&gt; file</span></span><br><span class="line">fs.symlinkSync(<span class="string">'dir'</span>, <span class="string">'dir-soft'</span>, <span class="string">'dir'</span>); <span class="comment">// dir-soft -&gt; dir</span></span><br></pre></td></tr></table></figure>
<h2 id="require"><a href="#require" class="headerlink" title="require"></a>require</h2><p>在 Node.js 中，我们经常通过 <code>require</code> 来引用模块。非常有趣的是，<code>require</code> 引用模块时，会“考虑”符号链接，但是却使用模块的真实路径作为 <code>__filename</code>、<code>__dirname</code>，而不是符号链接的路径。</p>
<p>考虑下面的目录结构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- app</span><br><span class="line">  - index.js // require(<span class="string">'dep1'</span>)</span><br><span class="line">  - node_modules</span><br><span class="line">    - dep1 -&gt; ../../mods/dep1 //符号链接</span><br><span class="line">- mods</span><br><span class="line">  - dep1</span><br><span class="line">    - index.js</span><br></pre></td></tr></table></figure>
<p>以及下面的文件内容：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'index.js'</span>, __dirname, __filename);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'dep1'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// dep1/index.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'dep1'</span>, __dirname, __filename);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">module</span>.paths);</span><br></pre></td></tr></table></figure>
<p>执行 <code>node index.js</code> 后输出是下面这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">index.js /Users/kohpoll/Workspace/<span class="built_in">test</span>/app /Users/kohpoll/Workspace/<span class="built_in">test</span>/app/index.js</span><br><span class="line"></span><br><span class="line">dep1 /Users/kohpoll/Workspace/<span class="built_in">test</span>/mods/dep1 /Users/kohpoll/Workspace/<span class="built_in">test</span>/mods/dep1/index.js</span><br><span class="line">[ <span class="string">'/Users/kohpoll/Workspace/test/mods/dep1/node_modules'</span>,</span><br><span class="line">  <span class="string">'/Users/kohpoll/Workspace/test/mods/node_modules'</span>,</span><br><span class="line">  <span class="string">'/Users/kohpoll/Workspace/test/node_modules'</span>,</span><br><span class="line">  <span class="string">'/Users/kohpoll/Workspace/node_modules'</span>,</span><br><span class="line">  <span class="string">'/Users/kohpoll/node_modules'</span>,</span><br><span class="line">  <span class="string">'/Users/node_modules'</span>,</span><br><span class="line">  <span class="string">'/node_modules'</span> ]</span><br></pre></td></tr></table></figure>
<p>我们发现，<code>index.js</code> 可以成功的 <code>require(&#39;dep1&#39;)</code>。这很好啊，这让我们调试本地开发中的 npm 模块很方便。我们只需要去 <code>require</code> 模块的文件所在的 <code>node_modules</code> 下面建立一个符号链接就行了。</p>
<p>但是在模块 <code>dep1</code> 中，<code>__dirname</code>、<code>__filename</code> 都变成了模块实际的路径，更要命的是模块查找路径 <code>module.paths</code> 也变成了从实际路径开始查找。</p>
<p>这会带来什么问题？</p>
<p>再考虑下面的目录结构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- app</span><br><span class="line">  - index.js // require(<span class="string">'dep1'</span>)</span><br><span class="line">  - node_modules</span><br><span class="line">    - dep1 -&gt; ../../mods/dep1 // require(<span class="string">'dep2'</span>)</span><br><span class="line">    - dep2 -&gt; ../../mods/dep2 // 符号连接</span><br><span class="line">- mods</span><br><span class="line">  - dep1</span><br><span class="line">    - index.js</span><br><span class="line">  - dep2</span><br><span class="line">    - index.js</span><br></pre></td></tr></table></figure>
<p>以及下面的文件内容：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'index.js'</span>, __dirname, __filename);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'dep1'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// dep1/index.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'dep1'</span>, __dirname, __filename);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">module</span>.paths);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'dep2'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// dep2/index.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'dep2'</span>, __dirname, __filename);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">module</span>.paths);</span><br></pre></td></tr></table></figure>
<p>当我们再执行 <code>node index.js</code> 时，输出是下面这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">index.js /Users/kohpoll/Workspace/<span class="built_in">test</span>/app /Users/kohpoll/Workspace/<span class="built_in">test</span>/app/index.js</span><br><span class="line"></span><br><span class="line">dep1 /Users/kohpoll/Workspace/<span class="built_in">test</span>/mods/dep1 /Users/kohpoll/Workspace/<span class="built_in">test</span>/mods/dep1/index.js</span><br><span class="line">[ <span class="string">'/Users/kohpoll/Workspace/test/mods/dep1/node_modules'</span>,</span><br><span class="line">  <span class="string">'/Users/kohpoll/Workspace/test/mods/node_modules'</span>,</span><br><span class="line">  <span class="string">'/Users/kohpoll/Workspace/test/node_modules'</span>,</span><br><span class="line">  <span class="string">'/Users/kohpoll/Workspace/node_modules'</span>,</span><br><span class="line">  <span class="string">'/Users/kohpoll/node_modules'</span>,</span><br><span class="line">  <span class="string">'/Users/node_modules'</span>,</span><br><span class="line">  <span class="string">'/node_modules'</span> ]</span><br><span class="line">  </span><br><span class="line">module.js:339</span><br><span class="line">    throw err;</span><br><span class="line">    ^</span><br><span class="line">Error: Cannot find module <span class="string">'dep2'</span></span><br><span class="line">    at Function.Module._resolveFilename (module.js:337:15)</span><br><span class="line">    at Function.Module._load (module.js:287:25)</span><br><span class="line">    at Module.require (module.js:366:17)</span><br><span class="line">    at require (module.js:385:17)</span><br><span class="line">    at Object.&lt;anonymous&gt; (/Users/kohpoll/Workspace/<span class="built_in">test</span>/mods/dep1/index.js:6:1)</span><br><span class="line">    at Module._compile (module.js:435:26)</span><br><span class="line">    at Object.Module._extensions..js (module.js:442:10)</span><br><span class="line">    at Module.load (module.js:356:32)</span><br><span class="line">    at Function.Module._load (module.js:311:12)</span><br><span class="line">    at Module.require (module.js:366:17)</span><br></pre></td></tr></table></figure>
<p>发现了吗？<code>dep1</code> 根本就 <code>require</code> 不到 <code>dep2</code>，因为 <code>dep2</code> 不在它的查找路径里面！</p>
<p>关于这个问题，github 上有一个冗长的 issue 在讨论。问题解决起来确实很麻烦，而且会 break 掉一大堆已有功能，所以，最终的结论是在找到更好的方法前给 Node.js v6 增加了一个 <code>--preserve-symlinks</code> 选项来禁止这种 <code>require</code> 的行为，而是使用全新的 <code>require</code> 逻辑。有兴趣和闲情的可以去围观：<a href="https://github.com/nodejs/node/issues/3402" target="_blank" rel="external">https://github.com/nodejs/node/issues/3402</a>（真的好长……）。</p>
<p>至于全新的 <code>require</code> 逻辑会不会有新的坑，在没有具体实践前，我也不知道。</p>
<p>那我们上面的情况有办法解决吗？其实也有，那就是将目录结构调整成下面这样，从而让 <code>dep2</code> 能在 <code>dep1</code> 的查找路径里面：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- app</span><br><span class="line">  - index.js // require(<span class="string">'dep1'</span>)</span><br><span class="line">  - node_modules</span><br><span class="line">    - dep1 -&gt; ../../mods/node_modules/dep1 // 软链接</span><br><span class="line">    - dep2 -&gt; ../../mods/node_modules/dep2 // 软连接</span><br><span class="line">- mods</span><br><span class="line">  - node_modules</span><br><span class="line">    - dep1</span><br><span class="line">      - index.js</span><br><span class="line">    - dep2</span><br><span class="line">      - index.js</span><br></pre></td></tr></table></figure>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://www.ruanyifeng.com/blog/2011/12/inode.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2011/12/inode.html</a></li>
<li><a href="http://www.geekride.com/hard-link-vs-soft-link/" target="_blank" rel="external">http://www.geekride.com/hard-link-vs-soft-link/</a></li>
<li><a href="http://man7.org/linux/man-pages/man2/symlink.2.html" target="_blank" rel="external">http://man7.org/linux/man-pages/man2/symlink.2.html</a></li>
<li><a href="https://nodejs.org/api/fs.html" target="_blank" rel="external">https://nodejs.org/api/fs.html</a></li>
<li><a href="https://github.com/nodejs/node/issues/3402" target="_blank" rel="external">https://github.com/nodejs/node/issues/3402</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="//img.alicdn.com/tfs/TB1eKetLXXXXXalXVXXXXXXXXXX-900-500.jpg" alt="纠结的链接：ln、ln -s、fs.symlink、require"></p>
<p>最近在使用 <code>fs.symlink</code> 实现软链时，发现<a href="https://nodejs.org/api/fs.html#fs_fs_symlink_target_path_type_callback">文档</a>里面写的是：<code>fs.symlink(target, path)</code>；然而 <code>man ln</code> 的时候显示的是：<code>ln source_file target_file</code>；而且，<code>require</code> 模块的时候其实还会处理软链但是处理的又不是想象中那样。于是，我彻底被相关东西绕晕。这篇文章算是我的学习笔记，希望对你有帮助。</p>]]>
    
    </summary>
    
      <category term="链接" scheme="http://taobaofed.org/tags/%E9%93%BE%E6%8E%A5/"/>
    
      <category term="require" scheme="http://taobaofed.org/tags/require/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ES6 你可能不知道的事 - 基础篇]]></title>
    <link href="http://taobaofed.org/blog/2016/07/22/es6-basics/"/>
    <id>http://taobaofed.org/blog/2016/07/22/es6-basics/</id>
    <published>2016-07-22T03:32:30.000Z</published>
    <updated>2016-12-21T02:40:37.000Z</updated>
    <content type="html"><![CDATA[<p><img src="//img.alicdn.com/tfs/TB1HPI1KVXXXXbBXpXXXXXXXXXX-900-500.jpg" alt="ES6 你可能不知道的事 - 基础篇"></p>
<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>ES6，或许应该叫 ES2015（2015 年 6 月正式发布），对于大多数前端同学都不陌生。</p>
<p>首先这篇文章不是工具书，不会去过多谈概念，而是想聊聊关于每个特性 <strong>你可能不知道的事</strong>，希望能为各位同学 <strong>正确使用</strong> ES6，提供一些指导。</p>
<p>对于 ES6，有些同学已经在项目中有过深入使用了，有些则刚刚开始认识他，但不论你是属于哪一类，相信这篇文章都有适合你的部分。针对文章中的问题或不同意见，欢迎随时拍砖、指正。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="Let-Const"><a href="#Let-Const" class="headerlink" title="Let + Const"></a>Let + Const</h3><p>这个大概是开始了解 ES6 后，我们第一个感觉自己完全明白并兴致勃勃的开始使用的特性。</p>
<p>以如下方式使用的同学请举下手？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义常量</span></span><br><span class="line"><span class="keyword">const</span> REG_GET_INPUT = <span class="regexp">/^\d&#123;1,3&#125;$/</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义配置项</span></span><br><span class="line"><span class="keyword">let</span> config = &#123;</span><br><span class="line">  isDev : <span class="literal">false</span>,</span><br><span class="line">  pubDir: <span class="string">'./admin/'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入 gulp</span></span><br><span class="line"><span class="keyword">let</span> gulp    = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入gulp相关插件</span></span><br><span class="line"><span class="keyword">let</span> concat  = <span class="built_in">require</span>(<span class="string">'gulp-concat'</span>);</span><br><span class="line"><span class="keyword">let</span> uglify  = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>);</span><br><span class="line"><span class="keyword">let</span> cssnano = <span class="built_in">require</span>(<span class="string">'gulp-cssnano'</span>);</span><br></pre></td></tr></table></figure>
<p>很多人看完概念之后，第一印象都是：“<code>const</code> 是表示不可变的值，而 <code>let</code> 则是用来替换原来的 <code>var</code> 的。”</p>
<p>所以就会出现上面代码中的样子；一段代码中出现大量的 <code>let</code>，只有部分常量用 <code>const</code> 去做定义，这样的使用方式是错误的。</p>
<h4 id="你可能不知道的事"><a href="#你可能不知道的事" class="headerlink" title="你可能不知道的事"></a>你可能不知道的事</h4><p><code>const</code> 的定义是<strong>不可重新赋值</strong>的值，与不可变的值(immutable value)不同；<code>const</code> 定义的 Object，在定义之后仍可以修改其属性。</p>
<p>所以其实他的使用场景很广，包括常量、配置项以及引用的组件、定义的 “大部分” 中间变量等，都应该以<code>const</code>做定义。反之就 <code>let</code> 而言，他的使用场景应该是相对较少的，我们只会在 loop(for，while 循环)及少量必须重定义的变量上用到他。</p>
<blockquote>
<p>猜想：就执行效率而言，<code>const</code> 由于不可以重新赋值的特性，所以可以做更多语法静态分析方面的优化，从而有更高的执行效率。</p>
</blockquote>
<p>所以上面代码中，所有使用 <code>let</code> 的部分，其实都应该是用 <code>const</code> 的。</p>
<h3 id="Template-Strings（字符串模板）"><a href="#Template-Strings（字符串模板）" class="headerlink" title="Template Strings（字符串模板）"></a>Template Strings（字符串模板）</h3><p>字符串模板是我刚接触ES6时最喜欢的特性之一，他语法简洁，语义明确，而且很好的解决了之前字符串拼接麻烦的问题。</p>
<p>因为他并不是 “必须” 的，而且原有的字符串拼接思维根深蒂固，导致我们很容易忽视掉他。</p>
<h4 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h4><p>我们先来看看他的一般使用场景：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> start = <span class="string">'hi all'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getName = () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'jelly'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> conf = &#123;</span><br><span class="line">  fav: <span class="string">'Coding'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板</span></span><br><span class="line"><span class="keyword">const</span> msg = <span class="string">`<span class="subst">$&#123;start&#125;</span>, my name is <span class="subst">$&#123;getName()&#125;</span>, <span class="subst">$&#123;conf.fav&#125;</span> is my favourite`</span>;</span><br></pre></td></tr></table></figure>
<h4 id="你可能不知道的事-1"><a href="#你可能不知道的事-1" class="headerlink" title="你可能不知道的事"></a>你可能不知道的事</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 与引号混用</span></span><br><span class="line"><span class="keyword">const</span> wantToSay = <span class="string">`I'm a "tbfed"`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 支持多行文本</span></span><br><span class="line"><span class="keyword">const</span> slogan = </span><br><span class="line"><span class="string">`</span><br><span class="line">I have a dream today!</span><br><span class="line">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较适合写HTML</span></span><br><span class="line"><span class="keyword">const</span> resultTpl = </span><br><span class="line"><span class="string">`</span><br><span class="line">  &lt;section&gt;</span><br><span class="line">    &lt;div&gt;...&lt;/div&gt;</span><br><span class="line">  &lt;/section&gt;</span><br><span class="line">`</span>;</span><br></pre></td></tr></table></figure>
<h3 id="Enhanced-Object-Literals（增强的对象字面量）"><a href="#Enhanced-Object-Literals（增强的对象字面量）" class="headerlink" title="Enhanced Object Literals（增强的对象字面量）"></a>Enhanced Object Literals（增强的对象字面量）</h3><p>增强的对象字面量是 ES6 中的升华功能，他设计了很多简写，这些简写不但保留了明确的语义，还减少了我们多余的代码量。</p>
<p>当他的使用成为一个习惯时，我们会看到自己代码变得更为优雅。</p>
<h4 id="你可能不知道的事-2"><a href="#你可能不知道的事-2" class="headerlink" title="你可能不知道的事"></a>你可能不知道的事</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> _bookNum = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> basicConfig = &#123;</span><br><span class="line">  level: <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="comment">// 直接指定原型对象</span></span><br><span class="line">  __proto__: basicConfig,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 属性简写</span></span><br><span class="line">  _bookNum,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 方法简写</span></span><br><span class="line">  getBookNum() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.bookNum;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Arrows-and-Lexical-This（箭头函数）"><a href="#Arrows-and-Lexical-This（箭头函数）" class="headerlink" title="Arrows and Lexical This（箭头函数）"></a>Arrows and Lexical This（箭头函数）</h3><p>箭头函数是ES6中的一个新的语法特性，他的用法简单，形态优雅，备受人们青睐。</p>
<p>大多数同学初识这个特性时，更多的仅仅用它作为函数定义的简写，这其实就有些屈才了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 未使用箭头函数的写法</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  addOptions: <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  </span><br><span class="line">    options.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">name, opts</span>)</span>&#123;</span><br><span class="line">      </span><br><span class="line">      self[name] = self.addChild(name, opts);</span><br><span class="line">      </span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用箭头函数后的写法</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  addOptions: <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">    options.forEach((name, opts) =&gt; &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">this</span>[name] = <span class="keyword">this</span>.addChild(name, opts);</span><br><span class="line">      </span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以注意到上下两段代码的区别。</p>
<p>在未使用箭头函数前，我们在过程函数中使用父级 <code>this</code>，需要将其显式缓存到另一个中间变量中，因为过程函数有独立的 <code>this</code> 变量，会覆盖父级；使用箭头函数后，不但简写了一个过程函数（ <code>forEach</code> 的参数），还省略掉了 <code>this</code> 的中间变量的定义。</p>
<p><em><strong>原因：箭头函数没有独立执行上下文（ <code>this</code> ），所以其内部引用 <code>this</code> 对象会直接访问父级。</strong></em></p>
<blockquote>
<p>插播：原来我们定义这个中间变量还有一个有趣的现象，就是明明千奇百怪，例如 <code>self, that, me, _that, _me, Self...</code>，快站出来说说你用过哪个，还是哪几个~</p>
</blockquote>
<p>当然，从这块我们也可以看出，箭头函数是无法替代全部 <code>function</code> 的使用场景的，例如我们需要有独立 <code>this</code> 的函数。</p>
<h4 id="你可能不知道的事-3"><a href="#你可能不知道的事-3" class="headerlink" title="你可能不知道的事"></a>你可能不知道的事</h4><ol>
<li>箭头函数不但没有独立 <code>this</code>，他也没有独立的 <code>arguments</code>，所以如果需要取不定参的时候，要么使用 <code>function</code>，要么用  ES6 的另一个新特性 <strong>rest</strong>（具体在 rest 中会有详解）。</li>
<li>箭头函数语法很灵活，在只有一个参数或者只有一句表达式做方法体时，可以省略相应括号。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完整写法</span></span><br><span class="line"><span class="keyword">const</span> getOptions = (name, key) =&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略参数括号</span></span><br><span class="line"><span class="keyword">const</span> getOptions = key =&gt; &#123;</span><br><span class="line">  ... </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略参数和方法体括号</span></span><br><span class="line"><span class="keyword">const</span> getOptions = key =&gt; <span class="built_in">console</span>.log(key);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参数或方法体，括号不能省略</span></span><br><span class="line"><span class="keyword">const</span> noop = () =&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>有个简单小栗子，这一灵活的语法在写连续的Promise链式调用时，可以使代码更加优雅</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gitPromise</span><br><span class="line">  .then(() =&gt; git.add())</span><br><span class="line">  .then(() =&gt; git.commit())</span><br><span class="line">  .then(() =&gt; git.log())</span><br><span class="line">  .then((msg) =&gt; &#123;</span><br><span class="line">      ...</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(() =&gt; git.push())</span><br><span class="line">  .catch((err) =&gt; &#123;</span><br><span class="line">      utils.error(err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Destructuring（解构）"><a href="#Destructuring（解构）" class="headerlink" title="Destructuring（解构）"></a>Destructuring（解构）</h3><p>解构这个特性可以简单解读为分别定义，用于一次定义多个变量，常常用于分解方法返回对象为多个变量，分别使用。<br>使用过ES6的同学应该或多或少接触过这个特性，但是你可能不知道它如下几个用法：</p>
<h4 id="你可能不知道的事-4"><a href="#你可能不知道的事-4" class="headerlink" title="你可能不知道的事"></a>你可能不知道的事</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bookSet = [<span class="string">'UED'</span>, <span class="string">'TB fed'</span>, <span class="string">'Not find'</span>];</span><br><span class="line"><span class="keyword">const</span> bookCollection = () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;book1: <span class="string">'UED'</span>, book2: <span class="string">'TB fed'</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 解构也可以设置默认值</span></span><br><span class="line"><span class="keyword">const</span> &#123;book1, book3 = <span class="string">'Not find'</span>&#125; = bookCollection();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 解构数组时候是可以跳过其中某几项的</span></span><br><span class="line"><span class="keyword">const</span> [book1,,book3] = bookSet;  <span class="comment">// book1 = 'UED', book3 = 'Not find'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 解构可以取到指定对象的任何属性，包括它包含的方法</span></span><br><span class="line"><span class="keyword">const</span> &#123;length: setLength&#125; = bookSet;  <span class="comment">// setLength = 3</span></span><br></pre></td></tr></table></figure>
<h3 id="Rest-Spread"><a href="#Rest-Spread" class="headerlink" title="Rest + Spread"></a>Rest + Spread</h3><p>Rest 和 Spread 主要是应用 <code>...</code> 运算符，完成值的聚合和分解。</p>
<h4 id="你可能不知道的事-5"><a href="#你可能不知道的事-5" class="headerlink" title="你可能不知道的事"></a>你可能不知道的事</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 1. rest 得到的是一个真正的数组而不是一个伪数组</span></span><br><span class="line"><span class="keyword">const</span> getOptions = <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(args.join); <span class="comment">// function</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. rest 可以配合箭头函数使用，达到取得所有参数的目的</span></span><br><span class="line"><span class="keyword">const</span> getOptions = (...args) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(args); <span class="comment">// array</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. spread 可以用于解构时，聚合所得的值</span></span><br><span class="line"><span class="keyword">const</span> [opt1, ...opts] = [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>, <span class="string">'four'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. spread 可以用于数组定义</span></span><br><span class="line"><span class="keyword">const</span> opts = [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>, <span class="string">'four'</span>];</span><br><span class="line"><span class="keyword">const</span> config = [<span class="string">'other'</span>, ...opts];</span><br></pre></td></tr></table></figure>
<h3 id="Classes"><a href="#Classes" class="headerlink" title="Classes"></a>Classes</h3><p>ES6 中实现的一个语法糖，用于简化基于原型集成实现类定义的场景。<br>虽然有很多人不太喜欢这个特性，认为它作为一个简单增强扩展，并没有其他语言 class 应有的特点。<br>但是就我自己观点来看，还是感觉这样一种写法确实比原有的原型继承的写法语义更清晰、明确，而且语法更简单。</p>
<p>同样，可能有些用法是你之前容易忽略掉的，在此做个补充。</p>
<h4 id="你可能不知道的事-6"><a href="#你可能不知道的事-6" class="headerlink" title="你可能不知道的事"></a>你可能不知道的事</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 1. 静态变量</span></span><br><span class="line"><span class="comment">// ES6 的类定义实现了静态方法的定义，但静态变量呢？</span></span><br><span class="line"><span class="comment">// 可以用如下方式实现: </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TbFedMembers</span></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> get HuaChen()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'jelly'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">TbFedMembers.HuaChen; <span class="comment">// "化辰"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 私有属性（私有属性有多种实现方式，只谈及其中一种）</span></span><br><span class="line"><span class="comment">// 闭包</span></span><br><span class="line"><span class="keyword">const</span> TbFedMembers = (() =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> HuaChen = <span class="string">'jelly'</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span></span>&#123;</span><br><span class="line">    getOneMemberName()&#123;</span><br><span class="line">      <span class="keyword">return</span> HuaChen;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<h3 id="Promises"><a href="#Promises" class="headerlink" title="Promises"></a>Promises</h3><p>Promise 不只是一个对象、一个语法，他更是一种异步编程方式的变化<br>相信使用过 ES6 的同学都已经开始尝试了 Promise，甚至在不支持ES6的时候，已经开始使用一些基于 Promise 思想的开源框架。</p>
<p>那么我们之前用 Promise 究竟用的对么？有什么需要注意的点呢？</p>
<h4 id="你可能不知道的事-7"><a href="#你可能不知道的事-7" class="headerlink" title="你可能不知道的事"></a>你可能不知道的事</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 1. 多个异步任务同时执行用 Promise.all，顺序执行使用链式调用</span></span><br><span class="line"><span class="comment">// Promise.all</span></span><br><span class="line"><span class="built_in">Promise</span></span><br><span class="line">  .all([jsBuildPromise, cssBuildPromise])</span><br><span class="line">  .then(() =&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// chain</span></span><br><span class="line">jsBuildPromise</span><br><span class="line">  .then(() =&gt; cssBuildPromise)</span><br><span class="line">  .then(() =&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Promise 的链式调用需要每一个过程返回一个 Promise 对象才能保证顺序执行</span></span><br><span class="line">gitPromise</span><br><span class="line">  .then(() =&gt; git.add())  <span class="comment">// 正确，箭头函数简写</span></span><br><span class="line">  .then(() =&gt; &#123;</span><br><span class="line">    git.commit(); <span class="comment">// 错误，函数返回 undefined，会立即执行下一过程</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(() =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> git.log(); <span class="comment">// 正确</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. Promise 需要调用 catch 方法来捕获错误，而且过程内的错误不会阻塞后续代码执行</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(() =&gt; &#123;</span><br><span class="line">  f;  <span class="comment">// not define error !</span></span><br><span class="line">&#125;)</span><br><span class="line">.catch((err) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err)  <span class="comment">// show 'f is not define'</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'error test'</span>);  <span class="comment">// 此行可以被正常执行</span></span><br></pre></td></tr></table></figure>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>基础篇主要是讲了我们最常用的一些特性，后续如果大家感兴趣，还可以再来个 “进阶篇”，最后，希望文章中的部分内容可以对大家理解和使用 ES6 有所帮助。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.stackoverflow.com" target="_blank" rel="external">https://www.stackoverflow.com</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/Web/JavaScript</a></li>
<li><a href="https://babeljs.io/docs/learn-es2015/" target="_blank" rel="external">https://babeljs.io/docs/learn-es2015/</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/Web/JavaScript</a></li>
<li><a href="https://ponyfoo.com/articles/es6-spread-and-butter-in-depth" target="_blank" rel="external">https://ponyfoo.com/articles/es6-spread-and-butter-in-depth</a></li>
<li><a href="http://12devs.co.uk/articles/promises-an-alternative-way-to-approach-asynchronous-javascript/" target="_blank" rel="external">http://12devs.co.uk/articles/promises-an-alternative-way-to-approach-asynchronous-javascript/</a></li>
<li><a href="http://www.2ality.com/2015/01/es6-destructuring.html" target="_blank" rel="external">http://www.2ality.com/2015/01/es6-destructuring.html</a></li>
<li><a href="http://www.datchley.name/es6-rest-spread-defaults-and-destructuring/" target="_blank" rel="external">http://www.datchley.name/es6-rest-spread-defaults-and-destructuring/</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="//img.alicdn.com/tfs/TB1HPI1KVXXXXbBXpXXXXXXXXXX-900-500.jpg" alt="ES6 你可能不知道的事 - 基础篇"></p>
<h2 id="序"><a href="#序" class="head]]>
    </summary>
    
      <category term="ES6" scheme="http://taobaofed.org/tags/ES6/"/>
    
      <category term="JavaScript" scheme="http://taobaofed.org/tags/JavaScript/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[性能优化：memoization]]></title>
    <link href="http://taobaofed.org/blog/2016/07/14/performance-optimization-memoization/"/>
    <id>http://taobaofed.org/blog/2016/07/14/performance-optimization-memoization/</id>
    <published>2016-07-14T04:01:25.000Z</published>
    <updated>2016-12-21T02:40:37.000Z</updated>
    <content type="html"><![CDATA[<p><img src="//img.alicdn.com/tfs/TB1wxWIKVXXXXXOapXXXXXXXXXX-900-500.jpg" alt="性能优化：memoization"></p>
<p><code>memoization</code>适用于递归计算场景，例如 <a href="http://en.wikipedia.org/wiki/Fibonacci_number" target="_blank" rel="external">fibonacci 数值</a> 的计算。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> n = process.env.N || <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'process $'</span>, process.pid);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'fibonacci recursive version with n = '</span>, n);</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  count++;</span><br><span class="line">  <span class="comment">//console.log(count);</span></span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">fibonacci(n);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'process memory usage'</span>, process.memoryUsage());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'final count'</span>, count);</span><br></pre></td></tr></table></figure>
<p>如果使用这种递归的写法去计算第 50 个 fibonacci 数值，需要执行 40730022147 次。随着执行次数的增加，执行所需时间成指数上涨：</p>
<p><img src="https://gtms04.alicdn.com/tps/i4/TB1d7ebKpXXXXXdXVXXue9FUVXX-1917-2180.png" alt=""></p>
<p><code>memoization</code>的技巧在于将计算过的结果『缓存』下来，避免重复计算带来的成本，例如将计算 fibonacci 的代码改写为如下形式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> N = process.env.N || <span class="number">50</span>;</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fibonacci = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> memo = &#123;&#125;;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">let</span> value;</span><br><span class="line">    <span class="keyword">if</span> (n <span class="keyword">in</span> memo) &#123;</span><br><span class="line">      value = memo[n];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) &#123;</span><br><span class="line">        value = n;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        value = f(n - <span class="number">1</span>) + f(n - <span class="number">2</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      memo[n] = value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">fibonacci(N);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'process memory usage'</span>, process.memoryUsage());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'final count'</span>, count);</span><br></pre></td></tr></table></figure>
<p>计算第 50 个 fibonacci 值只需要 99 次，执行时间为 0.06 秒，只有递归版本执行时间（546.41 秒）的万分之一，使用的内存（RSS 值 20111360）只有递归版本（RSS 值为 36757504）的 54%。</p>
<blockquote>
<p> 值得注意的是：这里闭包使用的<code>memo</code>对象有可能造成内存泄露。</p>
</blockquote>
<p><img src="https://gtms01.alicdn.com/tps/i1/TB1Q88ZKpXXXXcmaXXX9gOTNXXX-1922-768.png" alt=""></p>
<h3 id="处理多个参数"><a href="#处理多个参数" class="headerlink" title="处理多个参数"></a>处理多个参数</h3><p>如果需要处理多个参数，需要把缓存的内容变成多维数据结构，或者把多个参数结合起来作为一个索引。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> N = process.env.N || <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fibonacci = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> memo = &#123;&#125;;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> value;</span><br><span class="line">    memo[x] = memo[x] || &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (x <span class="keyword">in</span> memo &amp;&amp; n <span class="keyword">in</span> memo[x]) &#123;</span><br><span class="line">      value = memo[x][n];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) &#123;</span><br><span class="line">        value = n;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        value = f(n - <span class="number">1</span>) + f(n - <span class="number">2</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      memo[x][n] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">fibonacci(<span class="string">'a'</span>, N);</span><br><span class="line">fibonacci(<span class="string">'b'</span>, N);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'process memory usage'</span>, process.memoryUsage());</span><br></pre></td></tr></table></figure>
<p>上面执行了两次<code>fibonacci</code>函数，假设执行多次：</p>
<p><img src="https://gtms01.alicdn.com/tps/i1/TB1hgewKpXXXXXLXpXXASkp1VXX-1954-918.png" alt=""></p>
<p>可以看到内存的增长也是有限的，并且最终控制在了<code>22097920</code>这个值。下面是另一种处理多个参数的情况（将多个参数组成一个索引）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> N = process.env.N || <span class="number">50</span>;</span><br><span class="line"><span class="keyword">let</span> count;</span><br><span class="line"><span class="keyword">let</span> memo = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> slice = <span class="built_in">Array</span>.prototype.slice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fibonacci = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  count = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, n</span>) </span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">let</span> args = slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">let</span> value;</span><br><span class="line">    memo[x] = memo[x] || &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (args <span class="keyword">in</span> memo) &#123;</span><br><span class="line">      value = memo[args];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(n == <span class="number">0</span> || n == <span class="number">1</span>) &#123;</span><br><span class="line">        value = n;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        value = f(x, n - <span class="number">1</span>) + f(x, n - <span class="number">2</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      memo[args] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">  count = <span class="number">0</span>;</span><br><span class="line">  result = fibonacci(<span class="string">'#'</span> + i, i);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'process memory usage'</span>, process.memoryUsage());</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'final count'</span>, count);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'result of #'</span> + i, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与上面版本相比，内存有所增加，速度有所下降：</p>
<p><img src="https://gtms02.alicdn.com/tps/i2/TB1x71oKpXXXXcEXpXXj7Qt5VXX-3824-2270.png" alt="50 次对比" title="50 次对比"></p>
<p><img src="https://gtms03.alicdn.com/tps/i3/TB1TTt8KpXXXXc9XVXX4nXcUXXX-3832-2300.png" alt="100 次对比" title="100 次对比"></p>
<p><img src="https://gtms04.alicdn.com/tps/i4/TB18uugKpXXXXb9XFXXX9u8OXXX-3820-2304.png" alt="1000 次对比" title="1000 次对比"></p>
<h3 id="自动memoization"><a href="#自动memoization" class="headerlink" title="自动memoization"></a>自动<code>memoization</code></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">memoize</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> memo = &#123;&#125;;</span><br><span class="line">  <span class="keyword">let</span> slice = <span class="built_in">Array</span>.prototype.slice;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> args = slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">if</span> (args <span class="keyword">in</span> memo) &#123;</span><br><span class="line">      <span class="keyword">return</span> memo[args];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> memo[args] = func.apply(<span class="keyword">this</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是需要注意的是，并不是所有函数都可以自动<code>memoization</code>，只有<code>referential transparency</code>（引用透明）的函数可以。所谓<code>referential transparency</code>的函数是指：函数的输出完全由其输入决定，且不会有副作用的函数。下面的函数就是一个反例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo 函数的结果还受到全局变量 bar 的影响</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">baz</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> baz + bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>);</span><br><span class="line">bar++;</span><br><span class="line">foo(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>对比自动<code>memoization</code>前后的两个版本：</p>
<p><img src="https://gtms02.alicdn.com/tps/i2/TB1soOyKpXXXXaPXVXX28mEJXXX-3814-420.png" alt=""></p>
<p>自动<code>memoization</code>处理后的版本有所提高，但相比手动完全<code>memoization</code>的版本效率还是差了很多。</p>
<p>其实<code>memoization</code>这个词来自人工智能研究领域，其词源为拉丁语<code>memorandum</code>，这个词的创造者为<a href="http://www.aiai.ed.ac.uk/~dm/dm.html" target="_blank" rel="external">Donald Michie</a>，这种函数的设计初衷是为了提升机器学习的性能。随着函数式编程语言（Functional Programming，简称 FP）的兴起，例如 JavaScript、Haskell 以及 Erlang，这种用法才变得越来越流行。在前端编程中，可以使用<code>memoization</code>去处理各种需要递归计算的场景，例如缓存 canvas 动画的计算结果。</p>
<p>上面自动<code>memoization</code>的结果并不理想，可以参考<code>underscore</code>和<code>lodash</code>的<code>memoize</code>来做优化。</p>
<p>使用<a href="https://github.com/lodash/lodash/blob/145c3abb34ae327679d90d18804c7b955398c390/vendor/underscore/underscore.js#L777" target="_blank" rel="external"><code>lodash</code>的<code>memoize</code></a>方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * @filename: fibonacci-memoization-with-lodash.js</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> n = process.env.N || <span class="number">50</span>;</span><br><span class="line"><span class="keyword">let</span> _ = <span class="built_in">require</span>(<span class="string">'lodash'</span>);</span><br><span class="line"><span class="keyword">let</span> memoize = _.memoize;</span><br><span class="line"><span class="keyword">let</span> fibonacci = <span class="built_in">require</span>(<span class="string">'./fibonacci-recursive.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newFibonacci = memoize(fibonacci);</span><br><span class="line"><span class="keyword">let</span> result = newFibonacci(n);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'process memory usage'</span>, process.memoryUsage());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'result'</span>, result);</span><br></pre></td></tr></table></figure>
<p>对比结果：</p>
<p><img src="http://gtms01.alicdn.com/tps/i1/TB1pHCxKpXXXXcsXVXXT7Jp5pXX-3760-400.png" alt=""></p>
<p>可以看到<code>lodash</code>的<code>memoize</code>方法减少了一半执行时间。进一步优化：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">memoize</span>(<span class="params">func, context</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">memoizeArg</span>(<span class="params">argPos</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cache = &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (argPos == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(<span class="built_in">arguments</span>[argPos] <span class="keyword">in</span> cache)) &#123;</span><br><span class="line">          cache[<span class="built_in">arguments</span>[argPos]] = func.apply(context, <span class="built_in">arguments</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cache[<span class="built_in">arguments</span>[argPos]];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(<span class="built_in">arguments</span>[argPos] <span class="keyword">in</span> cache)) &#123;</span><br><span class="line">          cache[<span class="built_in">arguments</span>[argPos]] = memoizeArg(argPos - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cache[<span class="built_in">arguments</span>[argPos]].apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> arity = func.arity || func.length;</span><br><span class="line">  <span class="keyword">return</span> memoizeArg(arity - <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="http://gtms01.alicdn.com/tps/i1/TB1q4SZKpXXXXcRXXXXusZkMpXX-1918-320.png" alt=""></p>
<blockquote>
<p> 科普下：<code>function arity</code>指的是一个函数接受的参数个数，这是一个被废弃的属性，现在应使用<code>Function.prototype.length</code>。<br> <a href="https://stackoverflow.com/questions/4848149/get-a-functions-arity" target="_blank" rel="external">https://stackoverflow.com/questions/4848149/get-a-functions-arity</a></p>
</blockquote>
<p>zakas 的版本更加快，甚至比我们将<code>fibonacci</code>手动<code>memoization</code>的版本还快：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">let</span> n = process.env.N || <span class="number">50</span>;</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">memoizer</span>(<span class="params">fundamental, cache</span>) </span>&#123;</span><br><span class="line">  cache = cache || &#123;&#125;;</span><br><span class="line">  <span class="keyword">let</span> shell = <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cache.hasOwnProperty(arg)) &#123;</span><br><span class="line">      cache[arg] = fundamental(shell, arg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cache[arg];</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> shell;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fibonacci = memoizer(<span class="function"><span class="keyword">function</span>(<span class="params">recur, n</span>) </span>&#123;</span><br><span class="line">  count++;</span><br><span class="line">  <span class="keyword">return</span> recur(n - <span class="number">1</span>) + recur(n - <span class="number">2</span>);</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="number">1</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = fibonacci(n);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'process memory usage'</span>, process.memoryUsage());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'count'</span>, count);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'result'</span>, result);</span><br></pre></td></tr></table></figure>
<p><img src="http://gtms02.alicdn.com/tps/i2/TB1taHXKpXXXXXqXXXXHSJCLpXX-1916-570.png" alt=""></p>
<p>但是上面这些函数都存在问题，如果输入数目过大，会引发调用栈超过限制异常：<code>RangeError: Maximum call stack size exceeded</code>。</p>
<p>一种解决的方法就是将递归（<code>recursion</code>）修改为迭代（<code>iteration</code>）。例如下面这样的归并排序算法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> n = process.env.N || <span class="number">100</span>;</span><br><span class="line"><span class="keyword">let</span> isMemoized = process.env.M;</span><br><span class="line"><span class="keyword">let</span> test = [];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (left.length &gt; <span class="number">0</span> &amp;&amp; right.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left[<span class="number">0</span>] &lt; right[<span class="number">0</span>]) &#123;</span><br><span class="line">      result.push(left.shift());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.push(right.shift());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result.concat(left).concat(right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">items</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (items.length == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> items;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> middle = <span class="built_in">Math</span>.floor(items.length / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">let</span> left = items.slice(<span class="number">0</span>, middle);</span><br><span class="line">    <span class="keyword">let</span> right = items.slice(middle);</span><br><span class="line">    <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">  test.push(<span class="built_in">Math</span>.random() * <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result;</span><br><span class="line"><span class="keyword">if</span> (isMemoized) &#123;</span><br><span class="line">  <span class="keyword">let</span> memoize = <span class="built_in">require</span>(<span class="string">'./zakas-memo.js'</span>);</span><br><span class="line">  mergeSort = memoize(mergeSort);</span><br><span class="line">  result = mergeSort(test);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  result = mergeSort(test);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'process memory usage'</span>, process.memoryUsage());</span><br></pre></td></tr></table></figure>
<p><img src="http://gtms01.alicdn.com/tps/i1/TB1L8uRKpXXXXbkXFXXDHvXMXXX-3822-622.png" alt=""></p>
<p>而上面的排序函数在经过<code>memoization</code>后虽然不会抛出<code>RangeError: Maximum call stack size exceeded</code>的异常，但是在极端情况下也会因为内存不够分配导致失败：</p>
<p><img src="https://gtms02.alicdn.com/tps/i2/TB1XrjXKpXXXXaxXXXXrdqLOXXX-1926-1882.png" alt=""></p>
<p>解决<code>RangeError: Maximum call stack size exceeded</code>异常的一种方法是将递归的代码改写为迭代的代码，例如<code>fibonacci</code>的递归式写法为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  n = <span class="built_in">parseInt</span>(n);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'n = '</span>, n);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isNaN</span>(n)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> first = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> prev = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> sum;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">      sum = n;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        sum = first + prev;</span><br><span class="line">        first = prev;</span><br><span class="line">        prev = sum;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'i = '</span> + i + <span class="string">':'</span> + <span class="string">' sum = '</span> + sum);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="他山之石"><a href="#他山之石" class="headerlink" title="他山之石"></a>他山之石</h3><p>在 JavaScript 中我们是通过函数的形式来是实现函数的<code>memoization</code>，在 Python 中还可以用另一种被称为<code>decorator</code>的形式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">memoize</span><span class="params">(f)</span>:</span></span><br><span class="line">    memo = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> memo:</span><br><span class="line">            memo[x] = f(x)</span><br><span class="line">        <span class="keyword">return</span> memo[x]</span><br><span class="line">    <span class="keyword">return</span> helper</span><br><span class="line"></span><br><span class="line"><span class="meta">@memoize</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">print(fib(<span class="number">100</span>))</span><br></pre></td></tr></table></figure>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://www.sitepoint.com/implementing-memoization-in-javascript/" target="_blank" rel="external">https://www.sitepoint.com/implementing-memoization-in-javascript/</a></li>
<li><a href="http://en.wikipedia.org/wiki/Referential_transparency_(computer_science" target="_blank" rel="external">Referential transparency</a>)</li>
<li><a href="https://addyosmani.com/blog/faster-javascript-memoization/" target="_blank" rel="external">https://addyosmani.com/blog/faster-javascript-memoization/</a></li>
<li><a href="http://unscriptable.com/index.php/2009/05/01/a-better-javascript-memoizer/" target="_blank" rel="external">http://unscriptable.com/index.php/2009/05/01/a-better-javascript-memoizer/</a></li>
<li><a href="http://www.nczonline.net/blog/2009/01/27/speed-up-your-javascript-part-3/" target="_blank" rel="external">http://www.nczonline.net/blog/2009/01/27/speed-up-your-javascript-part-3/</a></li>
<li><a href="http://books.google.co.uk/books?id=PXa2bby0oQ0C&amp;pg=PA44&amp;lpg=PA44&amp;dq=crockford+memoization&amp;source=bl&amp;ots=HImnm6r1iH&amp;sig=lrdT9Sk4F4yQ-xQ-TLTx4SpLkuk&amp;hl=en&amp;ei=C-hyTvaIEofB8QO21Nn_DQ&amp;sa=X&amp;oi=book_result&amp;ct=result&amp;resnum=4&amp;ved=0CDMQ6AEwAw#v=onepage&amp;q&amp;f=false" target="_blank" rel="external">http://books.google.co.uk/books?id=PXa2bby0oQ0C&amp;pg=PA44&amp;lpg=PA44&amp;dq=crockford+memoization&amp;source=bl&amp;ots=HImnm6r1iH&amp;sig=lrdT9Sk4F4yQ-xQ-TLTx4SpLkuk&amp;hl=en&amp;ei=C-hyTvaIEofB8QO21Nn_DQ&amp;sa=X&amp;oi=book_result&amp;ct=result&amp;resnum=4&amp;ved=0CDMQ6AEwAw#v=onepage&amp;q&amp;f=false</a></li>
<li><a href="http://my.safaribooksonline.com/book/programming/javascript/9781449399115/functions/function_propertiesma_memoization_patter#X2ludGVybmFsX0ZsYXNoUmVhZGVyP3htbGlkPTk3ODE0NDkzOTkxMTUvNzY=" target="_blank" rel="external">http://my.safaribooksonline.com/book/programming/javascript/9781449399115/functions/function_propertiesma_memoization_patter#X2ludGVybmFsX0ZsYXNoUmVhZGVyP3htbGlkPTk3ODE0NDkzOTkxMTUvNzY=</a></li>
<li>memoize function javascript | npm memoize | lodash memoize | underscore memoize</li>
<li><a href="http://unscriptable.com/2009/05/01/a-better-javascript-memoizer/" target="_blank" rel="external">http://unscriptable.com/2009/05/01/a-better-javascript-memoizer/</a></li>
<li>programming optimization techniques</li>
<li><a href="http://blog.stevenlevithan.com/archives/timed-memoization" target="_blank" rel="external">http://blog.stevenlevithan.com/archives/timed-memoization</a></li>
<li><a href="https://github.com/addyosmani/memoize.js" target="_blank" rel="external">https://github.com/addyosmani/memoize.js</a></li>
<li><a href="https://en.wikipedia.org/wiki/Arity" target="_blank" rel="external">function arity</a></li>
<li><a href="https://philogb.github.io/blog/2008/09/05/memoization-in-javascript/" target="_blank" rel="external">https://philogb.github.io/blog/2008/09/05/memoization-in-javascript/</a></li>
<li><a href="https://stackoverflow.com/questions/6184869/what-is-difference-between-memoization-and-dynamic-programming" target="_blank" rel="external">https://stackoverflow.com/questions/6184869/what-is-difference-between-memoization-and-dynamic-programming</a></li>
<li><a href="http://www.python-course.eu/python3_memoization.php" target="_blank" rel="external">http://www.python-course.eu/python3_memoization.php</a></li>
<li><a href="https://en.wikipedia.org/wiki/Iteration" target="_blank" rel="external">https://en.wikipedia.org/wiki/Iteration</a></li>
<li><a href="https://en.wikipedia.org/wiki/Iterated_function" target="_blank" rel="external">https://en.wikipedia.org/wiki/Iterated_function</a></li>
<li><a href="https://www.ics.uci.edu/~eppstein/161/960109.html" target="_blank" rel="external">https://www.ics.uci.edu/~eppstein/161/960109.html</a></li>
<li><a href="https://classes.soe.ucsc.edu/cmpe012/Summer09/labs/lab8-Recursion-vs-Iteration/" target="_blank" rel="external">https://classes.soe.ucsc.edu/cmpe012/Summer09/labs/lab8-Recursion-vs-Iteration/</a></li>
<li>google: iterative merge sort</li>
<li>google: maximum call stack size exceeded | avoid maximum recursive</li>
<li><a href="http://www.python-course.eu/python3_decorators.php" target="_blank" rel="external">http://www.python-course.eu/python3_decorators.php</a></li>
<li><a href="https://www.cs.cornell.edu/courses/cs3110/2011sp/lectures/lec22-memoization/memo.htm" target="_blank" rel="external">https://www.cs.cornell.edu/courses/cs3110/2011sp/lectures/lec22-memoization/memo.htm</a></li>
<li>dynamic programming</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="//img.alicdn.com/tfs/TB1wxWIKVXXXXXOapXXXXXXXXXX-900-500.jpg" alt="性能优化：memoization"></p>
<p><code>memoization</code>适用于递归计算场景，]]>
    </summary>
    
      <category term="性能优化" scheme="http://taobaofed.org/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="javascript" scheme="http://taobaofed.org/tags/javascript/"/>
    
      <category term="memoization" scheme="http://taobaofed.org/tags/memoization/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[聊一聊淘宝首页和它背后的一套]]></title>
    <link href="http://taobaofed.org/blog/2016/06/02/thing-about-taobao-homepage/"/>
    <id>http://taobaofed.org/blog/2016/06/02/thing-about-taobao-homepage/</id>
    <published>2016-06-02T06:45:32.000Z</published>
    <updated>2016-12-21T02:40:37.000Z</updated>
    <content type="html"><![CDATA[<p><img src="//img.alicdn.com/tfs/TB1dcfNKXXXXXXcXVXXXXXXXXXX-900-500.png" alt="聊一聊淘宝首页和它背后的一套"></p>
<p>从 14 年双十二结束开始接手淘宝首页，到如今差不多 1 年半时间了，不久前完成了首页相关工作的交接。经历了两次改版和一次从 PHP 到 Node 的迁移，还是颇有感受，下面给大家分享下。</p>
<h3 id="一、相关背景介绍"><a href="#一、相关背景介绍" class="headerlink" title="一、相关背景介绍"></a>一、相关背景介绍</h3><p>淘宝首页是淘宝的门面，承载着几乎淘系所有业务的入口，流量很大，量级单位为亿。近几年无线端崛起，业务重点开始向无线终端偏移（目前不能叫偏移，基本以无线为主了），所以淘宝 PC 端首页的流量也有削减，不过即便如此，它的日均 PV 依然相当高。</p>
<p>淘宝首页一向是内部平台和技术的试验田，它一直在变化着。最新的框架和系统都会找淘宝首页试点，可以试想下，如果某一项需要推动的升级或者优化措施在淘宝首页已经上线，并且拿到了良好的数据和稳定性，其他业务还有什么理由不去尝试和更迭呢？同时，去年一年身在淘宝前端的技术架构组，自然而然也会主动去 push 一些实验性的内容到业务上。</p>
<p>淘系的站点页面包括首页、其他频道页和活动页等，这些页面并不都由淘宝前端一行一行的代码码出来，业务如此之多，这种玩法即便人数 double 也忙不过来。事实上，大多数页面都是依托内部的搭建平台——运营或者前端通过模块搭建的方式——构建的，而前端 focus 的重点在于搭建平台的建设自身以及模块的通用性和复用率的保障，当然，还有一些工程化的东西。</p>
<p>使用搭建平台搭建的页面，前端只需要考虑组成页面的原子模块的开发，整体的渲染由搭建平台提供的统一脚本全权负责。而在淘宝首页上，考虑到页面模块数量巨多，加上还有少量跨部门、跨团队的沟通，渲染模型略微不同。</p>
<h3 id="二、淘宝首页的整体变迁"><a href="#二、淘宝首页的整体变迁" class="headerlink" title="二、淘宝首页的整体变迁"></a>二、淘宝首页的整体变迁</h3><p>背景中提到，淘宝首页依托于内部搭建平台，它的变迁自然也是跟着搭建系统的变化而变化的。</p>
<h4 id="1-PHP-下的淘宝首页"><a href="#1-PHP-下的淘宝首页" class="headerlink" title="1. PHP 下的淘宝首页"></a>1. PHP 下的淘宝首页</h4><p>接手淘宝首页不久，便遇到了一年一度的改版，那时它还运行在 PHP 环境中。这里需要说明的是，淘宝首页的所有代码完全由前端掌控，前端不会直接跟数据库打交道，其数据来源分为两部分。</p>
<p><strong>数据来源</strong></p>
<p>一是 <em>运营填写的数据。</em> 采用前端挖坑的形式，预留坑位让运营获取填写数据，如（伪代码）：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> $info = Person(<span class="string">'name:String:姓名,age:Number:年龄'</span>, <span class="string">'个人信息坑位填写'</span>);<span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;div&gt;</span><br><span class="line"><span class="meta">&lt;?php</span> $info.<span class="keyword">forEach</span>(index) &#123; <span class="meta">?&gt;</span></span><br><span class="line">  Name: <span class="meta">&lt;?</span>= info[index].name <span class="meta">?&gt;</span>, Age: <span class="meta">&lt;?</span>= info[index].age <span class="meta">?&gt;</span></span><br><span class="line"><span class="meta">&lt;?php</span> &#125; <span class="meta">?&gt;</span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>上面的代码会产生一份 PHP 的模板和 info 字段对应的表单坑位，这个过程简称「挖坑」。</p>
<p><img src="http://ww4.sinaimg.cn/large/6c0378f8gw1f4g54zdicej20do09cdfy.jpg" alt="挖坑"></p>
<p>运营填写这些坑位就会产生这份 PHP 模板对应的数据，最后渲染出来就是一个完整的 HTML 片段（实时性渲染）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── data.json   <span class="comment"># 运营数据的来源</span></span><br><span class="line">└── index.php   <span class="comment"># 装载运营数据的 PHP 模板</span></span><br></pre></td></tr></table></figure>
<p>旧版搭建系统中就是通过这种方式构造一个子模块。我描述得十分简单，但作为一个平台它需要考虑的东西还有很多很多的，比如数据顺序的控制、定时发布、回滚机制、过滤机制、筛选机制、数据的同步、数据的更新、版本控制、权限控制、其他系统的引用等等。</p>
<p>二是 <em>后端或者个性化平台提供的数据。</em> 不同的业务有不同的诉求。一些业务有自己的后端，他们要求使用自己业务产出的数据；有的业务希望用户看到的内容不一样，千人千面，期望接入算法；一些业务跟卖家直接打交道，期望使用招商数据；而有些业务期望采用运营从数据池筛选出来的数据…总之，淘宝首页需要对接形形色色的系统，接口繁多。后面会提到对动态数据源的整合。</p>
<p>并且这些系统对应的域名是不一样的，JSONP 格式自然也就成了首选。但一些特殊的系统，比如广告，它的渲染并不是一个简单的 JSONP 请求，可能它还要干预整个广告的渲染流程，比如加载他们的 JS，把渲染的控制权交过去。</p>
<p><strong>页面的架构</strong></p>
<p>上面介绍了数据的来源和子模块的结构，那么整个页面又是如何构成的呢？模块的搭建分为两种，一种是可视化搭建，运营或者前端可以将开发好的模块（或者模块库中选取的模块）拖拽到容器内，形成一个页面，</p>
<p><img src="http://ww2.sinaimg.cn/large/6c0378f8gw1f4g51ddlmzj21ao0x4dij.jpg" alt="模块搭建"></p>
<p>当然，上图也只是一个模型，作为一个系统需要考虑的问题还有很多很多，如页面的布局、多终端适配、模块的临时隐藏、位置调整、皮肤选择、模块的复制等等。</p>
<p>也可以通过如下源码搭建的方式（伪代码）：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  <span class="meta">&lt;?</span>= loadModule(Mod1ID) <span class="meta">?&gt;</span></span><br><span class="line">  <span class="meta">&lt;?</span>= loadModule(Mod2ID) <span class="meta">?&gt;</span></span><br><span class="line">  <span class="meta">&lt;?</span>= loadModule(Mod3ID, <span class="string">'lazyload'</span>) <span class="meta">?&gt;</span></span><br><span class="line">  <span class="meta">&lt;?</span>= loadModule(Mod4ID, <span class="string">'lazyload'</span>) <span class="meta">?&gt;</span></span><br><span class="line">  <span class="meta">&lt;?</span>= loadModule(Mod5ID, <span class="string">'lazyload'</span>) <span class="meta">?&gt;</span></span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<p>通过模块 id 将模块引入，并且添加一些类似 <code>lazyload</code> 的标记，方便控制渲染节奏和数据入口。源码搭建和模块搭建的区别在于，前者更易于控制模块的结构以及模块的渲染顺序。</p>
<p><strong>动态数据源</strong></p>
<p>首页面对一大堆接口和平台，对接几十个业务方，接口是个很大的问题，由于后台系统的差异，基本没有办法统一数据源的格式，一旦运营哪天心血来潮要换一个他自己觉得用的更爽的或者数据更好的系统，前后端估计又得沟通和对接几次。所以出现了下面这张图：</p>
<p><img src="http://ww2.sinaimg.cn/large/6c0378f8gw1f4g5mwl5jzj218w0psdia.jpg" alt="动态数据源"></p>
<p>平台具备数据源接入的能力，也就是说我们挖的坑不仅仅可以让运营填数据，还可以从各种数据源中直接导入数据，当然，这里需要进行一次数据字段的映射转换。后端提供的接口是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"data"</span>: [&#123;</span><br><span class="line">    <span class="string">"item_name"</span>: <span class="string">"name"</span>,</span><br><span class="line">    <span class="string">"item_url"</span>: <span class="string">"http://xxx"</span>,</span><br><span class="line">    <span class="string">"item_pic"</span>: <span class="string">"http://xxx"</span></span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前端约定的接口形式是: </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"info"</span>: [&#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"name"</span>,</span><br><span class="line">    <span class="string">"url"</span>: <span class="string">"http://xxx"</span></span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么系统必须提供这种映射的绑定策略：</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">info</span>/<span class="keyword">name</span> -&gt;</span> <span class="keyword">data</span>/item_name</span><br><span class="line"><span class="function"><span class="title">info</span>/url -&gt;</span> <span class="keyword">data</span>/item_url</span><br></pre></td></tr></table></figure>
<p>绑定之后，数据既可以同步输出，也可以异步输出，这些都是平台提供的能力。这个方案基本上解决了后端系统/接口变化的问题，并且减少了前后端之间的沟通成本。</p>
<p>不过这里需要注意的是，虽然页面上的接口都通过平台统一梳理了一次，这也意味着，页面所有的请求会先流经平台，然后分发到各个后端，平台的抗压能力要求很高。</p>
<h4 id="2-PHP-到-Node-的变迁"><a href="#2-PHP-到-Node-的变迁" class="headerlink" title="2. PHP 到 Node 的变迁"></a>2. PHP 到 Node 的变迁</h4><p>淘宝首页日均请求的这个量级，不可能是十几二十台台服务器抗得住的，支撑它必须有一个服务集群。</p>
<p><img src="http://ww4.sinaimg.cn/large/6c0378f8gw1f4g6rdqpd0j212o0s076f.jpg" alt="集群"></p>
<p>每一个 CDN 节点上都具备 PHP 渲染的能力，当页面发布时，我们把该页面所有的模块和数据同步到全部 CDN 节点上，基本模式大概就是如此了。看起来还挺不错，但是经过一段时间的运维，很多安全、性能问题都慢慢浮现出来了：</p>
<p><em>性能问题。</em> 每个 PHP 页面包含多个子模块，而子模块也有可能引用了其他的子模块，PHP 的 <code>include</code> 操作是存在消耗的，每一次引用都是一次磁盘 IO，一个渲染节点上跑了成千上万个类似淘宝首页的 PHP 页面，并发一高其效率可想而知。</p>
<p><em>推送机制问题。</em> 文件同步（图中的 <code>sync</code> 动作）是一种比较恶心的机制，首先，时间上没法控制，一个文件同步到所有的节点，快则几秒钟，慢的话耗时会超过一两分钟；并且同步过程还有可能失败，健康检测的成本也是相当高的。发布比较紧凑时，需要同步的文件也很多，很容易造成队列堆积，加剧同步差的体验。</p>
<p><em>实时性强需求问题。</em> 文件在推送之前，还可能经过一些前置系统，发布链路越长，线上生效时间越慢，慢的时候大约五分钟才生效，这样的延时对于实时性要求很高（如秒杀）的需求来说是完全不能接受的。</p>
<p>当然，还有很多其他问题，如运维成本增高、安全风险增高、PHP 资深人才储备不足等等。所以 PHP 渲染容器的命运，就是，被干掉。</p>
<p><img src="http://ww4.sinaimg.cn/large/6c0378f8gw1f4g7eogvy9j21840tatb1.jpg" alt="回源"></p>
<p>上图改变了下玩法，服务集群为 Cache CDN，它只有静态文件处理能力，没有 PHP/Node 的渲染能力，所以处理效率高，性能也好，抗压能力相当强，并且扛不住的时候还可以花钱买服务，拓展 Cache 集群。</p>
<p>用户访问时，Nginx 转到 Cache CDN，如果命中缓存则直接返回，没有命中便回源到源站服务器。源站服务器是具备模块渲染能力的 Node 服务，它可以做很多事情：</p>
<ul>
<li>控制 Cache 响应头，通过 <code>max-age</code> 和 <code>s-maxage</code> 控制页面在客户端的缓存时间以及在 Cache 上的缓存时间，这个缓存时间可以根据需求随时做调整，比如大促的时候调长一些</li>
<li>控制内外网环境，和 AB 测试状态</li>
<li>融合前端相关的工具链，比如检测、压缩、过滤等等</li>
</ul>
<p>它的优势有很多，这里不一一列举了。这个模式中还添加了一层容灾，源站服务器每隔一段时间将数据推送到于 Cache 同机房的备份服务器，一点源站挂了，还能够自动容灾到备份数据上。</p>
<p>模式的变化不仅在运维上有了突破，CDN 被攻击时的安全风险也低了很多，同时也省却了 sync 所需的各种检测机制，每年节约成本也是百万以上，优势还是相当明显。</p>
<h4 id="3-Node，不一样的模式"><a href="#3-Node，不一样的模式" class="headerlink" title="3. Node，不一样的模式"></a>3. Node，不一样的模式</h4><p>上面 PHP 模块中，我们只说了 HTML 和数据部分，用心的读者应该已经发现，CSS 和 JS 这些静态资源都没提到，那页面是如何渲染的呢？</p>
<p>旧版 PHP 页面中，我们是直接引入了一个 CSS 和一个 JS，淘宝这边采用的是 git 版本迭代发布，这些静态资源都是直接放在一个 git 仓库中。也就是这样：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"//cdn/@VERSION@/index.css"</span>&gt;</span><br><span class="line">  &lt;script src=<span class="string">"//cdn/@VERSION@/index.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  <span class="meta">&lt;?</span>= loadModule(Mod1ID) <span class="meta">?&gt;</span></span><br><span class="line">  <span class="meta">&lt;?</span>= loadModule(Mod2ID) <span class="meta">?&gt;</span></span><br><span class="line">  <span class="meta">&lt;?</span>= loadModule(Mod3ID, <span class="string">'lazyload'</span>) <span class="meta">?&gt;</span></span><br><span class="line">  <span class="meta">&lt;?</span>= loadModule(Mod4ID, <span class="string">'lazyload'</span>) <span class="meta">?&gt;</span></span><br><span class="line">  <span class="meta">&lt;?</span>= loadModule(Mod5ID, <span class="string">'lazyload'</span>) <span class="meta">?&gt;</span></span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<p>每次发布完 git 文件，再修改 PHP 的版本号，然后发布 PHP 代码。当然，也做了相关的优化，比如发布 git 时自动更新版本号等。</p>
<p>而新版搭建平台的页面渲染模式与 PHP 的模式不太一样。</p>
<p><img src="http://ww1.sinaimg.cn/large/6c0378f8gw1f4g8566uz3j21kw0yt79h.jpg" alt="Node渲染模型"></p>
<p>一个模块的 CSS/JS 和模板放在一起，CSS/JS 与页面其他模块的静态资源是相互独立的，目的就是希望单个模块也能够完整的跑起来，更加利于模块的复用。</p>
<p>而模块的挖坑，也从模板中独立了出来，采用 JSON Schema 的形式定义数据格式，</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── <span class="keyword">index</span>.css    <span class="meta"># 模块样式</span></span><br><span class="line">├── <span class="keyword">index</span>.js     <span class="meta"># 模块渲染脚本</span></span><br><span class="line">├── schema.json  <span class="meta"># schema 配置</span></span><br><span class="line">└── <span class="keyword">index</span>.xtpl   <span class="meta"># 模块的模板</span></span><br></pre></td></tr></table></figure>
<p>搭建平台通过这个 JSON Schema 解析成 <a href="http://ww4.sinaimg.cn/large/6c0378f8gw1f4g54zdicej20do09cdfy.jpg" target="_blank" rel="external">图一</a> 的坑位。那么一个模块的渲染就变成了 <code>index.xtpl</code> 和挖坑数据之间的拼装了。</p>
<p>模块之间相互独立隔离，所以会存在一定程度的冗余，不过模块解偶带来的收益要比这点冗余要多得多。事实上，我们是通过一个仓库去管理单个模块的。页面的渲染就比较简单了，源站 Node 容器会将所有的 <code>index.xtpl</code> 合并成一个 <code>page.xtpl</code>，为减少页面请求，css 和 js 也会 combo 成一个文件，如上图所示的 <code>http://cdn/??mod1.css,mod2.css,mod3.css</code>。</p>
<p>任何模块的更新，页面都会有感知，下次进入系统时，就会提示是否需要升级模块和页面。</p>
<h3 id="三、淘宝首页的性能优化"><a href="#三、淘宝首页的性能优化" class="headerlink" title="三、淘宝首页的性能优化"></a>三、淘宝首页的性能优化</h3><p>首页模块众多，如果一口气吐出来，DOM 数量必然超过 4k 个，其结果就是首屏时间极长。按照 TMS 的开发规范，每个 TMS 模块都包含一个 <code>index.js</code> 和 <code>index.css</code>，最后展示出来两个 combo 的 js 和 css。首页加载的时候也不会一口气执行所有 <code>index.js</code>，否则刚开始页面阻塞会十分严重。</p>
<p><strong>页面的渲染逻辑</strong></p>
<p><img src="http://ww2.sinaimg.cn/large/6c0378f8gw1f4gse45ss8j20fn0jr0v3.jpg" alt="页面的渲染逻辑"></p>
<p>首页框架的加载逻辑，大致上图所示：</p>
<ul>
<li>遍历所有 TMS 模块（包含一个 <code>J_Module</code> 的钩子）</li>
<li>部分 TMS 模块无 JS 内容，但是加载了一个 <code>index.js</code>，为模块添加 <code>tb-pass</code> 的 class，用于跳过该模块 JS 的执行</li>
<li>将页面分为两块，首屏为一块，非首屏整体为第二块，先将首屏模块加入到懒加载监控</li>
<li>待首屏模块加载完成，或者用户处理了页面交互时（滚动、鼠标移动等），将非首屏模块加入到懒加载监控</li>
<li>处理一些特殊模块，它们会在进入视窗之前几百像素就开始加载</li>
<li>监控滚动，按照以上逻辑，渲染模块</li>
</ul>
<p>部分模块即便是被执行了，也不一定渲染出来，因为它的优先级不高，在模块内部加了事件监听，比如等到 <code>mouseover/onload</code> 事件触发的时候再渲染这些内容。</p>
<p>之前写过性能优化相关的文章，复制就没必要了，直接贴地址：</p>
<ul>
<li><a href="http://taobaofed.org/blog/2016/04/05/optimize-in-tbhome/">《淘宝首页性能优化实践》</a></li>
</ul>
<p>代码的性能优化是一个精细活，如果你要在一个庞大的未经优化的页面上做性能优化，可能会面临一次重构代码。</p>
<p>上面的文章提到的是页面内部的细节优化，但是在开发流程中做的规范化、标准化，以及线上访问通路中的各个环节优化还没有提及。</p>
<h3 id="四、淘宝首页的稳定性保障"><a href="#四、淘宝首页的稳定性保障" class="headerlink" title="四、淘宝首页的稳定性保障"></a>四、淘宝首页的稳定性保障</h3><p>在大流量下，任何小问题都会被放大成大问题，所以开发环节遇到的任何偶发性问题都需要引起重视。不过很多偶发性问题在我们的测试环境中是找不到的，比如与地域相关的问题（如上海的某个 CDN 节点挂了），用户属性问题（如 nickname 最后一个为字母 s 的用户页面天窗），浏览器插件问题，运营商广告注入问题等等。</p>
<p>难以在上线之前把所有问题考虑周全，但是有两点是必须做好的：<strong>兜底容灾 + 监控预警。</strong></p>
<h4 id="1-兜底容灾机制"><a href="#1-兜底容灾机制" class="headerlink" title="1. 兜底容灾机制"></a>1. 兜底容灾机制</h4><p>兜底容灾有两个层面的考虑：</p>
<ul>
<li>异步接口请求错误，包括接口数据格式错误，接口请求超时等</li>
<li>同步渲染，源站页面渲染出错</li>
</ul>
<p>异步接口请求，主要涉及到的是后台系统，对接系统较多，各个系统的稳定性和抗压能力各不相同，这方面的保障有多种方案，下面是最常见的：</p>
<p><img src="http://ww4.sinaimg.cn/large/6c0378f8gw1f4go51ui9zj20kh0h7n0b.jpg" alt="请求缓存"></p>
<p>每次数据请求都缓存到本地，并且为每个接口都提供一个硬兜底。还有一种方案是「重试」，请求一次不成功那就请求第二次。这方面的讨论具体可以看看之前写的这篇文章：<a href="http://taobaofed.org/blog/2015/10/28/disaster-recovery-at-taobao-home-page/">《淘宝首页兜底容灾方案》</a>。</p>
<p>对于同步渲染，它只需要页面模板和同步数据，两者中任一种存在错误，源站都会报错，此时回源返回的内容就是一个 error 页面，状态码为 <code>5xx</code>。这个错误不一定是开发者造成的，有可能是系统链路出现同步异常或者断路问题。针对这种问题，我给淘宝首页做了一个镜像页：</p>
<p><img src="http://ww1.sinaimg.cn/large/6c0378f8gw1f4gonwmraoj21ce0rq0vr.jpg" alt="镜像"></p>
<p>一旦源站任何异常，Nginx 都会转到与 Cache CDN 同机房的首页镜像上去，这个镜像内容就是淘宝首页的 HTML 备份源码。</p>
<h4 id="2-监控预警机制"><a href="#2-监控预警机制" class="headerlink" title="2. 监控预警机制"></a>2. 监控预警机制</h4><p>监控也有两个层面：</p>
<ul>
<li>模块级别的监控，接口请求布点、模块天窗检测等</li>
<li>页面的监控，在页面上添加特殊标记，定时回归所有 CDN 节点，查看特殊标记是否存在</li>
</ul>
<p>模块层面的监控，内容还是相当多的，监控的点越多越详细，到最后定位问题的效率就会越高，比如在一个稍微复杂的模块上，我会埋下这些监控：</p>
<ul>
<li>接口请求格式错误、请求失败、请求超时，至少三个埋点</li>
<li>硬兜底数据请求失败埋点</li>
<li>模块 5s 内没有渲染完成统计埋点</li>
<li>模块内链接和图片黑白名单匹配埋点</li>
</ul>
<p><img src="http://ww3.sinaimg.cn/large/6c0378f8gw1f4gtw0jjxxj20w50akace.jpg" alt="监控"></p>
<p>其中部分监控还会自动处理明确的错误，比如 https 页面下出现了 http 的图片，会立即自动处理掉这些问题。</p>
<h4 id="3-上线前的自动化检测"><a href="#3-上线前的自动化检测" class="headerlink" title="3. 上线前的自动化检测"></a>3. 上线前的自动化检测</h4><p>这属于淘宝整个工程化环境的一部分，前端自动化测试。一般会在上线之前处理这些问题：</p>
<ul>
<li>检测 HTML 是否符合规范</li>
<li>检测 https 升级情况</li>
<li>检测链接合法性</li>
<li>检测静态资源合法性</li>
<li>检测 JavaScript 报错</li>
<li>检测页面加载时是否有弹出框</li>
<li>检测页面是否调用 <code>console.*</code></li>
<li>页面 JS 内存记录</li>
</ul>
<p>当然，也可以自己添加测试用例，比如检测接口数据格式、模块天窗问题等。自动化检测也可以设定定时回归，还是比较有保障的。</p>
<h3 id="五、淘宝首页的敏捷措施"><a href="#五、淘宝首页的敏捷措施" class="headerlink" title="五、淘宝首页的敏捷措施"></a>五、淘宝首页的敏捷措施</h3><h4 id="1-健康检查"><a href="#1-健康检查" class="headerlink" title="1. 健康检查"></a>1. 健康检查</h4><p>页面模块众多，为了能够追踪页面上每一个小点的变化，我在请求、渲染的每一个环节都做了详细的统计，如下图所示：</p>
<p><img src="http://ww3.sinaimg.cn/large/6c0378f8gw1f4gt6p2lsfj20la0gmjwg.jpg" alt="Console"></p>
<p>一旦接口请求失败，或者接口走了容灾逻辑，或者模块渲染超过 5s，控制台都会有黄色警报，当然此时，也已经向服务器发送了警报统计。</p>
<h4 id="2-接口-Hub"><a href="#2-接口-Hub" class="headerlink" title="2. 接口 Hub"></a>2. 接口 Hub</h4><p>接口 Hub 是对数据请求的管理工具，如下图所示：</p>
<p><img src="http://ww1.sinaimg.cn/large/6c0378f8gw1f4gt7e0p74j20j70cvtbv.jpg" alt="HubCache"></p>
<p>页面很多模块的渲染都需要一个以上的数据源，一旦运营反馈页面渲染数据异常，可以直接通过 Hub 找到数据，加速 Bug 定位效率。同时 Hub 也可以用来切换环境，将一个接口的请求切换到日常或者预发环境的接口之中，它是调试的利器。</p>
<h4 id="3-快捷通道"><a href="#3-快捷通道" class="headerlink" title="3. 快捷通道"></a>3. 快捷通道</h4><p>我在页面脚本执行前后都放了一个快捷操作通道，一旦遇到紧急线上问题，比如样式错乱溢出、接口报错导致天窗等，可以通过快捷通道直接修改页面的 CSS 和 JS，两分钟内上线。</p>
<p>不过这类通道只适合紧急问题的修复，毕竟随意插入 JS 代码是存在很大风险的。</p>
<h3 id="六、小结"><a href="#六、小结" class="headerlink" title="六、小结"></a>六、小结</h3><p>写的好像有点虎头蛇尾（码字和画图都太累），还有很多方面没有延伸拓展开。希望以上可以让你对淘宝首页有一个基本的认识。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="//img.alicdn.com/tfs/TB1dcfNKXXXXXXcXVXXXXXXXXXX-900-500.png" alt="聊一聊淘宝首页和它背后的一套"></p>
<p>从 14 年双十二结束开始接手淘宝首页，到如今差不多 1 年半时间了，不]]>
    </summary>
    
      <category term="淘宝首页" scheme="http://taobaofed.org/tags/%E6%B7%98%E5%AE%9D%E9%A6%96%E9%A1%B5/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
</feed>
