<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Taobao FED | 淘宝前端团队]]></title>
  <subtitle><![CDATA[淘宝前端团队（FED）]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://taobaofed.org/"/>
  <updated>2017-03-18T09:50:27.000Z</updated>
  <id>http://taobaofed.org/</id>
  
  <author>
    <name><![CDATA[Taobao FED]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[我眼中的 JavaScript 函数式编程]]></title>
    <link href="http://taobaofed.org/blog/2017/03/16/javascript-functional-programing/"/>
    <id>http://taobaofed.org/blog/2017/03/16/javascript-functional-programing/</id>
    <published>2017-03-15T23:18:05.000Z</published>
    <updated>2017-03-18T09:50:27.000Z</updated>
    <content type="html"><![CDATA[<p><img src="https://gw.alicdn.com/tfs/TB1xJN9QXXXXXbXXpXXXXXXXXXX-900-500.jpg" alt="我眼中的 JavaScript 函数式编程"></p>
<p>JavaScript 函数式编程是一个存在了很久的话题，但似乎从 2016 年开始，它变得越来越火热。这可能是因为 ES6 语法对于函数式编程更为友好，也可能是因为诸如 RxJS (ReactiveX) 等函数式框架的流行。</p>
<p>看过许多关于函数式编程的讲解，但是其中大部分是停留在理论层面，还有一些是仅针对 Haskell 等纯函数式编程语言的。而本文旨在聊一聊我眼中的函数式编程在 <strong>JavaScript</strong> 中的具体实践，之所以是 “我眼中的” 即我所说的仅代表个人观点，可能和部分 <strong>严格概念</strong> 是有冲突的。</p>
<p>本文将略去一大堆形式化的概念介绍，重点展示在 JavaScript 中到底什么是函数式的代码、函数式代码与一般写法有什么区别、函数式的代码能给我们带来什么好处以及常见的一些函数式模型都有哪些。</p>
<h2 id="我理解的函数式编程"><a href="#我理解的函数式编程" class="headerlink" title="我理解的函数式编程"></a>我理解的函数式编程</h2><p>我认为函数式编程可以理解为，<strong>以函数作为主要载体的编程方式</strong>，用函数去拆解、抽象一般的表达式</p>
<p>与命令式相比，这样做的好处在哪？主要有以下几点：</p>
<ul>
<li>语义更加清晰</li>
<li>可复用性更高</li>
<li>可维护性更好</li>
<li>作用域局限，副作用少</li>
</ul>
<h3 id="基本的函数式编程"><a href="#基本的函数式编程" class="headerlink" title="基本的函数式编程"></a>基本的函数式编程</h3><p>下面例子是一个具体的函数式体现</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组中每个单词，首字母大写</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般写法</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="string">'apple'</span>, <span class="string">'pen'</span>, <span class="string">'apple-pen'</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> i <span class="keyword">in</span> arr)&#123;</span><br><span class="line">  <span class="keyword">const</span> c = arr[i][<span class="number">0</span>];</span><br><span class="line">  arr[i] = c.toUpperCase() + arr[i].slice(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数式写法一</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">upperFirst</span>(<span class="params">word</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> word[<span class="number">0</span>].toUpperCase() + word.slice(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wordToUpperCase</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.map(upperFirst);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(wordToUpperCase([<span class="string">'apple'</span>, <span class="string">'pen'</span>, <span class="string">'apple-pen'</span>]));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数式写法二</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.map([<span class="string">'apple'</span>, <span class="string">'pen'</span>, <span class="string">'apple-pen'</span>], word =&gt; word[<span class="number">0</span>].toUpperCase() + word.slice(<span class="number">1</span>)));</span><br></pre></td></tr></table></figure>
<p>当情况变得更加复杂时，表达式的写法会遇到几个问题：</p>
<ol>
<li>表意不明显，逐渐变得难以维护</li>
<li>复用性差，会产生更多的代码量</li>
<li>会产生很多中间变量</li>
</ol>
<p>函数式编程很好的解决了上述问题。首先参看 <strong>函数式写法一</strong>，它利用了函数封装性将功能做拆解（粒度不唯一），并封装为不同的函数，而再利用组合的调用达到目的。这样做使得表意清晰，易于维护、复用以及扩展。其次利用 <strong>高阶函数</strong>，<code>Array.map</code> 代替 <code>for…of</code> 做数组遍历，减少了中间变量和操作。</p>
<p>而 <strong>函数式写法一</strong> 和 <strong>函数式写法二</strong> 之间的主要差别在于，可以考虑函数是否后续有复用的可能，如果没有，则后者更优。</p>
<h3 id="链式优化"><a href="#链式优化" class="headerlink" title="链式优化"></a>链式优化</h3><p>从上面 <strong>函数式写法二</strong> 中我们可以看出，函数式代码在写的过程中，很容易造成 <strong>横向延展</strong>，即产生多层嵌套，下面我们举个比较极端点的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算数字之和</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般写法</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span> - <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数式写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sub</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sub(sum(sum(<span class="number">1</span>, <span class="number">2</span>), <span class="number">3</span>), <span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<p>本例仅为展示 <strong>横向延展</strong> 的比较极端的情况，随着函数的嵌套层数不断增多，导致代码的可读性大幅下降，还很容易产生错误。</p>
<p>在这种情况下，我们可以考虑多种优化方式，比如下面的 <strong>链式优化</strong> 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优化写法 (嗯，你没看错，这就是 lodash 的链式写法)</span></span><br><span class="line"><span class="keyword">const</span> utils = &#123;</span><br><span class="line">  chain(a) &#123;</span><br><span class="line">    <span class="keyword">this</span>._temp = a;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  sum(b) &#123;</span><br><span class="line">    <span class="keyword">this</span>._temp += b;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  sub(b) &#123;</span><br><span class="line">    <span class="keyword">this</span>._temp -= b;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  value() &#123;</span><br><span class="line">    <span class="keyword">const</span> _temp = <span class="keyword">this</span>._temp;</span><br><span class="line">    <span class="keyword">this</span>._temp = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">return</span> _temp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(utils.chain(<span class="number">1</span>).sum(<span class="number">2</span>).sum(<span class="number">3</span>).sub(<span class="number">4</span>).value());</span><br></pre></td></tr></table></figure>
<p>这样改写后，结构会整体变得比较清晰，而且链的每一环在做什么也可以很容易的展现出来。函数的嵌套和链式的对比还有一个很好的例子，那就是 <strong>回调函数 和 Promise 模式</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顺序请求两个接口</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数</span></span><br><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">'jquery'</span>;</span><br><span class="line">$.post(<span class="string">'a/url/to/target'</span>, (rs) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span>(rs)&#123;</span><br><span class="line">    $.post(<span class="string">'a/url/to/another/target'</span>, (rs2) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span>(rs2)&#123;</span><br><span class="line">        $.post(<span class="string">'a/url/to/third/target'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise</span></span><br><span class="line"><span class="keyword">import</span> request <span class="keyword">from</span> <span class="string">'catta'</span>;  <span class="comment">// catta 是一个轻量级请求工具，支持 fetch,jsonp,ajax，无依赖</span></span><br><span class="line">request(<span class="string">'a/url/to/target'</span>)</span><br><span class="line">  .then(rs =&gt; rs ? $.post(<span class="string">'a/url/to/another/target'</span>) : <span class="built_in">Promise</span>.reject())</span><br><span class="line">  .then(rs2 =&gt; rs2 ? $.post(<span class="string">'a/url/to/third/target'</span>) : <span class="built_in">Promise</span>.reject());</span><br></pre></td></tr></table></figure>
<p>随着回调函数嵌套层级和单层复杂度增加，它将会变得臃肿且难以维护，而 <code>Promise</code> 的链式结构，在高复杂度时，仍能纵向扩展，而且层次隔离很清晰。</p>
<h2 id="常见的函数式编程模型"><a href="#常见的函数式编程模型" class="headerlink" title="常见的函数式编程模型"></a>常见的函数式编程模型</h2><h3 id="闭包（Closure）"><a href="#闭包（Closure）" class="headerlink" title="闭包（Closure）"></a>闭包（Closure）</h3><blockquote>
<p>可以保留局部变量不被释放的代码块，被称为一个闭包</p>
</blockquote>
<p>闭包的概念比较抽象，相信大家都或多或少知道、用到这个特性</p>
<p>那么闭包到底能给我们带来什么好处？</p>
<p>先来看一下如何创建一个闭包：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个闭包</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ++k;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter = makeCounter();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(counter());  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(counter());  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p><code>makeCounter</code> 这个函数的代码块，在返回的函数中，对局部变量 <code>k</code> ，进行了引用，导致局部变量无法在函数执行结束后，被系统回收掉，从而产生了闭包。而这个闭包的作用就是，“保留住“ 了局部变量，使内层函数调用时，可以重复使用该变量；而不同于全局变量，该变量只能在函数内部被引用。</p>
<p>换句话说，闭包其实就是创造出了一些函数私有的 ”持久化变量“。</p>
<p>所以从这个例子，我们可以总结出，闭包的创造条件是：</p>
<ol>
<li>存在内、外两层函数</li>
<li>内层函数对外层函数的局部变量进行了引用</li>
</ol>
<h4 id="闭包的用途"><a href="#闭包的用途" class="headerlink" title="闭包的用途"></a>闭包的用途</h4><p>闭包的主要用途就是可以定义一些作用域局限的持久化变量，这些变量可以用来做缓存或者计算的中间量等等。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单的缓存工具</span></span><br><span class="line"><span class="comment">// 匿名函数创造了一个闭包</span></span><br><span class="line"><span class="keyword">const</span> cache = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> store = &#123;&#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    get(key) &#123;</span><br><span class="line">      <span class="keyword">return</span> store[key];</span><br><span class="line">    &#125;,</span><br><span class="line">    set(key, val) &#123;</span><br><span class="line">      store[key] = val;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">cache.set(<span class="string">'a'</span>, <span class="number">1</span>);</span><br><span class="line">cache.get(<span class="string">'a'</span>);  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面例子是一个简单的缓存工具的实现，匿名函数创造了一个闭包，使得 <code>store</code> 对象 ，一直可以被引用，不会被回收。</p>
<h4 id="闭包的弊端"><a href="#闭包的弊端" class="headerlink" title="闭包的弊端"></a>闭包的弊端</h4><p>持久化变量不会被正常释放，持续占用内存空间，很容易造成内存浪费，所以一般需要一些额外手动的清理机制。</p>
<h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><blockquote>
<p>接受或者返回一个函数的函数称为高阶函数</p>
</blockquote>
<p>听上去很高冷的一个词汇，但是其实我们经常用到，只是原来不知道他们的名字而已。JavaScript 语言是原生支持高阶函数的，因为 JavaScript 的函数是一等公民，它既可以作为参数又可以作为另一个函数的返回值使用。</p>
<p>我们经常可以在 JavaScript 中见到许多原生的高阶函数，例如 <code>Array.map</code> , <code>Array.reduce</code> , <code>Array.filter</code></p>
<p>下面以 <code>map</code> 为例，我们看看他是如何使用的</p>
<h4 id="map-（映射）"><a href="#map-（映射）" class="headerlink" title="map （映射）"></a>map （映射）</h4><blockquote>
<p>映射是对集合而言的，即把集合的每一项都做相同的变换，产生一个新的集合</p>
</blockquote>
<p><code>map</code> 作为一个高阶函数，他接受一个函数参数作为映射的逻辑</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组中每一项加一，组成一个新数组</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般写法</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> rs = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> n <span class="keyword">of</span> arr)&#123;</span><br><span class="line">  rs.push(++n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(rs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// map改写</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> rs = arr.map(n =&gt; ++n);</span><br></pre></td></tr></table></figure>
<p>上面一般写法，利用 <code>for...of</code> 循环的方式遍历数组会产生额外的操作，而且有改变原数组的风险</p>
<p>而 <code>map</code> 函数封装了必要的操作，使我们仅需要关心映射逻辑的函数实现即可，减少了代码量，也降低了副作用产生的风险。</p>
<h3 id="柯里化（Currying）"><a href="#柯里化（Currying）" class="headerlink" title="柯里化（Currying）"></a>柯里化（Currying）</h3><blockquote>
<p>给定一个函数的部分参数，生成一个接受其他参数的新函数</p>
</blockquote>
<p>可能不常听到这个名词，但是用过 <code>undescore</code> 或 <code>lodash</code> 的人都见过他。</p>
<p>有一个神奇的 <code>_.partial</code> 函数，它就是柯里化的实现</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取目标文件对基础路径的相对路径</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般写法</span></span><br><span class="line"><span class="keyword">const</span> BASE = <span class="string">'/path/to/base'</span>;</span><br><span class="line"><span class="keyword">const</span> relativePath = path.relative(BASE, <span class="string">'/some/path'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// _.parical 改写</span></span><br><span class="line"><span class="keyword">const</span> BASE = <span class="string">'/path/to/base'</span>;</span><br><span class="line"><span class="keyword">const</span> relativeFromBase = _.partial(path.relative, BASE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> relativePath = relativeFromBase(<span class="string">'/some/path'</span>);</span><br></pre></td></tr></table></figure>
<p>通过 <code>_.partial</code> ，我们得到了新的函数 <code>relativeFromBase</code> ，这个函数在调用时就相当于调用 <code>path.relative</code> ，并默认将第一个参数传入 <code>BASE</code> ，后续传入的参数顺序后置。</p>
<p>本例中，我们真正想完成的操作是每次获得相对于 <code>BASE</code> 的路径，而非相对于任何路径。柯里化可以使我们只关心函数的部分参数，使函数的用途更加清晰，调用更加简单。</p>
<h3 id="组合（Composing）"><a href="#组合（Composing）" class="headerlink" title="组合（Composing）"></a>组合（Composing）</h3><blockquote>
<p>将多个函数的能力合并，创造一个新的函数</p>
</blockquote>
<p>同样你第一次见到他可能还是在 <code>lodash</code> 中，<code>compose</code> 方法（现在叫 <code>flow</code>）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组中每个单词大写，做 Base64</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般写法 (其中一种)</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="string">'pen'</span>, <span class="string">'apple'</span>, <span class="string">'applypen'</span>];</span><br><span class="line"><span class="keyword">const</span> rs = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> w <span class="keyword">of</span> arr)&#123;</span><br><span class="line">  rs.push(btoa(w.toUpperCase()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(rs);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// _.flow 改写</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="string">'pen'</span>, <span class="string">'apple'</span>, <span class="string">'applypen'</span>];</span><br><span class="line"><span class="keyword">const</span> upperAndBase64 = _.partialRight(_.map, _.flow(_.upperCase, btoa));</span><br><span class="line"><span class="built_in">console</span>.log(upperAndBase64(arr));</span><br></pre></td></tr></table></figure>
<p><code>_.flow</code> 将转大写和转 Base64 的函数的能力合并，生成一个新的函数。方便作为参数函数或后续复用。</p>
<h2 id="自己的观点"><a href="#自己的观点" class="headerlink" title="自己的观点"></a>自己的观点</h2><p>我理解的 JavaScript 函数式编程，可能和许多传统概念不同。我并不只认为 <em>高阶函数</em> 算函数式编程，其他的诸如普通函数结合调用、链式结构等，我都认为属于函数式编程的范畴，只要他们是以函数作为主要载体的。</p>
<p>而我认为函数式编程并不是必须的，它也不应该是一个强制的规定或要求。与面向对象或其他思想一样，它也是其中一种方式。我们更多情况下，应该是几者的结合，而不是局限于概念。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://lodash.com/" target="_blank" rel="external">https://lodash.com/</a></li>
<li><a href="http://reactivex.io/" target="_blank" rel="external">http://reactivex.io/</a></li>
</ul>
<blockquote>
<p>题图：<a href="https://unsplash.com/photos/XJXWbfSo2f0" target="_blank" rel="external">https://unsplash.com/photos/XJXWbfSo2f0</a> By Luca Bravo</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="https://gw.alicdn.com/tfs/TB1xJN9QXXXXXbXXpXXXXXXXXXX-900-500.jpg" alt="我眼中的 JavaScript 函数式编程"></p>
<p>JavaScript 函数式编程是一个存在了很久]]>
    </summary>
    
      <category term="函数式编程" scheme="http://taobaofed.org/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[认识 TypeScript]]></title>
    <link href="http://taobaofed.org/blog/2017/03/09/head-first-typescript/"/>
    <id>http://taobaofed.org/blog/2017/03/09/head-first-typescript/</id>
    <published>2017-03-08T23:17:52.000Z</published>
    <updated>2017-03-18T09:50:27.000Z</updated>
    <content type="html"><![CDATA[<p><img src="//gw.alicdn.com/tfs/TB1_NDSPVXXXXcUXVXXXXXXXXXX-900-500.jpg" alt="认识 TypeScript"></p>
<p>这是一个系列文章，一共会有三篇：</p>
<ol>
<li>[本篇] 认识 TypeScript - 简单描述 TypeScript 的定位、特点。</li>
<li>TypeScript 语法学习 - 比较文档化的讲述 TypeScript 的使用方式。</li>
<li>TypeScript 工程使用 - 讲述如何在工程 —— 包括 Node.js 工程、React 工程 —— 中应用 TypeScript。</li>
</ol>
<p>最近几个月有幸体验了 TypeScript，它对大型软件 —— 大型 JavaScript 软件 —— 开发来说真是一把利刃。就像我斜后方那个男人一样，写了 TypeScript 就不想再写 JavaScript 了 —— 真乃取其精华去其糟粕啊！</p>
<p>没想到我一个 Linux 的老用户 Copyleft 的忠实拥护者，也会像今天这样喜欢用 M$ 出的东西，17 岁到 19 岁的我一定会鄙视死现在的我。</p>
<h2 id="背景认识"><a href="#背景认识" class="headerlink" title="背景认识"></a>背景认识</h2><p>TypeScript 是微软开发一款开源的编程语言，本质上是向 JavaScript 增加静态类型系统。它是 JavaScript 的超集，所有现有的 JavaScript 都可以不加改变就在其中使用。它是为大型软件开发而设计的，它最终编译产生 JavaScript，所以可以运行在浏览器、Node.js 等等的运行时环境。</p>
<h2 id="什么是类型系统"><a href="#什么是类型系统" class="headerlink" title="什么是类型系统"></a>什么是类型系统</h2><p>下面是摘自 <code>《 Types And Programming Languages 》</code> 中的定义： </p>
<blockquote>
<p>A type system is a tractable syntactic method for proving the absence of certain program behaviors by classifying phrases according to the kinds of values they compute.</p>
</blockquote>
<p>第一个重点是 <code>Proving the absence of certain program behaviors</code>，所以我们亦可将类型检查器看做一个程序推理工具，可以静态的证明程序成立。</p>
<p>另一个重点是 <code>Classifying phrases according to the kinds of values they compute</code>，对词语（比如变量）的值的性质进行分类，比如说 TypeScript 中的 <code>Interface</code> 、 <code>Class</code> 等能力。</p>
<h2 id="静态类型系统是什么"><a href="#静态类型系统是什么" class="headerlink" title="静态类型系统是什么"></a>静态类型系统是什么</h2><p>增加<code>静态</code>这个定语，是为了和运行时的类型检查机制加以区分，强调<code>静态类型系统</code>是在编译时进行类型分析。</p>
<p>JavaScript 不是一个静态编译语言,不存在编译这一步骤。但从 <code>程序推理工具</code> 的角度来看，JavaScript 的配套中还是有不少的，比如 <code>ESLint</code> 这个不完备的 <code>程序推理工具</code>。</p>
<h2 id="静态类型系统与-Lint-工具的关系"><a href="#静态类型系统与-Lint-工具的关系" class="headerlink" title="静态类型系统与 Lint 工具的关系"></a>静态类型系统与 Lint 工具的关系</h2><p>我们先看 <code>ESLint</code> 的定义：</p>
<blockquote>
<p>Code linting is a type of static analysis that is frequently used to find problematic patterns or code that doesn’t adhere to certain style guidelines. </p>
</blockquote>
<h3 id="区别一"><a href="#区别一" class="headerlink" title="区别一"></a>区别一</h3><p>同样强调 <code>Static Analysis</code>，不过更强调 <code>Certain Style Guidelines</code> ，<code>Lint 工具</code>是一种团队协作时的风格规范工具。</p>
<h3 id="区别二"><a href="#区别二" class="headerlink" title="区别二"></a>区别二</h3><p><code>静态类型类型分析</code>和 <code>Lint 工具</code> 的区别在于 <code>Lint 工具</code> 没有 <code>Classifying phrases according to the kinds of values they compute</code>。</p>
<p><code>Lint 工具</code>无法基于类型对程序进行静态分析，但两者都有基于 <code>CFG （控制流图，Control Flow Graph）</code>对程序进行分析的能力。比如 TypeScript 的控制流分析、<code>ESLint</code> 的 <code>complexity</code> （当你想写个比较复杂的迭代算法时，这个规则就是个渣） 规则等。</p>
<h2 id="TypeScript-和-JavaScript-的关系"><a href="#TypeScript-和-JavaScript-的关系" class="headerlink" title="TypeScript 和 JavaScript 的关系"></a>TypeScript 和 JavaScript 的关系</h2><p>和一些基于 JavaScript 的激进语言不同（比如 CoffeeScript），TypeScript 的语法设计首先考虑的就是兼容 JavaScript，或者说对 JavaScript 的语法做扩展。基本上是在 JavaScript 的基础之上增加了一些类型标记语法，以实现静态类型分析。把这些类型标注语法去掉之后，仍是一个标准的 JavaScript 语言。</p>
<p>TypeScript 同样也在做一些新语法编译到老语法的事情（就像 Babel 做的）， 基本实现常用的 <code>EcmaScript Stage 1</code> 以上的语法特性。</p>
<h2 id="类型系统的益处"><a href="#类型系统的益处" class="headerlink" title="类型系统的益处"></a>类型系统的益处</h2><h3 id="侦测错误"><a href="#侦测错误" class="headerlink" title="侦测错误"></a>侦测错误</h3><p>静态类型分析首要优点就是能尽早的发现逻辑错误，而不是上线之后才发现。比如我们在 JavaScript 中经常发生的问题，函数返回值含混。在开发过程中坚信一个函数返回字符串，但到了线上接受了真实数据却返回了 <code>undefined</code>。看似一个简单错误，却可能给公司造成数以万计的损失。</p>
<p>看个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过分数获取图标</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRankIcon</span>(<span class="params">score</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (score &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">500</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">1500</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> icon = getRankIcon(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">const</span> iconArray = icon.split();</span><br></pre></td></tr></table></figure>
<p>脆弱的 JS 啊，执行一下，Ops！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; node taste.js</span><br><span class="line">TypeError: Cannot read property &apos;split&apos; of undefined</span><br></pre></td></tr></table></figure>
<p>相同的逻辑我们用 <code>tsc</code> 编译一下（甚至不需要增加任何的类型标注）。直接静态分析出来程序有一个 <code>undefined</code> 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; tsc --strictNullChecks taste.ts</span><br><span class="line">x.ts(11,19): error TS2532: Object is possibly &apos;undefined&apos;.</span><br></pre></td></tr></table></figure>
<p>另一个重要的用处是作为维护工具（重构辅助工具），假如我们有一个很通用的函数，在工程里用的到处都是，有一天我们要在这个函数最前面增加一个参数。TypeScript 中你只需要改那个函数就好了，然后再执行静态类型分析，所有和这个函数参数不匹配的地方都会提示出来。但是，在 JavaScript 里，这个改动很有可能被忽略或者漏掉，打包也不会报错，然后发布后线上就挂了……</p>
<h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><p>类型系统的另一个优点是强化规范编程，TypeScript 提供了简便的方式定义接口。这一点在大型软件开发时尤为重要，一个系统模块可以抽象的看做一个 TypeScript 定义的接口。</p>
<p>用带清晰接口的模块来结构化大型系统，这是一种更为抽象的设计形式。接口设计（讨论）与最终实现方式无关，对接口思考得越抽象越有利。</p>
<p>换句话说就是让设计脱离实现，最终体现出一种 <code>IDL（接口定义语言，Interface Define Language）</code>，让程序设计回归本质。</p>
<p>看个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">interface Avatar &#123;</span><br><span class="line">  cdnUrl: string; <span class="comment">// 用户头像在 CDN 上的地址</span></span><br><span class="line">  filePath: string; <span class="comment">// 用户头像在对象存储上的路径</span></span><br><span class="line">  fileSize: number; <span class="comment">// 文件大小</span></span><br><span class="line">&#125;</span><br><span class="line">interface UserProfile &#123;</span><br><span class="line">  cuid?: string; <span class="comment">// 用户识别 ID，可选</span></span><br><span class="line">  avatar?: Avatar; <span class="comment">// 用户形象，可选</span></span><br><span class="line">  name: string; <span class="comment">// 用户名，必选</span></span><br><span class="line">  gender: string; <span class="comment">// 用户性别，必选</span></span><br><span class="line">  age: number; <span class="comment">// 用户年龄，必选</span></span><br><span class="line">&#125;</span><br><span class="line">interface UserModel &#123;</span><br><span class="line">  createUser(profile: UserProfile): string; <span class="comment">// 创建用户</span></span><br><span class="line">  getUser(cuid: string): UserProfile; <span class="comment">// 根据 cuid 获取用户</span></span><br><span class="line">  listFollowers(cuid: string): UserProfile[]; <span class="comment">// 获取所有关注者</span></span><br><span class="line">  followByCuid(cuid: string, who: string): string; <span class="comment">// 关注某人</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那我实现上述 <code>Interface</code> 也只需如下进行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserModelImpl</span> <span class="title">implements</span> <span class="title">UserModel</span> </span>&#123;</span><br><span class="line">   createUser(profile: UserProfile): string &#123;</span><br><span class="line">     <span class="comment">// do something</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 把 UserModel 定义的都实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><p>读程序时类型标注也有用处，不止是说人在读的时候。基于类型定义 IDE 可以对我们进行很多辅助，比如找到一个函数所有的使用，编写代码时对参数进行提示等等。</p>
<p>更重要的是这种文档能力不像纯人工维护的注释一样，稍不留神就忘了更新注释，最后注释和程序不一致。</p>
<p>更强大的是，可以自动根据类型标注产生文档，甚至都不需要编写注释（详细的人类语言描述还是要写注释的）。</p>
<p>首先安装全局的 <code>typedoc</code> 命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; npm install -g typedoc</span><br></pre></td></tr></table></figure>
<p>然后我们尝试对上面抽象的 <code>Interface</code> 产生文档。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; typedoc taste.ts --module commonjs --out doc</span><br></pre></td></tr></table></figure>
<p>然后下面就是效果了。</p>
<p><img src="https://gw.alicdn.com/tfs/TB1G_7nPVXXXXX1XXXXXXXXXXXX-935-1277.jpg" alt=""></p>
<h2 id="编写第一个-TypeScript-程序"><a href="#编写第一个-TypeScript-程序" class="headerlink" title="编写第一个 TypeScript 程序"></a>编写第一个 TypeScript 程序</h2><p>这一节会介绍如何开始体验 TypeScript，下一节开始会介绍一些有特点、有趣的例子。</p>
<h3 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h3><p>安装 TypeScript。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g typescript</span><br></pre></td></tr></table></figure>
<p>初始化工作区。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir learning-typescript</span><br><span class="line">cd learning-typescript</span><br></pre></td></tr></table></figure>
<p>新建第一个测试文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch taste.ts</span><br></pre></td></tr></table></figure>
<h3 id="第一个例子"><a href="#第一个例子" class="headerlink" title="第一个例子"></a>第一个例子</h3><p>我们刚才已经新建了一个名为 <code>taste.ts</code> 的文件，对 TypeScript 的后缀名为 <code>ts</code>，那我们写点什么进去吧！</p>
<p>taste.ts</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params">text: string</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(text);</span><br><span class="line">&#125;</span><br><span class="line">say(<span class="string">'hello!'</span>);</span><br></pre></td></tr></table></figure>
<p>然后执行命令（tsc 是刚才 npm 装的 typescript 中带的）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc taste.ts</span><br></pre></td></tr></table></figure>
<p>然后我们得到一个编译后的文件 <code>taste.js</code>，内容如下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(text);</span><br><span class="line">&#125;</span><br><span class="line">say(<span class="string">'hello!'</span>);</span><br></pre></td></tr></table></figure>
<p>可以看到，只是简单去除了 text 后面的类型标注，然后我们用 <code>node</code> 执行 <code>taste.js</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node taste.js</span><br><span class="line">// hello!</span><br></pre></td></tr></table></figure>
<p>完美执行，让我再改写东西看看？</p>
<p>taste.ts</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params">text: string</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(text);</span><br><span class="line">&#125;</span><br><span class="line">say(<span class="number">969</span>);</span><br></pre></td></tr></table></figure>
<p>然后再执行 <code>tsc taste.ts</code>，然后就类型检查就报错了。这就是 TypeScript 的主要功能 —— 静态类型检查。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; tsc taste.ts </span><br><span class="line">taste.ts(4,5): error TS2345: Argument of type &apos;969&apos; is not assignable to parameter of type &apos;string&apos;.</span><br></pre></td></tr></table></figure>
<h2 id="有趣的例子-基于控制流的分析"><a href="#有趣的例子-基于控制流的分析" class="headerlink" title="有趣的例子 - 基于控制流的分析"></a>有趣的例子 - 基于控制流的分析</h2><p>看一个 JavaScript 的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDefaultValue</span> (<span class="params">key, emphasis</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> ret;</span><br><span class="line">  <span class="keyword">if</span> (key === <span class="string">'name'</span>) &#123;</span><br><span class="line">    ret = <span class="string">'GuangWong'</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(key=== <span class="string">'gender'</span>) &#123;</span><br><span class="line">    ret = <span class="string">'Man'</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="string">'age'</span>) &#123;</span><br><span class="line">    ret = <span class="number">23</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Unkown key '</span> + info.type);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (emphasis) &#123;</span><br><span class="line">    ret = ret.toUpperCase();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getDefaultValue(<span class="string">'name'</span>); <span class="comment">// GuangWong</span></span><br><span class="line">getDefaultValue(<span class="string">'gender'</span>, <span class="literal">true</span>) <span class="comment">// MAN</span></span><br><span class="line">getDefaultValue(<span class="string">'age'</span>, <span class="literal">true</span>) <span class="comment">// Error: toUpperCase is not a function</span></span><br></pre></td></tr></table></figure>
<p>这是一个简单的函数，第一个参数 <code>key</code> 用来获得一个默认值。第二参数 <code>emphasis</code> 为了某些场景下要大写强调，只需要传入 <code>true</code> 即可自动将结果转成大写。 </p>
<p>但是我不小心将 <code>age</code> 的值写成了数字字面量，如果我调用 <code>getDefaultValue(&#39;age&#39;, true)</code> 就会在运行时报错。这个有可能是软件上线了之后才发生，直接导致业务不可用。</p>
<p>TypeScript 就能避免这类问题，我们只需要进行一个简单的标注。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDefaultValue</span> (<span class="params">key, emphasis?</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> ret: string;</span><br><span class="line">  <span class="keyword">if</span> (key === <span class="string">'name'</span>) &#123;</span><br><span class="line">    ret = <span class="string">'GuangWong'</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="string">'gender'</span>) &#123;</span><br><span class="line">    ret = <span class="string">'Man'</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="string">'age'</span>) &#123;</span><br><span class="line">    ret = <span class="number">23</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Unkown key '</span> + key);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (emphasis) &#123;</span><br><span class="line">    ret = ret.toUpperCase();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getDefaultValue(<span class="string">'name'</span>); <span class="comment">// GuangWong</span></span><br><span class="line">getDefaultValue(<span class="string">'gender'</span>, <span class="literal">true</span>) <span class="comment">// MAN</span></span><br><span class="line">getDefaultValue(<span class="string">'age'</span>, <span class="literal">true</span>) <span class="comment">// Error: toUpperCase is not a function</span></span><br></pre></td></tr></table></figure>
<p>在 <code>tsc</code> 编译时，逻辑错误会自动报出来。妈妈再也不怕我的逻辑混乱了！ </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; tsc taste.ts</span><br><span class="line">x.ts(8,5): error TS2322: Type &apos;23&apos; is not assignable to type &apos;string&apos;.</span><br></pre></td></tr></table></figure>
<h2 id="有趣的例子-Interface"><a href="#有趣的例子-Interface" class="headerlink" title="有趣的例子 - Interface"></a>有趣的例子 - Interface</h2><p>JavaScript 的类型我们称为鸭子类型。</p>
<blockquote>
<p>当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。</p>
</blockquote>
<p>鸭子类型总是有点损的感觉，不如叫做面向接口编程。所以 JavaScript 就是一门面向接口编程的语言，TypeScript 中相对应的就是 <code>Interface</code>。</p>
<p>接下来看个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface Profile &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  gender: <span class="string">'man'</span> | <span class="string">'woman'</span>;</span><br><span class="line">  age: number;</span><br><span class="line">  height?: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printProfile</span>(<span class="params">profile: Profile</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'name'</span>, profile.name);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'gender'</span>, profile. gender);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'age'</span>, profile.age);</span><br><span class="line">  <span class="keyword">if</span> (profile.height) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'height'</span>, profile.height);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printProfile(&#123;name: <span class="string">'GuangWong'</span>, gender: <span class="string">'man'</span>, age: <span class="number">23</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>使用 <code>tsc</code> 编译一切完美，那我们尝试下面的调用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printProfile(&#123;name: <span class="string">'GuangWong'</span>, age: <span class="number">23</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>使用 <code>tsc</code> 编译，报错了！说没有传属性 <code>gender</code>。不过 <code>height</code> 也没传怎么没报错呢？因为 <code>height?: number</code>，其中的 <code>?</code> 表示这个是可选的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; tsc taste.ts</span><br><span class="line">x.ts(19,14): error TS2345: Argument of type &apos;&#123; name: string; age: number; &#125;&apos; is not assignable to parameter of type &apos;Profile&apos;.</span><br><span class="line">  Property &apos;gender&apos; is missing in type &apos;&#123; name: string; age: number; &#125;&apos;.</span><br></pre></td></tr></table></figure>
<p>接下来我们试着传个非 <code>number</code> 的 <code>height</code> 试试看。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printProfile(&#123;height: <span class="string">'190cm'</span>, name: <span class="string">'GuangWong'</span>, gender: <span class="string">'man'</span>, age: <span class="number">23</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>使用 <code>tsc</code> 编译，报错了！<code>string</code> 类型无法赋值给 <code>number</code> 类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; tsc taste.ts</span><br><span class="line">x.ts(17,14): error TS2345: Argument of type &apos;&#123; height: string; name: string; gender: &quot;man&quot;; age: number; &#125;&apos; is not assignable to parameter of type &apos;Profile&apos;.</span><br><span class="line">  Types of property &apos;height&apos; are incompatible.</span><br><span class="line">    Type &apos;string&apos; is not assignable to type &apos;number&apos;.</span><br></pre></td></tr></table></figure>
<h2 id="有趣的例子-Implements"><a href="#有趣的例子-Implements" class="headerlink" title="有趣的例子 - Implements"></a>有趣的例子 - Implements</h2><p>这也是 <code>Interface</code> 的应用，假设我们有这么一个 <code>Interface</code>，是某个架构师写的让我来实现一种事物，比如榴莲。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type Fell = <span class="string">'good'</span> | <span class="string">'bad'</span>;</span><br><span class="line">interface Eatable &#123;</span><br><span class="line">  calorie: number;</span><br><span class="line">  looks(): Fell;</span><br><span class="line">  taste(): Fell;</span><br><span class="line">  flavour(): Fell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我只需要简单的实现  <code>Eatable</code> 即可，即 <code>implements Eatable</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Durian</span> <span class="title">implements</span> <span class="title">Eatable</span> </span>&#123;</span><br><span class="line">  calorie = <span class="number">1000</span>;</span><br><span class="line">  looks(): Fell &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'good'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  taste(): Fell &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'good'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  flavour(): Fell &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'bad'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我删掉 <code>flavour</code> 的实现，那就会报错了！说我错误的实现了 <code>Eatable</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; tsc taste.ts</span><br><span class="line">x.ts(8,7): error TS2420: Class &apos;Durian&apos; incorrectly implements interface &apos;Eatable&apos;.</span><br><span class="line">  Property &apos;flavour&apos; is missing in type &apos;Durian&apos;.</span><br></pre></td></tr></table></figure>
<h2 id="有趣的例子-函数重载"><a href="#有趣的例子-函数重载" class="headerlink" title="有趣的例子 - 函数重载"></a>有趣的例子 - 函数重载</h2><p>什么重载啊、多态啊、分派啊，在 JavaScript 里都是不存在的！那都是都是我们 Hacking 出来，Ugly！</p>
<p>TypeScript 对函数重载有一定的支持，不过因为 TypeScript 不扩展 JavaScript 的运行时机制，还是需要我们来处理根据宗量分派的问题（说白了就是运行时类型判断）。</p>
<p>下面是 TypeScript 文档中的一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> suits = [<span class="string">"hearts"</span>, <span class="string">"spades"</span>, <span class="string">"clubs"</span>, <span class="string">"diamonds"</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pickCard</span>(<span class="params">x: &#123;suit: string; card: number; &#125;[]</span>): <span class="title">number</span>;</span><br><span class="line"><span class="title">function</span> <span class="title">pickCard</span>(<span class="params">x: number</span>): </span>&#123;suit: string; card: number; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pickCard</span>(<span class="params">x</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Check to see if we're working with an object/array</span></span><br><span class="line">    <span class="comment">// if so, they gave us the deck and we'll pick the card</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x == <span class="string">"object"</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> pickedCard = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * x.length);</span><br><span class="line">        <span class="keyword">return</span> pickedCard;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Otherwise just let them pick the card</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x == <span class="string">"number"</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> pickedSuit = <span class="built_in">Math</span>.floor(x / <span class="number">13</span>);</span><br><span class="line">        <span class="keyword">return</span> &#123; suit: suits[pickedSuit], card: x % <span class="number">13</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myDeck = [&#123; suit: <span class="string">"diamonds"</span>, card: <span class="number">2</span> &#125;, &#123; suit: <span class="string">"spades"</span>, card: <span class="number">10</span> &#125;, &#123; suit: <span class="string">"hearts"</span>, card: <span class="number">4</span> &#125;];</span><br><span class="line"><span class="keyword">let</span> pickedCard1 = myDeck[pickCard(myDeck)];</span><br><span class="line">alert(<span class="string">"card: "</span> + pickedCard1.card + <span class="string">" of "</span> + pickedCard1.suit);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pickedCard2 = pickCard(<span class="number">15</span>);</span><br><span class="line">alert(<span class="string">"card: "</span> + pickedCard2.card + <span class="string">" of "</span> + pickedCard2.suit);</span><br></pre></td></tr></table></figure>
<p>这样至少在函数头的描述上清晰多了，而且函数的各个分派函数的类型定义也可以明确的标记出来了。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>第一篇就先这样简单介绍 TypeScript 吧，详细的语法、工程应用接下来的篇幅中再详细介绍。</p>
<ol>
<li>如果大家对 TypeScript 真的有兴趣的话，可以移步官方文档继续学习。<br><a href="http://www.typescriptlang.org/docs/tutorial.html" target="_blank" rel="external">http://www.typescriptlang.org/docs/tutorial.html</a></li>
<li>如果大家对类型系统的理论比较感兴趣的，建议把 <code>《 Types And Programming Languages 》</code> 买了并看了。</li>
</ol>
<blockquote>
<p>题图：<a href="https://unsplash.com/photos/HbbHfXvb6Xw" target="_blank" rel="external">https://unsplash.com/photos/HbbHfXvb6Xw</a> By Nirzar Pangarkar</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="//gw.alicdn.com/tfs/TB1_NDSPVXXXXcUXVXXXXXXXXXX-900-500.jpg" alt="认识 TypeScript"></p>
<p>这是一个系列文章，一共会有三篇：</p>
<ol>
<li>[本篇] 认识 ]]>
    </summary>
    
      <category term="TypeScript" scheme="http://taobaofed.org/tags/TypeScript/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[致未来的实习生]]></title>
    <link href="http://taobaofed.org/blog/2017/03/03/to-my-future-friend/"/>
    <id>http://taobaofed.org/blog/2017/03/03/to-my-future-friend/</id>
    <published>2017-03-03T01:14:01.000Z</published>
    <updated>2017-03-18T09:50:27.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://gtms03.alicdn.com/tfs/TB1PuyRPVXXXXXTXVXXXXXXXXXX-900-500.jpg" alt="致未来的实习生"></p>
<p>岁月如歌，你的人生即将翻开新的篇章，也许你需要一份展现自我的优秀简历，也许你需要一份属于自己的未来规划，也许你需要一个优秀的导师帮助你成长。淘宝前端团队有很多优秀的 FEDer，他们和你们一样富有激情和梦想，对于过去也有过徘徊和迷茫。优秀的他们用自己的激情和努力完成了学生到专业攻城师的华丽转身，成为淘宝的 FEDer、最新技术的弄潮儿、团队不可或缺的重要成员。来听听他们的经历和建议，以及 Winter 老师带来的面试官视角，希望对同学们有所帮助。</p>
<h2 id="那一年，我是如何“挤”进淘宝的"><a href="#那一年，我是如何“挤”进淘宝的" class="headerlink" title="那一年，我是如何“挤”进淘宝的"></a>那一年，我是如何“挤”进淘宝的</h2><p><img style="margin: 0;" src="http://gtms02.alicdn.com/tfs/TB1pjeUPVXXXXcgXFXXXXXXXXXX-770-1034.jpg" width="400"></p>
<h3 id="简历，机会的敲门砖"><a href="#简历，机会的敲门砖" class="headerlink" title="简历，机会的敲门砖"></a>简历，机会的敲门砖</h3><p>出身于计算机的我，当听说 BAT 的时候，心中的兴奋无以伦比，但是真正到写简历的时候，看下各大公司对前端的要求，整个人就蒙圈了。<br><img style="margin: 0;" src="http://img.alicdn.com/tfs/TB12ThVPVXXXXcPXpXXXXXXXXXX-798-310.png"><br><img style="margin: 0;" src="http://img.alicdn.com/tfs/TB14VRnPVXXXXXvaFXXXXXXXXXX-719-228.png"><br>居然有那么多要求，需要会那么多东西！怎么办？学校都没教啊！不在茫然中爆发，就在茫然中淘汰，于是，写简历我活活写了五天，从样式调整到内容规划，从网上借鉴到自己思考，前面越写越觉得自己什么都不会，后来越写越知道自己该做点什么：什么能吸引眼球有技术含量而且立马能做，就做什么！最终长达五页的第一份简历在学长的建议之下缩成了一张简简单单干干净净的 A4 纸。嗯，程序猿就应该这样，高内聚，低耦合。（推荐：《<a href="http://mp.weixin.qq.com/s?__biz=MzAxMjA5ODQwMQ==&amp;mid=2455058790&amp;idx=1&amp;sn=169da18fdb9eaf017400a952d9a0c080&amp;chksm=8c169768bb611e7e5cdb87f08283bd79ac18d810569927ebdf934b1a7aef38678e14ada001de&amp;mpshare=1&amp;scene=23&amp;srcid=03016PlteIDwL2yfkZVUJnjM%23rd" target="_blank" rel="external">写一份靠谱的简历</a>》）</p>
<h3 id="实习，初窥代码的世界"><a href="#实习，初窥代码的世界" class="headerlink" title="实习，初窥代码的世界"></a>实习，初窥代码的世界</h3><p>拿着简历去面试的过程永远都是那么紧张，那么兴奋，那么折磨和那么难忘。最开始是去参加学校组织的招聘会，打印多张简历，见到有前端岗位就投，见到能面试就面试。在大庭广众之下面试总是免不了有点紧张，有的时候会短路，有的时候可能结巴，有的时候恰好这个问题你想过或者很对口味，于是对答如流还会颇有些自豪，但是不多去尝试一下，你怎么能提高自己面试的心态呢？抱着不断面试才能深入理解市场需求的念想，我在招聘会待了很久，从人潮对比中感受到了自己的不足：我一定要好好学习，天天向上。<br>纸上得来终觉浅，绝知此事要躬行。要补充知识的空缺在学校的自由懒散环境下是颇有难度的，因此，在尚不了解自己要去的实习公司的情况下我决然远离学校出去实习，我相信一个陌生的环境能让我更加清醒的认识到自己的不足。后来我才知道我实习的公司是世界上屈指可数的安防大公司，而我参与开发的是它的商城官网，在实际的项目开发中我才深入接触到了几乎所有前端书籍上都会注重介绍的 Ajax，才渐渐学着把闭包、回调甚至设计模式运用到自己的代码里面来。有学习，自然有成果，程序员最大的优点就在于乐于分享，在实习的过程中我完善了自己的博客，给自己的 GitHub 仓库添加了不少“轮子”代码，算是勉强给简历美容了一下。</p>
<h3 id="面试，旧世界的告白，新成长的开始"><a href="#面试，旧世界的告白，新成长的开始" class="headerlink" title="面试，旧世界的告白，新成长的开始"></a>面试，旧世界的告白，新成长的开始</h3><p>先介绍一下阿里的面试过程：内推的同学在成功入职前一般会经历大约 4 次面试。部门一般会在接到简历后的7个工作日内完成简历评估、面试等环节。关于校招的具体时间安排可以到 <a href="http://campus.alibaba.com/trainProcess.htm" target="_blank" rel="external">阿里校招官网</a> 查询。</p>
<p><img style="margin: 0;" src="http://img.alicdn.com/tfs/TB1ycB6PVXXXXavXpXXXXXXXXXX-571-68.png"></p>
<p>值得注意的是，<strong>内推不会对正常校招产生影响，简历评估未通过、内推面试未通过、未面试的同学将会收到邮件&amp;短信通知参加统一校招笔试</strong>。校招的流程和内推的非常类似，但是在之前会多一个<strong>笔试</strong>环节。</p>
<h4 id="然后就是我“挤”进去的经过了。"><a href="#然后就是我“挤”进去的经过了。" class="headerlink" title="然后就是我“挤”进去的经过了。"></a>然后就是我“挤”进去的经过了。</h4><p>一面的时候是电话面试，当时我正在实习的公司敲代码，面试官很客气的询问是否方便接电话，然后等我慢慢走到楼梯口后又问了一遍准备好了面试没，之后才开始面试流程。一面的主要内容是前端的基础，从 HTML5 标签的理解和认知到 CSS3 的运用，最后到 JavaScript 基础概念和理解。其中由于 CSS3 相关我使用的比较少，Canvas 更是只跑过几个 demo，因此只好干净利落地回答不会，其余的问题基本上都回答出来了。这里需要注意一个地方，面试的时候一定不要慌，不要想到什么立马就说，可以先思考几秒钟组织一下语言再回答，不然必答项因为紧张没有回答好就后悔莫及了，当然基础一定要扎实，像知乎上常见的犀牛书等经典还是必看的，不然就只好说不知道了（知之为知之，不知为不知，求实为智也）。</p>
<p>二面的内容比一面的深入很多，前面几个问题问的是对当时的新技术 React、webpack 的理解，后来应该是由于我太老实地暴露了自己的学术研究不深，于是他开始问项目经验相关的问题。恰好我在做无线商城的交付那一块，遇到了不少问题也总结了一些经验，因此对于项目的分工协作，接口的异常处理等问题都有得说，在最后面试官问我还有没有什么问题的时候还和他简短地讨论了一下不同页面间的交互和跨域问题。由于预期三面会更加偏项目技术一点，我在那个周末对自己做的交付那一块做了一个总结归纳，同时也回顾了一下二面的知识短板和没有回答好的问题。</p>
<p>三面直接遇到了我们可亲的 HR 姐我还懵了一下，HR 姐问的问题主要是偏习惯和见解方向，她需要确定你有正确的价值观世界观和独立成型的学习体系。后来我仔细想了一下，校招并不是要求你一定要会什么什么，那是社招的要求，而是考你是否拥有快速学习和运用巩固的能力。对于一个公司来说，如果员工最基础的学习的能力都不具备，何谈创新和发展呢？</p>
<p>经历了约一周的等待后收到了录取的通知，说是不激动那是骗人的。但是这次面试确实突出体现了我很多的问题，例如基础不够扎实，对外面的新事物尝试甚少，囿于自己的项目代码而没有站在更高的角度去审视它。这些问题在后来我进入淘宝实习之初一直羁绊着我，我才深入体会到淘宝为什么能在前端技术上碾压我之前实习的公司，又为什么面试的时候面试官会问我那些问题，作为一个淘宝的前端我还需要什么。</p>
<h2 id="如何成长为一名达标的前端工程师"><a href="#如何成长为一名达标的前端工程师" class="headerlink" title="如何成长为一名达标的前端工程师"></a>如何成长为一名达标的前端工程师</h2><p><img style="margin: 0;" src="http://gtms03.alicdn.com/tfs/TB1j5CZPVXXXXbSXFXXXXXXXXXX-770-1034.jpg" width="400"></p>
<p>前端开发从 HTTP 1.0 时代演变至今，其技能栈与工种要求可谓一年一个样，时至今日，已经丝毫不亚于传统后端。时下流行的各种语言、类库、框架、构建工具、工程体系已经纷繁复杂到几个单词或汉字看着看着就不认识的程度。谁也没有预料，当年仅靠 HTML 标签就可以搞定的网页，如今需要延伸到深远的技术分支，前端甚至已经玩起了服务端语言，玩起了 VR/AR。</p>
<p>在这个喧哗的时代，只有静下心来才能够找到通途大道，欲成凌云木，必先扎稳根。前端的进阶之路，还得一步一个脚印。专业知识不可欠缺，我们需要了解计算机的初级工作原理，基于对操作系统、数据传输等基础知识的理解，才能够帮助我们进一步的理解上层的应用框架和设计原理；对数据结构、基础算法的掌握才能够帮助我们更快、更优雅的实现编程目标。俗话说：「磨刀不误砍柴工」，此言得之。</p>
<p>前端入门并不花功夫，互联网上的学习资源已经足够丰富，不需要半小时，你就可以入门前端开发。当你具备一个基本的页面开发能力时，你得沉下去，了解 HTML 和 CSS 规范，了解 JavaScript 标准，不同宿主环境的差异性，你可以通过阅读一些经典的书籍，例如《HTML 权威指南》、《CSS 权威指南》、《JavaScript 高级程序设计》等巩固自己的前端知识，到那个时候，再选择你的工具不迟。触类旁通，React、Angular、Vue 的使用已经毫无压力。同时，你还应该深入学习 Node.js，这将是你的一件利器。业界不停的延伸发展出更加优秀的解决方案，像 W3C，IETF 等互联网标准组织十分值得关注。</p>
<p>真正的掌握知识并学以致用，不断的动手演练和积极的思考是最好的方式。通过一次次的迭代，寻求不同的解决方案，遇到各种问题并解决它，一定会收获满满，等到你转身的时候看到的就是一片森林。人群中永远缺少的是一双发现问题的眼睛，并通过自己掌握的技能来解决问题。在开发 SDK 的过程中，我觉得旧有的开发流程路径太长，体验不佳，还有优化空间，即使没有人反馈，但我还是应该对性能和交互进行优化，这导致的结果就是既提高了大家的开发效率，也使客服量减少。我们要有主人翁意识，主动肩负起重任，在乱麻中披荆斩棘。</p>
<p>在此之后，有更多有趣的内容可供探索，你将有足够多的选择。前端的技术方向延伸众多，例如传统的 Web 开发，以及偏向架构、工具的类库、框架、企业级 Web 容器与解决方案、构建/测试体系，以及图形相关的渲染引擎、VR/AR 开发等等，每一片土地都值得你不断耕耘。</p>
<h2 id="从实习到转正，看看他们眼中的淘宝前端团队"><a href="#从实习到转正，看看他们眼中的淘宝前端团队" class="headerlink" title="从实习到转正，看看他们眼中的淘宝前端团队"></a>从实习到转正，看看他们眼中的淘宝前端团队</h2><p><img style="margin: 0;" src="http://gtms04.alicdn.com/tfs/TB1NM5LPVXXXXcrXVXXXXXXXXXX-770-1034.jpg" width="400"></p>
<p>从一个还没毕业的大学生，到一个能够独当一面的工程师，我都经历了什么？</p>
<p>在学校，重点在于学习，习惯了向自己灌输知识，证明自己知识水平的是每学期的考试和每年的各种竞赛。</p>
<p>然而到了这里，学习虽然仍旧重要，但重点不再是汲取，而是将自己汲取到的所有知识和经验，转化为思路、转化为代码、转化为项目的架构输出出去。我的知识面不再需要多而全，而是在保持广阔眼界的同时，找到属于自己的那个领域，然后一头扎进去，不再只是使用和理解，而是剖析、解构和重构，让它扎根生长于自己的技术土地，并且茁壮成长。</p>
<p>在我实习的时候，我选择了 React。那时的 React 还是一个新、奇、特的东西，采用了别具一格的思路，一经开源，在前端界引领了一阵潮流。然而很多人依旧对 React 持保守态度。然而我所在的团队，看到了 React 的不足之处，更看到了 React 的优势和独特，决定采用 React，就投入了 100% 的心血去了解它、发展它、茁壮它。</p>
<p>在淘宝之前我也实习过三四家公司，有的团队小而求快，技术栈够用即可，技术栈单一，也有团队积极尝试新鲜技术，但大多在内部产品和无关紧要的产品试水，只有淘宝前端团队，我看到了不同团队的人都充满热情地投入在自己喜欢的领域，大家不局限在自己团队，只要志同道合，可以跨团队组成虚拟小组。在进入淘宝前端团队之前，我没想过一个团队可以如此包罗万象、充满活力。</p>
<p>当然，挑战一定是不可或缺的。即便是实习生，也可以参与双促、营销活动、产品的开发，做出的东西有千千万万的人在用，这成就感，谁不喜欢呢？我也曾加班到很晚，对着老项目的代码焦头烂额；我也曾废寝忘食，只为了在团队开发 SDK 中接入一条全新的链路。苦思冥想的时候，会有同事来提供新鲜的思路，新奇的视角，那种豁然开朗的感觉，应该就是作为一个前端，最幸福的事情了。</p>
<p>随着能力的提升，一个人可以负责一个几十万、几百万、甚至上千万、过亿 UV 的产品，每次的发布，都会影响到大量的用户，慢慢地我学会对产品负责任、对自己负责任，勇于承担，也勇于改变。每一行代码对于我，都是在改变世界。</p>
<p>因为不缺乏机会，不缺乏热情，所以我选择了这里。这里给我带来的也不仅是技术栈的拓宽，技术深度的提高，更有包容的心态、承担责任的勇气和勇于开拓的精神。</p>
<h2 id="Winter-老师有话说"><a href="#Winter-老师有话说" class="headerlink" title="Winter 老师有话说"></a>Winter 老师有话说</h2><p><img style="margin: 0;" src="http://gtms02.alicdn.com/tfs/TB1k6OKPVXXXXciXVXXXXXXXXXX-770-1034.jpg" width="400"></p>
<p>又到了招聘季节，我们团队的校招也启动了，这里给参加校招的同学们一些建议，希望能帮助到你们。</p>
<h3 id="准备：重视基础，打开视野"><a href="#准备：重视基础，打开视野" class="headerlink" title="准备：重视基础，打开视野"></a>准备：重视基础，打开视野</h3><p>现在的前端技术圈，大量的新技术在产生，新人往往会失去焦点。</p>
<p>在任何公司，招聘的目标都是可靠的搭档，所以实际的编程能力和领域基础知识是考察的重点。</p>
<p>这里可以明确透露的是，我们不会对任何特定框架或者新技术有硬性要求，这些都属于加分项。</p>
<p>如果要准备面试，其实最好的办法就是自己做一些实际的作品，不但能锻炼能力，还可以写在简历里帮助你说服面试官。</p>
<p>除了实际动手，总结也是非常好的一种方式，比如用脑图的形式对 Web 技术来做整理，可以给自己查缺补漏，也可以在面试时讲给面试官听。</p>
<h3 id="简历：展现自己，不要硬性匹配岗位描述"><a href="#简历：展现自己，不要硬性匹配岗位描述" class="headerlink" title="简历：展现自己，不要硬性匹配岗位描述"></a>简历：展现自己，不要硬性匹配岗位描述</h3><p>简历上真正闪光的点是你做过最有价值的事，而不是机械匹配岗位描述，</p>
<p>在阿里巴巴，面试官培训会特别要求我们引导候选人根据 STAR 原则描述自己的经历。</p>
<p>STAR 即状态、任务、行动和结果，把一件事说清楚，从背景到结果，才是一个完整的陈述，即使很有经验的面试官，也很难在只看行动的的情况下做出准确判断。</p>
<p>简历上的经历如果以 STAR 原则描述，可以节约很多面试时间，也有更多机会。</p>
<h3 id="面试：摆正心态，过程比结果重要"><a href="#面试：摆正心态，过程比结果重要" class="headerlink" title="面试：摆正心态，过程比结果重要"></a>面试：摆正心态，过程比结果重要</h3><p>根据往年的经验，很多同学一旦遇到自己不熟悉的问题，都会立刻状态下降，影响后续发挥，甚至有些同学会尝试欺骗面试官。</p>
<p>实际上，面试中过程比结果重要得多。</p>
<p>一些同学喜欢准备面试题，“下水井盖为什么是圆的？”，“全世界有多少辆汽车？”</p>
<p>不知道有多少“微软面试题”，”Google 面试题”在网上到处流传。</p>
<p>但是面试题真的很重要吗？其实各个大公司之所以会有这类奇怪的题目，恰恰说明了一点：</p>
<p>题目不重要，思考过程最重要。</p>
<p>可以考虑以下场景，同样遇到不会的问题，哪一种更好呢？</p>
<ul>
<li>“能解释一下 HTTP 协议中 302 这个状态码是什么吗？”，“我不记得了。” </li>
<li>“能解释一下 HTTP 协议中 302 这个状态码是什么吗？”，“哦，记不清了，我只记得 404 是找不到页面，304 是可以从缓存读取，5xx 是服务端错误” </li>
<li>“能解释一下 HTTP 协议中 302 这个状态码是什么吗？”，“啊，那个，应该是服务端错误吧？”</li>
</ul>
<p>显然第二个更好，其实这样的沟通，留给面试官的印象未必不如直接回答答案。</p>
<p>所以，面试毕竟是根据印象而不是像考试一样算总分，其实跟面试官坦诚轻松地沟通，遇到不会的问题也不用紧张，展现最好的自己才能有更高的机会通过。</p>
<h3 id="面试：分析问题，再解决问题"><a href="#面试：分析问题，再解决问题" class="headerlink" title="面试：分析问题，再解决问题"></a>面试：分析问题，再解决问题</h3><p>一个很多人会误解的问题是：大部分面试问题是开放性的和复杂的，想象中的“正确答案”根本不存在。</p>
<p>所以，即使是非常有经验的应聘人，遇到面试问题直接回答答案的情况是非常少见的。</p>
<p>我推荐这样一种回答思路：</p>
<ol>
<li>厘清问题，必要时可以跟面试官沟通确认，避免误解，不但理解问题，还要同时思考面试官的意图</li>
<li>不急于开始回答，可以先从一些简单的案例入手，面试官要求你解决 n 的问题，可以先尝试 n=1，n=2 的情况，给自己争取思考时间</li>
<li>回答问题，不限于问题本身，可以以对面试官意图的理解为基础，主动讲解相关知识，展示自己对相关领域的体系化思考</li>
<li>如果真的不会，应该正面承认，不敷衍，不猜测，有记不清的地方，可以要求面试官提示</li>
</ol>
<h3 id="面试：利用好自由时间"><a href="#面试：利用好自由时间" class="headerlink" title="面试：利用好自由时间"></a>面试：利用好自由时间</h3><p>面试最后的环节，大部分面试官会问“你有什么问题”这时候就进入自由时间。一些同学是不知道这时间应该如何利用的。</p>
<p>这时候可以做的事情有：</p>
<ol>
<li>了解团队和公司的情况</li>
<li>讲清楚自己对工作地点、从事方向、心仪部门等方面的需求</li>
<li>要求面试官给自己一些职业发展或者技术提升上的建议</li>
<li>补充一些前面的问题的答案</li>
<li>讲一些自己对技术上的理解</li>
<li>要面试官的联系方式（这个要看运气啦）</li>
</ol>
<p>这时候不适当的行为有：</p>
<ol>
<li>追问面试结果（面试结果一般需要最后合议，实际上大部分公司规定，禁止面试官当场给出结果）</li>
<li>故意问一些业务上比较尖锐的问题或者产品 bug（因为一个公司往往很大，面试官可能根本不知道另外部门的事）</li>
<li>针对一些热点问题问面试官的看法（实际上即使面试官回答，也只代表他个人的观点，你无法通过问题了解公司的态度）</li>
</ol>
<p>总之，自由时间实际上非常有用，它可能不会影响面试结果，却是你了解公司，提出特别要求的很好途径。</p>
<h3 id="了解招聘方：知己知彼，百战百胜"><a href="#了解招聘方：知己知彼，百战百胜" class="headerlink" title="了解招聘方：知己知彼，百战百胜"></a>了解招聘方：知己知彼，百战百胜</h3><p>其实像阿里巴巴这样的大公司，很多团队会有自主选人的通道，比起官方通道，更直接到达招聘团队。</p>
<p>（以下是我团队的广告）</p>
<p>现在开始拿起手机/电脑把你的简历发送至 taobao-fed-zhaopin@list.alibaba-inc.com 直达你未来主管的邮箱！</p>
<p>通过即可获得面试机会，不通过还不占集团统一校招机会！</p>
<h2 id="关注我们"><a href="#关注我们" class="headerlink" title="关注我们"></a>关注我们</h2><ul>
<li>FED 博客：<a href="http://taobaofed.org/">http://taobaofed.org/</a></li>
<li>微信公众号</li>
</ul>
<p><img style="margin: 0;" src="http://img.alicdn.com/tfs/TB12fzTMVXXXXafaXXXXXXXXXXX-280-280.jpg"></p>
<style>

#post-to-my-future-friend p {
  text-align: left;
}

#post-to-my-future-friend img {
  margin: 0;
}
</style>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://gtms03.alicdn.com/tfs/TB1PuyRPVXXXXXTXVXXXXXXXXXX-900-500.jpg" alt="致未来的实习生"></p>
<p>岁月如歌，你的人生即将翻开新的篇章，也许你需要一份展现自我的优秀简历，]]>
    </summary>
    
      <category term="招聘" scheme="http://taobaofed.org/tags/%E6%8B%9B%E8%81%98/"/>
    
      <category term="团队生活" scheme="http://taobaofed.org/categories/%E5%9B%A2%E9%98%9F%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[浅析 requestAnimationFrame]]></title>
    <link href="http://taobaofed.org/blog/2017/03/02/thinking-in-request-animation-frame/"/>
    <id>http://taobaofed.org/blog/2017/03/02/thinking-in-request-animation-frame/</id>
    <published>2017-03-02T05:25:09.000Z</published>
    <updated>2017-03-18T09:50:27.000Z</updated>
    <content type="html"><![CDATA[<p><img src="//gw.alicdn.com/tfs/TB1kEx5PVXXXXXqXXXXXXXXXXXX-900-500.jpg" alt="浅析 requestAnimationFrame"></p>
<p>相信现在绝大多数人在 JavaScript 中绘制动画已经在使用 requestAnimationFrame 了，关于 requestAnimationFrame 的种种就不多说了，关于这个 API 的资料，详见 <a href="http://www.w3.org/TR/animation-timing/，https://developer.mozilla.org/en/docs/Web/API/window.requestAnimationFrame。" target="_blank" rel="external">http://www.w3.org/TR/animation-timing/，https://developer.mozilla.org/en/docs/Web/API/window.requestAnimationFrame。</a></p>
<p>如果我们把时钟往前拨到引入 requestAnimationFrame 之前，如果在 JavaScript 中要实现动画效果，怎么办呢？无外乎使用 setTimeout 或 setInterval。那么问题就来了：</p>
<ul>
<li>如何确定正确的时间间隔（浏览器、机器硬件的性能各不相同）？</li>
<li>毫秒的不精确性怎么解决？</li>
<li>如何避免过度渲染（渲染频率太高、tab 不可见等等）？</li>
</ul>
<p>开发者可以用很多方式来减轻这些问题的症状，但是彻底解决，这个、基本、很难。</p>
<p>归根到底，问题的根源在于<strong>时机</strong>。对于前端开发者来说，setTimeout 和 setInterval 提供的是一个等长的定时器循环（timer loop），但是对于浏览器内核对渲染函数的响应以及何时能够发起下一个动画帧的时机，是完全不了解的。对于浏览器内核来讲，它能够了解发起下一个渲染帧的合适时机，但是对于任何 setTimeout 和 setInterval 传入的回调函数执行，都是一视同仁的，它很难知道哪个回调函数是用于动画渲染的，因此，优化的时机非常难以掌握。悖论就在于，写 JavaScript 的人了解一帧动画在哪行代码开始，哪行代码结束，却不了解应该何时开始，应该何时结束，而在内核引擎来说，事情却恰恰相反，所以二者很难完美配合，直到 requestAnimationFrame 出现。</p>
<p>本人很喜欢 requestAnimationFrame 这个名字，因为起得非常直白 – request animation frame，对于这个 API 最好的解释就是名字本身了。这样一个 API，你传入的 API 不是用来渲染一帧动画，你上街都不好意思跟人打招呼。</p>
<p>由于本人是个喜欢阅读代码的人，为了体现自己好学的态度，特意读了下 Chrome 的代码去了解它是怎么实现 requestAnimationFrame 的（代码基于 Android 4.4）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Document::requestAnimationFrame(PassRefPtr&lt;RequestAnimationFrameCallback&gt; callback)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (!m_scriptedAnimationController) &#123;</span><br><span class="line">    m_scriptedAnimationController = ScriptedAnimationController::create(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// We need to make sure that we don't start up the animation controller on a background tab, for example.</span></span><br><span class="line">      <span class="keyword">if</span> (!page())</span><br><span class="line">        m_scriptedAnimationController-&gt;suspend();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> m_scriptedAnimationController-&gt;registerCallback(callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仔细看看就觉得底层实现意外地简单，生成一个 ScriptedAnimationController 的实例，然后注册这个 callback。那我们就看看 ScriptAnimationController 里面做了些什么：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ScriptedAnimationController::serviceScriptedAnimations(<span class="keyword">double</span> monotonicTimeNow)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (!m_callbacks.size() || m_suspendCount)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> highResNowMs = <span class="number">1000.0</span> * m_document-&gt;loader()-&gt;timing()-&gt;monotonicTimeToZeroBasedDocumentTime(monotonicTimeNow);</span><br><span class="line">    <span class="keyword">double</span> legacyHighResNowMs = <span class="number">1000.0</span> * m_document-&gt;loader()-&gt;timing()-&gt;monotonicTimeToPseudoWallTime(monotonicTimeNow);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// First, generate a list of callbacks to consider.  Callbacks registered from this point</span></span><br><span class="line">    <span class="comment">// on are considered only for the "next" frame, not this one.</span></span><br><span class="line">    <span class="function">CallbackList <span class="title">callbacks</span><span class="params">(m_callbacks)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Invoking callbacks may detach elements from our document, which clears the document's</span></span><br><span class="line">    <span class="comment">// reference to us, so take a defensive reference.</span></span><br><span class="line">    RefPtr&lt;ScriptedAnimationController&gt; protector(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; callbacks.size(); ++i) &#123;</span><br><span class="line">        RequestAnimationFrameCallback* callback = callbacks[i].get();</span><br><span class="line">      <span class="keyword">if</span> (!callback-&gt;m_firedOrCancelled) &#123;</span><br><span class="line">        callback-&gt;m_firedOrCancelled = <span class="literal">true</span>;</span><br><span class="line">        InspectorInstrumentationCookie cookie = InspectorInstrumentation::willFireAnimationFrame(m_document, callback-&gt;m_id);</span><br><span class="line">        <span class="keyword">if</span> (callback-&gt;m_useLegacyTimeBase)</span><br><span class="line">          callback-&gt;handleEvent(legacyHighResNowMs);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          callback-&gt;handleEvent(highResNowMs);</span><br><span class="line">        InspectorInstrumentation::didFireAnimationFrame(cookie);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove any callbacks we fired from the list of pending callbacks.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; m_callbacks.size();) &#123;</span><br><span class="line">      <span class="keyword">if</span> (m_callbacks[i]-&gt;m_firedOrCancelled)</span><br><span class="line">        m_callbacks.remove(i);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_callbacks.size())</span><br><span class="line">      scheduleAnimation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数自然就是执行回调函数的地方了。那么动画是如何被触发的呢？我们需要快速地看一串函数（一个从下往上的 call stack）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> PageWidgetDelegate::animate(Page* page, <span class="keyword">double</span> monotonicFrameBeginTime)</span><br><span class="line">&#123;</span><br><span class="line">  FrameView* view = mainFrameView(page);</span><br><span class="line">  <span class="keyword">if</span> (!view)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  view-&gt;serviceScriptedAnimations(monotonicFrameBeginTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> WebViewImpl::animate(<span class="keyword">double</span> monotonicFrameBeginTime)</span><br><span class="line">&#123;</span><br><span class="line">  TRACE_EVENT0(<span class="string">"webkit"</span>, <span class="string">"WebViewImpl::animate"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!monotonicFrameBeginTime)</span><br><span class="line">      monotonicFrameBeginTime = monotonicallyIncreasingTime();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create synthetic wheel events as necessary for fling.</span></span><br><span class="line">  <span class="keyword">if</span> (m_gestureAnimation) &#123;</span><br><span class="line">    <span class="keyword">if</span> (m_gestureAnimation-&gt;animate(monotonicFrameBeginTime))</span><br><span class="line">      scheduleAnimation();</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      m_gestureAnimation.clear();</span><br><span class="line">      <span class="keyword">if</span> (m_layerTreeView)</span><br><span class="line">        m_layerTreeView-&gt;didStopFlinging();</span><br><span class="line"></span><br><span class="line">      <span class="function">PlatformGestureEvent <span class="title">endScrollEvent</span><span class="params">(PlatformEvent::GestureScrollEnd,</span><br><span class="line">          m_positionOnFlingStart, m_globalPositionOnFlingStart, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">          <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">      mainFrameImpl()-&gt;frame()-&gt;eventHandler()-&gt;handleGestureScrollEnd(endScrollEvent);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!m_page)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  PageWidgetDelegate::animate(m_page.get(), monotonicFrameBeginTime);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (m_continuousPaintingEnabled) &#123;</span><br><span class="line">    ContinuousPainter::setNeedsDisplayRecursive(m_rootGraphicsLayer, m_pageOverlays.get());</span><br><span class="line">    m_client-&gt;scheduleAnimation();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> RenderWidget::AnimateIfNeeded() &#123;</span><br><span class="line">  <span class="keyword">if</span> (!animation_update_pending_)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Target 60FPS if vsync is on. Go as fast as we can if vsync is off.</span></span><br><span class="line">  base::TimeDelta animationInterval = IsRenderingVSynced() ? base::TimeDelta::FromMilliseconds(<span class="number">16</span>) : base::TimeDelta();</span><br><span class="line"></span><br><span class="line">  base::Time now = base::Time::Now();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// animation_floor_time_ is the earliest time that we should animate when</span></span><br><span class="line">  <span class="comment">// using the dead reckoning software scheduler. If we're using swapbuffers</span></span><br><span class="line">  <span class="comment">// complete callbacks to rate limit, we can ignore this floor.</span></span><br><span class="line">  <span class="keyword">if</span> (now &gt;= animation_floor_time_ || num_swapbuffers_complete_pending_ &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    TRACE_EVENT0(<span class="string">"renderer"</span>, <span class="string">"RenderWidget::AnimateIfNeeded"</span>)</span><br><span class="line">    animation_floor_time_ = now + animationInterval;</span><br><span class="line">    <span class="comment">// Set a timer to call us back after animationInterval before</span></span><br><span class="line">    <span class="comment">// running animation callbacks so that if a callback requests another</span></span><br><span class="line">    <span class="comment">// we'll be sure to run it at the proper time.</span></span><br><span class="line">    animation_timer_.Stop();</span><br><span class="line">    animation_timer_.Start(FROM_HERE, animationInterval, <span class="keyword">this</span>, &amp;RenderWidget::AnimationCallback);</span><br><span class="line">    animation_update_pending_ = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (is_accelerated_compositing_active_ &amp;&amp; compositor_) &#123;</span><br><span class="line">      compositor_-&gt;Animate(base::TimeTicks::Now());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">double</span> frame_begin_time = (base::TimeTicks::Now() - base::TimeTicks()).InSecondsF();</span><br><span class="line">      webwidget_-&gt;animate(frame_begin_time);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  TRACE_EVENT0(<span class="string">"renderer"</span>, <span class="string">"EarlyOut_AnimatedTooRecently"</span>);</span><br><span class="line">  <span class="keyword">if</span> (!animation_timer_.IsRunning()) &#123;</span><br><span class="line">    <span class="comment">// This code uses base::Time::Now() to calculate the floor and next fire</span></span><br><span class="line">    <span class="comment">// time because javascript's Date object uses base::Time::Now().  The</span></span><br><span class="line">    <span class="comment">// message loop uses base::TimeTicks, which on windows can have a</span></span><br><span class="line">    <span class="comment">// different granularity than base::Time.</span></span><br><span class="line">    <span class="comment">// The upshot of all this is that this function might be called before</span></span><br><span class="line">    <span class="comment">// base::Time::Now() has advanced past the animation_floor_time_.  To</span></span><br><span class="line">    <span class="comment">// avoid exposing this delay to javascript, we keep posting delayed</span></span><br><span class="line">    <span class="comment">// tasks until base::Time::Now() has advanced far enough.</span></span><br><span class="line">    base::TimeDelta delay = animation_floor_time_ - now;</span><br><span class="line">    animation_timer_.Start(FROM_HERE, delay, <span class="keyword">this</span>, &amp;RenderWidget::AnimationCallback);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>特别说明：RenderWidget 是在 <code>./content/renderer/render_widget.cc</code> 中（content::RenderWidget）而非在 <code>./core/rendering/RenderWidget.cpp</code> 中。笔者最早读 RenderWidget.cpp 还因为其中没有任何关于 animation 的代码而困惑了很久。</p>
</blockquote>
<p>看到这里其实 requestAnimationFrame 的实现原理就很明显了：</p>
<ul>
<li>注册回调函数</li>
<li>浏览器更新时触发 animate</li>
<li>animate 会触发所有注册过的 callback</li>
</ul>
<p>这里的工作机制可以理解为所有权的转移，把触发帧更新的时间所有权交给浏览器内核，与浏览器的更新保持同步。这样做既可以避免浏览器更新与动画帧更新的不同步，又可以给予浏览器足够大的优化空间。<br>在往上的调用入口就很多了，很多函数（RenderWidget::didInvalidateRect，RenderWidget::CompleteInit等）会触发动画检查，从而要求一次动画帧的更新。</p>
<p>这里一张图说明 requestAnimationFrame 的实现机制（来自<a href="http://www.chromium.org/developers/design-documents/rendering-architecture-diagrams" target="_blank" rel="external">官方</a>）：<br><img src="https://gw.alicdn.com/tfs/TB1lHxIPVXXXXXpXFXXXXXXXXXX-1636-1230.png" alt="chromium_request_anim_frame"></p>
<blockquote>
<p>题图：<a href="https://unsplash.com/photos/PEfMW274zGM" target="_blank" rel="external">https://unsplash.com/photos/PEfMW274zGM</a> By Kai Oberhäuser</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="//gw.alicdn.com/tfs/TB1kEx5PVXXXXXqXXXXXXXXXXXX-900-500.jpg" alt="浅析 requestAnimationFrame"></p>
<p>相信现在绝大多数人在 JavaScript 中绘制动画]]>
    </summary>
    
      <category term="JavaScript" scheme="http://taobaofed.org/tags/JavaScript/"/>
    
      <category term="requestAnimationFrame" scheme="http://taobaofed.org/tags/requestAnimationFrame/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从达标到卓越 —— API 设计之道]]></title>
    <link href="http://taobaofed.org/blog/2017/02/16/a-guide-to-api-design/"/>
    <id>http://taobaofed.org/blog/2017/02/16/a-guide-to-api-design/</id>
    <published>2017-02-16T05:33:13.000Z</published>
    <updated>2017-03-18T09:50:27.000Z</updated>
    <content type="html"><![CDATA[<p><img src="https://img.alicdn.com/tps/TB1qujpLXXXXXaLXFXXXXXXXXXX-900-500.jpg" alt="从达标到卓越 —— API 设计之道"></p>
<p>新技术层出不穷，长江后浪推前浪，而浪潮褪去后能留下来的，是一些经典的设计思想。</p>
<p>在前端界，以前有远近闻名的 jQuery，近来有声名鹊起的 Vue.js。这两者叫好又叫座的原因固然有很多，但是其中有一个共同特质不可忽视，那便是它们的 <strong>API 设计</strong> 非常优雅。</p>
<p>因此这次我想来谈个大课题 —— API 设计之道。</p>
<hr>
<h2 id="讨论内容的定义域"><a href="#讨论内容的定义域" class="headerlink" title="讨论内容的定义域"></a>讨论内容的定义域</h2><p>本文并不是《jQuery API 赏析》，当我们谈论 API 的设计时，不只局限于讨论「某个框架应该如何设计暴露出来的方法」。作为程序世界分治复杂逻辑的基本协作手段，广义的 API 设计涉及到我们日常开发中的方方面面。</p>
<p>最常见的 API 暴露途径是函数声明（Function Signiture），以及属性字段（Attributes）；而当我们涉及到前后端 IO 时，则需要关注通信接口的数据结构（JSON Schema）；如果还有异步的通信，那么事件（Events）或消息（Message）如何设计也是个问题；甚至，依赖一个包（Package）的时候，包名本身就是接口，你是否也曾碰到过一个奇葩的包名而吐槽半天？</p>
<p>总之，「API 设计」不只关乎到框架或库的设计者，它和每个开发者息息相关。</p>
<h2 id="提纲挈领"><a href="#提纲挈领" class="headerlink" title="提纲挈领"></a>提纲挈领</h2><p>有一个核心问题是，我们如何评判一个 API 的设计算「好」？在我看来，一言以蔽之，易用。</p>
<p>那「易用」又是什么呢？我的理解是，只要能够足够接近人类的日常语言和思维，并且不需要引发额外的大脑思考，那就是易用。</p>
<blockquote>
<p>Don’t make me think.</p>
</blockquote>
<p>具体地，我根据这些年来碰到的大量（反面和正面）案例，归纳出以下这些要点。按照要求从低到高的顺序如下：</p>
<ul>
<li>达标：词法和语法<ul>
<li>正确拼写</li>
<li>准确用词</li>
<li>注意单复数</li>
<li>不要搞错词性</li>
<li>处理缩写</li>
<li>用对时态和语态</li>
</ul>
</li>
<li>进阶：语义和可用性<ul>
<li>单一职责</li>
<li>避免副作用</li>
<li>合理设计函数参数</li>
<li>合理运用函数重载</li>
<li>使返回值可预期</li>
<li>固化术语表</li>
<li>遵循一致的 API 风格</li>
</ul>
</li>
<li>卓越：系统性和大局观<ul>
<li>版本控制</li>
<li>确保向下兼容</li>
<li>设计扩展机制</li>
<li>控制 API 的抽象级别</li>
<li>收敛 API 集</li>
<li>发散 API 集</li>
<li>制定 API 的支持策略</li>
</ul>
</li>
</ul>
<p>（本文主要以 JavaScript 作为语言示例。）</p>
<h2 id="达标：词法和语法"><a href="#达标：词法和语法" class="headerlink" title="达标：词法和语法"></a>达标：词法和语法</h2><p>高级语言和自然语言（英语）其实相差无几，因此正确地使用（英语的）词法和语法是程序员最基本的素养。而涉及到 API 这种供用户调用的代码时，则尤其重要。</p>
<p>但事实上，由于亚洲地区对英语的掌握能力普遍一般……所以现实状况并不乐观 —— 如果以正确使用词法和语法作为达标的门槛，很多 API 都没能达标。</p>
<h3 id="正确拼写"><a href="#正确拼写" class="headerlink" title="正确拼写"></a>正确拼写</h3><p>正确地拼写一个单词是底线，这一点无需赘述。然而 API 中的各种错别字现象仍屡见不鲜，即使是在我们阿里这样的大公司内。</p>
<p>曾经有某个 JSON 接口（mtop）返回这样一组店铺数据，以在前端模板中渲染：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// json</span></span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"shopBottom"</span>: &#123;</span><br><span class="line">      <span class="string">"isTmall"</span>: <span class="string">"false"</span>,</span><br><span class="line">      <span class="string">"shopLevel"</span>: <span class="string">"916"</span>,</span><br><span class="line">      <span class="string">"shopLeveImg"</span>: <span class="string">"//xxx.jpg"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>乍一看平淡无奇，结果我调试了小半天都没能渲染出店铺的「店铺等级标识图片」，即 <code>shopLevelImg</code> 字段。问题到底出在了哪里？</p>
<p>眼细的朋友可能已经发现，接口给的字段名是 <code>shopLeveImg</code>，少了一个 <code>l</code>，而在其后字母 <code>I</code> 的光辉照耀下，肉眼很难分辨出这个细节问题。</p>
<p>拼错单词的问题真的是太普遍了，再比如：</p>
<ul>
<li>某个叫做 <code>toast</code> 的库，package.json 中的 name 写成了 <code>taost</code>。导致在 npm 中没能找到这个包。</li>
<li>某个跑马灯组件，工厂方法中的一个属性错将 <code>panel</code> 写成了 <code>pannel</code>。导致以正确的属性名初始化时代码跑不起来。</li>
<li>某个 URL（www.ruanyifeng.com/blog/2017/01/entainment.html）中错将 <code>entertainment</code> 写成了 <code>entainment</code>……这倒没什么大影响，只是 URL 发布后就改不了了，留下了错别字不好看。</li>
<li>……</li>
</ul>
<p>注意到，这些拼写错误经常出现在 <strong>字符串</strong> 的场景中。不同于变量名，IDE 无法检查字符串中的单词是否科学、是否和一些变量名一致，因此，我们在对待一些需要公开出去的 API 时，需要尤其注意这方面的问题；另一方面，更认真地注意 IDE 的 typo 提示（单词拼写错误提示），也会对我们产生很大帮助。</p>
<h3 id="准确用词"><a href="#准确用词" class="headerlink" title="准确用词"></a>准确用词</h3><p>我们知道，中英文单词的含义并非一一对应，有时一个中文意思可以用不同的英文单词来解释，这时我们需要选择使用恰当的准确的词来描述。</p>
<p>比如中文的「消息」可以翻译为 message、notification、news 等。虽然这几个不同的单词都可以有「消息」的意思，但它们在用法和语境场景上存在着细微差异：</p>
<ul>
<li>message：一般指双方通信的消息，是内容载体。而且经常有来有往、成对出现。比如 <code>postMessage()</code> 和 <code>receiveMessage()</code>。</li>
<li>notification：经常用于那种比较短小的通知，现在甚至专指 iOS / Android 那样的通知消息。比如 <code>new NotificationManager()</code>。</li>
<li>news：内容较长的新闻消息，比 notification 更重量级。比如 <code>getTopNews()</code>。</li>
<li>feed：自从 RSS 订阅时代出现的一个单词，现在 RSS 已经日薄西山，但是 feed 这个词被用在了更多的地方。其含义只可意会不可言传。比如 <code>fetchWeitaoFeeds()</code>。</li>
</ul>
<p>所以，即使中文意思大体相近，也要准确地用词，从而让读者更易理解 API 的作用和 <strong>上下文场景</strong>。</p>
<p>有一个正面案例，是关于 React 的。（在未使用 ES2015 的）React 中，有两个方法叫做：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">React.createClass(&#123;</span><br><span class="line">  getDefaultProps: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// return a dictionary</span></span><br><span class="line">  &#125;,</span><br><span class="line">  getInitialState: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// return a dictionary either</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>它们的作用都是用来定义初始化的组件信息，返回值的类型也都一样，但是在方法名上却分别用了 <code>default</code> 和 <code>initial</code> 来修饰，为什么不统一为一个呢？</p>
<p>原因和 React 的机制有关：</p>
<ul>
<li><code>props</code> 是指 Element 的属性，要么是不存在某个属性值后来为它赋值，要么是存在属性的默认值后来将其覆盖。所以这种行为，<code>default</code> 是合理的修饰词。</li>
<li><code>state</code> 是整个 Component 状态机中的某一个特定状态，既然描述为了状态机，那么状态和状态之间是互相切换的关系。所以对于初始状态，用 <code>initial</code> 来修饰。</li>
</ul>
<p>就这么个小小的细节，就可一瞥 React 本身的机制，足以体现 API 设计者的智慧。</p>
<p>另外，最近我还碰到了这样一组事件 API：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// event name 1</span></span><br><span class="line">page.emit(<span class="string">'pageShowModal'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// event name 2</span></span><br><span class="line">page.emit(<span class="string">'pageCloseModal'</span>);</span><br></pre></td></tr></table></figure>
<p>这两个事件显然是一对正反义的动作，在上述案例中，表示「显示窗口」时使用了 <code>show</code>，表示「关闭窗口」时使用了 <code>close</code>，这都是非常直觉化的直译。而事实上，成对出现的词应该是：<code>show &amp; hide</code>、<code>open &amp; close</code>。</p>
<p>因此这里必须强调：<strong>成对出现的正反义词不可混用</strong>。在程序世界经常成对出现的词还有：</p>
<ul>
<li>in &amp; out</li>
<li>on &amp; off</li>
<li>previous &amp; next</li>
<li>forward &amp; backward</li>
<li>success &amp; failure</li>
<li>…</li>
</ul>
<p>总之，我们可以试着扩充英语的词汇量，使用合适的词，这对我们准确描述 API 有很大的帮助。</p>
<h3 id="注意单复数"><a href="#注意单复数" class="headerlink" title="注意单复数"></a>注意单复数</h3><p>所有涉及到诸如数组（Array）、集合（Collection）、列表（List）这样的数据结构，在命名时都要使用复数形式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shopItems = [</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getShopItems</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// return an array</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fail</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getShopItem</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// unless you really return a non-array</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现实往往出人意表地糟糕，前不久刚改一个项目，我就碰到了这样的写法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MarketFloor</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    item: [</span><br><span class="line">      &#123;&#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 <code>item</code> 实为一个数组，即使它内部只有一个成员。因此应该命名为 <code>items</code> 或 <code>itemList</code>，无论如何，不应该是表示单数的 <code>item</code>。</p>
<p>同时要注意，在复数的风格上保持一致，要么所有都是 <code>-s</code>，要么所有都是 <code>-list</code>。</p>
<p>反过来，我们在涉及到诸如字典（Dictionary）、表（Map）的时候，不要使用复数！</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fail</span></span><br><span class="line"><span class="keyword">var</span> EVENT_MAPS = &#123;</span><br><span class="line">  MODAL_WILL_SHOW: <span class="string">'modalWillShow'</span>,</span><br><span class="line">  MODAL_WILL_HIDE: <span class="string">'modalWillHide'</span>,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>虽然这个数据结构看上去由很多 key-value 对组成，是个类似于集合的存在，但是「map」本身已经包含了这层意思，不需要再用复数去修饰它。</p>
<h3 id="不要搞错词性"><a href="#不要搞错词性" class="headerlink" title="不要搞错词性"></a>不要搞错词性</h3><p>另外一个容易犯的低级错误是搞错词性，即命名时拎不清名词、动词、形容词……</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">asyncFunc(&#123;</span><br><span class="line">  success: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  fail: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>success</code> 算是一个在程序界出镜率很高的词了，但是有些同学会搞混，把它当做动词来用。在上述案例中，成对出现的单词其词性应该保持一致，这里应该写作 <code>succeed</code> 和 <code>fail</code>；当然，在这个语境中，最好遵从惯例，使用名词组合 <code>success</code> 和 <code>failure</code>。</p>
<p>这一对词全部的词性如下：</p>
<ul>
<li>n. 名词：success, failure</li>
<li>v. 动词：succeed, fail</li>
<li>adj. 形容词：successful, failed（无形容词，以过去分词充当）</li>
<li>adv. 副词：successfully, fail to do sth.（无副词，以不定式充当）</li>
</ul>
<p>注意到，如果有些词没有对应的词性，则考虑变通地采用其他形式来达到同样的意思。</p>
<p>所以，即使我们大部分人都知道：方法命名用动词、属性命名用名词、布尔值类型用形容词（或等价的表语），但由于对某些单词的词性不熟悉，也会导致最终的 API 命名有问题，这样的话就很尴尬了。</p>
<h3 id="处理缩写"><a href="#处理缩写" class="headerlink" title="处理缩写"></a>处理缩写</h3><p>关于词法最后一个要注意的点是缩写。有时我们经常会纠结，首字母缩写词（acronym）如 <code>DOM</code>、<code>SQL</code> 是用大写还是小写，还是仅首字母大写，在驼峰格式中又该怎么办……</p>
<p>对于这个问题，简单不易混淆的做法是，首字母缩写词的所有字母均大写。（如果某个语言环境有明确的业界惯例，则遵循惯例。）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// before</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getDomNode</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// after</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getDOMNode</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>在经典前端库 KISSY 的早期版本中，<code>DOM</code> 在 API 中都命名为 <code>dom</code>，驼峰下变为 <code>Dom</code>；而在后面的版本内统一写定为全大写的 <code>DOM</code>。</p>
<p>另外一种缩写的情况是对长单词简写（shortened word），如 <code>btn (button)</code>、<code>chk (checkbox)</code>、<code>tpl (template)</code>。这要视具体的语言规范 / 开发框架规范而定。如果什么都没定，也没业界惯例，那么把单词写全了总是不会错的。</p>
<h3 id="用对时态和语态"><a href="#用对时态和语态" class="headerlink" title="用对时态和语态"></a>用对时态和语态</h3><p>由于我们在调用 API 时一般类似于「调用一条指令」，所以在语法上，一个函数命名是祈使句式，时态使用一般现在时。</p>
<p>但在某些情况下，我们需要使用其他时态（进行时、过去时、将来时）。比如，当我们涉及到 <strong>生命周期</strong>、<strong>事件节点</strong>。</p>
<p>在一些组件系统中，必然涉及到生命周期，我们来看一下 React 的 API 是怎么设计的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">componentWillMount</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">componentDidMount</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">componentWillUpdate</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">componentDidUpdate</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">componentWillUnmount</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>React 划分了几个关键的生命周期节点（mount, update, unmount, …），以将来时和过去时描述这些节点片段，暴露 API。注意到一个小细节，React 采用了 <code>componentDidMount</code> 这种过去时风格，而没有使用 <code>componentMounted</code>，从而跟 <code>componentWillMount</code> 形成对照组，方便记忆。</p>
<p>同样地，当我们设计事件 API 时，也要考虑使用合适的时态，特别是希望提供精细的事件切面时。或者，引入 <code>before</code>、<code>after</code> 这样的介词来简化：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// will render</span></span><br><span class="line">Component.on(<span class="string">'beforeRender'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// now rendering</span></span><br><span class="line">Component.on(<span class="string">'rendering'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// has rendered</span></span><br><span class="line">Component.on(<span class="string">'afterRender'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure>
<p>另一方面是关于语态，即选用主动语态和被动语态的问题。其实最好的原则就是 <strong>尽量避免使用被动语态</strong>。因为被动语态看起来会比较绕，不够直观，因此我们要将被动语态的 API 转换为主动语态。</p>
<p>写成代码即形如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// passive voice, make me confused</span></span><br><span class="line">object.beDoneSomethingBy(subject);</span><br><span class="line"></span><br><span class="line"><span class="comment">// active voice, much more clear now</span></span><br><span class="line">subject.doSomething(object);</span><br></pre></td></tr></table></figure>
<h2 id="进阶：语义和可用性"><a href="#进阶：语义和可用性" class="headerlink" title="进阶：语义和可用性"></a>进阶：语义和可用性</h2><p>说了那么多词法和语法的注意点，不过才是达标级别而已。确保 API 的可用性和语义才使 API 真正「可用」。</p>
<p>无论是友好的参数设置，还是让人甜蜜蜜的语法糖，都体现了程序员的人文关怀。</p>
<h3 id="单一职责"><a href="#单一职责" class="headerlink" title="单一职责"></a>单一职责</h3><p>单一职责是软件工程中一条著名的原则，然而知易行难，一是我们对于具体业务逻辑中「职责」的划分可能存在难度，二是部分同学仍没有养成贯彻此原则的习惯。</p>
<p>小到函数级别的 API，大到整个包，保持单一核心的职责都是很重要的一件事。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fail</span></span><br><span class="line">component.fetchDataAndRender(url, template);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">var</span> data = component.fetchData(url);</span><br><span class="line">component.render(data, template);</span><br></pre></td></tr></table></figure>
<p>如上，将混杂在一个大坨函数中的两件独立事情拆分出去，保证函数（function）级别的职责单一。</p>
<p>更进一步地，（假设）<code>fetchData</code> 本身更适合用另一个类（class）来封装，则对原来的组件类 <code>Component</code> 再进行拆分，将不属于它的取数据职责也分离出去：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataManager</span> </span>&#123;</span><br><span class="line">  fetchData(url) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.dataManager = <span class="keyword">new</span> DataManager();</span><br><span class="line">  &#125;</span><br><span class="line">  render(data, template) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// more code, less responsibility</span></span><br><span class="line"><span class="keyword">var</span> data = component.dataManager.fetchData(url);</span><br><span class="line">component.render(data, template);</span><br></pre></td></tr></table></figure>
<p>在文件（file）层面同样如此，一个文件只编写一个类，保证文件的职责单一（当然这对很多语言来说是天然的规则）。</p>
<p>最后，视具体的业务关联度而决定，是否将一簇文件做成一个包（package），或是拆成多个。</p>
<h3 id="避免副作用"><a href="#避免副作用" class="headerlink" title="避免副作用"></a>避免副作用</h3><p>严格「无 <a href="https://en.wikipedia.org/wiki/Side_effect_(computer_science)" target="_blank" rel="external">副作用</a> 的编程」几乎只出现在纯函数式程序中，现实中的 OOP 编程场景难免触及副作用。因此在这里所说的「避免副作用」主要指的是：</p>
<ol>
<li>函数本身的运行稳定可预期。</li>
<li>函数的运行不对外部环境造成意料外的污染。</li>
</ol>
<p>对于无副作用的纯函数而言，输入同样的参数，执行后总能得到同样的结果，这种幂等性使得一个函数无论在什么上下文中运行、运行多少次，最后的结果总是可预期的 —— 这让用户非常放心，不用关心函数逻辑的细节、考虑是否应该在某个特定的时机调用、记录调用的次数等等。希望我们以后设计的 API 不会出现这个案例中的情况：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// return x.x.x.1 while call it once</span></span><br><span class="line"><span class="keyword">this</span>.context.getSPM();</span><br><span class="line"></span><br><span class="line"><span class="comment">// return x.x.x.2 while call it twice</span></span><br><span class="line"><span class="keyword">this</span>.context.getSPM();</span><br></pre></td></tr></table></figure>
<p>在这里，<code>getSPM()</code> 用来获取每个链接唯一的 SPM 码（SPM 是阿里通用的埋点统计方案）。但是用法却显得诡异：每调用一次，就会返回一个不同的 SPM 串，于是当我们需要获得几个 SPM 时，就会这样写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> spm1 = <span class="keyword">this</span>.context.getSPM();</span><br><span class="line"><span class="keyword">var</span> spm2 = <span class="keyword">this</span>.context.getSPM();</span><br><span class="line"><span class="keyword">var</span> spm3 = <span class="keyword">this</span>.context.getSPM();</span><br></pre></td></tr></table></figure>
<p>虽然在实现上可以理解 —— 此函数内部维护了一个计数器，每次返回一个自增的 SPM D 位，但是 <strong>这样的实现方式与这个命名看似是幂等的 getter 型函数完全不匹配</strong>，换句话说，这使得这个 API 不可预期。</p>
<p>如何修改之？一种做法是，不改变此函数内部的实现，而是将 API 改为 Generator 式的风格，通过形如 <code>SPMGenerator.next()</code> 接口来获取自增的 SPM 码。</p>
<p>另一种做法是，如果要保留原名称，可以将函数签名改为 <code>getSPM(spmD)</code>，接受一个自定义的 SPM D 位，然后返回整个 SPM 码。这样在调用时也会更明确。</p>
<p>除了函数内部的运行需可预期外，它对外部一旦造成不可预期的污染，那么影响将更大，而且更隐蔽。</p>
<p>对外部造成污染一般是两种途径：一是在函数体内部直接修改外部作用域的变量，甚至全局变量；二是通过修改实参间接影响到外部环境，如果实参是引用类型的数据结构。</p>
<p>曾经也有发生因为对全局变量操作而导致整个容器垮掉的情况，这里就不再展开。</p>
<p>如何防止此类副作用发生？本质上说，需要控制读写权限。比如：</p>
<ol>
<li>模块沙箱机制，严格限定模块对外部作用域的修改；</li>
<li>对关键成员作访问控制（access control），冻结写权限等等。</li>
</ol>
<h3 id="合理设计函数参数"><a href="#合理设计函数参数" class="headerlink" title="合理设计函数参数"></a>合理设计函数参数</h3><p>对一个函数来说，「函数签名」（Function Signature）比函数体本身更重要。函数名、参数设置、返回值类型，这三要素构成了完整的函数签名。而其中，参数设置对用户来说是接触最频繁，也最为关心的部分。</p>
<p>那如何优雅地设计函数的入口参数呢？我的理解是这样几个要点：</p>
<p>优化参数顺序。<strong>相关性越高的参数越要前置</strong>。</p>
<p>这很好理解，相关性越高的参数越重要，越要在前面出现。其实这还有两个隐含的意思，即 <strong>可省略的参数后置</strong>，以及 <strong>为可省略的参数设定缺省值</strong>。对某些语言来说（如 C++），调用的时候如果想省略实参，那么一定要为它定义缺省值，而带缺省值的参数必须后置，这是在编译层面就规定死的。而对另一部分灵活的语言来说（如 JS），将可省参数后置同样是最佳实践。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderPage</span>(<span class="params">pageIndex, pageData</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">renderPage(<span class="number">0</span>, &#123;&#125;);</span><br><span class="line">renderPage(<span class="number">1</span>, &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderPage</span>(<span class="params">pageData, pageIndex = 0</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">renderPage(&#123;&#125;);</span><br><span class="line">renderPage(&#123;&#125;, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>第二个要点是控制参数个数。用户记不住过多的入口参数，因此，参数能省略则省略，或更进一步，<strong>合并同类型的参数</strong>。</p>
<p>由于可以方便地创建 Object 这种复合数据结构，合并参数的这种做法在 JS 中尤为普遍。常见的情况是将很多配置项都包成一个配置对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// traditional</span></span><br><span class="line">$.ajax(url, params, success);</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">  url,</span><br><span class="line">  params,</span><br><span class="line">  success,</span><br><span class="line">  failure</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这样做的好处是：</p>
<ul>
<li>用户虽然仍需记住参数名，但不用再关心参数顺序。</li>
<li>不必担心参数列表过长。将参数合并为字典这种结构后，想增加多少参数都可以，也不用关心需要将哪些可省略的参数后置的问题。</li>
</ul>
<p>当然，凡事有利有弊，由于缺乏顺序，就无法突出哪些是最核心的参数信息；另外，在设定参数的默认值上，会比参数列表的形式更繁琐。因此，需要兼顾地使用最优的办法来设计函数参数，为了同一个目的：易用。</p>
<h3 id="合理运用函数重载"><a href="#合理运用函数重载" class="headerlink" title="合理运用函数重载"></a>合理运用函数重载</h3><p>谈到 API 的设计，尤其是函数的设计，总离不开一个机制：重载（overload）。</p>
<p>对于强类型语言来说，重载是个很 cool 的功能，能够大幅减少函数名的数量，避免命名空间的污染。然而对于弱类型语言而言，由于不需要在编译时做 type-binding，函数在调用阶段想怎么传实参都行……所以重载在这里变得非常微妙。以下着重谈一下，什么时候该选择重载，什么时候又不该。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Element <span class="title">getElementById</span><span class="params">(String: id)</span></span><br><span class="line"></span><br><span class="line">HTMLCollection <span class="title">getElementsByClassName</span><span class="params">(String: names)</span></span><br><span class="line"></span><br><span class="line">HTMLCollection <span class="title">getElementsByTagName</span><span class="params">(String: name)</span></span></span><br></pre></td></tr></table></figure>
<p>以上三个函数是再经典不过的 DOM API，而在当初学习它们的时候（从 Java 思维转到 JS 思维）我就在想这两个问题：</p>
<ol>
<li>为什么要设计成 <code>getSomethingBySomething</code> 这么复杂结构的名字，而不是使用 <code>getSomething</code> 做重载？</li>
<li>这三个函数只有 <code>getElementById</code> 是单数形式，为何不设计为返回 HTMLCollection（即使只返回一个成员也可以包一个 Collection 嘛），以做成复数形式的函数名从而保持一致性？</li>
</ol>
<p>两个问题中，如果第二个问题能解决，那么这三个函数的结构将完全一致，从而可以考虑解决第一个问题。</p>
<p>先来看问题二。稍微深入下 DOM 知识后就知道，id 对于整个 DOM 来说必须是唯一的，因此在理论上 <code>getElementsById</code>（注意有复数）将永远返回仅有 0 或 1 个成员的 Collection，这样一来用户的调用方式将始终是 <code>var element = getElementsById(id)[0]</code>，而这是非常荒谬的。所以 DOM API 设计得没问题。</p>
<p>既然问题二无解，那么自然这三个函数没法做成一个重载。退一步说，即使问题二能解决，还存在另外一个麻烦：它们的入口参数都是一样的，都是 String！对于强类型语言来说，参数类型和顺序、返回值统统一样的情况下，压根无法重载。因为编译器无法通过任何一个有效的特征，来执行不同的逻辑！</p>
<p>所以，<strong>如果入口参数无法进行有效区分，不要选择重载</strong>。</p>
<p>当然，有一种奇怪的做法可以绕过去：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fail</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getElementsBy</span>(<span class="params">byWhat, name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(byWhat) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'className'</span>:</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'tagName'</span>:</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getElementsBy(<span class="string">'tagName'</span>, name);</span><br><span class="line">getElementsBy(<span class="string">'className'</span>, name);</span><br></pre></td></tr></table></figure>
<p>一种在风格上类似重载的，但实际是在运行时走分支逻辑的做法……可以看到，API 的信息总量并没降低。不过话不能说死，这种风格在某些特定场景也有用武之地，只是多数情况下并不推荐。</p>
<p>与上述风格类似的，是这样一种做法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get elements by tag-name by default</span></span><br><span class="line"><span class="function">HTMLCollection <span class="title">getElements</span><span class="params">(String: name)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// if you add a flag, it goes by class-name</span></span><br><span class="line">HTMLCollection <span class="title">getElements</span><span class="params">(String: name, Boolean: byClassName)</span></span></span><br></pre></td></tr></table></figure>
<p>「将 flag 标记位作为了重载手段」—— 在早期微软的一些 API 中经常能见到这样的写法，可以说一旦离开了文档就无法编码，根本不明白某个 Boolean 标记位是用来干嘛的，这大大降低了用户的开发体验，以及代码可读性。</p>
<p>这样看起来，可重载的场景真是太少了！也不尽然，在我看来有一种场景很适合用重载：批量处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Module <span class="title">handleModules</span><span class="params">(Module: <span class="keyword">module</span>)</span></span><br><span class="line"></span><br><span class="line">Collection&lt;Module&gt; <span class="title">handleModules</span><span class="params">(Collection&lt;Module&gt;: modules)</span></span></span><br></pre></td></tr></table></figure>
<p>当用户经常面临处理一个或多个不确定数量的对象时，他可能需要思考和判断，什么时候用单数 <code>handleModule</code>、什么时候用复数 <code>handleModules</code>。将这种类型的操作重载为一个（大抵见于 setter 型操作），同时支持单个和批量的处理，可以降低用户的认知负担。</p>
<p>所以，在合适的时机重载，否则宁愿选择「函数名结构相同的多个函数」。原则是一样的，保证逻辑正确的前提下，尽可能降低用户负担。</p>
<p>对了，关于 <code>getElements</code> 那三个 API，它们最终的进化版本回到了同一个函数：<code>querySelector(selectors)</code>。</p>
<h3 id="使返回值可预期"><a href="#使返回值可预期" class="headerlink" title="使返回值可预期"></a>使返回值可预期</h3><p>函数的易用性体现在两方面：入口和出口。上面已经讲述了足够多关于入口的设计事项，这一节讲出口：函数返回值。</p>
<p>对于 getter 型的函数来说，调用的直接目的就是为了获得返回值。因此我们要让返回值的类型和函数名的期望保持一致。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// expect 'a.b.c.d'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSPMInString</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// fail</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    a, b, c, d</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这一点上来讲，要慎用 ES2015 中的新特性「解构赋值」。</p>
<p>而对于 setter 型的函数，调用的期望是它能执行一系列的指令，然后去达到一些副作用，比如存文件、改写变量值等等。因此绝大多数情况我们都选择了返回 undefined / void —— 这并不总是最好的选择。</p>
<p>回想一下，我们在调用操作系统的命令时，系统总会返回「exit code」，这让我们能够获知系统命令的执行结果如何，而不必通过其他手段去验证「这个操作到底生效了没」。因此，创建这样一种返回值风格，或可一定程度增加健壮性。</p>
<p>另外一个选项，是让 setter 型 API 始终返回 <code>this</code>。这是 jQuery 为我们带来的经典启示 —— 通过返回 <code>this</code>，来产生一种「链式调用（chaining）」的风格，简化代码并且增加可读性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div'</span>)</span><br><span class="line">  .attr(<span class="string">'foo'</span>, <span class="string">'bar'</span>)</span><br><span class="line">  .data(<span class="string">'hello'</span>, <span class="string">'world'</span>)</span><br><span class="line">  .on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure>
<p>最后还有一个异类，就是异步执行的函数。由于异步的特性，对于这种需要一定延时才能得到的返回值，只能使用 callback 来继续操作。使用 Promise 来包装它们尤为必要。对异步操作都返回一个 Promise，使整体的 API 风格更可预期。</p>
<h3 id="固化术语表"><a href="#固化术语表" class="headerlink" title="固化术语表"></a>固化术语表</h3><p>在前面的词法部分中曾经提到「准确用词」，但即使我们已经尽量去用恰当的词，在有些情况下仍然不免碰到一些难以抉择的尴尬场景。</p>
<p>比如，我们经常会看到 pic 和 image、path 和 url 混用的情况，这两组词的意思非常接近（当然严格来说 path 和 url 的意义是明确不同的，在此暂且忽略），稍不留神就会产生 4 种组合……</p>
<ul>
<li>picUrl</li>
<li>picPath</li>
<li>imageUrl</li>
<li>imagePath</li>
<li>更糟糕的情况是 imgUrl、picUri、picURL……</li>
</ul>
<p>所以，在一开始就要 <strong>产出术语表</strong>，包括对缩写词的大小写如何处理、是否有自定义的缩写词等等。一个术语表可以形如：</p>
<table>
<thead>
<tr>
<th>标准术语</th>
<th>含义</th>
<th>禁用的非标准词</th>
</tr>
</thead>
<tbody>
<tr>
<td>pic</td>
<td>图片</td>
<td>image, picture</td>
</tr>
<tr>
<td>path</td>
<td>路径</td>
<td>URL, url, uri</td>
</tr>
<tr>
<td>on</td>
<td>绑定事件</td>
<td>bind, addEventListener</td>
</tr>
<tr>
<td>off</td>
<td>解绑事件</td>
<td>unbind, removeEventListener</td>
</tr>
<tr>
<td>emit</td>
<td>触发事件</td>
<td>fire, trigger</td>
</tr>
<tr>
<td>module</td>
<td>模块</td>
<td>mod</td>
</tr>
</tbody>
</table>
<p>不仅在公开的 API 中要遵守术语表规范，在局部变量甚至字符串中都最好按照术语表来。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">page.emit(<span class="string">'pageRenderRow'</span>, &#123;</span><br><span class="line">  index: <span class="keyword">this</span>.props.index,</span><br><span class="line">  modList: moduleList</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>比如这个我最近碰到的案例，同时写作了 <code>modList</code> 和 <code>moduleList</code>，这就有点怪怪的。</p>
<p>另外，对于一些创造出来的、业务特色的词汇，如果不能用英语简明地翻译，就直接用拼音：</p>
<ul>
<li>淘宝 <code>Taobao</code></li>
<li>微淘 <code>Weitao</code></li>
<li>极有家 <code>Jiyoujia</code></li>
<li>……</li>
</ul>
<p>在这里，千万不要把「微淘」翻译为 <code>MicroTaobao</code>……当然，专有词已经有英文名的除外，如 <code>Tmall</code>。</p>
<h3 id="遵循一致的-API-风格"><a href="#遵循一致的-API-风格" class="headerlink" title="遵循一致的 API 风格"></a>遵循一致的 API 风格</h3><p>这一节算得上是一个复习章节。词法、语法、语义中的很多节都指向同一个要点：一致性。</p>
<blockquote>
<p>一致性可以最大程度降低信息熵。</p>
</blockquote>
<p>好吧，这句话不是什么名人名言，就是我现编的。总而言之，一致性能大大降低用户的学习成本，并对 API 产生准确的预期。</p>
<ol>
<li>在词法上，提炼术语表，全局保持一致的用词，避免出现不同的但是含义相近的词。</li>
<li>在语法上，遵循统一的语法结构（主谓宾顺序、主被动语态），避免天马行空的造句。</li>
<li>在语义上，合理运用函数的重载，提供可预期的甚至一致类型的函数入口和出口。</li>
</ol>
<p>甚至还可以一致得更细节些，只是举些例子：</p>
<ol>
<li>打 log 要么都用中文，要么都用英文。</li>
<li>异步接口要么都用回调，要么都改成 Promise。</li>
<li>事件机制只能选择其一：<code>object.onDoSomething = func</code> 或 <code>object.on(&#39;doSomething&#39;, func)</code>。</li>
<li>所有的 setter 操作必须返回 <code>this</code>。</li>
<li>……</li>
</ol>
<blockquote>
<p>一份代码写得再怎么烂，把某个单词都拼成一样的错误，也好过这个单词只出现一次错误。</p>
</blockquote>
<p>是的，一致性，再怎么强调都不为过。</p>
<h2 id="卓越：系统性和大局观"><a href="#卓越：系统性和大局观" class="headerlink" title="卓越：系统性和大局观"></a>卓越：系统性和大局观</h2><p>不管是大到发布至业界，或小到在公司内跨部门使用，一组 API 一旦公开，整体上就是一个产品，而调用方就是用户。所谓牵一发而动全身，一个小细节可能影响整个产品的面貌，一个小改动也可能引发整个产品崩坏。因此，我们一定要站在全局的层面，甚至考虑整个技术环境，系统性地把握整个体系内 API 的设计，体现大局观。</p>
<h3 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h3><p>80% 的项目开发在版本控制方面做得都很糟糕：随心所欲的版本命名、空洞诡异的提交信息、毫无规划的功能更新……人们显然需要一段时间来培养规范化开发的风度，但是至少得先保证一件事情：</p>
<blockquote>
<p>在大版本号不变的情况下，API 保证向前兼容。</p>
</blockquote>
<p>这里说的「大版本号」即「语义化版本命名」<code>&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;</code> 中的第一位 <code>&lt;major&gt;</code> 位。</p>
<p>这一位的改动表明 API 整体有大的改动，很可能不兼容，因此用户对大版本的依赖改动会慎之又慎；反之，如果 API 有不兼容的改动，意味着必须修改大版本号，否则用户很容易出现在例行更新依赖后整个系统跑不起来的情况，更糟糕的情况则是引发线上故障。</p>
<p>如果这种情况得不到改善，用户们就会选择 <strong>永远不升级依赖</strong>，导致更多的潜在问题。久而久之，最终他们便会弃用这些产品（库、中间件、whatever）。</p>
<p>所以，希望 API 的提供者们以后不会再将大版本锁定为 <code>0</code>。更多关于「语义化版本」的内容，请参考我的另一篇文章《<a href="http://taobaofed.org/blog/2016/08/04/instructions-of-semver/">论版本号的正确打开方式</a>》。</p>
<h3 id="确保向下兼容"><a href="#确保向下兼容" class="headerlink" title="确保向下兼容"></a>确保向下兼容</h3><p>如果不希望对客户造成更新升级方面的困扰，我们首先要做好的就是确保 API 向下兼容。</p>
<p>API 发生改动，要么是需要提供新的功能，要么是为之前的糟糕设计买单……具体来说，改动无外乎：增加、删除、修改 三方面。</p>
<p>首先是删除。<strong>不要轻易删除公开发布的 API</strong>，无论之前写得多么糟糕。如果一定要删除，那么确保正确使用了「<code>Deprecated</code>」：</p>
<p>对于某个不想保留的可怜 API，先不要直接删除，将其标记为 <code>@deprecated</code> 后置入下一个小版本升级（比如从 <code>1.0.2</code> 到 <code>1.1.0</code>）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* @deprecated</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">youWantToRemove</span>(<span class="params">foo, bar</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">* This is the replacement.</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">youWantToKeep</span>(<span class="params">foo</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>并且，在 changelog 中明确指出这些 API 即将移除（不推荐使用，但是目前仍然能用）。</p>
<p>之后，在下一个 <strong>大版本</strong> 中（比如 <code>1.1.0</code> 到 <code>2.0.0</code>）删除标记为 <code>@deprecated</code> 的部分，同时在 changelog 中指明它们已删除。</p>
<p>其次是 API 的修改。如果我们仅仅是修复 bug、重构实现、或者添加一些小特性，那自然没什么可说的；但是如果想彻底修改一个 API……比如重做入口参数、改写业务逻辑等等，建议的做法是：</p>
<ol>
<li>确保原来的 API 符合「单一职责」原则，如果不是则修改之。</li>
<li>增加一个全新的 API 去实现新的需求！由于我们的 API 都遵循「单一职责」，因此一旦需要彻底修改 API，意味着新需求和原来的职责已经完全无法匹配，不如干脆新增一个 API。</li>
<li>视具体情况选择保留或移除旧 API，进入前面所述「删除 API」的流程。</li>
</ol>
<p>最后是新增 API。事实上，即使是只加代码不删代码，整体也不一定是向下兼容的。有一个经典的正面案例是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// modern browsers</span></span><br><span class="line"><span class="built_in">document</span>.hidden == <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// out-of-date browsers</span></span><br><span class="line"><span class="built_in">document</span>.hidden == <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure>
<p>浏览器新增的一个 API，用以标记「当前文档是否可见」。直观的设计应该是新增 <code>document.visible</code> 这样的属性名……问题是，在逻辑上，文档默认是可见的，即 <code>document.visible</code> 默认为 <code>true</code>，而不支持此新属性的旧浏览器返回 <code>document.visible == undefined</code>，是个 falsy 值。因此，如果用户在代码中简单地以：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.visible) &#123;</span><br><span class="line">  <span class="comment">// do some stuff</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>做特征检测的话，在旧浏览器中就会进入错误的条件分支……而反之，以 <code>document.hidden</code> API 来判断，则是向下兼容的。</p>
<h3 id="设计扩展机制"><a href="#设计扩展机制" class="headerlink" title="设计扩展机制"></a>设计扩展机制</h3><p>毫无疑问，在保证向下兼容的同时，API 需要有一个对应的扩展机制以可持续发展 —— 一方面便于开发者自身增加功能，另一方面用户也能参与进来共建生态。</p>
<p>技术上来说，接口的扩展方式有很多，比如：继承（extend）、组合（mixin）、装饰（decorate）……选择没有对错，因为不同的扩展方式适用于不同的场景：在逻辑上确实存在派生关系，并且需要沿用基类行为同时自定义行为的，采用重量级的继承；仅仅是扩充一些行为功能，但是逻辑上压根不存在父子关系的，使用组合；而装饰手法更多应用于给定一个接口，将其包装成多种适用于不同场景新接口的情况……</p>
<p>另一方面，对于不同的编程语言来说，由于不同的语言特性……静态、动态等，各自更适合用某几种扩展方式。所以，到底采用什么扩展办法，还是得视情况而定。</p>
<p>在 JS 界，有一些经典的技术产品，它们的扩展甚至已经形成生态，如：</p>
<ul>
<li>jQuery。耳熟能详的 <code>$.fn.customMethod = function() {};</code>。这种简单的 mixin 做法已经为 jQuery 提供了成千上万的插件，而 jQuery 自己的大部分 API 本身也是基于这个写法构建起来的。</li>
<li>React。React 自身已经处理了所有有关组件实例化、生命周期、渲染和更新等繁琐的事项，只要开发者基于 <code>React.Component</code> 来继承出一个组件类。对于一个 component system 来说，这是一个经典的做法。</li>
<li>Gulp。相比于近两年的大热 Webpack，个人认为 Gulp 更能体现一个 building system 的逻辑 —— 定义各种各样的「任务」，然后用「管道」将它们串起来。一个 Gulp 插件也是那么的纯粹，接受文件流，返回文件流，如是而已。</li>
<li>Koa。对于主流的 HTTP Server 来说，中间件的设计大同小异：接受上一个 request，返回一个新的 response。而对天生 Promise 化的 Koa 来说，它的中间件风格更接近于 Gulp 了，区别仅在于一个是 file stream，一个是 HTTP stream。</li>
</ul>
<p>不只是庞大的框架需要考虑扩展性，设计可扩展的 API 应该变成一种基本的思维方式。比如这个活生生的业务例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// json</span></span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"item"</span>,</span><br><span class="line">    <span class="string">"otherAttrs"</span>: <span class="string">"foo"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"shop"</span>,</span><br><span class="line">    <span class="string">"otherAttrs"</span>: <span class="string">"bar"</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// render logic</span></span><br><span class="line"><span class="keyword">switch</span>(feed.type) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'item'</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render in item-style.'</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'shop'</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render in shop-style.'</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'other'</span>:</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render in other styles, maybe banner or sth.'</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据不同的类型渲染一组 feeds 信息：商品模块、店铺模块，或是其他。某天新增了需求说要支持渲染天猫的店铺模块（多显示个天猫标等等），于是 JSON 接口直接新增一个 <code>type = &#39;tmallShop&#39;</code> —— 这种接口改法很简单直观，但是并不好。在不改前端代码的情况下，<code>tmallShop</code> 类型默认进入 <code>default</code> 分支，导致奇奇怪怪的渲染结果。</p>
<p>考虑到 <code>tmallShop</code> 和 <code>shop</code> 之间是一个继承的关系，<code>tmallShop</code> 完全可以当一个普通的 <code>shop</code> 来用，执行后者的所有逻辑。用 Java 的表达方式来说就是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a tmallShop is a shop</span></span><br><span class="line">Shop tmallShop = <span class="keyword">new</span> TmallShop();</span><br><span class="line">tmallShop.doSomeShopStuff();</span><br></pre></td></tr></table></figure>
<p>将这个逻辑关系反映到 JSON 接口中，合理的做法是新增一个 <code>subType</code> 字段，用来标记 <code>tmallShop</code>，而它的 <code>type</code> 仍然保持为 <code>shop</code>。这样一来，即使原来的前端代码完全不修改，仍然可以正常运行，除了无法渲染出一些天猫店铺的特征。</p>
<p>这里还有一个非常类似的正面案例，是 ABS 搭建系统（淘宝 FED 出品的站点搭建系统）设计的模块 JSON Schema：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// json</span></span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">    <span class="string">"format"</span>: <span class="string">"enum"</span></span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">    <span class="string">"format"</span>: <span class="string">"URL"</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>同样采用了 <code>type</code> 为主类型，而扩展字段在这里变成了 <code>format</code>，用来容纳一些扩展特性。在实际开发中，的确也很方便新增各种新的数据结构逻辑。</p>
<h3 id="控制-API-的抽象级别"><a href="#控制-API-的抽象级别" class="headerlink" title="控制 API 的抽象级别"></a>控制 API 的抽象级别</h3><p>API 能扩展的前提是什么？是接口足够抽象。这样才能够加上各种具体的定语、装饰更多功能。用日常语言举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// abstract</span></span><br><span class="line">I want to go to a place.</span><br><span class="line"><span class="comment">// when</span></span><br><span class="line">&#123;Today, Tomorrow, Jan. <span class="number">1</span>st&#125; I want to go to a place.</span><br><span class="line"><span class="comment">// where</span></span><br><span class="line">I want to go to &#123;mall, cafe, bed&#125;.</span><br><span class="line"></span><br><span class="line"><span class="comment">// concrete, no extends any more</span></span><br><span class="line">Today I want to go to a cafe <span class="keyword">for</span> my business.</span><br></pre></td></tr></table></figure>
<p>所以，在设计 API 时要高抽象，不要陷入具体的实现，不要陷入具体的需求，要高屋建瓴。</p>
<p>看个实际的案例：一个类 React Native 的页面框架想暴露出一个事件「滚动到第二屏」，以便页面开发者能监听这个事件，从而更好地控制页面资源的加载策略（比如首屏默认加载渲染、到第二屏之后再去加载剩下的资源）。</p>
<p>但是因为一些实现上的原因，页面框架还不能通过页面位移（offset）来精确地通知「滚动到了第二屏」，而只能判断「第二屏的第一个模块出现了」。于是这个事件没有被设计为 <code>secondScreenReached</code>，而变成了 <code>secondScreenFirstModuleAppear</code>……虽然 <code>secondScreenFirstModuleAppear</code> 不能精确定义 <code>secondScreenReached</code>，但是直接暴露这个具体的 API 实在太糟糕了，问题在于：</p>
<ul>
<li>用户在依赖一个非常非常具体的 API，给用户造成了额外的信息负担。「第二屏的第一个模块出现了！」这很怪异，用户根本不关心模块的事情，用户关心的只是他是否到达了第二屏。</li>
<li>一旦页面框架能够真正通过页面位移来实现「滚动到第二屏」，如果我们暴露的是高抽象的 <code>secondScreenReached</code>，那么只需要更改一下这个接口的具体实现即可；反之，我们暴露的是很具体的 <code>secondScreenFirstModuleAppear</code>，就只能挨个通知用户：「你现在可以不用依赖这个事件了，改成我们新出的 <code>secondScreenReached</code> 吧！」</li>
</ul>
<p>是的，抽象级别一般来说越高越好，将 API 设计成业务无关的，更通用，而且方便扩展。但是物极必反，对于像我这样的抽象控来说，最好能学会控制接口的抽象级别，将其保持在一个恰到好处的层次上，不要做无休止的抽象。</p>
<p>还是刚才的例子 <code>secondScreenReached</code>，我们还可以将其抽象成 <code>targetScreenReached</code>，可以支持到达首屏、到达第二屏、第三屏……的事件，这样是不是更灵活、更优雅呢？并没有 ——</p>
<ul>
<li>抽象时一定要考虑到具体的业务需求场景，有些实现路径如果永远不可能走到，就没必要抽出来。比如这个例子中，没有人会去关心第三屏、第四屏的事件。</li>
<li>太高的抽象容易造成太多的层次，带来额外的耦合、通信等不同层次之间的沟通成本，这将会成为新的麻烦。对用户而言，也是额外的信息负担。</li>
</ul>
<p>对于特定的业务来说，接口越抽象越通用，而越具体则越能解决特定问题。所以，思考清楚，API 面向的场景范围，避免懒惰设计，避免过度设计。</p>
<h3 id="收敛-API-集"><a href="#收敛-API-集" class="headerlink" title="收敛 API 集"></a>收敛 API 集</h3><p>对于一整个体系的 API 来说，用户面对的是这个整体集合，而不是其中某几个单一的 API。我们要保证集合内的 API 都在一致的抽象维度上，并且适当地合并 API，减小整个集合的信息量，酌情做减法。</p>
<blockquote>
<p>产品开始做减法，便是对用户的温柔。</p>
</blockquote>
<p><strong>收敛近似意义的参数和局部变量</strong>。下面这样的一组 API 好像没什么不对，但是对强迫症来说一定产生了不祥的直觉：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">selectTab</span>(<span class="params">index</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">highlightTab</span>(<span class="params">tabIndex</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">gotoPage</span>(<span class="params">index</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>又是 <code>index</code> 又是 <code>tabIndex</code> 的，或许还会有 <code>pageIndex</code>？诚然，函数形参和局部变量的命名对最终用户来说没有直接影响，但是这些不一致的写法仍然能反映到 API 文档中，并且，对开发者自身也会产生混淆。所以，选一个固定的命名风格，然后从一而终！如果忘了的话，回头看一下前文「固化术语表」这一节吧！</p>
<p><strong>收敛近似职责的函数</strong>。对用户暴露出太多的接口不是好事，但是一旦要合并不同的函数，是否就会破坏「单一职责」原则呢？</p>
<p>不，因为「单一职责」本身也要看具体的抽象层次。以下这个例子和前文「合理运用函数重载」中的例子有相似之处，但具体又有所不同。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a complex rendering process</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderPage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// too many APIs here</span></span><br><span class="line">  renderHeader();</span><br><span class="line">  renderBody();</span><br><span class="line">  renderSidebar();</span><br><span class="line">  renderFooter();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// now merged</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderPage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  renderSections([</span><br><span class="line">    <span class="string">'header'</span>, <span class="string">'body'</span>, <span class="string">'sidebar'</span>, <span class="string">'footer'</span></span><br><span class="line">  ]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// call renderSection</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderSections</span>(<span class="params">sections</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// and the real labor</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderSection</span>(<span class="params">section</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>类似于这样，避免暴露过多近似的 API，合理利用抽象将其合并，减小对用户的压力。</p>
<p>对于一个有清晰继承树的场景来说，收敛 API 显得更加自然且意义重大 —— 利用多态性（Polymorphism）构建 Consistent APIs。（以下例子来源于 <a href="https://github.com/ryanmcdermott/clean-code-javascript" target="_blank" rel="external">Clean Code JS</a>。）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad: type-checking here</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">travelToTexas</span>(<span class="params">vehicle</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (vehicle <span class="keyword">instanceof</span> Bicycle) &#123;</span><br><span class="line">    vehicle.pedal(<span class="keyword">this</span>.currentLocation, <span class="keyword">new</span> Location(<span class="string">'texas'</span>));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vehicle <span class="keyword">instanceof</span> Car) &#123;</span><br><span class="line">    vehicle.drive(<span class="keyword">this</span>.currentLocation, <span class="keyword">new</span> Location(<span class="string">'texas'</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cool</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">travelToTexas</span>(<span class="params">vehicle</span>) </span>&#123;</span><br><span class="line">  vehicle.move(<span class="keyword">this</span>.currentLocation, <span class="keyword">new</span> Location(<span class="string">'texas'</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有一个将 API 收敛到极致的家伙恐怕大家都不会陌生：jQuery 的 <code>$()</code>。这个风格不正是 jQuery 当年的杀手级特性之一吗？</p>
<blockquote>
<p>如果 <code>$()</code> 能让我搞定这件事，就不要再给我 <code>foo()</code> 和 <code>bar()</code>。</p>
</blockquote>
<p><strong>收敛近似功能的包</strong>。再往上一级，我们甚至可以合并相近的 package。</p>
<p>淘宝 FED 的 Rax 体系（类 RN 框架）中，有基础的组件标签，如 <code>&lt;Image&gt; (in @ali/rax-components)</code>、<code>&lt;Link&gt; (in @ali/rax-components)</code>，也有一些增强功能的 package，如 <code>&lt;Picture&gt; (in @ali/rax-picture)</code>、<code>&lt;Link&gt; (in @ali/rax-spmlink)</code>。</p>
<p>在这里，后者包之于前者相当于装饰了更多功能，是前者的增强版。而在实际应用中，也是推荐使用诸如 <code>&lt;Picture&gt;</code> 而禁止使用 <code>&lt;Image&gt;</code>。那么在这种大环境下，<code>&lt;Image&gt;</code> 等基础 API 的暴露就反而变得很扰民。可以考虑将增强包的功能完全合并入基础组件，即将 <code>&lt;Picture&gt;</code> 并入 <code>&lt;Image&gt;</code>，用户只需面对单一的、标准的组件 API。</p>
<h3 id="发散-API-集"><a href="#发散-API-集" class="headerlink" title="发散 API 集"></a>发散 API 集</h3><p>这听上去很荒谬，为什么一个 API 集合又要收敛又要发散？仅仅是为了大纲上的对称性吗？</p>
<p>当然不是。存在这个小节是因为我有一个不得不提的案例，不适合放在其他段落，只能放在这里……不，言归正传，我们有时的确需要发散 API 集，提供几个看似接近的 API，以引导用户。因为 —— 虽然这听起来很荒谬 —— 某些情况下，API 其实不够用，但是用户 <strong>没有意识到 API 不够用</strong>，而是选择了混用、滥用。看下面这个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the func is used here</span></span><br><span class="line">requestAnimationFrame(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// what? trigger an event?</span></span><br><span class="line">  emitter.emit(<span class="string">'moduleDidRenderRow'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...and there</span></span><br><span class="line">requestAnimationFrame(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// another one here, I guess rendering?</span></span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在重构一组代码时，我看到代码里充斥着 <code>requestAnimationFrame()</code>，这是一个比较新的全局 API，它会以接近 60 FPS 的速率延时执行一个传入的函数，类似于一个针对特定场景优化过的 <code>setTimeout()</code>，但它的初衷是用来绘制动画帧的，而不应该用在奇奇怪怪的场景中。</p>
<p>在深入地了解了代码逻辑之后，我认识到这里如此调用是为了「延时一丢丢执行一些操作」，避免阻塞主渲染线程。然而这种情况下，还不如直接调用 <code>setTimeout()</code> 来做延时操作。虽然没有太明确的语义，但是至少好过把自己伪装成一次动画的绘制。更可怕的是，据我所知 <code>requestAnimationFrame()</code> 的滥用不仅出现在这次重构的代码中，我至少在三个不同的库见过它的身影 —— 无一例外地，这些库和动画并没有什么关系。</p>
<p>（一个可能的推断是，调用 <code>requestAnimationFrame(callback)</code> 时不用指定 <code>timeout</code> 毫秒数，而 <code>setTimeout(callback, timeout)</code> 是需要的。似乎对很多用户来说，前者的调用方式更 cool？）</p>
<p>所以，在市面上有一些 API 好像是「偏方」一般的存在：虽然不知道为什么要这么用，但是……用它就对了！</p>
<p>事实上，对于上面这个场景，最恰当的解法是使用一个更加新的 API，叫做 <code>requestIdleCallback(callback)</code>。这个 API 从名字上看起来就很有语义：在线程空闲的时候再执行操作。这完全契合上述场景的需求，而且还自带底层的优化。</p>
<p>当然，由于 API 比较新，还不是所有的平台都能支持。即便如此，我们也可以先面向接口编程，自己做一个 polyfill：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// simple polyfill</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">requestIdleCallback</span>(<span class="params">callback</span>) =&gt; </span>&#123;</span><br><span class="line">  callback &amp;&amp; setTimeout(callback, <span class="number">1e3</span> / <span class="number">60</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>另一个经典的滥用例子是 ES2015 中的「Generator / yield」。</p>
<p>原本使用场景非常有限的生成器 Generator 机制被大神匠心独运地加以改造，包装成用来异步代码同步化的解决方案。这种做法自然很有创意，但是从语义用法上来说实在不足称道，让代码变得非常难读，并且带来维护隐患。与其如此，还不如仅仅使用 Promise。</p>
<p>令人欣慰的是，随后新版的 ES 即提出了新的异步代码关键字「async / await」，真正在语法层面解决了异步代码同步化的问题，并且，新版的 Node.js 也已经支持这种语法。</p>
<p>因此，我们作为 API 的开发者，一定要提供足够场景适用的 API，来引导我们的用户，不要让他们做出一些出人意料的「妙用」之举。</p>
<h3 id="制定-API-的支持策略"><a href="#制定-API-的支持策略" class="headerlink" title="制定 API 的支持策略"></a>制定 API 的支持策略</h3><p>我们说，一组公开的 API 是产品。而产品，一定有特定的用户群，或是全球的开发者，或仅仅是跨部门的同事；产品同时有保质期，或者说，生命周期。</p>
<p>面向目标用户群体，我们要制定 API 的支持策略：</p>
<ul>
<li>每一个大版本的支持周期是多久。</li>
<li>是否有长期稳定的 API 支持版本。（Long-term Support）</li>
<li>如何从旧版本升级。</li>
</ul>
<p>老旧版本很可能还在运行，但维护者已经没时间精力再去管这些历史遗物，这时明确地指出某些版本不再维护，对开发者和用户都好。当然，同时别忘了给出升级文档，指导老用户如何迁移到新版本。还有一个更好的做法是，在我们开启一个新版本之际，就确定好上一个版本的寿命终点，提前知会到用户。</p>
<p>还有一个技术上的注意事项，那就是：<strong>大版本间最好有明确的隔离</strong>。对于一个复杂的技术产品来说，API 只是最终直接面向用户的接口，背后还有特定的环境、工具组、依赖包等各种支撑，互相之间并不能混用。</p>
<p>比如，曾经的经典前端库 KISSY。在业界技术方案日新月异的大潮下，KISSY 6 版本已经强依赖了 TNPM（阿里内网的 NPM）、DEF 套件组（淘宝 FED 的前端工具套件），虽然和之前的 1.4 版本相比 API 的变化并不大，但是仍然不能在老环境下直接使用 6 版本的代码库……这一定程度上降低了自由组合的灵活度，但事实上随着业务问题场景的复杂度提升，解决方案本身会需要更定制化，因此，将环境、工具等上下游关联物随代码一起打包，做成一整个技术方案，这正是业界的现状。</p>
<p>所以，隔离大版本，制定好 API 支持策略，让我们的产品更专业，让用户免去后顾之忧。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上，便是我从业以来感悟到的一些「道」，三个进阶层次、几十个细分要点，不知有没有给读者您带来一丁点启发。</p>
<p>但实际上，<strong>大道至简</strong>。我一直认为，程序开发和平时的说话写字其实没有太大区别，无非三者 ——</p>
<ol>
<li>逻辑和抽象。</li>
<li>领域知识。</li>
<li>语感。</li>
</ol>
<p>写代码，就像写作，而设计 API 好比列提纲。勤写、勤思，了解前人的模式、套路，学习一些流行库的设计方法，掌握英语、提高语感……相信大家都能设计出卓越的 API。</p>
<p>最后，附上 API 设计的经典原则：</p>
<blockquote>
<p>Think about future, design with flexibility, but only implement for production.</p>
</blockquote>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol>
<li><a href="https://msdn.microsoft.com/en-us/library/ms229042(v=vs.110).aspx" target="_blank" rel="external">Framework Design Guidelines</a></li>
<li><a href="https://github.com/lifesinger/blog/issues/164" target="_blank" rel="external">Page Visibility 的 API 设计</a></li>
<li><a href="https://github.com/lifesinger/blog/issues/119" target="_blank" rel="external">我心目中的优秀 API</a></li>
<li><a href="https://github.com/ryanmcdermott/clean-code-javascript" target="_blank" rel="external">Clean Code JavaScript</a></li>
</ol>
<hr>
<p>题图：<a href="https://www.flickr.com/photos/132889348@N07/20013034943" target="_blank" rel="external">只是一张符合上下文的图片，并没有更深的含义</a>。</p>
<p>花絮：由于文章很长，在编写过程中我也不由得发生了「同一个意思却使用多种表达方式」的情况。某些时候这是必要的 —— 可以丰富文字的多样性；而有些时候，则显得全文缺乏一致性。在发表本文之前，我搜索了这些词语：「调用者」、「调用方」、「引用者」、「使用者」，然后将它们统一修改为我们熟悉的名字：「用户」。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="https://img.alicdn.com/tps/TB1qujpLXXXXXaLXFXXXXXXXXXX-900-500.jpg" alt="从达标到卓越 —— API 设计之道"></p>
<p>新技术层出不穷，长江后浪推前浪，而浪潮褪去后能留下来]]>
    </summary>
    
      <category term="API 设计" scheme="http://taobaofed.org/tags/API-%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Why Rax?]]></title>
    <link href="http://taobaofed.org/blog/2017/02/10/why-rax/"/>
    <id>http://taobaofed.org/blog/2017/02/10/why-rax/</id>
    <published>2017-02-10T10:17:45.000Z</published>
    <updated>2017-03-18T09:50:27.000Z</updated>
    <content type="html"><![CDATA[<p><img src="//img.alicdn.com/tps/TB1LxebPVXXXXaHXpXXXXXXXXXX-900-500.png" alt="Why Rax?"></p>
<blockquote>
<p><a href="https://github.com/alibaba/rax" target="_blank" rel="external">https://github.com/alibaba/rax</a></p>
</blockquote>
<p>从今年 1 月 12 日在 Weex Conf 上宣布 <a href="https://github.com/alibaba/rax" target="_blank" rel="external">Rax</a> 开源，至今已过去一个月左右的时间，这段时间里，Rax 拿到 2400+ 的 star, 我们深知这对一个开源产品来说是微不足道的，但是从中可以发现的是「前端或者 Weex 社区对于类 React 的技术方案是有很大需求的」。同时，结合近期 GitHub 上的相关 <a href="https://github.com/alibaba/rax/issues?q=is%3Aissue+is%3Aclosed" target="_blank" rel="external">issue</a>, 大抵上就有了这样一篇完整介绍 Rax 的文章。</p>
<h2 id="淘宝无线端的发展历程"><a href="#淘宝无线端的发展历程" class="headerlink" title="淘宝无线端的发展历程"></a>淘宝无线端的发展历程</h2><p>在前端这条道路上，淘宝 FED 一直以来的使命就是「用技术为体验提供无限可能」，Rax 自然也是在追求体验的道路上发展出来的。</p>
<p>从 2014 年开始，结合阿里双十一双十二的数据变化，无论从用户访问量还是最终成交量上都可以清晰的看到：「移动端已然是当下业务的主要阵地」，当业务重心向移动端偏移时，技术也在悄然发生变化，传统而成熟的 PC 端技术方案俨然已经无法满足移动端对体验性能、开发效率等各个方面的要求，这也开启了我们在无线端上的技术探索之路。</p>
<h3 id="KIMI"><a href="#KIMI" class="headerlink" title="KIMI"></a>KIMI</h3><p>2014 年伊始，算是阿里无线业务起步的阶段，那时候大家把无线页面还称为 H5, 诸如 KISSY, jQuery 之类的库对于无线页面来说尺寸太大、加载太慢，于是我们基于社区成熟的 Zepto 迅速打造了 KIMI 这个核心库，然后围绕业务不断完善 KIMI 的组件生态以及包含工程化、性能检测等一系列生态。这套生态伴随着我们走过了将近两年时间，至今仍可以在一些页面上找到 KIMI 的影子。</p>
<p>然而，KIMI 始终是一个 Web 端的解决方案，即便可以通过一些方案去调用 native 的原生方法，也无法跨域无线端上 Web 体验不及 native 体验这样一个既定事实。于是，如何能让页面达到 native 的体验成为我们的下一个探索点。</p>
<h3 id="React-Web"><a href="#React-Web" class="headerlink" title="React Web"></a>React Web</h3><p>说起 native 的体验，最直观的方案就是直接去写 native 代码，然而 native 的开发模式一直存在一些难以解决的问题：</p>
<ul>
<li>成本与效率：iOS, Andriod, Web 三端需要不同的技术团队各自开发一套，成本大，效率低</li>
<li>灵活性：受限于 AppStore 的审核机制，版本发布周期较长，难以满足业务需求</li>
</ul>
<p>所以，我们需要一套基于 Web 的开发模式但可以产出 native 页面的解决方案，效率与体验兼得。在这个思路下，阿里也有过一些尝试，不过都没有形成最终的解决方案，这里就不再详细讲述了。直到 2015 年中期，Facebook 开源了 React Native(RN), 虽然初期只有 iOS 的版本，但丝毫不影响其对整个无线开发方案的巨大冲击。RN 基本完美解决了需要编写两端代码的问题，同时还有一个非常活跃完善的 React 社区，因此这个方案也得到了诸多开发者的青睐。</p>
<p>接着，我们也快速在手淘里尝试了 RN 的方案，受限于 RN 的兼容性问题以及用户可能在浏览器端打开页面，因此整个页面必须要有能力降级到 Web 版本。这时候回想下 RN 的口号：Learn once, write anywhere. 但这对于我们来说，或许还不够，我们真正需要的是：Write once, run everywhere.</p>
<p>因此我们开始探索如何让 RN 的代码运行在 Web 端，这就是 <a href="https://github.com/taobaofed/react-web" target="_blank" rel="external">React Web</a> 方案。</p>
<h3 id="Rax"><a href="#Rax" class="headerlink" title="Rax"></a>Rax</h3><p>2015 年双十一，Weex 的方案开始逐步使用，经过这次试水，证明了这套方案未来的场景及可行性，接着 2016 年 Weex 开始进入快速发展的阶段。但是使用 Weex 就意味着必须用 Vue 的语法，这对于整个团队来说是一个不小的挑战：PC 场景下的项目，小伙伴们普遍基于 React 开发，已经有了相当多的经验与沉淀。如果无线的项目要采用一个不同方案（Vue）去做，强推未必会不奏效，但是小伙伴们大概会伤心吧。</p>
<p>于是我们尝试将 React 与 Weex 结合起来，但是由于方案太过 hack 导致各种问题，遂无奈放弃。接着 Rax 的方案应运而生：「Rax 基于 React 的标准，支持在不同容器中渲染，当前最重要的容器即 Weex 和 Web」。</p>
<h2 id="Rax-体系"><a href="#Rax-体系" class="headerlink" title="Rax 体系"></a>Rax 体系</h2><h3 id="Rax-与-React"><a href="#Rax-与-React" class="headerlink" title="Rax 与 React"></a>Rax 与 React</h3><blockquote>
<p>React 是一种标准，Rax 是对该标准的一个实现。</p>
</blockquote>
<p>社区里很多人关心 Rax 与 React 的优缺点以及相互取代的可能性，事实上，从上文的发展历程就可以看出来，Rax  只是无线端的解决方案，与 React 并无冲突。事实上淘宝 PC 端的新项目，依然主要是基于 React，并且我们也有一套基于 React 的解决方案名为 ICE，通过一系列的工具帮助开发者提高效率，此处不再展开。</p>
<p>当然，Rax 跟 Preact 之类的方案也有本质区别，前者偏向于解决多端问题，后者偏向于解决性能问题，具体可参考下文「Rax 的特点」。</p>
<h3 id="Rax-的特点"><a href="#Rax-的特点" class="headerlink" title="Rax 的特点"></a>Rax 的特点</h3><h4 id="1-设计上支持不同容器"><a href="#1-设计上支持不同容器" class="headerlink" title="1. 设计上支持不同容器"></a>1. 设计上支持不同容器</h4><p>Rax 在设计上抽象出 Driver 的概念，用来支持在不同容器中渲染，比如目前所支持的：Web, Weex, Node.js. 基于 Driver 的概念，未来即使出现更多的容器（如 VR 等），Rax 也可以从容应对。Rax 在设计上尽量抹平各个端的差异性，这也使得开发者在差异性和兼容性方面再也不需要投入太多精力了。</p>
<p>详细内容可参考 <a href="https://github.com/alibaba/rax/blob/master/docs/driver-spec.md" target="_blank" rel="external">Rax Driver Spec</a>.</p>
<h4 id="2-体积足够小"><a href="#2-体积足够小" class="headerlink" title="2. 体积足够小"></a>2. 体积足够小</h4><p>如上文所说，Rax 是一个面向无线端的解决方案，因此自身的体积对于性能来讲就显得非常重要。Rax 压缩 + gzip 后的体积是 8.0kb, 相比 React 的 43.7kb, 对于无线端友好了很多。</p>
<h4 id="3-支持返回多个同级节点"><a href="#3-支持返回多个同级节点" class="headerlink" title="3. 支持返回多个同级节点"></a>3. 支持返回多个同级节点</h4><p>任何用过 React 的同学大概都踩过同一个坑：方法返回了多个同级节点导致报错。在设计上 React 只能返回单个节点，因此页面上或多或少会产生一些冗余的节点，这在 PC 端并没有太多问题，然而在无线 Android 端嵌套层级越多，应用的 crash 率会不断提高，这一点在低端 Android 机上表现尤其明显。因此 Rax 支持了返回多个同级节点的功能，如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createElement, Component, render&#125; <span class="keyword">from</span> <span class="string">'rax'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map((item) =&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;item&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一特性可以有效减少页面的嵌套层级，从而减少应用因嵌套层级过多而出现的 crash 问题。</p>
<h4 id="4-标准化"><a href="#4-标准化" class="headerlink" title="4. 标准化"></a>4. 标准化</h4><p>在上文里，我们不断的提各个端的一致性，一致则必有规范可依，Rax 遵循 W3C 标准，比如在 Weex 容器中已经可以直接调用 <code>navigator</code>, <code>document</code>, <code>location</code>, <code>alert</code> 等 W3C 的标准 API.</p>
<p>当然，受限于各个端的差异，标准化的道路还很长，「更标准化」这也是 Rax 未来的重要目标之一。</p>
<h3 id="RAXUI"><a href="#RAXUI" class="headerlink" title="RAXUI"></a>RAXUI</h3><p>Rax 旨在解决多端一致的问题，这帮助我们无需关注各个端的差异性，实现「Write once, run everywhere」的愿景。然而在前端开发领域，开发人员需要直面的还是 UI 体系，不同项目间夜以继日的开发着功能类似的组件，想想就觉得头疼，因此 Rax 在最基础的元件 <a href="https://github.com/alibaba/rax/tree/master/packages/rax-components/src" target="_blank" rel="external">rax-components</a> 之上实现了一套官方的 UI 组件，即 RAXUI.</p>
<p><img src="https://gw.alicdn.com/tps/TB1499MOVXXXXcIXXXXXXXXXXXX-641-436.png" alt=""></p>
<p>RAXUI 是 RAX 上层的一套通用 UI 组件，帮助开发者快速完成模块和页面的开发。比如 Picture 组件是对元件里的 Image 做了一层封装，包含图片优化、H5 懒加载等更多功能，TabHeader 组件可以帮助开发者便捷的实现横向滚动导航… RAXUI 不仅能降低业务的开发成本，同时为了保证产品质量，RAXUI 在兼容性、性能、设计规范等很多方面都有更多更完善的考虑。在不久的将来，这套 UI 体系也会逐渐向社区开放。</p>
<h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><p>Write once, run everywhere. 这是口号，亦是目标。Rax 未来会在更多的端上不断探索，比如 VR/AR, 甚至之前微博上有同学提出的是否可以用 Rax 写微信小程序，也是一个蛮有意思的想法。</p>
<p>对于开发者来说，当越来越多的端不断出现在眼前时，我们应该如何应对？是通过不断的踩坑来整理一份长长的 checklist, 然后做项目时一一对照？ 或者让我们一起来探索 Rax? </p>
<p>Rax 团队敬上。</p>
<hr>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ul>
<li><a href="https://github.com/alibaba/rax" target="_blank" rel="external">github</a></li>
<li><a href="https://github.com/alibaba/rax/issues" target="_blank" rel="external">issue 反馈</a></li>
<li><a href="http://taobaofed.org/blog/2017/01/13/rax-in-act/">淘宝双促中的 Rax</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="//img.alicdn.com/tps/TB1LxebPVXXXXaHXpXXXXXXXXXX-900-500.png" alt="Why Rax?"></p>
<blockquote>
<p><a href="https://github.com/a]]>
    </summary>
    
      <category term="Rax" scheme="http://taobaofed.org/tags/Rax/"/>
    
      <category term="无线开发" scheme="http://taobaofed.org/categories/%E6%97%A0%E7%BA%BF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[淘宝双促中的 Rax]]></title>
    <link href="http://taobaofed.org/blog/2017/01/13/rax-in-act/"/>
    <id>http://taobaofed.org/blog/2017/01/13/rax-in-act/</id>
    <published>2017-01-13T03:53:44.000Z</published>
    <updated>2017-03-18T09:50:27.000Z</updated>
    <content type="html"><![CDATA[<p><img src="//gw.alicdn.com/tfs/TB1XDuDPXXXXXbRapXXXXXXXXXX-900-500.jpg" alt="淘宝双促中的 Rax"></p>
<p>引子</p>
<p>本文开始之前先调整一个概念，陪我们奋战穿促的 Rx 更名为 <a href="http://rax.taobaofed.org/" target="_blank" rel="external">Rax</a>。本文会全部使用新的概念去描述。首先简单介绍一下 Rax 是什么以及在双促中的定位。然后介绍一下大促通用页面渲染逻辑以及模块渲染逻辑。</p>
<h2 id="Rax"><a href="#Rax" class="headerlink" title="Rax"></a>Rax</h2><p>Rax 是一个基于 React 方式的跨容器的 JS 框架</p>
<ul>
<li>React：你会用 React，那么你会很快上手 Rax</li>
<li>跨容器：Browser、WEEX、Node.js</li>
</ul>
<p><img src="https://gw.alicdn.com/tps/TB1GloTOVXXXXa1XVXXXXXXXXXX-1455-368.jpg_500x500.jpg" alt=""></p>
<p>gzip 大小 8k，与 Angular、React、Vue 相比更加轻量。在服务端也有更优的渲染性能，1553 op/s。作为双促页面的底层核心框架，让今年的淘宝双促的 native 100% 成为可能。</p>
<h2 id="组件与模块"><a href="#组件与模块" class="headerlink" title="组件与模块"></a>组件与模块</h2><h3 id="体系提供的能力"><a href="#体系提供的能力" class="headerlink" title="体系提供的能力"></a>体系提供的能力</h3><p>Rax 核心框架之上，有一个支撑业务的基础体系。模拟浏览器行为和业务基础功能的 API、最基础的简单标签 Components、以及基础 UI 组件 RAXUI。</p>
<p><img src="https://gw.alicdn.com/tps/TB1oWxhPXXXXXc_XpXXXXXXXXXX-763-431.jpg_500x500.jpg" alt=""></p>
<p>Components 对应最基础的 HTML 标签，提供了最基础的标签能力，开发同学可以通过 Components 标签搭建出最基础的组件以及模块和页面。</p>
<p>通过最基础的标签组成通用 UI 组件 RAXUI，除了 UI 组件，双促中使用的页面核心渲染逻辑也是基于 Components 标签搭建出来的。RAXUI 成为了大促模块搭建的基础、rax-page 则是页面渲染的基础。通过上层对数据请求的封装、缓存策略、页面渲染顺序的控制等组织成了斑马联路中使用的 PI，让页面可以在斑马环境中运作。</p>
<h3 id="RAXUI-组件"><a href="#RAXUI-组件" class="headerlink" title="RAXUI 组件"></a>RAXUI 组件</h3><p><img src="https://gw.alicdn.com/tps/TB19PE1OVXXXXcsaXXXXXXXXXXX-1020-699.jpg_500x500.jpg" alt=""></p>
<p>RAXUI 是 Rax 上层的组件生态，包含了业务中常用的组件，比如横向滚动轮播（slider）、icon、tab 导航头（tabheader）、视频播放（player）等。</p>
<p>上图中列出了部分 RAXUI 组件，通过 rax-picture、rax-slider、rax-tabheader、rax-gotop  等可以组成一个常见的带电梯长列表页面，如下图。</p>
<p><img src="https://gw.alicdn.com/tps/TB1499MOVXXXXcIXXXXXXXXXXXX-641-436.png_500x500.jpg" alt=""></p>
<p>RAXUI 组件已经涵盖了大部分业务中需要的组件场景，为开发提供了一定的便利。</p>
<h3 id="对开发者的影响"><a href="#对开发者的影响" class="headerlink" title="对开发者的影响"></a>对开发者的影响</h3><p><img src="https://gw.alicdn.com/tps/TB1eGRnPXXXXXXcXpXXXXXXXXXX-587-465.jpg_500x500.jpg" alt=""></p>
<p>一个淘宝大促页面模块的开发与往年有很大不同，除了开始使用 React 的写法外，还有一套模块与页面渲染 PI 的约定。</p>
<p><img src="https://gw.alicdn.com/tps/TB1bbcPOVXXXXc9aXXXXXXXXXXX-722-362.jpg_500x500.jpg" alt=""></p>
<p>大促模块分为两类，滚动容器外部的 app 级模块和 滚动容器内的 page 级模块。在 page 级模块的开发过程中需要遵循一些与页面渲染相关的约定，来实现特定逻辑和特定渲染策略。例如 moduleRenderMode 来制定模块类型、getModuleRowHeight 来获取模块高度，以及通过 props 透传的工具方法等。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Module</span> <span class="title">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 模块行高</span></span><br><span class="line">  static getModuleRowHeight = (attrs) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>；</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 无限重复的模块</span></span><br><span class="line">  static moduleRenderMode = <span class="string">'repeat'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 事件通信</span></span><br><span class="line">  static contextTypes = &#123;</span><br><span class="line">    page: PropTypes.<span class="keyword">object</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">    let page = <span class="keyword">this</span>.context.page;</span><br><span class="line">    <span class="keyword">if</span> (page &amp;&amp; <span class="keyword">this</span>.props.isFirstRepeatModule) &#123;</span><br><span class="line">      let moduleName = <span class="keyword">this</span>.props.moduleName;</span><br><span class="line">      <span class="comment">// 模拟异步请求数据</span></span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">          <span class="comment">// 重置模块数据</span></span><br><span class="line">          <span class="keyword">this</span>.props.setDataSource([<span class="string">'异步数据1'</span>, <span class="string">'异步数据2'</span>]);</span><br><span class="line">      &#125;, <span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (&lt;View&gt;<span class="keyword">data</span> : &#123;<span class="keyword">this</span>.props.<span class="keyword">data</span>&#125;&lt;/View&gt;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个简单的长列表模块示例，包含了部分约定的内容。对于这些约定规则表现出的不同渲染策略，下文中会详细列出。</p>
<h2 id="双促页面的通用渲染逻辑"><a href="#双促页面的通用渲染逻辑" class="headerlink" title="双促页面的通用渲染逻辑"></a>双促页面的通用渲染逻辑</h2><p><img src="https://gw.alicdn.com/tps/TB1Z1tqPXXXXXb.XXXXXXXXXXXX-730-448.jpg_500x500.jpg" alt=""></p>
<p>双促中的页面核心渲染逻辑依赖 rax-page，这个仓库主要负责不同容器上样式差异的抹平、页面级别的事件通信、页面滚动容器的实现、页面模块渲染、页面性能优化、业务级的通用埋点、以及部分页面级的通用功能。</p>
<p><img src="https://gw.alicdn.com/tps/TB1Byg3OVXXXXb3XVXXXXXXXXXX-736-444.jpg_500x500.jpg" alt=""></p>
<p>上文中有提到，模块分为 app 级别和 page 级别两类。在页面渲染过程中 app 级别的模块会直接渲染。先解释两个概念</p>
<ul>
<li>Page：页面的外层包裹容器，主要功能包括不同容器上样式差异的抹平、页面级别的事件通信。</li>
<li>Block：页面级的滚动容器，用来控制模块的渲染与页面的滚动。</li>
</ul>
<p>双促的 Block 是页面唯一的全屏滚动容器，所有需要跟随页面滚动的模块都在 Block 内，被定义为 page 级模块。对于页面渲染层面的优化也主要是在 Block 这一层。下面主要介绍一下渲染策略上 WEEX 与 H5 的不同，以及这样做带来的收益。</p>
<p><img src="https://gw.alicdn.com/tps/TB1la3YOVXXXXbVaXXXXXXXXXXX-718-529.jpg_500x500.jpg" alt=""></p>
<p>WEEX 页面的渲染主要依赖 WEEX 原生提供的 list 标签。在页面的滚动过程中，list 内部非当前可视区域的 cell 标签会被回收，保证整个列表渲染内容不会过多。</p>
<p>借助 list + cell 的方案，为了达到更大的收益，在 WEEX 上的实现上就需要拆分出更多的 cell（后面讲双促中的长列表渲染中会详细说明）。一次性渲染出说有的模块必然会很慢，为了让用户能更快的看到页面，在 WEEX 上的策略是首屏优先渲染，渲染完成后一次性渲染非首屏模块。这样做的好处是页面可以看到的时候就可以向下顺畅的滑动。</p>
<p>此处和天猫双 11 会场页面不同，天猫的方案是优先加载首屏，非首屏不加载。在页面向下滚动时在首屏底部的 loadmore 时机一次性渲染第二屏幕。淘宝双促会场页面在 WEEX 的渲染策略不同，主要解决的问题时首屏电梯的跳转，与向下快速滑动过程中的体验流畅。</p>
<p><img src="https://gw.alicdn.com/tps/TB1Ba75OVXXXXcaXVXXXXXXXXXX-698-515.jpg_500x500.jpg" alt=""></p>
<p>H5 页面的渲染策略与 WEEX 完全不同。吸收了 WEEX 页面渲染的部分思路，同时也沿用了往年淘宝大促页面渲染的经验。</p>
<p>对于 H5 页面的渲染，同样区分首屏和非首屏。不同的是首屏渲染结束后非首屏的模块不会继续渲染，甚至模块标签都不会出现在页面上。</p>
<p>这里引入一个站位容器的概念。非首屏的模块默认只渲染出一个和模块真实高度相同的容器。当容器出现在可视区域时（也就是容器的 appear 时机）用真实模块替换掉占位容器。这样做的好处是有效的减少了页面的节点数。当页面电梯跳转到指定楼层时，非可视区域内的模块也不会渲染。</p>
<h2 id="双促中的长列表渲染"><a href="#双促中的长列表渲染" class="headerlink" title="双促中的长列表渲染"></a>双促中的长列表渲染</h2><p>上文中简单介绍了页面整体渲染的思路，这部分主要讲一下会场中应用最多的长列表的渲染策略。</p>
<p>首先了解一下淘宝双促中的长列表模块，也就是 repeat 类型的模块。一个模块中包含了许多个重复相同样式的行，这样的一个模块可以自身无限加载，一个页面中可以有许多这样的模块。</p>
<p>那么问题来了</p>
<ul>
<li>list 下更细化的 cell 性能会更好，这样一个多行模块渲染性能肯定是有问题的</li>
<li>页面底部会出发到达底部的事件，显然页面有多个无限加载的列表，这个方案就不适用了</li>
</ul>
<p>为解决这两个问题，也主要是 WEEX 上的渲染问题，我们借助了一些 WEEX 页面渲染的方案。<br>在 Block 容器内的元素，绑定 appear 事件后都可以在进入可视区域或离开可视区域时做一些事情。利用这个机制加上 cell 细化拆分的性能优化方案，就是 repeat 类型模块的基本渲染思路。</p>
<p><img src="https://gw.alicdn.com/tps/TB1OPISOVXXXXaRXVXXXXXXXXXX-570-501.jpg_500x500.jpg" alt=""></p>
<p><strong>占位容器的替换与模块的拆分</strong></p>
<p>WEEX 下占位容器是一个高度撑开的 cell，在 repeat 类型模块渲染时，占位容器首先会被替换成真实的单个模块。这个模块可以进行自己业务逻辑的处理，比如请求数据。在模块渲染数据时，会将数据发送给页面的 Block，Block 判断这是一组 repeat 数据时进行真实数据的渲染</p>
<p><img src="https://gw.alicdn.com/tps/TB1VFM7OVXXXXavXVXXXXXXXXXX-424-387.jpg_500x500.jpg" alt=""></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Rax 第一次接受淘宝双促的考验，在 native 化、性能、稳定性等多个方面表现优异，达成了预定的目标。在双促中沉淀下的经验也将陆续反哺给其他业务和活动中，在未来会有更多的场景使用 Rax，Rax 体系也将不断完善。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="//gw.alicdn.com/tfs/TB1XDuDPXXXXXbRapXXXXXXXXXX-900-500.jpg" alt="淘宝双促中的 Rax"></p>
<p>引子</p>
<p>本文开始之前先调整一个概念，陪我们奋战穿促的 Rx 更名为 <]]>
    </summary>
    
      <category term="Rax" scheme="http://taobaofed.org/tags/Rax/"/>
    
      <category term="无线开发" scheme="http://taobaofed.org/categories/%E6%97%A0%E7%BA%BF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[编写「可读」代码的实践]]></title>
    <link href="http://taobaofed.org/blog/2017/01/05/writing-readable-code/"/>
    <id>http://taobaofed.org/blog/2017/01/05/writing-readable-code/</id>
    <published>2017-01-05T07:21:11.000Z</published>
    <updated>2017-03-18T09:50:27.000Z</updated>
    <content type="html"><![CDATA[<p><img src="https://img.alicdn.com/tfs/TB18Nv3OpXXXXXWaXXXXXXXXXXX-900-500.jpg" alt="编写「可读」代码的实践"></p>
<p>编写<strong>可读</strong>的代码，对于以代码谋生的程序员而言，是一件极为重要的事。从某种角度来说，代码最重要的功能是<strong>能够被阅读</strong>，其次才是<strong>能够被正确执行</strong>。一段无法正确执行的代码，也许会使项目延期几天，但它造成的危害只是暂时和轻微的，毕竟这种代码无法通过测试并影响最终的产品；但是，一段能够正确执行，但缺乏条理、难以阅读的代码，它造成的危害却是深远和广泛的：这种代码会提高产品后续迭代和维护的成本，影响产品的稳定，破坏团队的团结（雾），除非我们花费数倍于编写这段代码的时间和精力，来消除它对项目造成的负面影响。</p>
<p>在最近的工作和业余生活中，我对「如何写出可读的代码」这个问题颇有一些具体的体会，不妨记录下来吧。</p>
<blockquote>
<p>JavaScript 是动态和弱类型的语言，使用起来比较「轻松随意」，在 IE6 时代，轻松随意的习惯确实不是什么大问题，反而能节省时间，提高出活儿的速度。但是，随着当下前端技术的快速发展，前端项目规模的不断膨胀，以往那种轻松随意的编码习惯，已经成为项目推进的一大阻力。</p>
<p>这篇文章讨论的是 ES6/7 代码，不仅因为 ES6/7 已经在大部分场合替代了 JavaScript，还因为 ES6/7 中的很多特性也能帮助我们改善代码的可读性。</p>
</blockquote>
<h2 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h2><p>变量命名是编写可读代码的基础。只有变量被赋予了一个合适的名字，才能表达出它在环境中的意义。</p>
<p>命名必须传递足够的信息，形如 <code>getData</code> 这样的函数命名就没能提供足够的信息，读者也完全无法猜测这个函数会做出些什么事情。而 <code>fetchUserInfoAsync</code> 也许就好很多，读者至少会猜测出，这个函数大约会远程地获取用户信息；而且因为它有一个 <code>Async</code> 后缀，读者甚至能猜出这个函数会返回一个 Promise 对象。</p>
<h3 id="命名的基础"><a href="#命名的基础" class="headerlink" title="命名的基础"></a>命名的基础</h3><p>通常，我们使用名词来命名对象，使用动词来命名函数。比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">monkey.eat(banana);  <span class="comment">// the money eats a banana</span></span><br><span class="line"><span class="keyword">const</span> apple = pick(tree);  <span class="comment">// pick an apple from the tree</span></span><br></pre></td></tr></table></figure>
<p>这两句代码与自然语言（右侧的注释）很接近，即使完全不了解编程的人也能看懂大概。</p>
<p>有时候，我们需要表示某种集合概念，比如数组或哈希对象。这时可以通过名词的复数形式来表示，比如用 <code>bananas</code> 表示一个数组，这个数组的每一项都是一个 <code>banana</code>。如果需要特别强调这种集合的形式，也可以加上 <code>List</code> 或 <code>Map</code> 后缀来显式表示出来，比如用 <code>bananaList</code> 表示数组。</p>
<blockquote>
<p>有些单词的复数形式和单数形式相同，有些不可数的单词没有复数形式（比如 data，information），这时我也会使用 <code>List</code> 等后缀来表示集合概念。</p>
</blockquote>
<h3 id="命名的上下文"><a href="#命名的上下文" class="headerlink" title="命名的上下文"></a>命名的上下文</h3><p>变量都是处在<strong>上下文</strong>（作用域）之内，变量的命名应与上下文相契合，同一个变量，在不同的上下文中，命名可以不同。举个例子，假设我们的程序需要管理一个动物园，程序的代码里有一个名为 <code>feedAnimals</code> 的函数来喂食动物园中的所有动物：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">feedAnimals</span>(<span class="params">food, animals</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 上下文中有 bananas, peaches, monkey 变量</span></span><br><span class="line">  <span class="keyword">const</span> banana = bananas.pop();</span><br><span class="line">  <span class="keyword">if</span> (banana) &#123;</span><br><span class="line">    monkey.eat(banana);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> peach = peaches.pop();</span><br><span class="line">    monkey.eat(peach);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>负责喂食动物的函数 <code>feedAnimals</code> 函数的主要逻辑就是：用各种食物把动物园里的各种动物喂饱。也许，每种动物能接受的食物种类不同，也许，我们需要根据各种食物的库存来决定每种动物最终分到的食物，总之在这个上下文中，我们需要关心食物的种类，所以传给 <code>money.eat</code> 方法的实参对象命名为 <code>banana</code> 或者 <code>peach</code>，代码很清楚地表达出了它的关键逻辑：「猴子要么吃香蕉，要么吃桃子（如果没有香蕉了）」。我们肯定不会这样写：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们不会这样写</span></span><br><span class="line"><span class="keyword">const</span> food = bananas.pop();</span><br><span class="line"><span class="keyword">if</span>(food) &#123;</span><br><span class="line">  monkey.eat(food);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> food = peaches.pop();</span><br><span class="line">  monkey.eat(food);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Monkey#eat</code> 方法内部就不一样了，这个方法很可能是下面这样的（假设 <code>eat</code> 是 <code>Monkey</code> 的基类 <code>Animal</code> 的方法）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  eat(food) &#123;</span><br><span class="line">    <span class="keyword">this</span>.hunger -= food.energy;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monkey</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123; </span><br><span class="line">  <span class="comment">// ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如代码所示，「吃」这个方法的核心逻辑就是根据食物的能量来减少动物（猴子）自身的饥饿度，至于究竟是吃了桃子还是香蕉，我们不关心，所以在这个方法的上下文中，我们直接将表示食物的函数形参命名为 <code>food</code>。</p>
<p>想象一下，假设我们正在编写某个函数，即将写一段公用逻辑，我们会选择去写一个新的功能函数来执行这段公用逻辑。在编写这个新的功能函数过程中，往往会受到之前那个函数的影响，变量的命名也是按照其在之前那个函数中的意义来的。虽然写的时候不感觉有什么阻碍，但是读者阅读的单元是函数（他并不了解之前哪个函数），会被深深地困扰。</p>
<h3 id="严格遵循一种命名规范的收益"><a href="#严格遵循一种命名规范的收益" class="headerlink" title="严格遵循一种命名规范的收益"></a>严格遵循一种命名规范的收益</h3><p>如果你能够时刻按照某种严格的规则来命名变量和函数，还能带来一个潜在的好处，那就是你再也不用<strong>记住</strong>哪些之前命名过（甚至其他人命名过）的变量或函数了。特定上下文中的特定含义只有一种命名方式，也就是说，只有一个名字。比如，「获取用户信息」这个概念，就叫作 <code>fetchUserInfomation</code>，不管是在早晨还是傍晚，不管你是在公司还是家中，你都会将它命名为 <code>fetchUserInfomation</code> 而不是 <code>getUserData</code>。那么当你再次需要使用这个变量时，你根本不用翻阅之前的代码或依赖 IDE 的代码提示功能，你只需要再<strong>命名</strong>一下「获取用户信息」这个概念，就可以得到 <code>fetchUserInfomation</code> 了，是不是很酷？</p>
<h2 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h2><p>分支是代码里最常见的结构，一段结构清晰的代码单元应当是像二叉树一样，呈现下面的结构。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition1) &#123;</span><br><span class="line">  <span class="keyword">if</span> (condition2) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (condition3) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种优美的结构能够帮助我们在大脑中迅速绘制一张图，便于我们在脑海中模拟代码的执行。但是，我们大多数人都不会遵循上面这样的结构来写分支代码。以下是一些常见的，在我看来可读性比较差的分支语句的写法：</p>
<h3 id="不好的做法：在分支中-return"><a href="#不好的做法：在分支中-return" class="headerlink" title="不好的做法：在分支中 return"></a>不好的做法：在分支中 return</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="comment">// 分支1的逻辑</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 分支2的逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种分支代码很常见，而且往往分支 2 的逻辑是先写的，也是函数的主要逻辑，分支 1 是后来对函数进行修补的过程中产生的。这种分支代码有一个很致命的问题，那就是，如果读者没有注意到分支1中的 <code>return</code>（我敢保证，在使用 IDE 把代码折叠起来后，没人能第一时间注意到这个 <code>return</code>），就不会意识到后面一段代码（分支 2）是有可能不会执行的。我的建议是，把分支 2 放到一个 <code>else</code> 语句块中，代码就会清晰可读很多：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="comment">// 分支 1 的逻辑</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 分支 2 的逻辑</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果某个分支是空的，我也倾向于留下一个空行，这个空行明确地告诉代码的读者，如果走到这个 <code>else</code>，我什么都不会做。如果你不告诉读者，读者就会产生怀疑，并尝试自己去弄明白。</p>
</blockquote>
<h3 id="不好的做法：多个条件复合"><a href="#不好的做法：多个条件复合" class="headerlink" title="不好的做法：多个条件复合"></a>不好的做法：多个条件复合</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition1 &amp;&amp; condition2 &amp;&amp; condition3) &#123;</span><br><span class="line">  <span class="comment">// 分支1：做一些事情</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 分支2：其他的事情</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种代码也很常见：在若干条件同时满足（或有任一满足）的时候做一些主要的事情（分支1，也就是函数的主逻辑），否则就做一些次要的事情（分支2，比如抛异常，输出日志等）。虽然写代码的人知道什么是主要的事情，什么是次要的事情，但是代码的读者并不知道。读者遇到这种代码，就会产生困惑：分支2到底对应了什么条件？</p>
<p>在上面这段代码中，三种条件只要任意一个不成立就会执行到分支 2，但这其实<strong>本质</strong>上是多个分支：1)条件 1 不满足，2)条件 1 满足而条件 2 不满足，3)条件 1 和 2 都满足而条件 3 不满足。如果我们笼统地使用同一段代码来处理多个分支，那么就会增加阅读者阅读分支 2 时的负担（需要考虑多个情况）。更可怕的是，如果后面需要增加一些额外的逻辑（比如，在条件 1 成立且条件 2 不成立的时候多输出一条日志），整个 <code>if-else</code> 都可能需要重构。</p>
<p>对这种场景，我通常这样写：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition1) &#123;</span><br><span class="line">  <span class="keyword">if</span> (condition2) &#123;</span><br><span class="line">    <span class="comment">// 分支1：做一些事情</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 分支2：其他的事情</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 分支3：其他的事情</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即使分支 2 和分支 3 是完全一样的，我也认为有必要将其分开。虽然多了几行代码，收益却是很客观的。</p>
<blockquote>
<p>万事非绝对。对于一种情况，我不反对将多个条件复合起来，那就是当被复合的多个条件联系十分紧密的时候，比如 <code>if(foo &amp;&amp; foo.bar)</code>。</p>
</blockquote>
<h3 id="不好的做法：使用分支改变环境"><a href="#不好的做法：使用分支改变环境" class="headerlink" title="不好的做法：使用分支改变环境"></a>不好的做法：使用分支改变环境</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = someValue;</span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">  foo = doSomethingTofoo(foo);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继续使用 foo 做一些事情</span></span><br></pre></td></tr></table></figure>
<p>这种风格的代码很容易出现在那些屡经修补的代码文件中，很可能一开始是没有这个 <code>if</code> 代码块的，后来发现了一个 bug，于是加上了这个 <code>if</code> 代码块，在某些条件下对 <code>foo</code> 做一些特殊的处理。如果你希望项目在迭代过程中，风险越积越高，那么这个习惯绝对算得上「最佳实践」了。</p>
<p>事实上，这样的「补丁」积累起来，很快就会摧毁代码的可读性和可维护性。怎么说呢？当我们在写下上面这段代码中的 <code>if</code> 分支以试图修复 bug 的时候，我们内心存在这样一个假设：我们是<strong>知道</strong>程序在执行到这一行时，<code>foo</code> 什么样子的；但事实是，我们根本<strong>不知道</strong>，因为在这一行之前，<code>foo</code> 很可能已经被另一个人所写的尝试修复另一个 bug 的另一个 if 分支所篡改了。所以，当代码出现问题的时候，我们应当完整地审视一段独立的功能代码（通常是一个函数），并且多花一点时间来修复他，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = condition ? doSomethingToFoo(someValue) : someValue;</span><br></pre></td></tr></table></figure>
<p>我们看到，很多风险都是在项目快速迭代的过程中积累下来的。为了「快速」迭代，在添加功能代码的时候，我们有时候连函数这个最小单元的都不去了解，仅仅着眼于自己插入的那几行，希望在那几行中解决/hack掉所有问题，这是十分不可取的。</p>
<p>我认为，项目的迭代再快，其代码质量和可读性都应当有一个底线。这个底线是，当我们在修改代码的时候，应当<strong>完整了解当前修改的这个函数的逻辑</strong>，然后<strong>修改这个函数</strong>，以达到添加功能的目的。注意，这里的「修改一个函数」和「在函数某个位置添加几行代码」是不同的，在「修改一个函数」的时候，为了保证函数功能独立，逻辑清晰，不应该畏惧在这个函数的任意位置增删代码。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数只做一件事情"><a href="#函数只做一件事情" class="headerlink" title="函数只做一件事情"></a>函数只做一件事情</h3><p>有时，我们会自作聪明地写出一些很「通用」的函数。比如，我们有可能写出下面这样一个获取用户信息的函数 <code>fetchUserInfo</code>：其逻辑是：</p>
<p>1) 当传入的参数是用户ID（字符串）时，返回单个用户数据；<br>2) 而传入的参数是用户ID的列表（数组）时，返回一个数组，其中的每一项是一个用户的数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchUserInfo</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isSingle = <span class="keyword">typeof</span> idList === <span class="string">'string'</span>;</span><br><span class="line">  <span class="keyword">const</span> idList = isSingle ? [id] : id;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> request.post(<span class="string">'/api/userInfo'</span>, &#123;idList&#125;);</span><br><span class="line">  <span class="keyword">return</span> isSingle ? result[<span class="number">0</span>] : result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以这样调用</span></span><br><span class="line"><span class="keyword">const</span> userList = <span class="keyword">await</span> fetchUserInfo([<span class="string">'1011'</span>, <span class="string">'1013'</span>]);</span><br><span class="line"><span class="comment">// 也可以这样调用</span></span><br><span class="line"><span class="keyword">const</span> user = <span class="keyword">await</span> fetchUserInfo(<span class="string">'1017'</span>);</span><br></pre></td></tr></table></figure>
<p>这个函数能够做两件事：1)获取多个用户的数据列表；2)获取单个用户的数据。在项目的其他地方调用 <code>fetchUserInfo</code> 函数时，也许我们确实能感到「方便」了一些。但是，代码的读者一定不会有相同的体会，当读者在某处读到 <code>fetchUserInfo([&#39;1011&#39;, &#39;1013&#39;])</code> 这句调用的代码时，他就会立刻对 <code>fetchUserInfo</code> 产生「第一印象」：这个函数需要传入用户ID数组；当他读到另外一种调用形式时，他一定会怀疑自己之前是不是眼睛花了。读者并不了解背后的「潜规则」，除非规则是预先设计好并且及时地更新到文档中。总之，我们绝不该一时兴起就写出上面这种函数。</p>
<p>遵循<strong>一个函数只做一件事</strong>的原则，我们可以将上述功能拆成两个函数<code>fetchMultipleUser</code> 和 <code>fetchSingleUser</code> 来实现。在需要获取用户数据时，只需要选择调用其中的一个函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchMultipleUser</span>(<span class="params">idList</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> request.post(<span class="string">'/api/users/'</span>, &#123;idList&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchSingleUser</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> fetchMultipleUser([id])[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述改良不仅改善了代码的可读性，也改善了可维护性。举个例子，假设随着项目的迭代，获取单一用户信息的需求不再存在了。</p>
<ul>
<li>如果是改良前，我们会删掉那些「传入单个用户ID来调用 <code>fetchUserInfo</code>」的代码，同时保留剩下的那些「传入多个用户ID调用 <code>fetchUserInfo</code>」的代码， 但是 <code>fetchUserInfo</code> 函数几乎一定不会被更改。这样，函数内部 <code>isSingle</code> 为 <code>true</code> 的分支，就留在了代码中，成了永远都不会执行的「脏代码」，谁愿意看到自己的项目中充斥着永远不会执行的代码呢？</li>
<li>对于改良后的代码，我们（也许借助IDE）能够轻松检测到 <code>fetchSingleUser</code> 已经不会被调用了，然后放心大胆地直接删掉这个函数。</li>
</ul>
<p>那么，如何界定某个函数做的是不是<strong>一件事情</strong>？我的经验是这样：如果一个函数的参数仅仅包含<strong>输入数据（交给函数处理的数据）</strong>，而没有混杂或暗含有<strong>指令</strong>（以某种约定的方式告诉函数该怎么处理数据），那么函数所做的应当就是<strong>一件事情</strong>。比如说，改良前的 <code>fetchUserInfo</code> 函数的参数是「多个用户的ID数组<strong>或</strong>单个用户的ID」，这个「或」字其实就暗含了某种指令。</p>
<h3 id="函数应适当地处理异常"><a href="#函数应适当地处理异常" class="headerlink" title="函数应适当地处理异常"></a>函数应适当地处理异常</h3><p>有时候，我们会陷入一种很不好的习惯中，那就是，总是去尝试写出永远不会报错的函数。我们会给参数配上默认值，在很多地方使用 <code>||</code> 或者 <code>&amp;&amp;</code> 来避免代码运行出错，仿佛如果你的函数报错会成为某种耻辱似的。而且，当我们尝试去修复一个运行时报错的函数时，我们往往倾向于在报错的那一行添加一些兼容逻辑来避免报错。</p>
<p>举个例子，假设我们需要编写一个获取用户详情的函数，它要返回一个完整的用户信息对象：不仅包含ID，名字等基本信息，也包含诸如「收藏的书籍」等通过额外接口返回的信息。这些额外的接口也许不太稳定：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getUserDetail</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> user = <span class="keyword">await</span> fetchSingleUser(id);</span><br><span class="line">  user.favoriteBooks = (<span class="keyword">await</span> fetchUserFavorits(id)).books;</span><br><span class="line">  <span class="comment">// 上面这一行报错了：Can not read property 'books' of undefined.</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设 <code>fetchUserFavorites</code> 会时不时地返回 <code>undefined</code>，那么读取其 <code>books</code> 属性自然就会报错。为了修复该问题，我们很可能会这样做：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> favorites = <span class="keyword">await</span> fetchUserFavorits(id);</span><br><span class="line">user.favoriteBooks = favorites &amp;&amp; favorites.books;</span><br><span class="line"><span class="comment">// 这下不会报错了</span></span><br></pre></td></tr></table></figure>
<p>这样做看似解决了问题：的确，<code>getUserDetail</code> 不会再报错了，但同时埋下了更深的隐患。</p>
<p>当 <code>fetchUserFavorites</code> 返回 <code>undefined</code> 时，程序已经处于一种异常状态了，我们没有任何理由放任程序继续运行下去。试想，如果后面的某个时刻（比如用户点击「我收藏的书」选项卡），程序试图遍历 <code>user.favoriteBooks</code> 属性（它被赋值成了<code>undefined</code>），那时也会报错，而且那时排查起来会更加困难。</p>
<p>如何处理上述的情况呢？我认为，如果被我们依赖的 <code>fetchUserFavorits</code> 属于当前的项目，那么 <code>getUserDetail</code> 对此报错真的没什么责任，因为 <code>fetchUserFavorits</code> 就不应该返回 <code>undefined</code>，我们应该去修复 <code>fetchUserFavorits</code>，任务失败时显式地告知出来，或者直接抛出异常。同时，<code>getUserDetail</code> 稍作修改：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情况1：显式告知，此时应认为获取不到收藏数据不算致命的错误</span></span><br><span class="line"><span class="keyword">const</span> result = <span class="keyword">await</span> fetchUserFavorits(id);</span><br><span class="line"><span class="keyword">if</span>(result.success) &#123;</span><br><span class="line">  user.favoriteBooks = result.data.books;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  user.favoriteBooks = []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况2：直接抛出异常</span></span><br><span class="line">user.favoriteBooks = (<span class="keyword">await</span> fetchUserFavorits(id)).books;</span><br><span class="line"><span class="comment">// 这时 `getUserDetail` 不需要改动，任由异常沿着调用栈向上冒泡</span></span><br></pre></td></tr></table></figure>
<p>那么如果 <code>fetchUserFavorits</code> 不在当前项目中，而是依赖的外部模块呢？我认为，这时你就该为选择了这样一个不可靠的模块负责，在 <code>getUserDetail</code> 中增加一些「擦屁股」代码，来避免你的项目的<strong>其他部分</strong>受到侵害。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> favorites = <span class="keyword">await</span> fetchUserFavorits(id);</span><br><span class="line"><span class="keyword">if</span>(favorites) &#123;</span><br><span class="line">  user.favoriteBooks = favorites.books;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'获取用户收藏失败'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="控制函数的副作用"><a href="#控制函数的副作用" class="headerlink" title="控制函数的副作用"></a>控制函数的副作用</h3><p>无副作用的函数，是<strong>不依赖上下文</strong>，也<strong>不改变上下文</strong>的函数。长久依赖，我们已经习惯了去写「有副作用的函数」，毕竟 JavaScript 需要通过副作用去操作环境的 API 完成任务。这就导致了，很多原本可以用纯粹的、无副作用的函数完成任务的场合，我们也会不自觉地采取有副作用的方式。</p>
<p>虽然看上去有点可笑，但我们有时候就是会写出下面这样的代码！</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getUserDetail</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> user = <span class="keyword">await</span> fetchSingleUserInfo(id);</span><br><span class="line">  <span class="keyword">await</span> addFavoritesToUser(user);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">addFavoritesToUser</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> fetchUserFavorits(user.id);</span><br><span class="line">  user.favoriteBooks = result.books;</span><br><span class="line">  user.favoriteSongs = result.songs;</span><br><span class="line">  user.isMusicFan = result.songs.length &gt; <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面，<code>addFavoritesToUser</code> 函数就是一个「有副作用」的函数，它改变了 <code>users</code>，给它新增了几个个字段。问题在于，仅仅阅读 <code>getUserData</code> 函数的代码完全无法知道，user 会发生怎样的改变。</p>
<p>一个无副作用的函数应该是这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getUserDetail</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> user = <span class="keyword">await</span> fetchSingleUserInfo(id);</span><br><span class="line">  <span class="keyword">const</span> &#123;books, songs, isMusicFan&#125; = <span class="keyword">await</span> getUserFavorites(id);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(user, &#123;books, songs, isMusicFan&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getUserFavorites</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;books, songs&#125; = <span class="keyword">await</span> fetchUserFavorits(user.id);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    books, songs, isMusicFan: result.songs.length &gt; <span class="number">100</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>难道这不是理所当然的形式吗？</p>
<h3 id="非侵入性地改造函数"><a href="#非侵入性地改造函数" class="headerlink" title="非侵入性地改造函数"></a>非侵入性地改造函数</h3><p>函数是一段独立和内聚的逻辑。在产品迭代的过程中，我们有时候不得不去修改函数的逻辑，为其添加一些新特性。之前我们也说过，一个函数只应做一件事，如果我们需要添加的新特性，与原先函数中的逻辑没有什么联系，那么决定是否通过<strong>改造这个函数</strong>来添加新功能，应当格外谨慎。</p>
<p>仍然用「向服务器查询用户数据」为例，假设我们有如下这样一个函数（为了让它看上去复杂一些，假设我们使用了一个更基本的 <code>request</code> 库）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchUserInfo = (userId, callback) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> param = &#123;</span><br><span class="line">    url: <span class="string">'/api/user'</span>,</span><br><span class="line">    method: <span class="string">'post'</span>,</span><br><span class="line">    payload: &#123;id: userId&#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  request(param, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在有了一个新需求：为 <code>fetchUserInfo</code> 函数增加一道本地缓存，如果第二次请求同一个 userId 的用户信息，就不再重新向服务器发起请求，而直接以第一次请求得到的数据返回。</p>
<p>按照如下快捷简单的解决方案，改造这个函数只需要五分钟时间：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userInfoMap = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> fetchUserInfo = (userId, callback) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (userInfoMap[userId]) &#123;            <span class="comment">// 新增代码</span></span><br><span class="line">    callback(userInfoMap[userId]);    <span class="comment">// 新增代码</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;                              <span class="comment">// 新增代码</span></span><br><span class="line">    <span class="keyword">const</span> param = &#123;</span><br><span class="line">      <span class="comment">// ... 参数</span></span><br><span class="line">    &#125;;</span><br><span class="line">    request(param, (result) =&gt; &#123;</span><br><span class="line">      userInfoMap[userId] = result;   <span class="comment">// 新增代码</span></span><br><span class="line">      callback(result);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不知你有没有发现，经此改造，这个函数的可读性已经明显降低了。没有缓存机制前，函数很清晰，一眼就能明白，加上新增的几行代码，已经不能一眼就看明白了。</p>
<p>实际上，「缓存」和「获取用户数据」完全是独立的两件事。我提出的方案是，编写一个通用的缓存包装函数（类似装饰器）<code>memorizeThunk</code>，对 <code>fetchUserInfo</code> 进行包装，产出一个新的具有缓存功能的 <code>fetchUserInfoCache</code>，在不破坏原有函数可读性的基础上，提供缓存功能。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> memorizeThunk = (func, reducer) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> cache = &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> (...args, callback) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> key = reducer(...args);</span><br><span class="line">    <span class="keyword">if</span> (cache[key]) &#123;</span><br><span class="line">      callback(...cache[key]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      func(...args, (...result) =&gt; &#123;</span><br><span class="line">        cache[key] = result;</span><br><span class="line">        callback(...result);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> fetchUserInfo = (userInfo, callback) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 原来的逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> fetchUserInfoCache = memorize(fetchUserInfo, (userId) =&gt; userId);</span><br></pre></td></tr></table></figure>
<p>也许实现这个方案需要十五分钟，但是试想一下，如果将来的某个时候，我们又不需要缓存功能了（或者需要提供一个开关来打开/关闭缓存功能），修改代码的负担是怎样的？第一种简单方案，我们需要精准（提心吊胆地）地删掉新增的若干行代码，而我提出的这种方案，是以函数为单位增删的，负担要轻很多，不是吗？</p>
<h2 id="类的结构"><a href="#类的结构" class="headerlink" title="类的结构"></a>类的结构</h2><h3 id="避免滥用成员函数"><a href="#避免滥用成员函数" class="headerlink" title="避免滥用成员函数"></a>避免滥用成员函数</h3><p>JavaScript 中的类，是 ES6 才有的概念，此前是通过函数和原型链来模拟的。在编写类的时候，我们常常忍不住地写很多没必要的成员函数：当类的某个成员函数的内部逻辑有点复杂了，行数有点多了之后，我们往往会将其中一部分「独立」逻辑拆分出来，实现为类的另一个成员函数。比如，假设我们编写某个 React 组件来显示用户列表，用户列表的形式是<strong>每两个用户为一行</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserList</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  chunk = (users) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 将 ['张三', '李四', '王二', '麻子'] 转化为 [['张三', '李四'], ['王二', '麻子']]</span></span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">const</span> chunks = <span class="keyword">this</span>.chunk(<span class="keyword">this</span>.props.users);</span><br><span class="line">    <span class="comment">// 每两个用户为一行</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        &#123;chunks.map(users=&gt;</span><br><span class="line">          <span class="tag">&lt;<span class="name">row</span>&gt;</span></span><br><span class="line">            &#123;users.map(user =&gt; </span><br><span class="line">              <span class="tag">&lt;<span class="name">col</span>&gt;</span><span class="tag">&lt;<span class="name">UserItem</span> <span class="attr">user</span>=<span class="string">&#123;user&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">col</span>&gt;</span></span><br><span class="line">            )&#125;</span><br><span class="line">          <span class="tag">&lt;/<span class="name">row</span>&gt;</span></span><br><span class="line">        )&#125;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>如上述代码所示，<code>UserList</code> 组件按照「两个一行」的方式来显示用户列表，所以需要先将用户列表进行组合。进行组合的工作这件事情看上去是比较独立的，所以我们往往会将 <code>chunk</code> 实现成 <code>UserList</code> 的一个成员函数，在 render 中调用它。</p>
<p>我认为这样做并不可取，因为 chunk 只会被 render 所调用，仅仅服务于 render。阅读这个类源码的时候，读者其实只需要在 render 中去了解 chunk 函数就够了。然而 chunk 以成员函数的形式出现，扩大了它的可用范围，提前把自己曝光给了读者，反而会造成干扰。读者阅读源码，首先就是将代码折叠起来，然后他看到的是这样的景象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserList</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentDidMount() &#123;...&#125;</span><br><span class="line">  componentWillUnmount() &#123;...&#125;</span><br><span class="line">  chunk() &#123;...&#125;    <span class="comment">// 读者的内心独白：这是什么鬼？</span></span><br><span class="line">  render() &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>熟悉 React 的同学对组件中出现一个不熟悉的方法多半会感到困惑。不管怎么说，读者肯定会首先去浏览一遍这些成员函数，但是阅读 <code>chunk</code> 函数带给读者的信息基本是零，反而还会干扰读者的思路，因为读者现在还不知道用户列表需要以「每两个一行」的方式呈现。所以我认为，<code>chunk</code> 函数绝对应该定义在 <code>render</code> 中，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">render()&#123;</span><br><span class="line">  <span class="keyword">const</span> chunk = (users) =&gt; ...</span><br><span class="line">  const chunks = <span class="keyword">this</span>.chunk(<span class="keyword">this</span>.props.users);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这样虽然函数的行数可能会比较多，但将代码折叠起来后，函数的逻辑则会非常清楚。而且，<code>chunk</code> 函数曝光在读者眼中的时机是非常正确的，那就是，在它即将被调用的地方。实际上，在「计算函数的代码行数」这个问题上，我会把内部定义的函数视为一行，因为函数对读者可以是黑盒，它的负担只有一行。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>伟大的文学作品都是建立在废纸堆上的，不断删改作品的过程有助于写作者培养良好的「语感」。当然，代码毕竟不是艺术品，程序员没有精力也不一定有必要像作家一样反复<strong>打磨</strong>自己的代码/作品。但是，如果我们能够在编写代码时稍稍多考虑一下实现的合理性，或者在添加新功能的时候稍稍回顾一下之前的实现，我们就能够培养出一些「代码语感」。这种「代码语感」会非常有助于我们写出高质量的可读的代码。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="https://img.alicdn.com/tfs/TB18Nv3OpXXXXXWaXXXXXXXXXXX-900-500.jpg" alt="编写「可读」代码的实践"></p>
<p>编写<strong>可读</strong>的代码，对于以代码谋生的]]>
    </summary>
    
      <category term="JavaScript" scheme="http://taobaofed.org/tags/JavaScript/"/>
    
      <category term="可读性" scheme="http://taobaofed.org/tags/%E5%8F%AF%E8%AF%BB%E6%80%A7/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[QCon San Francisco 2016 前端参会总结]]></title>
    <link href="http://taobaofed.org/blog/2016/12/20/qconsf-2016/"/>
    <id>http://taobaofed.org/blog/2016/12/20/qconsf-2016/</id>
    <published>2016-12-20T12:10:14.000Z</published>
    <updated>2017-03-18T09:50:27.000Z</updated>
    <content type="html"><![CDATA[<p><img src="https://gw.alicdn.com/tps/TB1pOFzOVXXXXbhaXXXXXXXXXXX-900-500.jpg" alt="QCon San Francisco 2016 前端参会总结"></p>
<p>11 月初有幸参加了在美国旧金山举行的 Qcon 会议，会议之余在小伙伴们的各路关系中拜访了一些美国的科技公司。此行受益颇多，这里谈一下自己的所见、所闻以及自己的感受。</p>
<h2 id="会议内容"><a href="#会议内容" class="headerlink" title="会议内容"></a>会议内容</h2><p>会议内容覆盖了前端、设计、容器、微服务、devops、JAVA 等等，内容非常的丰富，这里选择几个前端相关的场做下分享。</p>
<p><img src="https://gw.alicdn.com/tps/TB1F5cMOFXXXXb3XVXXXXXXXXXX-1440-1920.jpg_790x10000.jpg" alt=""></p>
<h3 id="Webpack-The-One-Build-Step-To-Rule-Them-All"><a href="#Webpack-The-One-Build-Step-To-Rule-Them-All" class="headerlink" title="Webpack: The One Build Step To Rule Them All"></a>Webpack: The One Build Step To Rule Them All</h3><p>webpack 自诞生以来席卷全球，为我们的开发带来了无限可能，相信很多童鞋都在使用 webpack，webpack is great!</p>
<p>来自 webpack 核心团队的 <a href="https://twitter.com/thelarkinn" target="_blank" rel="external">@thelarkinn</a> 介绍了 webpack 的基本概念及使用方法，最后介绍了一些 webpack 2.0 的计划和未来的一些方向。</p>
<ol>
<li>webpack 的几个核心的概念：entry、output、loader、plugin：<ul>
<li>Entry 就是我们的源码入口文件，可以是一个，也可以是多个；</li>
<li>Output 是源码编译后的输出 bundle 文件，它根据你定义的 Entry 文件进行生成；</li>
<li>Loader 可以说是 webpack 最屌的地方了，它定义了你的文件通过什么样的规则进行转换，它目前已经拥有 N 种 loader，市场上你只要见过的类型它基本都支持。分享者给了一张目前的 Loader 图，当时也是被震惊到了：<br><img src="https://gw.alicdn.com/tps/TB1rtEIOFXXXXacaXXXXXXXXXXX-892-509.png" alt=""></li>
<li>Plugins 是 webpack 另一个易用的设计，你可以比较方便的开发使用自己的插件以实现特殊的效果。</li>
</ul>
</li>
<li>webpack 的一些主要功能：<ul>
<li>本地服务；</li>
<li>模块热替换；</li>
<li>模块懒加载；</li>
<li>Source Maps；</li>
</ul>
</li>
<li>webpack2 的新特性：<br> <img src="https://gw.alicdn.com/tps/TB15TwzOFXXXXcvaXXXXXXXXXXX-894-513.png" alt=""><ul>
<li>首先是它将会原生的支持 ES2015，这意味着未来我们无需先将代码转换为 CommonJS 格式了，同时也为 Tree Shaking 的优化提供了基础。</li>
<li>Tree Shaking 可以帮助我们移除未使用到的代码，以使我们的代码文件更小，这在寸土寸金的无线时代可能更实在。但是，Tree Shaking 能否发挥它的最大作用，还是取决于我们的编码习惯、规范，这也是我们需要去思考和改进的地方。<strong>特别对于公共的组件、模块，我们更需要关注其质量、规范。</strong>开发者关心的不应该只是代码是否能跑起来，同时更需要关心如何跑的更好。</li>
<li>其它的在编译速度、语法设计、配置校验等方面也做了一些改进。</li>
</ul>
</li>
<li>webpack 的未来：<br> <img src="https://gw.alicdn.com/tps/TB1xxwuOFXXXXbnapXXXXXXXXXX-897-518.png" alt=""><ul>
<li>webpack 在未来还会针对 HTTP2 的场景做特殊的优化支持，也会与浏览器厂商合作，在 DevTools 上提供更好的体验。另外还提到了会利用 Chrome 的 timeline 去做一些智能调整配置加载的事情，至于具体是什么，尚未查到资料，目前应该仅仅是 idea 阶段。</li>
</ul>
</li>
</ol>
<p>整场分享其实比较初级，基本是手把手教你用 webpack，帮你理清了 webpack 的一些思路，最后谈到了 webpack2 以及未来的一些计划，缺乏真正的实战分享。但 webpack 给我们带来的技术革新是巨大的，或许有一天，当所有的语言都可以通过 webpack 编译成 JavaScript，而 JavaScript 又可以运行在任意的平台上，那将会是一个怎样的世界？……</p>
<h3 id="Building-Robust-Web-Applications-With-RxJS"><a href="#Building-Robust-Web-Applications-With-RxJS" class="headerlink" title="Building Robust Web Applications With RxJS"></a>Building Robust Web Applications With RxJS</h3><blockquote>
<p>RxJS is an API for asynchronous programming<br>with observable streams。</p>
</blockquote>
<p>RxJS 5 的带头大哥、来自 Netflix 的 <a href="https://twitter.com/benlesh" target="_blank" rel="external">@BenLesh</a> 通过一个例子分享了 RxJS5 的一些新特性。</p>
<ul>
<li>RxJS is “Lodash for events”</li>
<li>RxJS is Observables</li>
</ul>
<p>在 RxJS 的世界里，一切都是流，你可以把任何的东西当成流，通过对这些流的创建、合并、过滤来解耦、分离自己的业务逻辑。</p>
<p>@BenLesh 通过一个 WebSocket 的例子讲解了 RxJS 的一些基本用法以及新的 RxJS5 带来了哪些新的改变，总体上其实就是在对 RxJS5 做一些宣传工作。</p>
<p>大家可以从这里下载 @BenLesh 演示的 Demo，自己亲自试一下上：<a href="https://github.com/blesh/robust-websocket-talk" target="_blank" rel="external">https://github.com/blesh/robust-websocket-talk</a></p>
<p>RxJS 巧妙的利用了观察者模式将一些状态、点击、事件抽象为一系列的流，通过对他们的过滤、组合来实现我们的业务逻辑，对于我们未来的一些实时互动产品，搭配这样的事件流，或许能够可以让我们的代码更清晰、相互之间更解耦。</p>
<h3 id="The-Strengths-of-Ember-Angular-amp-React-Explored"><a href="#The-Strengths-of-Ember-Angular-amp-React-Explored" class="headerlink" title="The Strengths of Ember, Angular &amp; React Explored"></a>The Strengths of Ember, Angular &amp; React Explored</h3><p>来自 Ember 团队的 @larasm、Angular 团队的 @robwormald（Google）、React 团队的 @leeb（Facebook） 分享了各自的库/框架，然后主持人跟三位分享者进行了一些互动。</p>
<p>先简单介绍一下这三个东东：</p>
<ol>
<li>React：<ul>
<li>React 并不是 MVC，它是基于 Component 的 UI；</li>
<li>React 不是为了构建 Web App，它是为了构建 UI，你可以把它类比为 DOM；<br>  <img src="https://gw.alicdn.com/tps/TB1GtU0OFXXXXXIXFXXXXXXXXXX-1072-334.jpg_790x10000.jpg" alt=""></li>
<li>你可以整个应用都使用 React，也可以像 Facebook 一样在部分模块里使用 React，你可以与其它任何的 framework 一起使用 React。<br><img src="https://gw.alicdn.com/tps/TB1XFZGOFXXXXbjXVXXXXXXXXXX-894-517.png" alt=""></li>
</ul>
</li>
<li>AngularJS： <ul>
<li>AngularJS 的组件由三部分组成：HTML、CSS、Class；<br><img src="https://gw.alicdn.com/tps/TB1OmIDOFXXXXbBaXXXXXXXXXXX-893-519.png" alt=""></li>
<li>它的模板就是 HTML，通过属性和事件来定义组件的行为；</li>
<li>它提供了 router 功能；</li>
<li>AngularJS 可以运行在任何的环境、平台；</li>
<li>因为 TypeScript 的类型检测、可读性、易用性以及强大的工具支持，AngularJS 使用 TypeScript；</li>
<li>AngularJS 2 通过预编译提升了不少性能；</li>
</ul>
</li>
<li>ember：<ul>
<li>ember 是为构建巨型应用而生的，而巨型应用具备几个条件：多人创建，长期维护，升级而不是重写；</li>
<li>ember 几乎包含了你可能用到的、在其它框架/库里看到的 NB 的特性，例如路由、组件、DOM diffing、单向/双向绑定、模板、服务端渲染等等……</li>
<li>ember 是一个大型的框架，它在为社区做出巨大的贡献，也在推进着社区技术的发展；</li>
<li>ember 发展了 5 年，有成熟的、完善的生态圈，Yahoo、LinkedIn 等公司都在为其贡献代码，目前已经有 3000+ 的插件，覆盖各种各样的交互场景；</li>
<li>ember 拥有最专业、最好用的工具集，可以帮助你更快、更好的入门、编码；</li>
</ul>
</li>
</ol>
<p>最后，主持人与三位分享者进行了一场小的讨论会。</p>
<p><img src="https://gw.alicdn.com/tps/TB1RSQnOFXXXXcuaFXXXXXXXXXX-896-508.png" alt=""></p>
<p>React 一再说明它不是 framework，而是一个 library，非常的轻量级，入门也比较简单，需要了解一下 babel，最主要的是 <a href="https://facebook.github.io/react/docs/thinking-in-react.html" target="_blank" rel="external">Think in React</a>！React 对于 Virtual DOM 的抽象及使用，使得它可以更好的应用在各个环境、语言层面，为各个平台提供了无限可能。React 有强大的社区支持，虽然 React 自身并无法完全覆盖你的任何需求、功能，但是社区里有大量的 library 可以配合 React 一起来使用，以满足你的任何需求和功能。</p>
<p>AngularJS 相对来说功能比 React 全，是一个轻量级的 framework，经历了从 1 到 2 的升华，现在逐渐找到了自己的核心并稳定下来。相比 React，它提供了更多的功能以及更完善的体系，你可以在不借助任何外部 library 的情况下基本满足所有的需求和功能，当然，你也同样可以使用外部 library 来弥补 AngularJS 的功能。AngularJS 跟 React 走着完全不同的两个路子，但是理念和思路却在相互的借鉴和学习。使用 AngularJS 2 你需要首先了解 TypeScript，然后根据其文档，理解 Component 等概念，学习成本稍高。</p>
<p>ember 相对于前两个，基本上就是巨无霸，所有你能想到的功能它都能包含，定位也是大型应用。相较于 AngularJS 被吐槽的升级问题，ember 有严格的升级步骤和规范，配合 ember 强大的 cli 工具及易读好用的文档，你可以轻松的入门、使用 ember。</p>
<p>总的来说，每一个 framework/library 都在进化，相互的学习、借鉴，都在不断的提升自身的质量和技术，也期望未来我们能够看到更精彩的一些 idea，路走对了就不怕远！没有最好的框架/库，只有更合适的。</p>
<h2 id="科技公司"><a href="#科技公司" class="headerlink" title="科技公司"></a>科技公司</h2><p>托各位牛逼的小伙们的福，在美期间拜访了一些不错的互联网公司，学到了一些不一样的东西，这里谈一下自己的感受。</p>
<blockquote>
<p>由于接待的人的岗位或者资历不同，我们从中了解到的内容跟真实的情况可能存在差异。</p>
</blockquote>
<h3 id="Yelp"><a href="#Yelp" class="headerlink" title="Yelp"></a>Yelp</h3><p>Yelp 是一个美国版的大众点评，但用下来你会发现这个大众点评完全不在一个量级，所以拜访之前以为这公司应该比较小，但其实蛮大的，在 downtown 能拥有十多层的办公楼也是够 NB 的。</p>
<p>Yelp 的办公室跟普通的办公室区别不大，每层会有个小厨房（里边有免费的饮料、小零食等），另外每几排办公桌的墙壁上会有一台电视，据带头大哥说平时无甚鸟用，偶尔会被一些同事连上放一下恶搞的照片、视频之类的。另外呢，员工可申请可升降的桌子用于办公（再也不用自己搞个高架子了……）</p>
<p>Yelp 的工作比较轻松，施行弹性工作制，公司提倡八小时工作制，我们是大概七点左右去的，基本上比较少的人在“加班”。据带头大哥说，有人竟然会花上两周时间去解决一个 bug！虽然这个问题可能一两个小时就可以通过其他方式修复，但依然坚持要找到问题的原因去修复，想想也是醉了……（刨根问底固然好，但总得先解决问题吧……）</p>
<p>Yelp 的主要流量入口还是在 PC，手机上可能只占二三十的量，这个让人大跌眼镜。</p>
<p>Yelp 使用 AWS。</p>
<h3 id="Airbnb"><a href="#Airbnb" class="headerlink" title="Airbnb"></a>Airbnb</h3><p>Airbnb 的办公室还是蛮有特色的，室内的设计很有艺术感和趣味感，空间很大，感觉工作起来应该很惬意，这里的所有员工桌子均为可升降桌子。</p>
<p>作为前端，对 Airbnb 最熟悉的莫过于其在 GitHub 上推出的前端规范，我们的规范很多内容也是参考他们来制订的。由于带头大哥并不是前端，问其 Airbnb 各个地方代码规范情况，反馈其实并没有那么的规范…… 少数部门在严格的执行编码规范，大多数部门还是有点散的。</p>
<p>跟 Yelp 类似，Airbnb 只有百分之三四十的流量在手机端。</p>
<p>Airbnb 使用 AWS。</p>
<p><img src="https://gw.alicdn.com/tps/TB17wMvOFXXXXc5apXXXXXXXXXX-1440-1920.jpg_790x10000.jpg" alt=""></p>
<p><img src="https://gw.alicdn.com/tps/TB1ap7sOFXXXXXTaFXXXXXXXXXX-1152-864.jpg_790x10000.jpg" alt=""></p>
<p><img src="https://gw.alicdn.com/tps/TB197gvOFXXXXc1apXXXXXXXXXX-1152-864.jpg_790x10000.jpg" alt=""></p>
<p><img src="https://gw.alicdn.com/tps/TB1nzEGOFXXXXavaXXXXXXXXXXX-1440-1920.jpg_790x10000.jpg" alt=""></p>
<p><img src="https://gw.alicdn.com/tps/TB1CboNOFXXXXakXVXXXXXXXXXX-1152-864.jpg_790x10000.jpg" alt=""></p>
<p><img src="https://gw.alicdn.com/tps/TB1p9UvOFXXXXXSapXXXXXXXXXX-1152-864.jpg_790x10000.jpg" alt=""></p>
<p>这是 3D 打印的作品。</p>
<h3 id="Twitter"><a href="#Twitter" class="headerlink" title="Twitter"></a>Twitter</h3><p>Twitter 同样位于 downtown，拥有十几层的办公楼，员工大约有 2000 多名，楼上还有一个露天的大阳台，能看到有些员工就懒洋洋的躺在阳台的草坪上办公…… 内部还有一个比较大的餐厅，平时还可以用来开 party、一些庆功会、活动之类的。</p>
<p>Twitter 的工作相对来说比较繁忙，时常也会出现加班的情况。</p>
<p>由于数据量巨大及自身的业务特殊原因，Twitter 并没有使用 AWS，而是通过自建服务来满足业务需求。同样，Twitter 也并没有使用 docker，而是在很早之前就开发了类似的容器来满足需求。</p>
<p><img src="https://gw.alicdn.com/tps/TB1gtJaOVXXXXa4XXXXXXXXXXXX-4608-3456.jpg_790x10000.jpg" alt=""></p>
<p>大大的阳台。</p>
<p><img src="https://gw.alicdn.com/tps/TB1K2IUOFXXXXbgXFXXXXXXXXXX-4608-3456.jpg_790x10000.jpg" alt=""></p>
<p>内部餐厅。</p>
<p><img src="https://gw.alicdn.com/tps/TB1UtQDOFXXXXbfaXXXXXXXXXXX-3456-4608.jpg_790x10000.jpg" alt=""></p>
<p>仔细看，这里边有一个 Twitter 的 logo。</p>
<h3 id="Google"><a href="#Google" class="headerlink" title="Google"></a>Google</h3><p>会议结束后，我们一行来到了硅谷，拜访了这里的 Google 和 Facebook，先来看看 Google。</p>
<p><img src="https://gw.alicdn.com/tps/TB1vntbOVXXXXX2XXXXXXXXXXXX-1440-1920.jpg_790x10000.jpg" alt=""></p>
<p>最先参观了 Google 的 Android 乐园，里边摆放着每个版本的 Android 代号标志：</p>
<p><img src="https://gw.alicdn.com/tps/TB1qX3LOFXXXXbQXVXXXXXXXXXX-4608-3456.jpg_790x10000.jpg" alt=""></p>
<p>先是来了 Google Vistor Center，在这里体验了一个还在试验的谷歌地球。这个系统由一圈竖着的屏幕以及一个操控台组成，输入想看的地点，屏幕上就会带你进入相应的地点（当然需要先建模的），画面非常的逼真、细腻，看了纽约曼哈顿、大峡谷、故宫等，感觉比较 NB，以后在家就可以欣赏到世界各地的美景了，还能自己操控来一场峡谷漂流……</p>
<p><img src="https://gw.alicdn.com/tps/TB1X7gCOFXXXXXmaXXXXXXXXXXX-1440-1920.jpg_790x10000.jpg" alt=""></p>
<p>Vistor Center 里还有一些 ChromeBook 的展览，在世界上第一台 ChromeBook 上访问了下我们的淘宝首页，运行良好……</p>
<p><img src="https://gw.alicdn.com/tps/TB1py3qOFXXXXb9aFXXXXXXXXXX-1440-1920.jpg_790x10000.jpg" alt=""></p>
<p>由于办公区域不能参观，Google 在这里设置了一个小的办公区供人参观，同样也都是可升降桌子。 另外提供睡觉的壳仓蛮有意思，躺进去后自己关上门，睡起来蛮惬意……</p>
<p><img src="https://gw.alicdn.com/tps/TB1TI7MOFXXXXbxXVXXXXXXXXXX-1440-1920.jpg_790x10000.jpg" alt=""></p>
<p>Vistor Center 里还有一组照片墙，据说这是一个 Google 的基层员工，每次有大人物来园区，这货都会想尽办法与其合照，然后照的多了就成为了“红人”，每个大人物来都会跟他合照，还有奥巴马…… Google 还专门在 Vistor Center 里给他搞了一堵照片墙…… 事实证明，不管是啥事儿，坚持就会有回报……</p>
<p><img src="https://gw.alicdn.com/tps/TB1jLQEOFXXXXXIaXXXXXXXXXXX-1152-864.jpg_790x10000.jpg" alt=""></p>
<p>随后去了 Google 早期的园区，这里是一个开放的区域，不算大，但也不小。有大大的餐厅、各种奇怪的设备、游戏厅、沙滩排球场、小小的静止游泳池、健身房等等，据带头大姐说，员工可以在任意一个喜欢的地方办公，上班时间有的打游戏、有的打球、有的游泳……</p>
<p><img src="https://gw.alicdn.com/tps/TB1cr._OFXXXXbXXXXXXXXXXXXX-4608-3456.jpg_790x10000.jpg" alt=""></p>
<h3 id="Facebook"><a href="#Facebook" class="headerlink" title="Facebook"></a>Facebook</h3><p>进入 FaceBook 的第一感觉就是，这里简直就像一个五彩斑斓的风情小镇，虽然不大，但是足够的温馨，商店、餐厅、电话亭、游戏厅、办公楼静静的立在街道两旁。</p>
<p>先是去参观了 Instgram，这里的一些员工桌上有气球挂着，据带头大哥说，是员工一年、两年、三年时会挂不同的气球，但由于人员流动性大，挂球的人其实并不多……</p>
<p>Facebook 的工程师文化比较浓，我们的厕所里贴的是各种广告，人家的厕所里直接贴的是代码、技术，让你尿尿的时候都能够在大脑中执行一次代码……</p>
<p><img src="https://gw.alicdn.com/tps/TB1ar.BOFXXXXbmaXXXXXXXXXXX-4608-3456.jpg_790x10000.jpg" alt=""></p>
<p><img src="https://gw.alicdn.com/tps/TB1NC.LOFXXXXc2XVXXXXXXXXXX-4608-3456.jpg_790x10000.jpg" alt=""></p>
<p><img src="https://gw.alicdn.com/tps/TB1WqEWOFXXXXabXFXXXXXXXXXX-3456-4608.jpg_790x10000.jpg" alt=""></p>
<p><img src="https://gw.alicdn.com/tps/TB1ZBZyOFXXXXcEaXXXXXXXXXXX-4608-3456.jpg_790x10000.jpg" alt=""></p>
<p>Facebook 的大 logo。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>先说 QCon，参会之前，根据主题先看了相关的一些资料，实际听的过程还是稍微有点小失望，前端方面的演讲普遍比较简单，基本是在较少框架、工具的基本使用方式，缺乏真正的实践和应用。如果放在两三年前，或许会是比较有意思的东西，但是今天，这些主题过于基础。相较之前的 QCon 上海，少了无线相关的主题，也少了真正的实践。当然，也并非毫无意义，更多的我们可以听到在被人眼里，这个技术是如何被使用，在这项技术的发展历程中，经历了哪些抉择，变革的思路是怎样的，其实这些对我们的指导意义还是蛮大的。另外，QCon 每天的开场 Keynote 非常的精彩。</p>
<p>再说下拜访各个公司的收获，从 QCon 到各个创业公司，基本都在使用 AWS，大家都是围绕这 AWS 去做相关的优化、工具来帮助自己的业务运行的更好。我们的阿里云前景广阔啊，如果能够圈住国内的中小创业者，这个市场也是巨大无比的…… 各个公司都各有特色，他们的市场、他们的用户，很多时候真的令你无法想象，跟国内的场景、用户完全是两个不同的景象。员工的工作环境普遍比较惬意，时间也相对比较自由，大多都没有 KPI 的压力。</p>
<p>再说下美国印象。如果说美国的刷卡业甩中国 100 条街的话，那么中国的移动互联网、移动支付可以甩美国 500 条街。在拜访过程中了解到，在美国，手机的流量套餐基本上是无限量的，但是各个产品的手机端用户并不多，很多人的手机里就装了少数几个 App，他们很少用手机做啥事儿…… 在国内都被用烂了的二维码，在美国几乎看不到，就连 Twitter 也仅仅是在最近才有了二维码功能…… 另外，这些人真是爱跑步啊，无论何时、无论何地，都能看到各种各样的人在跑步…… 很多人周末的活动一般也都是野营、打球、徒步等户外活动，感觉上比较健康。</p>
<p>美国人在创新上真的是秒杀我们，如高晓松所说，或许是因为美国的强大使美国人感觉到自信、骄傲，更容易创造出不一样的东西，从他们的技术、电影、动画等等我们都能看出美国人的脑洞大开，而我们基本是在其基础上去做增强、改造。在中国逐步的强大、崛起的时候，期望我们也能够更加的自信、骄傲，特别是我们的程序员们能够有自己的创新、自己的不一样的东西，一千个人脑中应该有一千幅不同的 HelloKitty！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="https://gw.alicdn.com/tps/TB1pOFzOVXXXXbhaXXXXXXXXXXX-900-500.jpg" alt="QCon San Francisco 2016 前端参会总结"></p>
<p>11 月初有幸参加了在美国旧金]]>
    </summary>
    
      <category term="React" scheme="http://taobaofed.org/tags/React/"/>
    
      <category term="框架" scheme="http://taobaofed.org/tags/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="QCon" scheme="http://taobaofed.org/tags/QCon/"/>
    
      <category term="Angular" scheme="http://taobaofed.org/tags/Angular/"/>
    
      <category term="webpack" scheme="http://taobaofed.org/tags/webpack/"/>
    
      <category term="RxJS" scheme="http://taobaofed.org/tags/RxJS/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[「八面玲珑的 Node.js」- Node 地下铁第三期广州站线下沙龙总结]]></title>
    <link href="http://taobaofed.org/blog/2016/12/14/node-subway-season-3-guangzhou/"/>
    <id>http://taobaofed.org/blog/2016/12/14/node-subway-season-3-guangzhou/</id>
    <published>2016-12-14T03:19:30.000Z</published>
    <updated>2017-03-18T09:50:27.000Z</updated>
    <content type="html"><![CDATA[<p><img src="https://img.alicdn.com/tfs/TB1BVZQOFXXXXa0XpXXXXXXXXXX-900-500.jpg" alt="「八面玲珑的 Node.js」- Node 地下铁第三期广州站线下沙龙总结"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>转眼 2016 年就要结束了，距上次地下铁沙龙已经过去了大半年，我们在这冬天来到温暖的广州，跟朋友们相聚一堂，一起学习探讨开发 Node.js 过程中的心得，以及探讨 Node.js 领域内的新动向。</p>
<p>本次活动受广州地主 UC 前端团队的大力支持，由 UC 提供了会场，博文视点、图灵、稀土掘金提供了本次活动的赞助。</p>
<p>广州的同学非常热情，会场里面座无虚席。</p>
<p><img src="https://img.alicdn.com/tfs/TB1sukYOFXXXXcXXXXXXXXXXXXX-1280-853.jpg" alt="IMG_0251.jpg"></p>
<p><img src="https://img.alicdn.com/tfs/TB1rfoCOFXXXXXQXVXXXXXXXXXX-1280-853.jpg" alt="IMG_0344.jpg"></p>
<h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><h2 id="Thrift-下的-Node-js-跨语言异构"><a href="#Thrift-下的-Node-js-跨语言异构" class="headerlink" title="Thrift 下的 Node.js 跨语言异构"></a>Thrift 下的 Node.js 跨语言异构</h2><p>Node.js 越来越成为主流选型，在实际工作和复杂的历史遗留问题中，往往需要使用 Node.js 和其它服务，组件进行各种通讯和相互调用，如何让 Node.js 和其它服务一起和谐相处，是我们越来越多所面临的局面。来自 UC 的前端工程师刘欣给我们介绍了他们如何在实际生产中使用 Thrift 做接口在异构系统之间做通讯，以及性能上有怎样的提升。</p>
<p><img src="https://img.alicdn.com/tfs/TB18XwcOFXXXXcvaFXXXXXXXXXX-1280-853.jpg" alt="IMG_0275.jpg"></p>
<p><a href="http://taobaofed.github.io/nodejs-club/slides/season-3/thrift-liuxin%40uc.pdf" target="_blank" rel="external">PPT</a></p>
<h2 id="Node-js-服务前端数据接口的演化"><a href="#Node-js-服务前端数据接口的演化" class="headerlink" title="Node.js 服务前端数据接口的演化"></a>Node.js 服务前端数据接口的演化</h2><p>九十为我们介绍了在淘宝前端团队中，Node.js 在数据接口服务上的演变。</p>
<p>从传统的半栈开始，逐步引入 BFF（Backend For Frontend），然后形成统一的 API 接入层。</p>
<p><img src="https://img.alicdn.com/tfs/TB1V1QROFXXXXXLXpXXXXXXXXXX-1280-853.jpg" alt="IMG_0302.jpg"></p>
<p><a href="http://v.youku.com/v_show/id_XMTg2MTI3NjMwNA==.html" target="_blank" rel="external">视频</a><br><a href="http://taobaofed.github.io/nodejs-club/slides/season-3/Node.js%20api%20serving%20frontend%20-%20wangguang%40taobaofed.pdf" target="_blank" rel="external">PPT</a></p>
<h2 id="TypeScript-简介"><a href="#TypeScript-简介" class="headerlink" title="TypeScript 简介"></a>TypeScript 简介</h2><p>UC 的小鲜肉 Randy 为我们简单介绍了 TypeScript 在实际开发中给我们带来的好处</p>
<p>他从写 JavaScript 常遇到的类型不匹配的问题开始，介绍了类型判断在 TypeScript 中如何为开发减少错误，还介绍了 TypeScript 的一些其他高级特性如 async/await, decorator 等。</p>
<p><img src="https://img.alicdn.com/tfs/TB1FIoTOFXXXXaeXpXXXXXXXXXX-1280-853.jpg" alt="IMG_0309.jpg"></p>
<p><a href="http://v.youku.com/v_show/id_XMTg2MTI4MzU0NA==.html" target="_blank" rel="external">视频</a><br><a href="http://slides.com/randylu/deck-3/" target="_blank" rel="external">PPT</a></p>
<h2 id="Node-js-直出套路"><a href="#Node-js-直出套路" class="headerlink" title="Node.js 直出套路"></a>Node.js 直出套路</h2><p>来自腾讯视频的前端 Leader 姚穗斌给我们带来了一种新的直出思路。直出其实并不算是新概念。只不过在 Web 2.0 单页应用流行的年代，一直被人遗忘在身后。直出能对首屏的渲染带来不错的性能提升。姚穗斌通过层层展开，给我们在提升直出的性能和扩展性上很多启发。</p>
<p><img src="https://img.alicdn.com/tfs/TB1fvknOFXXXXXyapXXXXXXXXXX-1280-853.jpg" alt="IMG_0339.jpg"></p>
<p><a href="http://v.youku.com/v_show/id_XMTg2MTI5MDI0NA==.html" target="_blank" rel="external">视频</a><br><a href="http://taobaofed.github.io/nodejs-club/slides/season-3/Nodejs%20patterns%20of%20directly%20rendering%20-%20vicyao%40tencent.pdf" target="_blank" rel="external">PPT</a></p>
<h2 id="辩论会"><a href="#辩论会" class="headerlink" title="辩论会"></a>辩论会</h2><p>此次活动最大的亮点在于试水了辩论会这种活动形式，程序员撕逼往往只是在键盘上，鲜有正儿八经的辩论，此次活动特地设置这个环节让大家能在台上友好的探讨一些问题</p>
<p>辩论的主题是“统一单语言构建系统” vs “混合多语言构建系统”哪个更好，由正方 叶倍宏、Randy、Leon、姚穗斌对阵反方 九十、刘欣、老雷和三圈。这些都是拥有丰富经验的工程师们。</p>
<p><img src="https://img.alicdn.com/tfs/TB1MCMuOFXXXXXxaXXXXXXXXXXX-1280-853.jpg" alt="IMG_0359.jpg"></p>
<p>辩论中双方辩友唇枪舌剑，你来我往，摆事实，讲道理，证据凿凿，场面非常激烈。双方从历史遗留现状，到架构，到成本，到商业价值等等，都展开了攻防辩论。最后由观众评选出正方“统一单语言构建系统”表现更好，三辩 Leon 被认为是最佳辩手。</p>
<p><a href="http://v.youku.com/v_show/id_XMTg2MTI5NDQzNg==.html" target="_blank" rel="external">视频</a></p>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>感谢各位同学的参与，我们下次再约！欢迎关注 Node.js 地下铁微信公共账号，随时关注下一次线下沙龙动态。</p>
<p><img src="https://img.alicdn.com/tfs/TB15lsyOFXXXXbMXVXXXXXXXXXX-1280-853.jpg" alt="IMG_0362.jpg"></p>
<p><img src="https://img.alicdn.com/tps/TB1roZoKVXXXXcWXFXXXXXXXXXX-86-86.jpg" alt="IMG_0362.jpg"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="https://img.alicdn.com/tfs/TB1BVZQOFXXXXa0XpXXXXXXXXXX-900-500.jpg" alt="「八面玲珑的 Node.js」- Node 地下铁第三期广州站线下沙龙总结"></p>
<h1 id="前言]]>
    </summary>
    
      <category term="nodejs" scheme="http://taobaofed.org/tags/nodejs/"/>
    
      <category term="地下铁" scheme="http://taobaofed.org/tags/%E5%9C%B0%E4%B8%8B%E9%93%81/"/>
    
      <category term="沙龙" scheme="http://taobaofed.org/tags/%E6%B2%99%E9%BE%99/"/>
    
      <category term="广州" scheme="http://taobaofed.org/tags/%E5%B9%BF%E5%B7%9E/"/>
    
      <category term="Node.js" scheme="http://taobaofed.org/categories/Node-js/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[happypack 原理解析]]></title>
    <link href="http://taobaofed.org/blog/2016/12/08/happypack-source-code-analysis/"/>
    <id>http://taobaofed.org/blog/2016/12/08/happypack-source-code-analysis/</id>
    <published>2016-12-08T07:54:38.000Z</published>
    <updated>2017-03-18T09:50:27.000Z</updated>
    <content type="html"><![CDATA[<p><img src="https://img.alicdn.com/tfs/TB15ZeJOFXXXXcYXVXXXXXXXXXX-900-500.jpg" alt="happypack 原理解析"></p>
<p>说起 <a href="https://www.npmjs.com/package/happypack" target="_blank" rel="external">happypack</a> 可能很多同学还比较陌生，其实 happypack 是 webpack 的一个插件，目的是通过多进程模型，来加速代码构建，目前我们的线上服务器已经上线这个插件功能，并做了一定适配，效果显著。这里有一些大致参考：</p>
<p><img src="http://gw.alicdn.com/tfs/TB1apiAOFXXXXcnXVXXXXXXXXXX-549-451.png" alt=""></p>
<p>这张图是 happypack 九月逐步全量上线后构建时间的的参考数据，线上构建服务器 16 核环境。</p>
<p>在上这个插件的过程中，我们也发现了这个单人维护的社区插件有一些问题，我们在解决这些问题的同时，也去修改了内部的代码，发布了自己维护的版本 @ali/happypack，那么内部是怎么跑起来的，这里做一个总结记录。</p>
<h2 id="webpack-加载配置"><a href="#webpack-加载配置" class="headerlink" title="webpack 加载配置"></a>webpack 加载配置</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> HappyPack = <span class="built_in">require</span>(<span class="string">'happypack'</span>);</span><br><span class="line"><span class="keyword">var</span> happyThreadPool = HappyPack.ThreadPool(&#123; size: os.cpus().length &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略其余配置</span></span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  loaders: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        loader: ExtractTextPlugin.extract(</span><br><span class="line">            <span class="string">'style'</span>,</span><br><span class="line">            path.resolve(__dirname, <span class="string">'./node_modules'</span>, <span class="string">'happypack/loader'</span>) + <span class="string">'?id=less'</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">      <span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">        id: <span class="string">'less'</span>,</span><br><span class="line">        loaders: [<span class="string">'css!less'</span>],</span><br><span class="line">        threadPool: happyThreadPool,</span><br><span class="line">        cache: <span class="literal">true</span>,</span><br><span class="line">        verbose: <span class="literal">true</span></span><br><span class="line">      &#125;)</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure>
<p>这个示例只单独抽取了配置 happypack 的部分。可以看到，类似 <a href="https://github.com/webpack/extract-text-webpack-plugin" target="_blank" rel="external">extract-text-webpack-plugin</a> 插件，happypack 也是通过 webpack 中 <a href="http://webpack.github.io/docs/using-loaders.html" target="_blank" rel="external">loader</a> 与 <a href="http://webpack.github.io/docs/using-plugins.html" target="_blank" rel="external">plugin</a> 的相互调用协作的方式来运作。</p>
<p>loader 配置直接指向 happypack 提供的 loader， 对于文件实际匹配的处理 loader ，则是通过配置在 plugin 属性来传递说明，这里 happypack 提供的 loader 与 plugin 的衔接匹配，则是通过 <code>id=less</code> 来完成。</p>
<h2 id="happypack-文件解析"><a href="#happypack-文件解析" class="headerlink" title="happypack 文件解析"></a>happypack 文件解析</h2><h3 id="HappyPlugin-js"><a href="#HappyPlugin-js" class="headerlink" title="HappyPlugin.js"></a>HappyPlugin.js</h3><p><img src="http://gw.alicdn.com/tfs/TB1svtKOFXXXXcAXpXXXXXXXXXX-767-269.png" alt=""></p>
<p>对于 webpack 来讲，plugin 是贯穿在整个构建流程，同样对于 happypack 配置的构建流程，首先进入逻辑的是 plugin 的部分，从初始化的部分查看 happypack 中与 plugin 关联的文件。 </p>
<p><strong>1. 基础参数设置</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HappyPlugin</span>(<span class="params">userConfig</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> HappyPlugin)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HappyPlugin(userConfig);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.id = <span class="built_in">String</span>(userConfig.id || ++uid);</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'HappyPack'</span>;</span><br><span class="line">  <span class="keyword">this</span>.state = &#123;</span><br><span class="line">    started: <span class="literal">false</span>,</span><br><span class="line">    loaders: [],</span><br><span class="line">    baseLoaderRequest: <span class="string">''</span>,</span><br><span class="line">    foregroundWorker: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 省略 config</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于基础参数的初始化，对应上文提到的配置，可以看到插件设置了两个标识</p>
<ul>
<li>id: 在配置文件中设置的与 loader 关联的 id 首先会设置到实例上，为了后续 loader 与 plugin 能进行一对一匹配</li>
<li>name: 标识插件类型为 <code>HappyPack</code>,方便快速在 loader 中定位对应 plugin，同时也可以避免其他插件中存在 id 属性引起错误的风险</li>
</ul>
<p>对于这两个属性的应用，可以看到 loader 文件中有这样一段代码 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isHappy</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">plugin</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> plugin.name === <span class="string">'HappyPack'</span> &amp;&amp; plugin.id === id;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">happyPlugin = <span class="keyword">this</span>.options.plugins.filter(isHappy(id))[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<p>其次声明 state 对象标识插件的运行状态之后，开始配置信息的处理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HappyPlugin</span>(<span class="params">userConfig</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 省略基础标识设置</span></span><br><span class="line">  <span class="keyword">this</span>.config = OptionParser(userConfig, &#123;</span><br><span class="line">    id:                       &#123; type: <span class="string">'string'</span> &#125;,</span><br><span class="line">    tempDir:                  &#123; type: <span class="string">'string'</span>, <span class="keyword">default</span>: <span class="string">'.happypack'</span> &#125;,</span><br><span class="line">    threads:                  &#123; type: <span class="string">'number'</span>, <span class="keyword">default</span>: <span class="number">3</span> &#125;,</span><br><span class="line">    threadPool:               &#123; type: <span class="string">'object'</span>, <span class="keyword">default</span>: <span class="literal">null</span> &#125;,</span><br><span class="line">    cache:                    &#123; type: <span class="string">'boolean'</span>, <span class="keyword">default</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    cachePath:                &#123; type: <span class="string">'string'</span> &#125;,</span><br><span class="line">    cacheContext:             &#123; type: <span class="string">'object'</span>, <span class="keyword">default</span>: &#123;&#125; &#125;,</span><br><span class="line">    cacheSignatureGenerator:  &#123; type: <span class="string">'function'</span> &#125;,</span><br><span class="line">    verbose:                  &#123; type: <span class="string">'boolean'</span>, <span class="keyword">default</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    debug:                    &#123; type: <span class="string">'boolean'</span>, <span class="keyword">default</span>: process.env.DEBUG === <span class="string">'1'</span> &#125;,</span><br><span class="line">    enabled:                  &#123; type: <span class="string">'boolean'</span>, <span class="keyword">default</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    loaders:                  &#123;</span><br><span class="line">      validate: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">          ...</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="string">"HappyPack["</span> + <span class="keyword">this</span>.id + <span class="string">"]"</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 省略 threadPool 、HappyFSCache 初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用 <code>OptionParser</code> 函数来进行插件过程中使用到的参数合并，在合并函数的参数对象中，提供了作为数据合并依据的一些属性，例如合并类型 <code>type</code>、默认值 <code>default</code> 以及还有设置校验函数的校验属性 <code>validate</code> 完成属性检查。</p>
<p>这里对一些运行过车中的重要属性进行解释:</p>
<ul>
<li>tmpDir: 存放打包缓存文件的位置</li>
<li>cache: 是否开启缓存，目前缓存如果开启，(注: 会以<strong>数量级的差异</strong>来缩短构建时间，很方便日常开发)</li>
<li>cachePath: 存放缓存文件映射配置的位置</li>
<li>verbose: 是否输出过程日志</li>
<li>loaders: 因为配置中文件的处理 loader 都指向了 happypack 提供的 loadr ,这里配置的对应文件实际需要运行的 loader</li>
</ul>
<p><strong>2. 线程池初始化</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HappyPlugin</span>(<span class="params">userConfig</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 省略基础参数设置</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">this</span>.threadPool = <span class="keyword">this</span>.config.threadPool || HappyThreadPool(&#123;</span><br><span class="line">    id: <span class="keyword">this</span>.id,</span><br><span class="line">    size: <span class="keyword">this</span>.config.threads,</span><br><span class="line">    verbose: <span class="keyword">this</span>.config.verbose,</span><br><span class="line">    debug: <span class="keyword">this</span>.config.debug,</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 省略 HappyFSCache 初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 thread 其实严格意义说是 process，应该是进程，猜测只是套用的传统软件的一个主进程多个线程的模型。这里不管是在配置中，配置的是 <code>threads</code> 属性还是 <code>threadPool</code> 属性，都会生成一个 <code>HappyThreadPool</code> 对象来管理生成的子进程对象。</p>
<p><strong>2.1. HappyThreadPool.js</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HappyThreadPool</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> happyRPCHandler = <span class="keyword">new</span> HappyRPCHandler();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> threads = createThreads(config.size, happyRPCHandler, &#123;</span><br><span class="line">   id: config.id,</span><br><span class="line">   verbose: config.verbose,</span><br><span class="line">   debug: config.debug,</span><br><span class="line"> &#125;);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 省略返回对象部分</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>在返回 <code>HappyThreadPool</code> 对象之前，会有两个操作:</p>
<p><strong>2.1.1. HappyRPCHandler.js</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HappyRPCHandler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.activeLoaders = &#123;&#125;;</span><br><span class="line">  <span class="keyword">this</span>.activeCompiler = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 <code>HappyRPCHandler</code> 实例，可以从构造函数看到，会绑定当前运行的 loader 与 compiler ，同时在文件中，针对 loader 与 compiler 定义调用接口:</p>
<ul>
<li>对应 compiler 会绑定查找解析路径的 reolve 方法: </li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">COMPILER_RPCs = &#123;</span><br><span class="line">  resolve: <span class="function"><span class="keyword">function</span>(<span class="params">compiler, payload, done</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> resolver = compiler.resolvers.normal;</span><br><span class="line">    <span class="keyword">var</span> resolve = compiler.resolvers.normal.resolve;</span><br><span class="line">    <span class="comment">// 省略部分判断</span></span><br><span class="line">    resolve.call(resolver, payload.context, payload.context, payload.resource, done);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>对应 loader 其中一些绑定: </li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">LOADER_RPCS = &#123;</span><br><span class="line">  emitWarning: <span class="function"><span class="keyword">function</span>(<span class="params">loader, payload</span>) </span>&#123;</span><br><span class="line">    loader.emitWarning(payload.message);</span><br><span class="line">  &#125;,</span><br><span class="line">  emitError: <span class="function"><span class="keyword">function</span>(<span class="params">loader, payload</span>) </span>&#123;</span><br><span class="line">      loader.emitError(payload.message);</span><br><span class="line">  &#125;,</span><br><span class="line">  addDependency: <span class="function"><span class="keyword">function</span>(<span class="params">loader, payload</span>) </span>&#123;</span><br><span class="line">      loader.addDependency(payload.file);</span><br><span class="line">  &#125;,</span><br><span class="line">  addContextDependency: <span class="function"><span class="keyword">function</span>(<span class="params">loader, payload</span>) </span>&#123;</span><br><span class="line">      loader.addContextDependency(payload.file);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过定义调用 webpack 流程过程中的 loader、compiler 的能力来完成功能，类似传统服务中的 RPC 过程。</p>
<p><strong>2.1.2. 创建子进程 (HappyThread.js)</strong></p>
<p>传递子进程数参数 <code>config.size</code> 以及之前生成的 HappyRPCHandler 对象，调用 <code>createThreads</code>  方法生成实际的子进程。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createThreads</span>(<span class="params">count, happyRPCHandler, config</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> set = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> threadId = <span class="number">0</span>; threadId &lt; count; ++threadId) &#123;</span><br><span class="line">    <span class="keyword">var</span> fullThreadId = config.id ? [ config.id, threadId ].join(<span class="string">':'</span>) : threadId;</span><br><span class="line">    set.push(HappyThread(fullThreadId, happyRPCHandler, config));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> set;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>fullThreadId</code> 生成之后，传入 <code>HappyThread</code> 方法，生成对应的子进程，然后放在 set 集合中返回。调用 <code>HappyThread</code> 返回的对象就是 <code>Happypack</code> 的编译 worker 的上层控制。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">HappyThread: </span><br><span class="line">&#123;</span><br><span class="line">    open: <span class="function"><span class="keyword">function</span>(<span class="params">onReady</span>) </span>&#123;</span><br><span class="line">      fd = fork(WORKER_BIN, [id], &#123;</span><br><span class="line">        execArgv: []</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">// 省略进程消息绑定处理</span></span><br><span class="line">    &#125;,</span><br><span class="line">    configure: <span class="function"><span class="keyword">function</span>(<span class="params">compilerOptions, done</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 省略具体过程</span></span><br><span class="line">    &#125;,</span><br><span class="line">    compile: <span class="function"><span class="keyword">function</span>(<span class="params">params, done</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 省略具体过程</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    isOpen: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> !!fd;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    close: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      fd.kill(<span class="string">'SIGINT'</span>);</span><br><span class="line">      fd = <span class="literal">null</span>;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>
<p>对象中包含了对应的进程状态控制 <code>open</code> 、<code>close</code>，以及通过子进程来实现编译的流程控制 <code>configure</code>、<code>compile</code>。</p>
<p><strong>2.1.2.1 子进程执行文件 HappyWorkerChannel.js</strong></p>
<p>上面还可以看到一个信息是，<code>fd</code> 子进程的运行文件路径变量 <code>WORKER_BIN</code>，这里对应的是相同目录下的 <code>HappyWorkerChannel.js</code> 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> HappyWorker = <span class="built_in">require</span>(<span class="string">'./HappyWorker'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (process.argv[<span class="number">1</span>] === __filename) &#123;</span><br><span class="line">  startAsWorker();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">startAsWorker</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  HappyWorkerChannel(<span class="built_in">String</span>(process.argv[<span class="number">2</span>]), process);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HappyWorkerChannel</span>(<span class="params">id, stream</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> worker = <span class="keyword">new</span> HappyWorker(&#123; compiler: fakeCompiler &#125;);</span><br><span class="line"></span><br><span class="line">  stream.on(<span class="string">'message'</span>, accept);</span><br><span class="line">  stream.send(&#123; name: <span class="string">'READY'</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">accept</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 省略函数内容</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>精简之后的代码可以看到 <code>fork</code> 子进程之后，最终执行的是 <code>HappyWorkerChannel</code> 函数，这里的 <code>stream</code> 参数对应的是子进程的 <code>process</code> 对象，用来与主进程进行通信。</p>
<p>函数的逻辑是通过 <code>stream.on(&#39;messgae&#39;)</code> 订阅消息，控制层 <code>HappyThread</code> 对象来传递消息进入子进程，通过 <code>accept()</code> 方法来路由消息进行对应编译操作。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">accept</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (message.name === <span class="string">'COMPILE'</span>) &#123;</span><br><span class="line">      worker.compile(message.data, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">        stream.send(&#123;</span><br><span class="line">          id: message.id,</span><br><span class="line">          name: <span class="string">'COMPILED'</span>,</span><br><span class="line">          sourcePath: result.sourcePath,</span><br><span class="line">          compiledPath: result.compiledPath,</span><br><span class="line">          success: result.success</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (message.name === <span class="string">'COMPILER_RESPONSE'</span>) &#123;</span><br><span class="line">      <span class="comment">// 省略具体流程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (message.name === <span class="string">'CONFIGURE'</span>) &#123;</span><br><span class="line">      <span class="comment">// 省略具体流程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 省略具体流程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于不同的上层消息进行不通的子进程处理。</p>
<p><strong>2.1.2.1.1 子进程编译逻辑文件 HappyWorker.js</strong></p>
<p>这里的核心方法 <code>compile</code> ，对应了一层 <code>worker</code> 抽象，包含 <code>Happypack</code> 的实际编译逻辑，这个对象的构造函数对应 <code>HappyWorker.js</code> 的代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">HappyWorker.js</span><br><span class="line"></span><br><span class="line">HappyWorker.prototype.compile = <span class="function"><span class="keyword">function</span>(<span class="params">params, done</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  applyLoaders(&#123;</span><br><span class="line">    compiler: <span class="keyword">this</span>._compiler,</span><br><span class="line">    loaders: params.loaders,</span><br><span class="line">    loaderContext: params.loaderContext,</span><br><span class="line">  &#125;, params.loaderContext.sourceCode, params.loaderContext.sourceMap, <span class="function"><span class="keyword">function</span>(<span class="params">err, source, sourceMap</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 省略部分判断</span></span><br><span class="line">    <span class="keyword">var</span> compiledPath = params.compiledPath;</span><br><span class="line">    <span class="keyword">var</span> success = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略错误处理</span></span><br><span class="line">    fs.writeFileSync(compiledPath, source);</span><br><span class="line">    fs.writeFileSync(compiledPath + <span class="string">'.map'</span>, SourceMapSerializer.serialize(sourceMap));</span><br><span class="line"></span><br><span class="line">    success = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    done(&#123;</span><br><span class="line">      sourcePath: params.loaderContext.resourcePath,</span><br><span class="line">      compiledPath: compiledPath,</span><br><span class="line">      success: success</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>从 <code>applyLoaders</code> 的参数看到，这里会把 webpack 编辑过程中的 <code>loaders</code>、<code>loaderContext</code> 通过最上层的 <code>HappyPlugin</code> 进行传递，来模拟实现 loader 的编译操作。</p>
<p>从回调函数中看到当编译完成时， <code>fs.writeFileSync(compiledPath, source);</code> 会将编译结果写入 <code>compilePath</code> 这个编译路径，并通过 <code>done</code> 回调返回编译结果给主进程。</p>
<p><strong>3. 编译缓存初始化</strong></p>
<p><code>happypack</code> 会将每一个文件的编译进行缓存，这里通过</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HappyPlugin</span>(<span class="params">userConfig</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 省略基础参数设置</span></span><br><span class="line">  <span class="comment">// 省略 threadPool 初始化</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">this</span>.cache = HappyFSCache(&#123;</span><br><span class="line">    id: <span class="keyword">this</span>.id,</span><br><span class="line">    path: <span class="keyword">this</span>.config.cachePath ?</span><br><span class="line">      path.resolve(<span class="keyword">this</span>.config.cachePath.replace(<span class="regexp">/\[id\]/g</span>, <span class="keyword">this</span>.id)) :</span><br><span class="line">      path.resolve(<span class="keyword">this</span>.config.tempDir, <span class="string">'cache--'</span> + <span class="keyword">this</span>.id + <span class="string">'.json'</span>),</span><br><span class="line">    verbose: <span class="keyword">this</span>.config.verbose,</span><br><span class="line">    generateSignature: <span class="keyword">this</span>.config.cacheSignatureGenerator</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  HappyUtils.mkdirSync(<span class="keyword">this</span>.config.tempDir); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 <code>cachePath</code> 默认会将 plugin 的 <code>tmpDir</code> 的目录作为生成缓存映射配置文件的目录路径。同时创建好 <code>config.tempDir</code> 目录。</p>
<p><strong>3.1 happypack 缓存控制 HappyFSCache.js</strong><br><code>HappyFSCache</code> 函数这里返回对应的 cache 对象，在编译的开始和 worker 编译完成时进行缓存加载、设置等操作。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HappyFSCache.js</span></span><br><span class="line"></span><br><span class="line">exports.load = <span class="function"><span class="keyword">function</span>(<span class="params">currentContext</span>) </span>&#123;&#125;;</span><br><span class="line">exports.save = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">exports.getCompiledSourceCodePath = <span class="function"><span class="keyword">function</span>(<span class="params">filePath</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> cache.mtimes[filePath] &amp;&amp; cache.mtimes[filePath].compiledPath;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">exports.updateMTimeFor = <span class="function"><span class="keyword">function</span>(<span class="params">filePath, compiledPath, error</span>) </span>&#123;</span><br><span class="line">    cache.mtimes[filePath] = &#123;</span><br><span class="line">      mtime: generateSignature(filePath),</span><br><span class="line">      compiledPath: compiledPath,</span><br><span class="line">      error: error</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">exports.getCompiledSourceMapPath = <span class="function"><span class="keyword">function</span>(<span class="params">filePath</span>) </span>&#123;&#125;;</span><br><span class="line">exports.hasChanged = <span class="function"><span class="keyword">function</span>(<span class="params">filePath</span>) </span>&#123;&#125;;</span><br><span class="line">exports.hasErrored = <span class="function"><span class="keyword">function</span>(<span class="params">filePath</span>) </span>&#123;&#125;;</span><br><span class="line">exports.invalidateEntryFor = <span class="function"><span class="keyword">function</span>(<span class="params">filePath</span>) </span>&#123;&#125;;</span><br><span class="line">exports.dump = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>对于编译过程中的单个文件，会通过 <code>getCompiledSourceCodePath</code> 函数来获取对应的缓存内容的文件物理路径，同时在新文件编译完整之后，会通过 <code>updateMTimeFor</code> 来进行缓存设置的更新。</p>
<h3 id="HappyLoader-js"><a href="#HappyLoader-js" class="headerlink" title="HappyLoader.js"></a>HappyLoader.js</h3><p>在 happypack 流程中，配置的对应 loader 都指向了 <code>happypack/loader.js</code> ，文件对应导出的是 <code>HappyLoader.js</code> 导出的对象 ，对应的 bundle 文件处理都通过 <code>happypack</code> 提供的 loader 来进行编译流程。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HappyLoader</span>(<span class="params">sourceCode, sourceMap</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> happyPlugin, happyRPCHandler;</span><br><span class="line">  <span class="keyword">var</span> callback = <span class="keyword">this</span>.async();</span><br><span class="line">  <span class="keyword">var</span> id = getId(<span class="keyword">this</span>.query);</span><br><span class="line">  </span><br><span class="line">  happyPlugin = <span class="keyword">this</span>.options.plugins.filter(isHappy(id))[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  happyPlugin.compile(&#123;</span><br><span class="line">    remoteLoaderId: remoteLoaderId,</span><br><span class="line">    sourceCode: sourceCode,</span><br><span class="line">    sourceMap: sourceMap,</span><br><span class="line">    useSourceMap: <span class="keyword">this</span>._module.useSourceMap,</span><br><span class="line">    context: <span class="keyword">this</span>.context,</span><br><span class="line">    request: happyPlugin.generateRequest(<span class="keyword">this</span>.resource),</span><br><span class="line">    resource: <span class="keyword">this</span>.resource,</span><br><span class="line">    resourcePath: <span class="keyword">this</span>.resourcePath,</span><br><span class="line">    resourceQuery: <span class="keyword">this</span>.resourceQuery,</span><br><span class="line">    target: <span class="keyword">this</span>.target,</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, outSourceCode, outSourceMap</span>) </span>&#123;</span><br><span class="line">    callback(<span class="literal">null</span>, outSourceCode, outSourceMap);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>省略了部分代码，<code>HappyLoader</code> 首先拿到配置 <code>id</code> ,然后对所有的 webpack plugin 进行遍历 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isHappy</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">plugin</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> plugin.name === <span class="string">'HappyPack'</span> &amp;&amp; plugin.id === id;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>找到 id 匹配的 <code>happypackPlugin</code>。传递原有 <code>webpack</code> 编译提供的 <code>loaderContext</code> (loader 处理函数中的 <code>this</code> 对象)中的参数，调用 <code>happypackPlugin</code> 的 <code>compile</code> 进行编译。</p>
<p>上面是 happypack 的主要文件，作者在项目介绍中也提供了一张图来进行结构化描述:</p>
<p><img src="http://gw.alicdn.com/tfs/TB12jI.OpXXXXcLaXXXXXXXXXXX-916-556.png" alt=""></p>
<h2 id="实际运行"><a href="#实际运行" class="headerlink" title="实际运行"></a>实际运行</h2><p>从前面的文件解析，已经把 <code>happypack</code> 的工程文件关联结构大致说明了一下，这下结合日常在构建工程的一个例子，将整个流程串起来说明。</p>
<h3 id="启动入口"><a href="#启动入口" class="headerlink" title="启动入口"></a>启动入口</h3><p><img src="http://gw.alicdn.com/tfs/TB1px8jOFXXXXbDaXXXXXXXXXXX-1022-487.png" alt=""></p>
<p>在 webpack 编译流程中，在完成了基础的配置之后，就开始进行编译流程，这里 webpack 中的 <code>compiler</code> 对象会去触发 <code>run</code> 事件，这边 <code>HappypackPlugin</code> 以这个事件作为流程入口，进行初始化。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HappyPlugin.prototype.apply = <span class="function"><span class="keyword">function</span>(<span class="params">compiler</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  compiler.plugin(<span class="string">'run'</span>, that.start.bind(that));</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 <code>run</code> 事件触发时，开始进行 <code>start</code> 整个流程</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HappyPlugin.prototype.start = <span class="function"><span class="keyword">function</span>(<span class="params">compiler, done</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">async</span>.series([</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">registerCompilerForRPCs</span>(<span class="params">callback</span>) </span>&#123;&#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">normalizeLoaders</span>(<span class="params">callback</span>) </span>&#123;&#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolveLoaders</span>(<span class="params">callback</span>) </span>&#123;&#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">loadCache</span>(<span class="params">callback</span>) </span>&#123;&#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">launchAndConfigureThreads</span>(<span class="params">callback</span>) </span>&#123;&#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">markStarted</span>(<span class="params">callback</span>) </span>&#123;&#125;</span><br><span class="line">  ], done);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>start</code>函数通过 <code>async.series</code> 将整个过程串联起来。</p>
<p><strong>1. registerCompilerForRPCs: <code>RPCHandler</code> 绑定 <code>compiler</code></strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">registerCompilerForRPCs</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  that.threadPool.getRPCHandler().registerActiveCompiler(compiler);</span><br><span class="line"></span><br><span class="line">  callback();</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>通过调用 plugin 初始化时生成的 handler 上的方法，完成对 <code>compiler</code> 对象的调用绑定。</p>
<p><strong>2. normalizeLoaders: loader 解析</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js: </span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">    id: <span class="string">'less'</span>,</span><br><span class="line">    loaders: [<span class="string">'css!less'</span>],</span><br><span class="line">    threadPool: happyThreadPool,</span><br><span class="line">    cache: <span class="literal">true</span>,</span><br><span class="line">    verbose: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>对应中的 <code>webpack</code> 中的 happypackPlugin 的 loaders 配置的处理: </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalizeLoaders</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> loaders = that.config.loaders;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 省略异常处理</span></span><br><span class="line">  </span><br><span class="line">  that.state.loaders = loaders.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">list, entry</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> list.concat(WebpackUtils.normalizeLoader(entry));</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  callback(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应配置的 loaders ，经过 <code>normalizeLoader</code> 的处理后，例如 <code>[css!less]</code> 会返回成一个 <code>loader</code> 数组 <code>[{path: &#39;css&#39;},{path: &#39;less&#39;}]</code>，复制到 plugin 的 <code>this.state</code> 属性上。</p>
<p><strong>3.resolveLoaders: loader 对应文件路径查询</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolveLoaders</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> loaderPaths = that.state.loaders.map(<span class="function"><span class="keyword">function</span>(<span class="params">loader</span>) </span>&#123; <span class="keyword">return</span> loader.path; &#125;);</span><br><span class="line"></span><br><span class="line">  WebpackUtils.resolveLoaders(compiler, loaderPaths, <span class="function"><span class="keyword">function</span>(<span class="params">err, loaders</span>) </span>&#123;</span><br><span class="line">    that.state.loaders = loaders;</span><br><span class="line">    that.state.baseLoaderRequest = loaders.map(<span class="function"><span class="keyword">function</span>(<span class="params">loader</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> loader.path + (loader.query || <span class="string">''</span>);</span><br><span class="line">    &#125;).join(<span class="string">'!'</span>);</span><br><span class="line">    callback();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了实际执行 loader 过程，这里将上一步 <strong>loader 解析</strong> 处理过后的 <code>loaders</code> 数组传递到 <code>resolveLoaders</code> 方法中，进行解析</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">exports.resolveLoaders = <span class="function"><span class="keyword">function</span>(<span class="params">compiler, loaders, done</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> resolve = compiler.resolvers.loader.resolve;</span><br><span class="line">  <span class="keyword">var</span> resolveContext = compiler.resolvers.loader;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span>.parallel(loaders.map(<span class="function"><span class="keyword">function</span>(<span class="params">loader</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> callArgs = [ compiler.context, loader, <span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">        callback(<span class="literal">null</span>, extractPathAndQueryFromString(result));</span><br><span class="line">      &#125;];</span><br><span class="line">      resolve.apply(resolveContext, callArgs);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;), done);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>而 <code>resolveLoaders</code> 方法采用的是借用原有 <code>webpack</code> 的 compiler 对象上的对应 <code>resolvers.loader</code> 这个 <code>Resolver</code> 实例的 <code>resolve</code> 方法进行解析，构造好解析参数后，通过 <code>async.parallel</code> 并行解析 loader 的路径</p>
<p><strong>4.loadCache: cache 加载</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadCache</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (that.config.cache) &#123;</span><br><span class="line">    that.cache.load(&#123;</span><br><span class="line">      loaders: that.state.loaders,</span><br><span class="line">      external: that.config.cacheContext</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  callback();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>cache 加载通过调用 <code>cache.load</code> 方法来加载上一次构建的缓存，快速提高构建速度。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">exports.load = <span class="function"><span class="keyword">function</span>(<span class="params">currentContext</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> oldCache, staleEntryCount;</span><br><span class="line">  cache.context = currentContext;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    oldCache = <span class="built_in">JSON</span>.parse(fs.readFileSync(cachePath, <span class="string">'utf-8'</span>));</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    oldCache = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cache.mtimes = oldCache.mtimes;</span><br><span class="line">  cache.context = currentContext;</span><br><span class="line"></span><br><span class="line">  staleEntryCount = removeStaleEntries(cache.mtimes, generateSignature);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>load</code> 方法会去读取 <code>cachePath</code> 这个路径的缓存配置文件，然后将内容设置到当前 <code>cache</code> 对象上的 <code>mtimes</code> 上。</p>
<p>在 happypack 设计的构建缓存中，存在一个上述的一个缓存映射文件，里面的配置会映射到一份编译生成的缓存文件。</p>
<p><strong>5.launchAndConfigureThreads: 线程池启动</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">launchAndConfigureThreads</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  that.threadPool.start(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 省略 thread congigure 过程</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>上面有提到，在加载完 <code>HappyPlugin</code> 时，会创建对应的 <code>HappyThreadPool</code> 对象以及设置数量的 <code>HappyThread</code>。但实际上一直没有创建真正的子进程实例，这里通过调用 <code>threadPool.start</code> 来进行子进程创建。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HappyThreadPool.js:</span><br><span class="line"></span><br><span class="line">    start: <span class="function"><span class="keyword">function</span>(<span class="params">done</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">async</span>.parallel(threads.filter(not(send(<span class="string">'isOpen'</span>))).map(get(<span class="string">'open'</span>)), done);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>start</code> 方法通过 <code>send</code> 、<code>not</code>、<code>get</code> 这三个方法来进行过滤、启动的串联。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">HappyThreadPool.js:</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">send</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">receiver</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> receiver[method].call(receiver);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">not</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !f(x);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">attr</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> object[attr];</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>传递 <code>&#39;isOpen&#39;</code> 到 <code>send</code> 返回函数中，<code>receiver</code> 对象绑定调用 <code>isOpen</code> 方法；再传递给 <code>not</code> 返回函数中，返回前面函数结构取反。传递给 <code>threads</code> 的 <code>filter</code> 方法进行筛选；最后通过 <code>get</code> 传递返回的 <code>open</code> 属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HappyThread.js </span><br><span class="line"></span><br><span class="line">    isOpen: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> !!fd;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>HappyThread</code> 对象中 <code>isOpen</code> 通过判断 <code>fd</code> 变量来判断是否创建子进程。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">open: <span class="function"><span class="keyword">function</span>(<span class="params">onReady</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> emitReady = Once(onReady);</span><br><span class="line"></span><br><span class="line">  fd = fork(WORKER_BIN, [id], &#123;</span><br><span class="line">    execArgv: []</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  fd.on(<span class="string">'error'</span>, throwError);</span><br><span class="line">  fd.on(<span class="string">'exit'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">exitCode</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (exitCode !== <span class="number">0</span>) &#123;</span><br><span class="line">      emitReady(<span class="string">'HappyPack: worker exited abnormally with code '</span> + exitCode);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  fd.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> <span class="title">acceptMessageFromWorker</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (message.name === <span class="string">'READY'</span>) &#123;</span><br><span class="line">      emitReady();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (message.name === <span class="string">'COMPILED'</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> filePath = message.sourcePath;</span><br><span class="line"></span><br><span class="line">      callbacks[message.id](message);</span><br><span class="line">      <span class="keyword">delete</span> callbacks[message.id];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>HappyThread</code> 对象的 <code>open</code> 方法首先将 <code>async.parallel</code> 传递过来的 <code>callback</code> 钩子通过 <code>Once</code> 方法封装，避免多次触发，返回成 <code>emitReady</code> 函数。</p>
<p>然后调用 <code>childProcess.fork</code> 传递 <code>HappyWorkerChannel.js</code> 作为子进程执行文件来创建一个子进程，绑定对应的 <code>error</code> 、<code>exit</code> 异常情况的处理，同时绑定最为重要的 <code>message</code> 事件，来接受子进程发来的处理消息。而这里 <code>COMPILED</code> 消息就是对应的子进程完成编译之后会发出的消息。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HappyWorkerChannel.js</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HappyWorkerChannel</span>(<span class="params">id, stream</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fakeCompiler = <span class="keyword">new</span> HappyFakeCompiler(id, stream.send.bind(stream));</span><br><span class="line">  <span class="keyword">var</span> worker = <span class="keyword">new</span> HappyWorker(&#123; compiler: fakeCompiler &#125;);</span><br><span class="line"></span><br><span class="line">  stream.on(<span class="string">'message'</span>, accept);</span><br><span class="line">  stream.send(&#123; name: <span class="string">'READY'</span> &#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 省略消息处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在子进程完成创建之后，会向主进程发送一个 <code>READY</code> 消息，表明已经完成创建，在主进程接受到 <code>READY</code> 消息后，会调用前面封装的 <code>emitReady</code> ，来反馈给 <code>async.parallel</code> 表示完成 <code>open</code> 流程。</p>
<p><strong>6.markStarted: 标记启动</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">markStarted</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  that.state.started = <span class="literal">true</span>;</span><br><span class="line">  callback();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后一步，在完成之前的步骤后，修改状态属性 <code>started</code> 为 <code>true</code>，完成整个插件的启动过程。</p>
<h3 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h3><p><img src="http://gw.alicdn.com/tfs/TB1qd5UOFXXXXXQXXXXXXXXXXXX-1141-720.png" alt=""></p>
<p><strong>1. loader 传递</strong><br>在 webpack 流程中，在源码文件完成内容读取之后，开始进入到 loader 的编译执行阶段，这时 <code>HappyLoader</code> 作为编译逻辑入口，开始进行编译流程。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HappyLoader</span>(<span class="params">sourceCode, sourceMap</span>) </span>&#123;</span><br><span class="line"> <span class="comment">// 省略 Plugin 查找</span></span><br><span class="line"></span><br><span class="line"> happyPlugin.compile(&#123;</span><br><span class="line">    remoteLoaderId: remoteLoaderId,</span><br><span class="line">    sourceCode: sourceCode,</span><br><span class="line">    sourceMap: sourceMap,</span><br><span class="line">    useSourceMap: <span class="keyword">this</span>._module.useSourceMap,</span><br><span class="line">    context: <span class="keyword">this</span>.context,</span><br><span class="line">    request: happyPlugin.generateRequest(<span class="keyword">this</span>.resource),</span><br><span class="line">    resource: <span class="keyword">this</span>.resource,</span><br><span class="line">    resourcePath: <span class="keyword">this</span>.resourcePath,</span><br><span class="line">    resourceQuery: <span class="keyword">this</span>.resourceQuery,</span><br><span class="line">    target: <span class="keyword">this</span>.target,</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, outSourceCode, outSourceMap</span>) </span>&#123;</span><br><span class="line">    callback(<span class="literal">null</span>, outSourceCode, outSourceMap);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>loader</code> 中将 webpack 原本的 <code>loaderContext(this指向)</code> 对象的一些参数例如 <code>this.resource</code>、<code>this.resourcePath</code>等透传到 <code>HappyPlugin.compile</code> 方法进行编译。</p>
<p><strong>2. plugin 编译逻辑运行</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">HappyPlugin.js: </span><br><span class="line"></span><br><span class="line">HappyPlugin.prototype.compile = <span class="function"><span class="keyword">function</span>(<span class="params">loaderContext, done</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 省略 foregroundWorker 情况</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.compileInBackground(loaderContext, done);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HappyPlugin.prototype.compileInBackground = <span class="function"><span class="keyword">function</span>(<span class="params">loaderContext, done</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cache = <span class="keyword">this</span>.cache;</span><br><span class="line">  <span class="keyword">var</span> filePath = loaderContext.resourcePath;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!cache.hasChanged(filePath) &amp;&amp; !cache.hasErrored(filePath)) &#123;</span><br><span class="line">    <span class="keyword">var</span> cached = <span class="keyword">this</span>.readFromCache(filePath);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> done(<span class="literal">null</span>, cached.sourceCode, cached.sourceMap);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>._performCompilationRequest(<span class="keyword">this</span>.threadPool.get(), loaderContext, done);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>HappyPlugin</code> 中的 <code>compile</code> 方法对应 build 过程，通过调用 <code>compileInBackground</code> 方法来完成调用。</p>
<p><strong>2.1 构建缓存判断 </strong></p>
<p>在 <code>compileInBackground</code> 中，首先会代用 cache 的 <code>hasChanged</code> 和 <code>hasErrored</code> 方法来判断是否可以从缓存中读取构建文件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HappyFSCache.js</span></span><br><span class="line">  exports.hasChanged = <span class="function"><span class="keyword">function</span>(<span class="params">filePath</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> nowMTime = generateSignature(filePath);</span><br><span class="line">    <span class="keyword">var</span> lastMTime = getSignatureAtCompilationTime(filePath);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nowMTime !== lastMTime;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  exports.hasErrored = <span class="function"><span class="keyword">function</span>(<span class="params">filePath</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cache.mtimes[filePath] &amp;&amp; cache.mtimes[filePath].error;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getSignatureAtCompilationTime</span>(<span class="params">filePath</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cache.mtimes[filePath]) &#123;</span><br><span class="line">      <span class="keyword">return</span> cache.mtimes[filePath].mtime;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><code>hasError</code> 判断的是更新缓存的时候的 <code>error</code> 属性是否存在。</p>
<p><code>hasChanged</code> 中会去比较 <code>nowMTime</code> 与 <code>lastMTime</code> 两个是否相等。实际上这里 <code>nowMTime</code> 通过调用 <code>generateSignature</code>（默认是 <code>getMTime</code>  函数） 返回的是文件目前的最后修改时间，<code>lastMTime</code> 返回的是编译完成时的修改时间。</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">getMTime</span>(filePath) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">fs.statSync(filePath).mtime.getTime()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 <code>nowMTime</code>、<code>lastMTime</code> 两个的最后修改时间相同且不存在错误，那么说明构建可以利用缓存</p>
<p><strong>2.1.1 缓存生效</strong></p>
<p>如果缓存判断生效，那么开始调用 <code>readFromCache</code> 方法，从缓存中读取构建对应文件内容。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HappyPlugin.js: </span></span><br><span class="line"></span><br><span class="line">HappyPlugin.prototype.readFromCache = <span class="function"><span class="keyword">function</span>(<span class="params">filePath</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cached = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> sourceCodeFilePath = <span class="keyword">this</span>.cache.getCompiledSourceCodePath(filePath);</span><br><span class="line">  <span class="keyword">var</span> sourceMapFilePath = <span class="keyword">this</span>.cache.getCompiledSourceMapPath(filePath);</span><br><span class="line"></span><br><span class="line">  cached.sourceCode = fs.readFileSync(sourceCodeFilePath, <span class="string">'utf-8'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (HappyUtils.isReadable(sourceMapFilePath)) &#123;</span><br><span class="line">    cached.sourceMap = SourceMapSerializer.deserialize(</span><br><span class="line">      fs.readFileSync(sourceMapFilePath, <span class="string">'utf-8'</span>)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> cached;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>函数的意图是通过 <code>cache</code> 对象的 <code>getCompiledSourceCodePath</code> 、<code>getCompiledSourceMapPath</code> 方法获取缓存的编译文件及 sourcemap 文件的存储路径，然后读取出来，完成从缓存中获取构建内容。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HappyFSCache.js</span></span><br><span class="line"></span><br><span class="line">  exports.getCompiledSourceCodePath = <span class="function"><span class="keyword">function</span>(<span class="params">filePath</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cache.mtimes[filePath] &amp;&amp; cache.mtimes[filePath].compiledPath;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  exports.getCompiledSourceMapPath = <span class="function"><span class="keyword">function</span>(<span class="params">filePath</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cache.mtimes[filePath] &amp;&amp; cache.mtimes[filePath].compiledPath + <span class="string">'.map'</span>;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>获取的路径是通过在完成编译时调用的 <code>updateMTimeFor</code> 进行存储的对象中的 <code>compiledPath</code> 编译路径属性。</p>
<p><strong>2.1.2 缓存失效</strong></p>
<p>在缓存判断失效的情况下，进入 <code>_performCompilationRequest</code> ，进行下一步 <code>happypack</code> 编译流程。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HappyPlugin.prototype.compileInBackground = <span class="function"><span class="keyword">function</span>(<span class="params">loaderContext, done</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>._performCompilationRequest(<span class="keyword">this</span>.threadPool.get(), loaderContext, done);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在调用 <code>_performCompilationRequest</code> 前， 还有一步是从 <code>ThreadPool</code> 获取对应的子进程封装对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HappyThreadPool.js</span></span><br><span class="line"></span><br><span class="line">get: RoundRobinThreadPool(threads),</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">RoundRobinThreadPool</span>(<span class="params">threads</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> lastThreadId = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">getThread</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> threadId = lastThreadId;</span><br><span class="line"></span><br><span class="line">    lastThreadId++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lastThreadId &gt;= threads.length) &#123;</span><br><span class="line">      lastThreadId = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> threads[threadId];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里按照递增返回的 <a href="https://zh.wikipedia.org/wiki/%E5%BE%AA%E7%92%B0%E5%88%B6" target="_blank" rel="external">round-robin</a>，这种在服务器进程控制中经常使用的简洁算法返回子进程封装对象。</p>
<p><strong>3. 编译开始</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">HappyPlugin.prototype._performCompilationRequest = <span class="function"><span class="keyword">function</span>(<span class="params">worker, loaderContext, done</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cache = <span class="keyword">this</span>.cache;</span><br><span class="line">  <span class="keyword">var</span> filePath = loaderContext.resourcePath;</span><br><span class="line"></span><br><span class="line">  cache.invalidateEntryFor(filePath);</span><br><span class="line"></span><br><span class="line">  worker.compile(&#123;</span><br><span class="line">    loaders: <span class="keyword">this</span>.state.loaders,</span><br><span class="line">    compiledPath: path.resolve(<span class="keyword">this</span>.config.tempDir,  </span><br><span class="line">    HappyUtils.generateCompiledPath(filePath)),</span><br><span class="line">    loaderContext: loaderContext,</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> contents = fs.readFileSync(result.compiledPath, <span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="keyword">var</span> compiledMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!result.success) &#123;</span><br><span class="line">      cache.updateMTimeFor(filePath, <span class="literal">null</span>, contents);</span><br><span class="line">      done(contents);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      cache.updateMTimeFor(filePath, result.compiledPath);</span><br><span class="line">      compiledMap = SourceMapSerializer.deserialize(</span><br><span class="line">        fs.readFileSync(cache.getCompiledSourceMapPath(filePath), <span class="string">'utf-8'</span>)</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      done(<span class="literal">null</span>, contents, compiledMap);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>首先对编译的文件，调用 <code>cache.invalidateEntryFor</code> 设置该文件路径的构建缓存失效。然后调用子进程封装对象的 compile 方法，触发子进程进行编译。</p>
<p>同时会生成衔接主进程、子进程、缓存的 <code>compiledPath</code>，当子进程完成编译后，会将编译后的代码写入 <code>compiledPath</code>，之后发送完成编译的消息回主进程，主进程也是通过 <code>compiledPath</code> 获取构建后的代码，同时传递 <code>compiledPath</code> 以及对应的编译前文件路径 <code>filePath</code>，更新缓存设置。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HappyThread.js</span></span><br><span class="line"></span><br><span class="line">    compile: <span class="function"><span class="keyword">function</span>(<span class="params">params, done</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> messageId = generateMessageId();</span><br><span class="line"></span><br><span class="line">      callbacks[messageId] = done;</span><br><span class="line"></span><br><span class="line">      fd.send(&#123;</span><br><span class="line">        id: messageId,</span><br><span class="line">        name: <span class="string">'COMPILE'</span>,</span><br><span class="line">        data: params,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里的 messageId 是个从 0 开始的递增数字，完成回调方法的存储注册，方便完成编译之后找到回调方法传递信息回主进程。同时在 <code>thread</code> 这一层，也是将参数透传给子进程执行编译。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HappyWorkerChannel.js</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">accept</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (message.name === <span class="string">'COMPILE'</span>) &#123;</span><br><span class="line">      worker.compile(message.data, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">        stream.send(&#123;</span><br><span class="line">          id: message.id,</span><br><span class="line">          name: <span class="string">'COMPILED'</span>,</span><br><span class="line">          sourcePath: result.sourcePath,</span><br><span class="line">          compiledPath: result.compiledPath,</span><br><span class="line">          success: result.success</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//省略其他操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子进程接到消息后，调用 <code>worker.compile</code> 方法 ,同时进一步传递构建参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HappyWorker.js</span></span><br><span class="line"></span><br><span class="line">HappyWorker.prototype.compile = <span class="function"><span class="keyword">function</span>(<span class="params">params, done</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  applyLoaders(&#123;</span><br><span class="line">    compiler: <span class="keyword">this</span>._compiler,</span><br><span class="line">    loaders: params.loaders,</span><br><span class="line">    loaderContext: params.loaderContext,</span><br><span class="line">  &#125;, params.loaderContext.sourceCode, params.loaderContext.sourceMap, <span class="function"><span class="keyword">function</span>(<span class="params">err, source, sourceMap</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> compiledPath = params.compiledPath;</span><br><span class="line">    <span class="keyword">var</span> success = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(err);</span><br><span class="line">      fs.writeFileSync(compiledPath, serializeError(err), <span class="string">'utf-8'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      fs.writeFileSync(compiledPath, source);</span><br><span class="line">      fs.writeFileSync(compiledPath + <span class="string">'.map'</span>, SourceMapSerializer.serialize(sourceMap));</span><br><span class="line"></span><br><span class="line">      success = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    done(&#123;</span><br><span class="line">      sourcePath: params.loaderContext.resourcePath,</span><br><span class="line">      compiledPath: compiledPath,</span><br><span class="line">      success: success</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在 HappyWorker.js 中的 <code>compile</code> 方法中，调用 <code>applyLoaders</code> 进行 loader 方法执行。<code>applyLoaders</code> 是 <code>happypack</code> 中对 <code>webpack</code> 中 loader 执行过程进行模拟，对应 NormalModuleMixin.js 中的 <a href="https://github.com/webpack/core/blob/master/lib/NormalModuleMixin.js#L49" target="_blank" rel="external"><code>doBuild</code></a> 方法。完成对文件的字符串处理编译。</p>
<p>根据 <code>err</code> 判断是否成功。如果判断成功，则将对应文件的编译后内容写入之前传递进来的 <code>compiledPath</code>,反之，则会把错误内容写入。</p>
<p>在子进程完成编译流程后，会调用传递进来的回调方法，在回调方法中将编译信息返回到主进程，主进程根据 <code>compiledPath</code> 来获取子进程的编译内容。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HappyPlugin.js</span></span><br><span class="line"></span><br><span class="line">HappyPlugin.prototype._performCompilationRequest = <span class="function"><span class="keyword">function</span>(<span class="params">worker, loaderContext, done</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> contents = fs.readFileSync(result.compiledPath, <span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="keyword">var</span> compiledMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!result.success) &#123;</span><br><span class="line">      cache.updateMTimeFor(filePath, <span class="literal">null</span>, contents);</span><br><span class="line">      done(contents);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      cache.updateMTimeFor(filePath, result.compiledPath);</span><br><span class="line">      compiledMap = SourceMapSerializer.deserialize(</span><br><span class="line">        fs.readFileSync(cache.getCompiledSourceMapPath(filePath), <span class="string">'utf-8'</span>)</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      done(<span class="literal">null</span>, contents, compiledMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取子进程的编译内容 <code>contents</code> 后，根据 <code>result.success</code> 属性来判断是否编译成功，如果失败的话，会将 <code>contents</code> 作为错误传递进去。</p>
<p>在完成调用 <code>updateMTimeFor</code> 缓存更新后，最后将内容返回到 HappyLoader.js 中的回调中，返回到 webpack 的原本流程。</p>
<p><strong>4. 编译结束</strong></p>
<p>当 webpack 整体编译流程结束后， <code>happypack</code> 开始进行一些善后工作 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HappyPlugin.js</span></span><br><span class="line"></span><br><span class="line">compiler.plugin(<span class="string">'done'</span>, that.stop.bind(that));</span><br><span class="line"></span><br><span class="line">HappyPlugin.prototype.stop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.config.cache) &#123;</span><br><span class="line">    <span class="keyword">this</span>.cache.save();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.threadPool.stop();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>4.1. 存储缓存配置</strong></p>
<p>首先调用 <code>cache.save()</code> 存储下这个缓存的映射设置。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HappyFSCache.js</span></span><br><span class="line"></span><br><span class="line">  exports.save = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    fs.writeFileSync(cachePath, <span class="built_in">JSON</span>.stringify(cache));</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>cache 对象的处理是会将这个文件直接写入 <code>cachePath</code> ，这样就能供下一次 <code>cache.load</code> 方法装载配置，利用缓存。</p>
<p><strong>4.2. 终止子进程 </strong></p>
<p>其次调用 <code>threadPool.stop</code> 来终止掉进程</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HappyThreadPool.js</span></span><br><span class="line"></span><br><span class="line">   stop: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      threads.filter(send(<span class="string">'isOpen'</span>)).map(send(<span class="string">'close'</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>类似前面提到的 <code>start</code> 方法，这里是筛选出来正在运行的 <code>HappyThread</code> 对象，调用 <code>close</code> 方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HappyThread.js</span></span><br><span class="line"></span><br><span class="line">    close: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      fd.kill(<span class="string">'SIGINT'</span>);</span><br><span class="line">      fd = <span class="literal">null</span>;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>
<p>在 <code>HappyThread</code> 中，则是调用 <code>kill</code> 方法，完成子进程的释放。</p>
<h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><p>happypack 的处理思路是将原有的 webpack 对 loader 的执行过程从单一进程的形式扩展多进程模式，原本的流程保持不变。整个流程代码结构上还是比较清晰，在使用过程中，也确实有明显提升，有兴趣的同学可以一起下来交流~</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="https://img.alicdn.com/tfs/TB15ZeJOFXXXXcYXVXXXXXXXXXX-900-500.jpg" alt="happypack 原理解析"></p>
<p>说起 <a href="https://www.npmjs.]]>
    </summary>
    
      <category term="happypack" scheme="http://taobaofed.org/tags/happypack/"/>
    
      <category term="工具&amp;平台" scheme="http://taobaofed.org/categories/%E5%B7%A5%E5%85%B7-%E5%B9%B3%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[React 组件间通讯]]></title>
    <link href="http://taobaofed.org/blog/2016/11/17/react-components-communication/"/>
    <id>http://taobaofed.org/blog/2016/11/17/react-components-communication/</id>
    <published>2016-11-17T06:54:48.000Z</published>
    <updated>2017-03-18T09:50:27.000Z</updated>
    <content type="html"><![CDATA[<p><img src="//img.alicdn.com/tfs/TB1KBJsOpXXXXaeXFXXXXXXXXXX-900-500.jpg" alt="React 组件间通讯"></p>
<h2 id="React-组件间通讯"><a href="#React-组件间通讯" class="headerlink" title="React 组件间通讯"></a>React 组件间通讯</h2><p>说 React 组件间通讯之前，我们先来讨论一下 React 组件究竟有多少种层级间的关系。假设我们开发的项目是一个纯 React 的项目，那我们项目应该有如下类似的关系：</p>
<p><img src="http://img.alicdn.com/tfs/TB19qddNVXXXXcbXVXXXXXXXXXX-1712-910.png" alt=""></p>
<p>父子：Parent 与 Child_1、Child_2、Child_1_1、Child_1_2、Child_2_1</p>
<p>兄弟：Child_1 与 Child_2、Child_1_1 与 Child_2、etc.</p>
<p>针对这些关系，我们将来好好讨论一下这些关系间的通讯方式。</p>
<p>（在 React 中，React 组件之间的关系为从属关系，与 DOM 元素之间的父子关系有所不同，下面只是为了说明方便，将 React 组件的关系类比成父子关系进行阐述）</p>
<h3 id="父组件向子组件通讯"><a href="#父组件向子组件通讯" class="headerlink" title="父组件向子组件通讯"></a>父组件向子组件通讯</h3><p>通讯是单向的，数据必须是由一方传到另一方。在 React 中，父组件可以向子组件通过传 props 的方式，向子组件进行通讯。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    msg: <span class="string">'start'</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        msg: <span class="string">'end'</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Child_1</span> <span class="attr">msg</span>=<span class="string">&#123;this.state.msg&#125;</span> /&gt;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child_1 extends Component&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;this.props.msg&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>如果父组件与子组件之间不止一个层级，如 Parent 与 Child_1_1 这样的关系，可通过 <code>... 运算符</code>（Object 剩余和展开属性），将父组件的信息，以更简洁的方式传递给更深层级的子组件。通过这种方式，不用考虑性能的问题，通过 babel 转义后的  <code>... 运算符</code> 性能和原生的一致，且上级组件 props 与 state 的改变，会导致组件本身及其子组件的生命周期改变，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 ... 运算符 向 Child_1_1 传递 Parent 组件的信息</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child_1</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;this.props.msg&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Child_1_1</span> &#123;<span class="attr">...this.props</span>&#125;/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child_1_1 extends Component&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;this.props.msg&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="子组件向父组件通讯"><a href="#子组件向父组件通讯" class="headerlink" title="子组件向父组件通讯"></a>子组件向父组件通讯</h3><p>在上一个例子中，父组件可以通过传递 props 的方式，自顶而下向子组件进行通讯。而子组件向父组件通讯，同样也需要父组件向子组件传递 props 进行通讯，只是父组件传递的，是作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信息，作为参数，传递到父组件的作用域中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    msg: <span class="string">'start'</span></span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  transferMsg(msg) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      msg</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>child msg: &#123;this.state.msg&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Child_1</span> <span class="attr">transferMsg</span> = <span class="string">&#123;msg</span> =&gt;</span> this.transferMsg(msg)&#125; /&gt;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child_1 extends Component&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      this.props.transferMsg('end')</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>child_1 component<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，我们使用了 <code>箭头函数</code>，将父组件的 transferMsg 函数通过 props 传递给子组件，得益于箭头函数，保证子组件在调用 transferMsg 函数时，其内部 <code>this</code> 仍指向父组件。</p>
<p>当然，对于层级比较深的子组件与父组件之间的通讯，仍可使用  <code>... 运算符</code>，将父组件的调用函数传递给子组件，具体方法和上面的例子类似。</p>
<h3 id="兄弟组件间通讯"><a href="#兄弟组件间通讯" class="headerlink" title="兄弟组件间通讯"></a>兄弟组件间通讯</h3><p>对于没有直接关联关系的两个节点，就如 Child_1 与 Child_2 之间的关系，他们唯一的关联点，就是拥有相同的父组件。参考之前介绍的两种关系的通讯方式，如果我们向由 Child_1 向 Child_2 进行通讯，我们可以先通过 Child_1 向 Parent 组件进行通讯，再由 Parent 向 Child_2 组件进行通讯，所以有以下代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    msg: <span class="string">'start'</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  transferMsg(msg) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      msg</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Parent update'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Child_1 transferMsg = &#123;msg =&gt; this.transferMsg(msg)&#125; /&gt;</span><br><span class="line">        &lt;Child_2 msg = &#123;this.state.msg&#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child_1 extends Component&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      this.props.transferMsg('end')</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate() &#123;</span><br><span class="line">    console.log('Child_1 update');</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">      &lt;p&gt;child_1 component&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child_2 extends Component&#123;</span><br><span class="line">  componentDidUpdate() &#123;</span><br><span class="line">    console.log('Child_2 update');</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">      &lt;p&gt;child_2 component: &#123;this.props.msg&#125;&lt;/p&gt;</span><br><span class="line">      &lt;Child_2_1 /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child_2_1 extends Component&#123;</span><br><span class="line">  componentDidUpdate() &#123;</span><br><span class="line">    console.log('Child_2_1 update');</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">      &lt;p&gt;child_2_1 component&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而，这个方法有一个问题，由于 Parent 的 state 发生变化，会触发 Parent 及从属于 Parent 的子组件的生命周期，所以我们在控制台中可以看到，在各个组件中的 componentDidUpdate 方法均被触发。</p>
<p><img src="https://img.alicdn.com/tfs/TB1VjpZNVXXXXcIXXXXXXXXXXXX-268-152.png" alt=""></p>
<p>有没有更好的解决方式来进行兄弟组件间的通讯，甚至是父子组件层级较深的通讯的呢？</p>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>在传统的前端解耦方面，观察者模式作为比较常见一种设计模式，大量使用在各种框架类库的设计当中。即使我们在写 React，在写 JSX，我们核心的部分还是 JavaScript。</p>
<p>观察者模式也叫 <code>发布者-订阅者模式</code>，发布者发布事件，订阅者监听事件并做出反应，对于上面的代码，我们引入一个小模块，使用观察者模式进行改造。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> eventProxy <span class="keyword">from</span> <span class="string">'../eventProxy'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Child_1</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Child_2</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// componentDidUpdate 与 render 方法与上例一致</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child_1</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      <span class="comment">// 发布 msg 事件</span></span><br><span class="line">      eventProxy.trigger(<span class="string">'msg'</span>, <span class="string">'end'</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// componentDidUpdate 方法与上例一致</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child_2</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    msg: <span class="string">'start'</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">  	<span class="comment">// 监听 msg 事件</span></span><br><span class="line">    eventProxy.on(<span class="string">'msg'</span>, (msg) =&gt; &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        msg</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>child_2 component: &#123;this.state.msg&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Child_2_1</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在 child_2 组件的 componentDidMount 中订阅了 <code>msg</code> 事件，并在 child_1 componentDidMount 中，在 1s 后发布了 <code>msg</code> 事件，child_2 组件对 <code>msg</code> 事件做出相应，更新了自身的 state，我们可以看到，由于在整个通讯过程中，只改变了 child_2 的 state，因而只有 child_2 和 child_2_1 出发了一次更新的生命周期。</p>
<p><img src="https://img.alicdn.com/tfs/TB1WLJFNVXXXXaeXVXXXXXXXXXX-322-82.png" alt=""></p>
<p>而上面代码中，神奇的 eventProxy.js 究竟是怎样的一回事呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eventProxy.js</span></span><br><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">const</span> eventProxy = &#123;</span><br><span class="line">  onObj: &#123;&#125;,</span><br><span class="line">  oneObj: &#123;&#125;,</span><br><span class="line">  on: <span class="function"><span class="keyword">function</span>(<span class="params">key, fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.onObj[key] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.onObj[key] = [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.onObj[key].push(fn);</span><br><span class="line">  &#125;,</span><br><span class="line">  one: <span class="function"><span class="keyword">function</span>(<span class="params">key, fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.oneObj[key] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.oneObj[key] = [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.oneObj[key].push(fn);</span><br><span class="line">  &#125;,</span><br><span class="line">  off: <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.onObj[key] = [];</span><br><span class="line">    <span class="keyword">this</span>.oneObj[key] = [];</span><br><span class="line">  &#125;,</span><br><span class="line">  trigger: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> key, args;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">arguments</span>.length == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    key = <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">    args = [].concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.onObj[key] !== <span class="literal">undefined</span></span><br><span class="line">      &amp;&amp; <span class="keyword">this</span>.onObj[key].length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> <span class="keyword">this</span>.onObj[key]) &#123;</span><br><span class="line">        <span class="keyword">this</span>.onObj[key][i].apply(<span class="literal">null</span>, args);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.oneObj[key] !== <span class="literal">undefined</span></span><br><span class="line">      &amp;&amp; <span class="keyword">this</span>.oneObj[key].length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> <span class="keyword">this</span>.oneObj[key]) &#123;</span><br><span class="line">        <span class="keyword">this</span>.oneObj[key][i].apply(<span class="literal">null</span>, args);</span><br><span class="line">        <span class="keyword">this</span>.oneObj[key][i] = <span class="literal">undefined</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.oneObj[key] = [];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> eventProxy;</span><br></pre></td></tr></table></figure>
<p>eventProxy 中，总共有 on、one、off、trigger 这 4 个函数：</p>
<ul>
<li><strong>on、one：</strong>on 与 one 函数用于订阅者监听相应的事件，并将事件响应时的函数作为参数，on 与 one 的唯一区别就是，使用 one 进行订阅的函数，只会触发一次，而 使用 on 进行订阅的函数，每次事件发生相应时都会被触发。</li>
<li><strong>trigger：</strong>trigger 用于发布者发布事件，将除第一参数（事件名）的其他参数，作为新的参数，触发使用 one 与 on 进行订阅的函数。</li>
<li><strong>off：</strong>用于解除所有订阅了某个事件的所有函数。</li>
</ul>
<h3 id="Flux-与-Redux"><a href="#Flux-与-Redux" class="headerlink" title="Flux 与 Redux"></a>Flux 与 Redux</h3><p>Flux 作为 Facebook 发布的一种应用架构，他本身是一种模式，而不是一种框架，基于这个应用架构模式，在开源社区上产生了众多框架，其中最受欢迎的就是我们即将要说的 Redux。更多关于 Flux 和 Redux 的介绍这里就不一一展开，有兴趣的同学可以好好看看 <a href="https://facebook.github.io/flux/docs/overview.html" target="_blank" rel="external">Flux 官方介绍</a>、<a href="http://www.ruanyifeng.com/blog/2016/01/flux.html" target="_blank" rel="external">Flux 架构入门教程–阮一峰</a>等相关资料。<br>下面将来好好聊聊 Redux 在组件间通讯的方式。</p>
<p>Flux 需要四大部分组成：Dispatcher、Stores、Views/Controller-Views、Actions，其中的 Views/Controller-Views 可以理解为我们上面所说的 Parent 组件，其作用是从 state 当中获取到相应的数据，并将其传递给他的子组件（descendants）。而另外 3 个部分，则是由 Redux 来提供了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该例子主要对各组件的 componentDidMount 进行改造，其余部分一致</span></span><br><span class="line"><span class="keyword">import</span> &#123;createStore&#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state = &#123;&#125;, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> action;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> store = createStore(reducer);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child_1</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      store.dispatch(&#123;</span><br><span class="line">        type: <span class="string">'child_2'</span>,</span><br><span class="line">        data: <span class="string">'hello'</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      store.dispatch(&#123;</span><br><span class="line">        type: <span class="string">'child_2_1'</span>,</span><br><span class="line">        data: <span class="string">'bye'</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child_2</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    msg: <span class="string">'start'</span></span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  componentDidUpdate() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Child_2 update'</span>, store.getState());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    store.subscribe(() =&gt; &#123;</span><br><span class="line">      <span class="keyword">let</span> state = store.getState();</span><br><span class="line">      <span class="keyword">if</span> (state.type === <span class="string">'child_2'</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">          msg: state.data</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child_2_1</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    msg: <span class="string">'start'</span></span><br><span class="line">  &#125;;</span><br><span class="line">	</span><br><span class="line">  componentDidUpdate() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Child_2_1 update'</span>, store.getState());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    store.subscribe(() =&gt; &#123;</span><br><span class="line">      <span class="keyword">let</span> state = store.getState();</span><br><span class="line">      <span class="keyword">if</span> (state.type === <span class="string">'child_2_1'</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">          msg: state.data</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>child_2_1 component: &#123;this.state.msg&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，我们将一个名为 <code>reducer</code> 的函数作为参数，生成我们所需要的 store，reducer 接受两个参数，一个是存储在 store 里面的 state，另一个是每一次调用 dispatch 所传进来的 action。reducer 的作用，就是对 dispatch 传进来的 action 进行处理，并将结果返回。而里面的 state 可以通过 store 里面的 getState 方法进行获得，其结果与最后一次通过 reducer 处理后的结果保持一致。</p>
<p>在 child_1 组件中，我们每隔 1s 通过 store 的 dispatch 方法，向 store 传入包含有 type 字段的 action，reducer 直接将 action 进行返回。</p>
<p>而在 child_2 与 child_2_1 组件中，通过 store 的 subscribe 方法，监听 store 的变化，触发 dispatch 后，所有通过 subscribe 进行监听的函数都会作出相应，根据当前通过 store.getState() 获取到的结果进行处理，对当前组件的 state 进行设置。所以我们可以在控制台上看到各个组件更新及存储在 store 中 state 的情况：</p>
<p><img src="https://img.alicdn.com/tfs/TB1lP8FNVXXXXaEapXXXXXXXXXX-884-122.png" alt=""></p>
<p>在 Redux 中，store 的作用，与 MVC 中的 Model 类似，可以将我们项目中的数据传递给 store，交给 store 进行处理，并可以实时通过 store.getState() 获取到存储在 store 中的数据。我们对上面例子的 reducer 及各个组件的 componentDidMount 做点小修改，看看 store 的这一个特性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createStore&#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state = &#123;&#125;, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'child_2'</span>:</span><br><span class="line">      state.child_2 = action.data + <span class="string">' child_2'</span>;</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'child_2_1'</span>:</span><br><span class="line">      state.child_2_1 = action.data + <span class="string">' child_2_1'</span>;</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> store = createStore(reducer);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child_1</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      store.dispatch(&#123;</span><br><span class="line">        type: <span class="string">'child_2'</span>,</span><br><span class="line">        data: <span class="string">'hello'</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      store.dispatch(&#123;</span><br><span class="line">        type: <span class="string">'child_2_1'</span>,</span><br><span class="line">        data: <span class="string">'bye'</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child_2</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    store.subscribe(() =&gt; &#123;</span><br><span class="line">      <span class="keyword">let</span> state = store.getState();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (state.hasOwnProperty(<span class="string">'child_2'</span>)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">          msg: state.child_2</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child_2_1</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    store.subscribe(() =&gt; &#123;</span><br><span class="line">      <span class="keyword">let</span> state = store.getState();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (state.hasOwnProperty(<span class="string">'child_2_1'</span>)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">          msg: state.child_2_1</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们对创建 store 时所传进去的 reducer 进行修改。reducer 中，其参数 state 为当前 store 的值，我们对不同的 action 进行处理，并将处理后的结果存储在 state 中并进行返回。此时，通过 store.getState() 获取到的，就是我们处理完成后的 state。</p>
<p><img src="https://img.alicdn.com/tfs/TB1tsBQNVXXXXaGaXXXXXXXXXXX-1190-216.png" alt=""></p>
<p>Redux 内部的实现，其实也是基于观察者模式的，reducer 的调用结果，存储在 store 内部的 state 中，并在每一次 reducer 的调用中并作为参数传入。所以在 child_1 组件第 2s 的 dispatch 后，child_2 与 child_2_1 组件通过 subscribe 监听的函数，其通过 getState 获得的值，都包含有 child_2 与 child_2_1 字段的，这就是为什么第 2s 后的响应，child_2 也进行了一次生命周期。所以在对 subscribe 响应后的处理，最好还是先校对通过 getState() 获取到的 state 与当前组件的 state 是否相同。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// child_2</span></span><br><span class="line"> componentDidMount() &#123;</span><br><span class="line">    store.subscribe(() =&gt; &#123;</span><br><span class="line">      <span class="keyword">let</span> state = store.getState();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (state.hasOwnProperty(<span class="string">'child_2'</span>)</span><br><span class="line">        &amp;&amp; state.child_2 !== <span class="keyword">this</span>.state.msg) &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">          msg: state.child_2</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>加上这样的校验，各个组件的生命周期的触发就符合我们的预期了。</p>
<p><img src="https://img.alicdn.com/tfs/TB1vH8PNVXXXXaYaXXXXXXXXXXX-1254-132.png" alt=""></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Redux 对于组件间的解耦提供了很大的便利，如果你在考虑该不该使用 Redux 的时候，社区里有一句话说，“当你不知道该不该使用 Redux 的时候，那就是不需要的”。Redux 用起来一时爽，重构或者将项目留给后人的时候，就是个大坑，Redux 中的 dispatch 和 subscribe 方法遍布代码的每一个角落。刚刚的例子不是最好的，Flux 设计中的 Controller-Views 概念就是为了解决这个问题出发的，将所有的 subscribe 都置于 Parent 组件（Controller-Views），由最上层组件控制下层组件的表现，然而，这不就是我们所说的 <code>子组件向父组件通讯</code> 这种方式了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="//img.alicdn.com/tfs/TB1KBJsOpXXXXaeXFXXXXXXXXXX-900-500.jpg" alt="React 组件间通讯"></p>
<h2 id="React-组件间通讯"><a href="#React-组件间通讯]]>
    </summary>
    
      <category term="React" scheme="http://taobaofed.org/tags/React/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[聊一聊 JavaScript 中的错误隔离]]></title>
    <link href="http://taobaofed.org/blog/2016/11/10/prevent-prop-access-error-in-js/"/>
    <id>http://taobaofed.org/blog/2016/11/10/prevent-prop-access-error-in-js/</id>
    <published>2016-11-10T07:52:27.000Z</published>
    <updated>2017-03-18T09:50:27.000Z</updated>
    <content type="html"><![CDATA[<p><img src="//img.alicdn.com/tfs/TB1FOzEOXXXXXcjXFXXXXXXXXXX-900-500.jpg" alt="聊一聊 JavaScript 中的错误隔离"></p>
<p>接口请求失败、接口中部分数据缺失、运营数据不符合预期… 当我们的应用发布上线后，就开始面临这些风险。</p>
<p>而一旦这些问题导致了 JavaScript 报错（如空指针异常），并且没有被有效地隔离，就有可能引发页面的白屏、无法交互等线上问题。</p>
<p>在双 11 准备期间，我们收集了过往一年前端相关的线上问题，在收集的 21 个案例中，竟有一半的问题都与「数据异常触发页面显示异常」这个原因有些相关。</p>
<p>如何将错误的影响隔离在一定范围内，显得尤为重要。</p>
<p>这篇文章就和大家一起来聊一聊我们尝试过的一些方案，及遇到的问题。</p>
<h3 id="从空指针异常说起"><a href="#从空指针异常说起" class="headerlink" title="从空指针异常说起"></a>从空指针异常说起</h3><p>数据引发的最常见的问题就是空指针异常。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="literal">result</span> = a.b.c.d;</span><br></pre></td></tr></table></figure>
<p>这样的代码如同地雷，一旦 <code>a</code> 是一个动态数据，那么问题一触即发。</p>
<p>封装一个 get 的方法来取值，当数据不存在时，返回 <code>undefined</code>，可以快速避免此类问题。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="keyword">get</span>(a, <span class="string">'b.c.d'</span>);</span><br></pre></td></tr></table></figure>
<p>但如同我们期望大家在取值前，都先做判断一样，并不能保证所有人都这么用了，用不用全靠自觉。</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="comment">(a &amp;&amp; a.b &amp;&amp; a.b.c)</span> &#123;</span><br><span class="line">	var result = a.b.c.d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，有了以下的一些方案：</p>
<h3 id="异步数据校验"><a href="#异步数据校验" class="headerlink" title="异步数据校验"></a>异步数据校验</h3><p>对异步数据校验的想法是，在数据获取后、使用前，先做一遍schema校验，检测重要数据缺失、类型不对等异常情况。</p>
<p>与此方案对应的，我们在 <code>fetch</code> 的基础上封装了 <code>fetch-checker</code><sup>注1</sup> 组件。</p>
<p><code>fetch-checker</code> 强制要求用户在请求数据的同时，提供数据对应的 schema：</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">schema</span> = &#123;</span><br><span class="line">    <span class="string">"rule"</span>: &#123;</span><br><span class="line">      <span class="string">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"banner"</span>: &#123;</span><br><span class="line">      <span class="string">"type"</span>: <span class="string">"object"</span>,</span><br><span class="line">      <span class="string">"required"</span>: true,</span><br><span class="line">      <span class="string">"default"</span>: &#123;</span><br><span class="line">        <span class="string">"url"</span>: <span class="string">"https://item.taobao.com/item.htm?id=527331762117"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这份 schema 需要描述：</p>
<ul>
<li>每个字段的类型</li>
<li>字段是否 required</li>
<li>当 required 的字段缺失时，是否需要打底数据</li>
</ul>
<p><code>fetch-checker</code> 在拿到数据后，先做一层校验，如有需要的话，补上缺失的数据，然后再返回给调用者。这样，使用者拿到的数据就一定是符合预期的。</p>
<p>然而，这个方案面临的挑战是：</p>
<ol>
<li>如何确保调用者提供了完整的 schema 描述。不想写 schema，完全可以提供一个粗略的 schema 描述，来通过校验。</li>
<li>schema 如何精简。即不会对 bundle 大小造成太大影响，又能满足校验的功能。</li>
</ol>
<h3 id="代码编译"><a href="#代码编译" class="headerlink" title="代码编译"></a>代码编译</h3><p>受 babel 的启发，这个方案是对存在 NPE 隐患的代码，在编译阶段，将其转换成等价的安全代码。如下所示：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// input</span></span><br><span class="line"><span class="keyword">var</span> result = a.b.c;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="keyword">var</span> result = (_object2 = (_object3 = a) == <span class="literal">null</span> ? <span class="literal">null</span> : _object3.b) == <span class="literal">null</span> ? <span class="literal">null</span> : _object2.c;</span><br></pre></td></tr></table></figure>
<p>当 <code>a</code> 为空对象时，执行编译后的代码会返回 <code>null</code>，从而避免因为代码抛错，阻断后续进程。</p>
<p>在 <code>babel-plugin-safe-member-expression</code><sup>注2</sup> 这个 Babel 插件中，我们做了上述的尝试。目前，cake项目中，已经可以通过 <code>enableSafeMemberExpression</code> 这个配置，选择性的启用该功能。</p>
<p>这个方案相比来说接入成本较低，开发者无需对现有的代码做出调整，但同样存在挑战：</p>
<ul>
<li>开发阶段问题不易暴露，明明应该报错的场景，却没有任何反馈。理想的状态是：开发调试阶段尽可能多的暴露问题，线上则尽可能的减少报错。</li>
<li>隐患的代码如何界定。目前所有的 <code>a.b</code> 的调用方式都会按上述方案进行编译，虽然测试过程中还没有发现问题，但只处理有隐患的代码才更安全。</li>
</ul>
<h3 id="静态校验"><a href="#静态校验" class="headerlink" title="静态校验"></a>静态校验</h3><p>以 <a href="https://flowtype.org/" target="_blank" rel="external">flow</a> 为代表的静态校验工具，可以在一定程度上检测出 NPE 隐患。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> res = &#123;</span><br><span class="line">	<span class="keyword">data</span> ?: Object</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let <span class="keyword">name</span> = res.<span class="keyword">data</span>.<span class="keyword">name</span>;</span><br><span class="line">// property `<span class="keyword">name</span>`. Propery cannot be accessed on possibly undefined <span class="keyword">value</span></span><br></pre></td></tr></table></figure>
<p>如上面的代码所描述的，使用者需要首先理清自己的数据是否允许为空值，当 data 被允许为空值时，通过 flow 检测，<code>data.name</code> 类似这样调用便会被检测出错误。</p>
<p>然而，如何来推进所有的业务都接入静态校验，接入后，又如何保证开发者描述了所有的类型，却同样是个难点。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>总结以上几种方案，各有优缺点，都还不能算做最理想的解决方案。</p>
<table>
<thead>
<tr>
<th>方案名称</th>
<th style="text-align:center">优势</th>
<th style="text-align:right">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>提前判断</td>
<td style="text-align:center">实行简单</td>
<td style="text-align:right">全靠自觉</td>
</tr>
<tr>
<td>异步数据校验</td>
<td style="text-align:center">可确保所使用的数据是满足预期的</td>
<td style="text-align:right">schema 描述成本高</td>
</tr>
<tr>
<td>代码编译</td>
<td style="text-align:center">接入成本低，易执行</td>
<td style="text-align:right">开发阶段不易暴露问题</td>
</tr>
<tr>
<td>静态校验</td>
<td style="text-align:center">对现有代码逻辑侵入少</td>
<td style="text-align:right">落地成本高</td>
</tr>
</tbody>
</table>
<p>对于业务来说，最愿意使用和有效的方案一定是：</p>
<ul>
<li>能将线上问题隔离在一个小范围内，同时不影响开发调试阶段的问题暴露</li>
<li>能提前暴露出隐患</li>
<li>接入成本低，不需要大量修改现有业务代码</li>
</ul>
<p>关于空指针异常和错误隔离，机智的你又有哪些方案，一起来讨论吧。</p>
<h6 id="编者注-本文提到的所有工具如未提供链接，可能是内部代码，暂未对外公布。"><a href="#编者注-本文提到的所有工具如未提供链接，可能是内部代码，暂未对外公布。" class="headerlink" title="编者注: 本文提到的所有工具如未提供链接，可能是内部代码，暂未对外公布。"></a>编者注: 本文提到的所有工具如未提供链接，可能是内部代码，暂未对外公布。</h6>]]></content>
    <summary type="html">
    <![CDATA[<p><img src="//img.alicdn.com/tfs/TB1FOzEOXXXXXcjXFXXXXXXXXXX-900-500.jpg" alt="聊一聊 JavaScript 中的错误隔离"></p>
<p>接口请求失败、接口中部分数据缺失、运营数据不符合预期… 当]]>
    </summary>
    
      <category term="错误隔离" scheme="http://taobaofed.org/tags/%E9%94%99%E8%AF%AF%E9%9A%94%E7%A6%BB/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ES6 你可能不知道的事 - 进阶篇]]></title>
    <link href="http://taobaofed.org/blog/2016/11/03/es6-advanced/"/>
    <id>http://taobaofed.org/blog/2016/11/03/es6-advanced/</id>
    <published>2016-11-03T05:11:51.000Z</published>
    <updated>2017-03-18T09:50:27.000Z</updated>
    <content type="html"><![CDATA[<p><img src="https://img.alicdn.com/tfs/TB1xlp2OXXXXXaXXVXXXXXXXXXX-900-500.jpg" alt="ES6 你可能不知道的事 - 进阶篇"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章主要会针对上篇未涉及到的进阶特性展开；而与<a href="http://taobaofed.org/blog/2016/07/22/es6-basics/">前一篇文章</a>相同，本文主要介绍这些特性的一些容易忽略的部分，希望能对大家正确认识和使用 ES6 有帮助。</p>
<p>还是那句话，时间和能力有限，针对文章中的问题或不同意见，欢迎随时拍砖、指正！</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h4 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h4><p>模块化是个进行了很久的话题，发展历程中出现过很多模式，例如 AMD, CommonJS 等等。</p>
<p><code>Module</code> 是 ES6 的新特性，是语言层面对模块化的支持。</p>
<blockquote>
<p>与之前模块加载机制不同，Module 是动态的加载，导入的是变量的 <strong>只读引用</strong> ，而不是拷贝</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. export default 可以做默认导出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="number">5</span>;      <span class="comment">// 默认导出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">import</span> b, &#123;a&#125; <span class="keyword">from</span> <span class="string">'./a.js'</span>;    <span class="comment">// 默认导入，不需要加花括号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 动态的加载机制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  a = <span class="number">15</span>;</span><br><span class="line">  b = <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;a, b, add&#125; <span class="keyword">from</span> <span class="string">'./a.js'</span>;</span><br><span class="line">a+b;    <span class="comment">// 20</span></span><br><span class="line">add();  <span class="comment">// 35</span></span><br><span class="line">a+b;    <span class="comment">// 35</span></span><br></pre></td></tr></table></figure>
<h4 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h4><p><code>symbol</code> 是 ES6 的一个新特性，他有如下特点：</p>
<ul>
<li><code>symbol</code> 是一个 “新” 的 <strong>基础数据类型</strong> ；从 ES6 起，JavaScript 的 <strong>基础数据类型</strong> 变为 6 个：<code>string</code>, <code>number</code>, <code>boolean</code>, <code>null</code>, <code>undefined</code>, <code>symbol</code></li>
<li><code>symbol</code> 可以用作 <code>Object</code> 的 key</li>
<li><code>symbol</code> 存在全局作用域，利用 <code>Symbol.for(key)</code> 方法，可以创建（全局作用域无指定键）或获取全局作用域内的 <code>symbol</code> ；利用 <code>Symbol.keyFor(sym)</code> 方法，可以获取指定 <code>symbol</code> 的键</li>
<li>JavaScript 内部使用了很多内置 <code>symbol</code> ，作为特殊的键，来实现一些内部功能；例如 <code>Symbol.iterator</code> 用于标示对象的<a href="#Iterators + For..Of">迭代器</a></li>
</ul>
<blockquote>
<p>“新” 仅仅是针对前端开发人员来说的，其实 Symbol 概念本身已经在 JavaScript 语言内部长时间使用了</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. "Symbol(desc)" 方法用于创建一个新的 symbol，参数 "desc" 仅用做 symbol 的描述，并不用于唯一标示 symbol</span></span><br><span class="line"><span class="built_in">Symbol</span>(<span class="string">'abc'</span>) === <span class="built_in">Symbol</span>(<span class="string">'abc'</span>);    <span class="comment">// false，'abc'仅作为两个 symbol 的描述信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. "Symbol.for(key)" 方法，参数 "key" 是用于在全局作用域中标示 symbol 的唯一键，同时也作为该 symbol 的描述信息</span></span><br><span class="line"><span class="built_in">Symbol</span>.for(<span class="string">'abc'</span>) === <span class="built_in">Symbol</span>.for(<span class="string">'abc'</span>);    <span class="comment">// true，左侧为创建，右侧为获取</span></span><br><span class="line"><span class="built_in">Symbol</span>.for(<span class="string">'abc'</span>) === <span class="built_in">Symbol</span>(<span class="string">'abc'</span>);        <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. symbol 无法被 for...in 遍历到 (不可枚举)，可以利用 Object.getOwnPropertySymbols 获取</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">'abc'</span>)]: <span class="string">'abc'</span>,</span><br><span class="line">  <span class="string">'abc'</span>: <span class="string">'abc'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> obj)&#123;  <span class="comment">// abc</span></span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertySymbols(obj);    <span class="comment">// [Symbol(abc)]</span></span><br></pre></td></tr></table></figure>
<h4 id="Iterator-For-Of"><a href="#Iterator-For-Of" class="headerlink" title="Iterator + For..Of"></a>Iterator + For..Of</h4><p>ES6 中除了新特性外，还有一个新的规范，那就是关于迭代的规范，他包括两部分分别是 “可迭代规范（iterable protocol）” 和 “迭代器规范（iterator protocol）”。任何实现了前者的对象，都可以进行 <code>for…of</code> 循环。</p>
<p><code>String</code>, <code>Array</code>, <code>Map</code>, <code>Set</code>等是原生可迭代对象，因为他们都在原型（prototype）对象中实现了 Symbol.iterator 键对应的方法</p>
<blockquote>
<p><code>for…of</code> 是对象迭代器的遍历，而 <code>for…in</code> 是对象中 可枚举 值的遍历</p>
</blockquote>
<p>下面用代码来解释一下两个规范：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 迭代器规范</span></span><br><span class="line"><span class="keyword">const</span> iter = &#123;</span><br><span class="line">  counter: <span class="number">0</span>,</span><br><span class="line">  next()&#123;    <span class="comment">// 迭代器是实现了 "next()" 函数的对象</span></span><br><span class="line">    <span class="keyword">if</span>(++<span class="keyword">this</span>.counter &lt; <span class="number">10</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;    <span class="comment">// 返回一个含有两个键值对的对象，Object &#123;done =&gt; boolean, value =&gt; any&#125;</span></span><br><span class="line">        done: <span class="literal">false</span>,</span><br><span class="line">        value: <span class="keyword">this</span>.counter</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.counter = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span> &#123;    <span class="comment">// done = true 时，value非必须</span></span><br><span class="line">        done: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 可迭代规范，实现 "Symbol.iterator =&gt; func()" 键值对；而 "func()" 返回一个 迭代器对象</span></span><br><span class="line"><span class="keyword">const</span> iterObj = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">of</span> iterObj)&#123;&#125;;    <span class="comment">// TypeError: iterObj is not iterable</span></span><br><span class="line">iterObj[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> iter;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">of</span> iterObj)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);    <span class="comment">// 1,2,3,4,5,6,7,8,9</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="关于集合"><a href="#关于集合" class="headerlink" title="关于集合"></a>关于集合</h3><p>原来我们使用集合，多数情况下会直接用 <code>Object</code> 代替，ES6新增了两个特性，<code>Map</code> 和 <code>Set</code>，他们是对 JavaScript 关于集合概念的补充。</p>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>刚刚看到这个概念的同学会有几个常见的疑问，为什么我们需要 <code>Map</code> 这种数据结构？直接用 <code>Object</code> 不好么？ 是不是 <code>Map</code> 可以完全取代 <code>Object</code> 用于数据存取？</p>
<p><code>Map</code> 与 <code>Object</code> 的区别</p>
<ul>
<li><code>Map</code> 与 <code>Object</code> 都可以存取数据，<code>Map</code> 适用于存储需要 <strong>常需要变化（增减键值对）或遍历</strong> 的数据集，而 <code>Object</code> 适用于存储 <strong>静态</strong> （例如配置信息）数据集</li>
<li><code>Object</code> 的 key 必须是 <code>String</code> 或 <code>Symbol</code> 类型的，而 <code>Map</code> 无此限制，可以是任何值</li>
<li><code>Map</code> 可以很方便的取到键值对数量，而 <code>Object</code> 需要用额外途径</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. Map 的构造函数可以传入一个 “可迭代的对象（例如数组）”，其中包含键值对数组</span></span><br><span class="line"><span class="keyword">const</span> first = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'a'</span>, <span class="number">1</span>], [&#123;<span class="string">'b'</span>: <span class="number">1</span>&#125;, <span class="number">2</span>]]);    <span class="comment">// Map &#123;"a" =&gt; 1, Object &#123;b: 1&#125; =&gt; 2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Map 的键可以是任何值，甚至是 undefined 或 null</span></span><br><span class="line">first.set(<span class="literal">null</span>, <span class="number">1</span>).set(<span class="literal">undefined</span>, <span class="number">0</span>);    <span class="comment">// Map &#123;"a" =&gt; 1, Object &#123;b: 1&#125; =&gt; 2, null =&gt; 1, undefined =&gt; 0&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p><code>Set</code> 作为最简单的集合，有着如下几个特点：</p>
<ul>
<li><code>Set</code> 可以存储任何类型的值，遍历顺序与 <strong>插入顺序相同</strong></li>
<li><code>Set</code> 内无重复的值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. Set 的构造函数可以传入一个 “可迭代的对象（例如数组）”，其中包含任意值</span></span><br><span class="line"><span class="keyword">const</span> first = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'a'</span>, <span class="number">1</span>, &#123;<span class="string">'b'</span>: <span class="number">1</span>&#125;, <span class="literal">null</span>]);    <span class="comment">// Set &#123;"a", 1, Object &#123;b: 1&#125;, null&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Set 无法插入重复的值</span></span><br><span class="line">first.add(<span class="number">1</span>);    <span class="comment">// Set &#123;"a", 1, Object &#123;b: 1&#125;, null&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="WeakMap-WeakSet"><a href="#WeakMap-WeakSet" class="headerlink" title="WeakMap + WeakSet"></a>WeakMap + WeakSet</h4><p><code>WeakMap</code> 与 <code>WeakSet</code> 作为一个比较新颖的概念，其主要特点在于弱引用。</p>
<p>相比于 <code>Map</code> 与 <code>Set</code> 的强引用，弱引用可以令对象在 “适当” 情况下正确被 GC 回收，减少内存资源浪费。</p>
<p><strong>但由于不是强引用，所以无法进行遍历或取得值数量，只能用于值的存取（WeakMap）或是否存在值得判断（WeakSet）</strong></p>
<blockquote>
<p>在弱引用的情况下，GC 回收时，不会把其视作一个引用；如果没有其他强引用存在，那这个对象将被回收</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. WeakMap 键必须是对象</span></span><br><span class="line"><span class="keyword">const</span> err = <span class="keyword">new</span> <span class="built_in">WeakMap</span>([[<span class="string">'a'</span>,<span class="number">1</span>]]);    <span class="comment">// TypeError: Invalid value used as weak map key</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. WeakMap/WeakSet 的弱引用</span></span><br><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>([[&#123;<span class="string">'a'</span>:<span class="number">1</span>&#125;,<span class="number">1</span>]]);    <span class="comment">// Object &#123;'a': 1&#125; 会正常被 GC 回收</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>(); </span><br><span class="line">ws.add(&#123;<span class="string">'a'</span>:<span class="number">1</span>&#125;);    <span class="comment">// Object &#123;'a': 1&#125; 会正常被 GC 回收</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;<span class="string">'b'</span>: <span class="number">1</span>&#125;;</span><br><span class="line">ws.add(obj);        <span class="comment">// Object &#123;'b': 1&#125; 不会被正常 GC 回收，因为存在一个强引用</span></span><br><span class="line">obj = <span class="literal">undefined</span>;    <span class="comment">// Object &#123;'b': 1&#125; 会正常被 GC 回收</span></span><br></pre></td></tr></table></figure>
<h3 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h3><p>在 ES6 之前，JavaScript 的异步编程都跳不出回调函数这个方式。回调函数方式使用非常简单，在简单异步任务调用时候没有任何问题，但如果出现复杂的异步任务场景时，就显得力不从心了，最主要的问题就是多层回调函数的嵌套会导致代码的横向发展，难以维护；ES6 带来了两个新特性来解决异步编程的难题。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个简单的多层嵌套回调函数的例子 (Node.js)</span></span><br><span class="line"><span class="keyword">const</span> git = <span class="built_in">require</span>(<span class="string">'shell'</span>).git;</span><br><span class="line"><span class="keyword">const</span> commitMsg = <span class="string">'...'</span>;</span><br><span class="line"></span><br><span class="line">git.add(<span class="string">'pattern/for/some/files/*'</span>, (err) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">    git.commit(commitMsg, (err) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">        git.push(pushOption);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><p><code>Promise</code> 是 ES6 的一个新特性，同为异步编程方式，它主要有如下几个特点：</p>
<ul>
<li>本质还是回调函数</li>
<li>区分成功和失败的回调，省去嵌套在内层的判断逻辑</li>
<li>可以很轻松的完成回调函数模式到 Promise 模式的转化</li>
<li>代码由回调函数嵌套的横向扩展，变为链式调用的纵向扩展，易于理解和维护</li>
</ul>
<p><code>Promise</code> 虽然优势颇多，但是代码结构仍与同步代码区别较大</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上例用 Promise 实现</span></span><br><span class="line"><span class="comment">// 假定 git.add, git.commit, git.push 均做了 Promise 封装，返回一个 Promise 对象</span></span><br><span class="line"><span class="keyword">const</span> git = <span class="built_in">require</span>(<span class="string">'shell'</span>).git;</span><br><span class="line"><span class="keyword">const</span> commitMsg = <span class="string">'...'</span>;</span><br><span class="line"></span><br><span class="line">git.add(<span class="string">'pattern/for/some/files/*'</span>)</span><br><span class="line">  .then(() =&gt; git.commit(commitMsg))</span><br><span class="line">  .then(git.push)</span><br><span class="line">  .catch((err) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<h4 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h4><p><code>Generator</code> 作为 ES6 的新特性，是一个语言层面的升级。它有以下几个特点：</p>
<ul>
<li>可以通过 <code>yield</code> 关键字，终止执行并返回（内到外）</li>
<li>可以通过 <code>next(val)</code> 方法调用重新唤醒，继续执行（外回内）</li>
<li>运行时（包括挂起态），共享局部变量</li>
<li><code>Generator</code> 执行会返回一个结果对象，结果对象本身既是迭代器，同时也是可迭代对象（同时满足<a href="#Iterator + For..Of">两个迭代规范</a>），所以 <code>Generator</code> 可以直接用于 <strong>自定义对象迭代器</strong></li>
</ul>
<p>由于具备以上特点（第四点除外），<code>Generator</code> 也是 JavaScript 对 协程（coroutine）的实现，协程可以理解为 “可由开发人员控制调度的多线程”</p>
<blockquote>
<p>协程按照调度机制来区分，可以分为对称式和非对称式</p>
<p>非对称式：被调用者（协程）挂起时，必须将控制权返还调用者（协程）</p>
<p>对称式：被调用者（协程）挂起时，可将控制权转给 “任意” 其他协程</p>
<p>JavaScript 实现的是 非对称式协程（semi-coroutine）；非对称式协程相比于对称式协程，代码逻辑更清晰，易于理解和维护</p>
</blockquote>
<p>协程给 JavaScript 提供了一个新的方式去完成异步编程；由于 <code>Generator</code> 的执行会返回一个迭代器，需要手动去遍历，所以如果要达到自动执行的目的，除了本身语法外，还需要实现一个执行器，例如 <strong>TJ 大神的 co</strong> 框架。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上例用 Generator 实现</span></span><br><span class="line"><span class="comment">// 假定 git.add, git.commit, git.push 均做了 Promise 封装，返回一个 Promise 对象</span></span><br><span class="line"><span class="keyword">const</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>);</span><br><span class="line"><span class="keyword">const</span> git = <span class="built_in">require</span>(<span class="string">'shell'</span>).git;</span><br><span class="line"></span><br><span class="line">co(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> commitMsg = <span class="string">'...'</span>;      <span class="comment">// 共享的局部变量</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">yield</span> git.add(<span class="string">'pattern/for/some/files/*'</span>);</span><br><span class="line">  <span class="keyword">yield</span> git.commit(commitMsg);</span><br><span class="line">  <span class="keyword">yield</span> git.push();</span><br><span class="line">&#125;).catch((err) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>Generator</code> 是一个 ES6 最佳的异步编程选择么？显然不是，因为除了基本语法外，我们还要额外去实现执行器来达到执行的目的，但是它整体的代码结构是优于回调函数嵌套和 <code>Promise</code> 模式的。</p>
<h4 id="Async-Await"><a href="#Async-Await" class="headerlink" title="Async-Await"></a>Async-Await</h4><p>这并不是一个 ES6 新特性，而是 ES7 的语法，放在这里是因为它将是 JavaScript 目前支持异步编程最好的方式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上例用 async-await 实现</span></span><br><span class="line"><span class="comment">// 假定 git.add, git.commit, git.push 均做了 Promise 封装，返回一个 Promise 对象</span></span><br><span class="line"><span class="keyword">const</span> git = <span class="built_in">require</span>(<span class="string">'shell'</span>).git;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> commitMsg = <span class="string">'...'</span>;      <span class="comment">// 共享的局部变量</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">await</span> git.add(<span class="string">'pattern/for/some/files/*'</span>);</span><br><span class="line">    <span class="keyword">await</span> git.commit(commitMsg);</span><br><span class="line">    <span class="keyword">await</span> git.push();</span><br><span class="line">  &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<h3 id="元编程"><a href="#元编程" class="headerlink" title="元编程"></a>元编程</h3><p>元编程是指的是开发人员对 “语言本身进行编程”。一般是编程语言暴露了一些 API，供开发人员来操作语言本身的某些特性。ES6 两个新特性 <code>Proxy</code> 和 <code>Reflect</code> 是 JavaScript 关于对象元编程能力的扩展。</p>
<h4 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h4><p><code>Proxy</code> 是 ES6 加入的一个新特性，它可以 “代理” 对象的原生行为，替换为执行自定义行为。</p>
<p>这样的元编程能力使得我们可以更轻松的扩展出一些特殊对象。</p>
<ul>
<li>任何对象都可以被 “代理”</li>
<li>利用 <code>Proxy.revocable(target, handler)</code> 可以创建出一个可逆的 “被代理” 对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单 element 选择控制工具的实现</span></span><br><span class="line"><span class="keyword">const</span> cacheElement = <span class="function"><span class="keyword">function</span>(<span class="params">target, prop</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(target.hasOwnProperty(prop))&#123;</span><br><span class="line">      <span class="keyword">return</span> target[prop];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> target[prop] = <span class="built_in">document</span>.getElementById(prop);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> elControl = <span class="keyword">new</span> <span class="built_in">Proxy</span>(cacheElement, &#123;</span><br><span class="line">  get: (target, prop) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> cacheElement(target, prop);</span><br><span class="line">  &#125;,</span><br><span class="line">  set: (target, prop, val) =&gt; &#123;</span><br><span class="line">    cacheElement(target, prop).textContent = val;</span><br><span class="line">  &#125;,</span><br><span class="line">  apply: (target, thisArg, args) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.ownKeys(target);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">elControl.first;     <span class="comment">// div#first</span></span><br><span class="line">elControl.second;    <span class="comment">// div#second</span></span><br><span class="line">elControl.first = <span class="number">5</span>;    <span class="comment">// div#first =&gt; 5</span></span><br><span class="line">elControl.second = <span class="number">10</span>;  <span class="comment">// div#second =&gt; 10</span></span><br><span class="line">elControl();    <span class="comment">// ['first', 'second']</span></span><br></pre></td></tr></table></figure>
<h4 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h4><p>ES6 中引入的 <code>Reflect</code> 是另一个元编程的特性，它使得我们可以直接操纵对象的原生行为。<code>Reflect</code> 可操纵的行为与 <code>Proxy</code> 可代理的行为是一一对应的，这使得可以在 <code>Proxy</code> 的自定义方法中方便的使用 <code>Reflect</code> 调起原生行为。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. Proxy 的自定义方法中，通过 Reflect 调用原生行为</span></span><br><span class="line"><span class="keyword">const</span> customProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;</span><br><span class="line">  <span class="string">'custom'</span>: <span class="number">1</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">  get: (target, prop) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`get <span class="subst">$&#123;prop&#125;</span> !`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, <span class="literal">undefined</span>, prop);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">customProxy.custom;  <span class="comment">// get custom, 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 与 Object 对象上已经开放的操作原生行为方法相比，语法更加清晰易用（例如：Object.hasOwnProperty 与 Reflect.has）</span></span><br><span class="line"><span class="keyword">const</span> symb = <span class="built_in">Symbol</span>(<span class="string">'b'</span>);</span><br><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">  [symb]: <span class="number">1</span>,</span><br><span class="line">  <span class="string">'b'</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">Reflect</span>.has(a, symb) &amp;&amp; <span class="built_in">Reflect</span>.has(a, <span class="string">'b'</span>))&#123;  <span class="comment">// good</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'good'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys(a);  <span class="comment">// ["b", Symbol(b)]</span></span><br></pre></td></tr></table></figure>
<h2 id="进阶阅读"><a href="#进阶阅读" class="headerlink" title="进阶阅读"></a>进阶阅读</h2><p>篇幅有限，无法面面俱到，还想再最后推荐给大家一些想进阶了解 ES6 的必看内容</p>
<ul>
<li>如果你关注兼容性，推荐看：<a href="https://kangax.github.io/compat-table/es6/" target="_blank" rel="external">https://kangax.github.io/compat-table/es6/</a>，这里介绍了从 ES5 到 ES2016+ 的所有特性（包括仍未定稿的特性）及其在各环境的兼容性</li>
<li>如果你关注性能，推荐看：<a href="http://kpdecker.github.io/six-speed/" target="_blank" rel="external">http://kpdecker.github.io/six-speed/</a>，这里通过性能测试，将 ES6 特性的原生实现与 ES5 polyfill 版本进行对比，覆盖了各主流环境；同时也可以侧面对比出各环境在原生实现上的性能优劣</li>
<li>如果你想全面了解特性，推荐看：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/Web/JavaScript</a>，覆盖特性的各方面，包括全面的 API（包括不推荐和废弃的）和基础用法</li>
<li>如果你想看特性更多的使用示例和对应的 polyfill 实现，推荐看：<a href="http://es6-features.org/#Constants" target="_blank" rel="external">http://es6-features.org/#Constants</a>，这里对各个特性都给出了使用丰富的例子和一个 polyfill 实现，简单明了</li>
<li>如果想了解 ECMA Script 最多最全面的细节，英语又比较过硬，推荐在需要时看：<a href="http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf" target="_blank" rel="external">http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf</a>，（或者直接看最新的：<a href="https://tc39.github.io/ecma262/" target="_blank" rel="external">https://tc39.github.io/ecma262/</a>）</li>
</ul>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>基础篇+进阶篇基本介绍完了 ES6 的主要特性，但 ES6 仅仅是现在时，后续如果大家觉得这个系列有意思，可以再写一写 ES 2016+ 的相关内容，来拥抱一下更新的变化。</p>
<p>最后，希望文章中的部分内容可以对大家理解和使用 ES6 有所帮助，感谢支持~</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/Web/JavaScript</a></li>
<li><a href="https://babeljs.io/docs/learn-es2015/" target="_blank" rel="external">https://babeljs.io/docs/learn-es2015/</a></li>
<li><a href="https://www.stackoverflow.com/" target="_blank" rel="external">https://www.stackoverflow.com</a></li>
<li><a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">http://es6.ruanyifeng.com/</a></li>
<li><a href="https://kangax.github.io/compat-table/esnext/" target="_blank" rel="external">https://kangax.github.io/compat-table/esnext/</a></li>
<li><a href="http://www.ecma-international.org/ecma-262/6.0/" target="_blank" rel="external">http://www.ecma-international.org/ecma-262/6.0/</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="https://img.alicdn.com/tfs/TB1xlp2OXXXXXaXXVXXXXXXXXXX-900-500.jpg" alt="ES6 你可能不知道的事 - 进阶篇"></p>
<h2 id="前言"><a href="#前言" cla]]>
    </summary>
    
      <category term="ES6" scheme="http://taobaofed.org/tags/ES6/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何 hack Node.js 模块？]]></title>
    <link href="http://taobaofed.org/blog/2016/10/27/how-to-hack-nodejs-modules/"/>
    <id>http://taobaofed.org/blog/2016/10/27/how-to-hack-nodejs-modules/</id>
    <published>2016-10-27T08:16:05.000Z</published>
    <updated>2017-03-18T09:50:27.000Z</updated>
    <content type="html"><![CDATA[<p><img src="//img.alicdn.com/tfs/TB1SJkrNVXXXXXsXVXXXXXXXXXX-900-500.jpg" alt="如何 hack Node.js 模块？"></p>
<h2 id="为何要去-hack？"><a href="#为何要去-hack？" class="headerlink" title="为何要去 hack？"></a>为何要去 hack？</h2><p>在业务开发过程中，往往会依赖一些 Node.js 模块，hack 这些 Node.js 模块的主要目的是在不修改工具源码的情况下，篡改一些特定的功能。可能会是出于以下几种情况的考虑：</p>
<ol>
<li>总是存在一些特殊的本地需求，不一定能作为工具的通用需求来暴露正常的 API 给更多的用户。</li>
<li>临时且紧急的需求，提 PR 已经来不及了。</li>
<li>为什么不直接去改源码？考虑到工具会不定期升级，想使用工具的最新特性，改源码可维护性太差。</li>
</ol>
<h2 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h2><p>举个栗子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  dosomething();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// b.js </span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">require</span>(a);</span><br><span class="line"><span class="comment">// c.js </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">require</span>(b));</span><br></pre></td></tr></table></figure>
<p>b 是项目 c 依赖的一个工具模块，b 依赖 a。希望只在项目 c 中，b 调用 a 时，a 的函数里能注入一些方法 <code>injectSomething()</code></p>
<ul>
<li>hack 之前 c 的输出</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  dosomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>期望：hack 之后 c 的输出</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  injectSomething();</span><br><span class="line">  dosomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><b>具体案例比如：在做个人自动化工具时，需要 mock 一些工具的手动输入；在本地构建时，需要修改通用的构建流程</b>（后面案例部分会详细说）</p>
<h2 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h2><h3 id="利用模块-cache-篡改模块对象属性"><a href="#利用模块-cache-篡改模块对象属性" class="headerlink" title="利用模块 cache 篡改模块对象属性"></a>利用模块 cache 篡改模块对象属性</h3><p>这是我最早使用的方法，在模块 a 的类型是 object 的时候，可以在自己的项目 c 中提早 require 模块 a，按照你的需求修改一些属性，这样当模块 b 再去 require 模块 a 时，从缓存中取出的模块 a 已经是被修改过的了。</p>
<p>模块 a、b、c 栗子如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  p</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="built_in">require</span>(a);</span><br><span class="line">a.p();</span><br><span class="line"><span class="comment">// c.js</span></span><br><span class="line"><span class="built_in">require</span>(b);</span><br></pre></td></tr></table></figure></p>
<p>我想修改 a 的方法 p，在 c 中进行如下修改即可，而无需直接去修改工具 a、b 的源码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c.js</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="built_in">require</span>(a);</span><br><span class="line"><span class="keyword">let</span> oldp = a.p; </span><br><span class="line">a.p = <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">   injectSomething();</span><br><span class="line">   oldp.apply(<span class="keyword">this</span>, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">require</span>(b);</span><br></pre></td></tr></table></figure>
<p>缺陷：在某些模块属性是动态加载的情况，不是那么灵敏，而且只能篡改引用对象。但大部分情况下还是能够满足需求的。</p>
<h3 id="修改require-cache"><a href="#修改require-cache" class="headerlink" title="修改require.cache"></a>修改require.cache</h3><p>在遇到模块暴露的是非对象的情况，就需要直接去修改 require 的 cache 对象了。关于修改 <code>require.cache</code> 的有效性，会在后面的原理部分详细说，先来简单的说下操作：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.js 暴露的非对象,而是函数</span></span><br><span class="line">module.exports = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">   doSomething();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//c.js</span></span><br><span class="line"><span class="keyword">const</span> aOld = require(a); </span><br><span class="line">let aId = require.resolve(aPath);</span><br><span class="line">require.cache[aId] = <span class="function"><span class="keyword">function</span><span class="params">(<span class="rest_arg">...args</span>)</span></span>&#123;</span><br><span class="line">   injectSomething();</span><br><span class="line">   aOld.apply(<span class="keyword">this</span>, args);</span><br><span class="line">&#125;</span><br><span class="line">require(b);</span><br></pre></td></tr></table></figure>
<p>缺陷：可能后续调用链路会有人手动去修改 <code>require.cache</code>，例如热加载。</p>
<h3 id="修改-require"><a href="#修改-require" class="headerlink" title="修改 require"></a>修改 require</h3><p>这种方法是直接去代理 <code>require</code> ，是最稳妥的方法，但是侵入性相对来说比较强。Node.js 文件中的 require 其实是在 Module 的原型方法上，即 <code>Module.prototype.require</code>。后面会详细说，先简单说下操作：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Module = <span class="built_in">require</span>(<span class="string">'module'</span>);</span><br><span class="line"><span class="keyword">const</span> _require = Module.prototype.require;</span><br><span class="line">Module.prototype.require = <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = _require.apply(<span class="keyword">this</span>, args);</span><br><span class="line">    <span class="keyword">if</span>(args[<span class="number">0</span>] === <span class="string">'a'</span>) &#123; <span class="comment">// 只修改a模块内容</span></span><br><span class="line">        injectSomething();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>缺陷：对整个 Node.js 进程的 require 操作都具有侵入性。</p>
<h2 id="相关原理"><a href="#相关原理" class="headerlink" title="相关原理"></a>相关原理</h2><h3 id="node的启动过程"><a href="#node的启动过程" class="headerlink" title="node的启动过程"></a>node的启动过程</h3><p>我们先来看看在运行 <strong><code>node a.js</code></strong> 时发生些什么？<a href="https://github.com/nodejs/node/tree/master" target="_blank" rel="external">node源码</a><br><img src="https://img.alicdn.com/tfs/TB1QtALNVXXXXbCXXXXXXXXXXXX-720-297.png" alt="node_main"></p>
<p>上图是node运行 <code>a.js</code> 的一个核心流程，Node.js 的启动程序 <code>bootstrap_node.js</code> 是在 <code>node::LoadEnvironment</code> 中被立即执行的，<code>bootstrap_node.js</code> 中的 <code>startup()</code> 是包裹在一个匿名函数里面的，所以在一次执行 <code>node</code> 的行为中 <code>startup()</code> 只会被调用了一次，来保证 <code>bootstrap_node.js</code> 的所执行的所有依赖只会被加载一次。<code>C++</code> 语言部分中：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//node_main.cc 如果在win环境执行wmain()，unix则执行main()，函数最后都执行了node::Start(argc, argv)  </span><br><span class="line">#ifdef _WIN32</span><br><span class="line">  int wmain()</span><br><span class="line">#else</span><br><span class="line">  int main()</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">//node::Start(argc, argv) 提供载入 Node.js 进程的 V8 环境</span><br><span class="line">Environment::AsyncCallbackScope callback_scope(&amp;env);</span><br><span class="line">LoadEnvironment(&amp;env);</span><br><span class="line"></span><br><span class="line">//node::LoadEnvironment(Environment* env) 加载 Node.js 环境</span><br><span class="line">Local&lt;String&gt; script_name = FIXED_ONE_BYTE_STRING(env-&gt;isolate()," bootstrap_node.js");</span><br><span class="line">Local&lt;Value&gt; f_value = ExecuteString(env, MainSource(env), script_name);</span><br></pre></td></tr></table></figure>
<p>  在 <code>bootstrap_node.js</code> 中，会去执行 Module 的静态方法 <code>runMain</code>，而 <code>runMain</code> 中则去执行了 <code>Module._load</code>，也就是模块加载的过程。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bootstrap_node.js</span></span><br><span class="line"><span class="keyword">const</span> Module = NativeModule.require(<span class="string">'module'</span>);</span><br><span class="line">……</span><br><span class="line">run(Module.runMain);</span><br><span class="line"><span class="comment">// Module.js</span></span><br><span class="line">Module.runMain = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Module._load(process.argv[<span class="number">1</span>], <span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">    process._tickCallback();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="一个进程只存在一个-cache-对象？"><a href="#一个进程只存在一个-cache-对象？" class="headerlink" title="一个进程只存在一个 cache 对象？"></a>一个进程只存在一个 cache 对象？</h3><p>先来看看 <code>module._load</code> 干了什么？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Module._load = <span class="function"><span class="keyword">function</span>(<span class="params">request, parent, isMain</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> filename = Module._resolveFilename(request, parent, isMain);</span><br><span class="line">  <span class="keyword">var</span> cachedModule = Module._cache[filename]; <span class="comment">// get cache</span></span><br><span class="line">  <span class="keyword">if</span> (cachedModule) &#123;</span><br><span class="line">    <span class="keyword">return</span> cachedModule.exports; </span><br><span class="line">  &#125;</span><br><span class="line">  ……</span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">module</span> = <span class="keyword">new</span> Module(filename, parent);</span><br><span class="line">  ……</span><br><span class="line">  Module._cache[filename] = <span class="built_in">module</span>; <span class="comment">// set cache</span></span><br><span class="line">  tryModuleLoad(<span class="built_in">module</span>, filename);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，在 load 的一个模块时，会先读缓存 <code>Module._cache</code>，如果没有就会去 new 一个 Module 的实例,<br>然后再把实例放到缓存里。由前面的 Node.js 启动过程可以知道， <code>bootstrap_node.js</code> 中的 <code>startup()</code> 只会执行了一次，其中产生的 Module 对象在整个node进程调用链路中只会存在一个，进而 <code>Module._cache</code> 只有一个。</p>
<h3 id="Module-cache-和-require-cache-的关系"><a href="#Module-cache-和-require-cache-的关系" class="headerlink" title="Module._cache 和 require.cache 的关系"></a><code>Module._cache</code> 和 <code>require.cache</code> 的关系</h3><p>可以看下 <code>Module.prototype._compile</code> 这个方法，这里面会对大家写的 Node.js 文件进行一个包装，注入一些上下文，包括 <code>require</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">require</span> = internalModule.makeRequireFunction.call(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">var</span> args = [<span class="keyword">this</span>.exports, <span class="built_in">require</span>, <span class="keyword">this</span>, filename, dirname];</span><br><span class="line"><span class="keyword">var</span> depth = internalModule.requireDepth;</span><br><span class="line"><span class="keyword">var</span> result = compiledWrapper.apply(<span class="keyword">this</span>.exports, args);</span><br></pre></td></tr></table></figure>
<p>而在 <code>internalModule.makeRequireFunction</code> 中我们会发现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 makeRequireFunction 中</span></span><br><span class="line"><span class="built_in">require</span>.cache = Module._cache;</span><br></pre></td></tr></table></figure>
<p>所以，<code>Module._cache</code> 和 <code>require.cache</code> 是一样的，那么我们直接修改 <code>require.cache</code> 的缓存内容，在一个 Node.js 进程里都是有效的。</p>
<h3 id="require-不同场景的挂载"><a href="#require-不同场景的挂载" class="headerlink" title="require 不同场景的挂载"></a><code>require</code> 不同场景的挂载</h3><p>最开始我以为 require 是挂载在 global 上的，为了图省事，一般用 Node.js repl 来测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ node</span><br><span class="line">&gt; global.require</span><br><span class="line">&#123; [Function: require]</span><br><span class="line">  resolve: [Function: resolve],</span><br><span class="line">  main: undefined,</span><br><span class="line">  extensions: &#123; <span class="string">'.js'</span>: [Function], <span class="string">'.json'</span>: [Function], <span class="string">'.node'</span>: [Function] &#125;,</span><br><span class="line">  cache: &#123;&#125; &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，repl 下，global.require 是存在的，如果以为可以直接在 Node.js 文件中代理 <code>global.require</code> 那就踩坑了，因为如果在 Node.js 文件中使用会发现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(global.require);</span><br><span class="line"><span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>从上文可知，Node.js 文件中的 require 其实是来自于 <code>Module.prototype._compile</code> 中注入的 <code>Module.prototype.require</code>, 而最终的指向其实是 <code>Module._load</code>，并没有挂载到 module 上下文环境中的 global 对象上。</p>
<p>而 repl 中也是有 module 实例，于是我尝试在 repl 中打印：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ node</span><br><span class="line">&gt; global.require === module.require</span><br><span class="line">  <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>结果有点奇怪，于是我继续探究了下。在 <code>bootstrap_node.js</code> 中找到 repl 的调用文件 <code>repl.js</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">require</span> = internalModule.makeRequireFunction.call(<span class="built_in">module</span>);</span><br><span class="line">context.module = <span class="built_in">module</span>;</span><br><span class="line">context.require = <span class="built_in">require</span>;</span><br></pre></td></tr></table></figure>
<p>得到结论：在 repl 中，<code>module.require</code> 和 <code>global.require</code> 最终的调用方法是一样的，只是函数指向不同而已。</p>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><h3 id="path路径"><a href="#path路径" class="headerlink" title="path路径"></a>path路径</h3><p><code>require.cache</code> 是一个 key、value 的 map，key 看上去是模块所在的绝对路径，然而是不能用绝对路径直接去用的，需要 <code>require.resolve</code> 来解析路径，解析后才是 cache 中正确的 key 格式。</p>
<p>下面对比下区别：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模块的绝对路径</span></span><br><span class="line"><span class="regexp">/Users/</span>kino<span class="regexp">/.def/</span>def_modules<span class="regexp">/.builders/</span><span class="meta">@ali</span><span class="regexp">/builder-cake-kpm/</span>node_modules<span class="regexp">/@ali/</span>builder-cake-kpm<span class="regexp">/node_modules/</span><span class="meta">@ali</span><span class="regexp">/cake-webpack-config/</span>index.js</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 require.resolve 转义后的结果</span></span><br><span class="line"><span class="regexp">/Users/</span>kino<span class="regexp">/.def/</span>def_modules<span class="regexp">/.builders/</span><span class="meta">@ali</span><span class="regexp">/builder-cake-kpm/</span>node_modules<span class="regexp">/.0.16.23@@ali/</span>cake-webpack-config/index.js</span><br></pre></td></tr></table></figure>
<h3 id="多进程的情况"><a href="#多进程的情况" class="headerlink" title="多进程的情况"></a>多进程的情况</h3><p>模块间调用的链路比较长，有可能会新建子进程，需要考虑你项目中的入口文件和你需要代理的文件是否在一个进程中，简单的方法就是在入口文件和你需要代理的文件打印 pid：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(process.pid)</span><br></pre></td></tr></table></figure>
<p>如果一致，那么直接在入口调用前代理即可，否则情况会更复杂点，需要找到相应的进程调用处进行代理。</p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>DEF 是淘宝前端的集成开发环境，支持前端模块创建、构建打包、发布等一系列流程。 在以下案例中，主要 hack 的 Node.js 项目便是 DEF。</p>
<h3 id="篡改输入-prompt"><a href="#篡改输入-prompt" class="headerlink" title="篡改输入(prompt)"></a>篡改输入(prompt)</h3><p>场景：使用 DEF 创建模块 or 发布模块时</p>
<p>原因：想一键完成批量创建 or 批量发布，不想手动输入。</p>
<p>解决过程：以创建模块为例</p>
<ul>
<li><p>首先找到 DEF 的入口文件，即一个 bin 目录下的路径，可以通过这个入口文件不断追溯下去，发现创建模块的 generator 用的是 yeoman-generator 的方法。对 prompt 的方法进行代理，可以将该基础库提前 require，更改掉其 prompt 的方法即可。</p>
</li>
<li><p>附上示例代码（示例只篡改 <code>def add</code> 模块的创建类型，其他输入的篡改方法类似）：</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br><span class="line"><span class="meta"></span><br><span class="line">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'shelljs/global'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> HOME = process.env.HOME;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> yeomanRouter = <span class="built_in">require</span>(path.join(HOME, <span class="string">'.def/def_modules/.generators/@ali/generator-abs-router/node_modules/@ali/generator-abs-router/node_modules/yeoman-generator'</span>));</span><br><span class="line"></span><br><span class="line">yeomanRouter.generators.Base.prototype.prompt = <span class="function"><span class="keyword">function</span>(<span class="params">list, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> item = list[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">let</span> prop = &#123;&#125;;</span><br><span class="line">  prop[item.name] = <span class="string">'kissy-pc'</span>; <span class="comment">// 让模块类型输入自动为pc</span></span><br><span class="line">  callback(prop);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//require real def path</span></span><br><span class="line"><span class="keyword">const</span> defPath = which(<span class="string">'def'</span>).stdout;</span><br><span class="line"><span class="built_in">require</span>(defPath);</span><br></pre></td></tr></table></figure>
<h3 id="篡改构建流程（webpackconfig）"><a href="#篡改构建流程（webpackconfig）" class="headerlink" title="篡改构建流程（webpackconfig）"></a>篡改构建流程（webpackconfig）</h3><p>场景：一个淘宝的前端组件，需要在使用def本地调试时提前更改一个文件内容。（淘宝组件的构建会按照组件类型统一构建器，并不是每个组件单独去配置）</p>
<p>原因：一般来说，这种情况可以选择注释代码大法，本地调试时打开注释，发布前干掉。但这样造成代码很不美观，也容易引起误操作。不妨在本地调试的 reflect 过程中动态更换掉就好了。</p>
<p>解决过程：</p>
<ul>
<li><p>追溯 <code>def dev</code> 调用链路，找到最终reflect的文件, 在这个构建器 <code>@ali/builder-cake-kpm</code> 项目里。所使用的webpack的配置项在 <code>@ali/cake-webpack-config</code> 下。</p>
</li>
<li><p>现在就是往 webpack 配置项里动态注入一个 webpack loader 的过程了，我需要的 loader 是一个 preLoader，代码非常简单，我把它放在业务项目的文件里:</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">content</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> content.replace(<span class="string">'require\(\'\.\/plugin\'\)'</span>, <span class="string">"require('./localPlugin')"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>@ali/cake-webpack-config</code> 暴露的是个函数而非对象，所以必须从 require 下手了，最后附上案例的代理过程：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'shelljs/global'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> HOME = process.env.HOME;</span><br><span class="line"><span class="keyword">const</span> CWD = process.cwd();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cakeWcPath = path.join(HOME, <span class="string">'.def/def_modules/.builders/@ali/builder-cake-kpm/node_modules/@ali/builder-cake-kpm/node_modules/@ali/cake-webpack-config'</span>);</span><br><span class="line"><span class="keyword">const</span> preLoaderPath = path.join(CWD, <span class="string">'debug/plugin_compile.js'</span>); <span class="comment">// 注入的loader路径</span></span><br><span class="line"><span class="keyword">const</span> cakeWebpackConfig = <span class="built_in">require</span>(cakeWcPath);</span><br><span class="line"><span class="keyword">const</span> requireId = <span class="built_in">require</span>.resolve(cakeWcPath);</span><br><span class="line"><span class="built_in">require</span>.cache[requireId].exports = (options) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (options.callback) &#123;</span><br><span class="line">    <span class="keyword">let</span> oldCb = options.callback;</span><br><span class="line">    options.callback = <span class="function"><span class="keyword">function</span>(<span class="params">err, obj</span>) </span>&#123;</span><br><span class="line">      obj.module.preLoaders = [&#123;</span><br><span class="line">        <span class="string">'test'</span>: <span class="regexp">/index\.js$/</span>,</span><br><span class="line">        <span class="string">'loader'</span>: preLoaderPath</span><br><span class="line">      &#125;];</span><br><span class="line">      oldCb(err, obj);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cakeWebpackConfig(options);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//require real def path</span></span><br><span class="line"><span class="keyword">const</span> defPath = which(<span class="string">'def'</span>).stdout;</span><br><span class="line"><span class="built_in">require</span>(defPath);</span><br></pre></td></tr></table></figure>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>去 hack 一个 Node.js 模块，需要对该 Node.js 模块的调用链路有一定的了解，在很多情况下，不一定是最优的方法，但也不失为一种解决方案。有趣的是，Node.js 源码中其实有一行这样的注释：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hello, and welcome to hacking node.js!</span></span><br><span class="line"><span class="comment">// some descriptions</span></span><br></pre></td></tr></table></figure>
<p>So, just hacking for fun! </p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="//img.alicdn.com/tfs/TB1SJkrNVXXXXXsXVXXXXXXXXXX-900-500.jpg" alt="如何 hack Node.js 模块？"></p>
<h2 id="为何要去-hack？"><a href="#为何要去]]>
    </summary>
    
      <category term="hack" scheme="http://taobaofed.org/tags/hack/"/>
    
      <category term="Node.js" scheme="http://taobaofed.org/categories/Node-js/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[揭秘浏览器远程调试技术]]></title>
    <link href="http://taobaofed.org/blog/2016/10/19/chrome-remote-debugging-technics/"/>
    <id>http://taobaofed.org/blog/2016/10/19/chrome-remote-debugging-technics/</id>
    <published>2016-10-19T07:15:15.000Z</published>
    <updated>2017-03-18T09:50:27.000Z</updated>
    <content type="html"><![CDATA[<p><img src="https://img.alicdn.com/tfs/TB1MZ9aNVXXXXaQXFXXXXXXXXXX-900-500.jpg" alt="揭秘浏览器远程调试技术"></p>
<h2 id="调试技术的起源"><a href="#调试技术的起源" class="headerlink" title="调试技术的起源"></a>调试技术的起源</h2><p>1947 年 9 月 9 日，一名美国的科学家格蕾丝.霍普和她的同伴在对 Mark II 计算机进行研究的时候发现，一只飞蛾粘在一个继电器上，导致计算机无法正常工作，当他们把飞蛾移除之后，计算机又恢复了正常运转。于是他们将这只飞蛾贴在了他们当时记录的日志上，对这件事情进行了详细的记录，并在日志最后写了这样一句话：First actual case of bug being found。这是他们发现的第一个真正意义上的 bug，这也是人类计算机软件历史上，发现的第一个 bug，而他们找到飞蛾的方法和过程，就是 debugging 调试技术。</p>
<p><img src="https://img.alicdn.com/tps/TB1f_n8NpXXXXXBXpXXXXXXXXXX-740-583.jpg" alt="History of Debug"></p>
<p>从格蕾丝调试第一个 bug 到现在，69 年的时间里，在计算机领域，硬件、软件各种调试技术都在不断的发展和演进。那么对于日新月异的前端来说，调试技术也尤其显得重要。淘宝前端团队也正在使用一些创新的技术和手段来解决无线页面调试的问题。今天先跟大家分享下浏览器远程调试技术，本文将用 Chrome/Webview 来作为案例。</p>
<h2 id="调试原理"><a href="#调试原理" class="headerlink" title="调试原理"></a>调试原理</h2><h3 id="调试方式与权限管理"><a href="#调试方式与权限管理" class="headerlink" title="调试方式与权限管理"></a>调试方式与权限管理</h3><p><img src="https://img.alicdn.com/tps/TB1KA.XNpXXXXbFXFXXXXXXXXXX-1021-336.png" alt="-"></p>
<p>目前常规浏览器调试目标分为两种：Chrome PC 浏览器和 Chrome Mobile（Android 4.4 以后，Android WebView 其实就是 Chromium WebView）。</p>
<h4 id="Chrome-PC-浏览器"><a href="#Chrome-PC-浏览器" class="headerlink" title="Chrome PC 浏览器"></a>Chrome PC 浏览器</h4><p>对于调试 Chrome PC 浏览器，可能大家经常使用的是用鼠标右键或者快捷方式（mac:option + command + J），唤起 Chrome 的控制台，来对当前页面进行调试。其实还有另外一种方法，就是使用一个 Chrome 浏览器调试另一个 Chrome 浏览器。Chrome 启动的时候，默认是关闭了调试端口的，如果要对一个目标 Chrome PC 浏览器进行调试，那么启动的时候，可以通过传递参数来开启 Chrome 的调试开关：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># for mac</span></span><br><span class="line">sudo /Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome --remote-debugging-port=9222</span><br></pre></td></tr></table></figure>
<h4 id="Chrome-Android-浏览器"><a href="#Chrome-Android-浏览器" class="headerlink" title="Chrome Android 浏览器"></a>Chrome Android 浏览器</h4><p>对于调试 Android 上的 Chrome 或者 WebView 需要连接 USB 线。打开调试端口的方法如下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb forward tcp:9222 localabstract:chrome_devtools_remote</span><br></pre></td></tr></table></figure></p>
<p>跟 Chrome PC 浏览器不同的是，对于 Chrome Android 浏览器，由于数据传输是通过 USB 线而不是 WIFI，实际上 Chrome Android 创建的一个 chrome_devtools_remote 这个 path 的 domain socket。所以，上面一条命令则是通过 Android 的 adb 将 PC 的端口 9222 通过 USB 线与 chrome_devtools_remote 这个 domain socket 建立了一个端口映射。</p>
<h4 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h4><p>Google 为了限制调试端口的接入范围，对于 Chrome PC 浏览器，调试端口只接受来自 <code>127.0.0.1</code> 或者 <code>localhost</code> 的数据请求，所以，你无法通过你的本地机器 IP 来调试 Chrome。对于 Android Chrome/WebView，调试端口只接受来自于 <code>shell</code> 这个用户数据请求，也就是说只能通过 USB 进行调试，而不能通过 WIFI。</p>
<h3 id="开始调试"><a href="#开始调试" class="headerlink" title="开始调试"></a>开始调试</h3><p>通过以上的调试方式的接入以及调试端口的打开，这个时候在浏览器中输入：<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span><span class="comment">//127.0.0.1:9222/json</span></span><br></pre></td></tr></table></figure></p>
<p>将会看到类似下面的内容：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"description"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"devtoolsFrontendUrl"</span>: <span class="string">"/devtools/inspector.html?ws=127.0.0.1:9222/devtools/page/ebdace60-d482-4340-b622-a6198e7aad6e"</span>,</span><br><span class="line">    <span class="attr">"id"</span>: <span class="string">"ebdace60-d482-4340-b622-a6198e7aad6e"</span>,</span><br><span class="line">    <span class="attr">"title"</span>: <span class="string">"揭秘浏览器远程调试技术.mdown—/Users/harlen/Documents"</span>,</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"page"</span>,</span><br><span class="line">    <span class="attr">"url"</span>: <span class="string">"http://127.0.0.1:51004/view/61"</span>,</span><br><span class="line">    <span class="attr">"webSocketDebuggerUrl"</span>: <span class="string">"ws://127.0.0.1:9222/devtools/page/ebdace60-d482-4340-b622-a6198e7aad6e"</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>其中，最重要的 2 个参数分别是 id 和 webSocketDebuggerUrl。Chrome 会为每个页面分配一个唯一的 id，作为该页面的唯一标识符。几乎对目标浏览器的所有操作都是需要带上这个 id。</p>
<p>Chrome 提供了以下这些 http 接口控制目标浏览器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取当前所有可调式页面信息</span></span><br><span class="line">http://127.0.0.1:9222/json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取调试目标 WebView/blink 的版本号</span></span><br><span class="line">http://127.0.0.1:9222/json/version</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建新的 tab，并加载 url</span></span><br><span class="line">http://127.0.0.1:9222/json/new?url</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭 id 对应的 tab</span></span><br><span class="line">http://127.0.0.1:9222/json/close/id</span><br></pre></td></tr></table></figure></p>
<p>webSocketDebuggerUrl 则在调试该页面需要用到的一个 WebSocket 连接。chrome 的 devtool 的所有调试功能，都是基于 <a href="https://chromedevtools.github.io/debugger-protocol-viewer/1-1/Debugger/" target="_blank" rel="external">Remote Debugging Protocol</a> 使用 WebSocket 来进行数据传输的。那么这个 WebSocket，就是上面我们从 <code>http://127.0.0.1:9222/json</code> 获取的 <code>webSocketDebuggerUrl</code>，每一个页面都有自己不同的 <code>webSocketDebuggerUrl</code>。这个 <code>webSocketDebuggerUrl</code>是通过 url 的 query 参数传递给 chrome devtool 的。</p>
<p>chrome 的 devtool 可以从 Chrome 浏览器中进行提取 devtool 源码或者从 blink 源码中获取。在部署好自己的 chrome devtool 代码之后，下面既可以开始对 Chrome 进行调试, 浏览器输入一下内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://path_to_your_devtool/devtool.html?ws=127.0.0.1:9222/devtools/page/ebdace60<span class="_">-d</span>482-4340-b622<span class="_">-a</span>6198e7aad6e</span><br></pre></td></tr></table></figure></p>
<p>其中 ws 这个参数的值就是上面出现的 webSocketDebuggerUrl。Chrome 的 devtool 会使用这个 url 创建 WebSocket 对该页面进行调试。</p>
<h3 id="如何实现-JavaScript-调试"><a href="#如何实现-JavaScript-调试" class="headerlink" title="如何实现 JavaScript 调试"></a>如何实现 JavaScript 调试</h3><p>在进入 Chrome 的 devtool 之后，我们可以调出控制台，来查看 devtool 的 WebSocket 数据。这个里面有很多数据，我这里只讲跟 JavaScript 调试相关的。<br><img src="https://img.alicdn.com/tps/TB1.H3kNpXXXXalXVXXXXXXXXXX-740-191.png" alt="-"></p>
<p>图中，对于 JavaScript 调试，有一条非常重要的消息，我蓝色选中的那条消息：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"id"</span>:<span class="number">6</span>,<span class="attr">"method"</span>:<span class="string">"Debugger.enable"</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后选中要调试的 JavaScript 文件，然后设置一个断点，我们再来看看 WebSocket 消息：<br><img src="https://img.alicdn.com/tps/TB1h2UANpXXXXaYXpXXXXXXXXXX-912-214.png" alt="-"></p>
<p>devtool 像目标 Chrome 发送了 2 条消息<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"id"</span>: <span class="number">23</span>,</span><br><span class="line">  <span class="attr">"method"</span>: <span class="string">"Debugger.getScriptSource"</span>,</span><br><span class="line">  <span class="attr">"params"</span>: &#123;</span><br><span class="line">    <span class="attr">"scriptId"</span>: <span class="string">"103"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"id"</span>: <span class="number">24</span>,</span><br><span class="line">  <span class="attr">"method"</span>: <span class="string">"Debugger.setBreakpointByUrl"</span>,</span><br><span class="line">  <span class="attr">"params"</span>: &#123;</span><br><span class="line">    <span class="attr">"lineNumber"</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">"url"</span>: <span class="string">"https://g.alicdn.com/alilog/wlog/0.2.10/??aplus_wap.js,spm_wap.js,spmact_wap.js"</span>,</span><br><span class="line">    <span class="attr">"columnNumber"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"condition"</span>: <span class="string">""</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么收到这几条消息之后，V8 做了些什么呢？<br>我们先来简单的看下 V8 里面的一小段源码片段：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// V8 Debugger.cpp</span></span><br><span class="line">DispatcherImpl(FrontendChannel* frontendChannel, Backend* backend) : DispatcherBase(frontendChannel), m_backend(backend) &#123;</span><br><span class="line">    m_dispatchMap[<span class="string">"Debugger.enable"</span>] = &amp;DispatcherImpl::enable;</span><br><span class="line">    m_dispatchMap[<span class="string">"Debugger.disable"</span>] = &amp;DispatcherImpl::disable;</span><br><span class="line">    m_dispatchMap[<span class="string">"Debugger.setBreakpointsActive"</span>] = &amp;DispatcherImpl::setBreakpointsActive;</span><br><span class="line">    m_dispatchMap[<span class="string">"Debugger.setSkipAllPauses"</span>] = &amp;DispatcherImpl::setSkipAllPauses;</span><br><span class="line">    m_dispatchMap[<span class="string">"Debugger.setBreakpointByUrl"</span>] = &amp;DispatcherImpl::setBreakpointByUrl;</span><br><span class="line">    m_dispatchMap[<span class="string">"Debugger.setBreakpoint"</span>] = &amp;DispatcherImpl::setBreakpoint;</span><br><span class="line">    m_dispatchMap[<span class="string">"Debugger.removeBreakpoint"</span>] = &amp;DispatcherImpl::removeBreakpoint;</span><br><span class="line">    m_dispatchMap[<span class="string">"Debugger.continueToLocation"</span>] = &amp;DispatcherImpl::continueToLocation;</span><br><span class="line">    m_dispatchMap[<span class="string">"Debugger.stepOver"</span>] = &amp;DispatcherImpl::stepOver;</span><br><span class="line">    m_dispatchMap[<span class="string">"Debugger.stepInto"</span>] = &amp;DispatcherImpl::stepInto;</span><br><span class="line">    m_dispatchMap[<span class="string">"Debugger.stepOut"</span>] = &amp;DispatcherImpl::stepOut;</span><br><span class="line">    m_dispatchMap[<span class="string">"Debugger.pause"</span>] = &amp;DispatcherImpl::pause;</span><br><span class="line">    m_dispatchMap[<span class="string">"Debugger.resume"</span>] = &amp;DispatcherImpl::resume;</span><br><span class="line">    m_dispatchMap[<span class="string">"Debugger.searchInContent"</span>] = &amp;DispatcherImpl::searchInContent;</span><br><span class="line">    m_dispatchMap[<span class="string">"Debugger.setScriptSource"</span>] = &amp;DispatcherImpl::setScriptSource;</span><br><span class="line">    m_dispatchMap[<span class="string">"Debugger.restartFrame"</span>] = &amp;DispatcherImpl::restartFrame;</span><br><span class="line">    m_dispatchMap[<span class="string">"Debugger.getScriptSource"</span>] = &amp;DispatcherImpl::getScriptSource;</span><br><span class="line">    m_dispatchMap[<span class="string">"Debugger.setPauseOnExceptions"</span>] = &amp;DispatcherImpl::setPauseOnExceptions;</span><br><span class="line">    m_dispatchMap[<span class="string">"Debugger.evaluateOnCallFrame"</span>] = &amp;DispatcherImpl::evaluateOnCallFrame;</span><br><span class="line">    m_dispatchMap[<span class="string">"Debugger.setVariableValue"</span>] = &amp;DispatcherImpl::setVariableValue;</span><br><span class="line">    m_dispatchMap[<span class="string">"Debugger.setAsyncCallStackDepth"</span>] = &amp;DispatcherImpl::setAsyncCallStackDepth;</span><br><span class="line">    m_dispatchMap[<span class="string">"Debugger.setBlackboxPatterns"</span>] = &amp;DispatcherImpl::setBlackboxPatterns;</span><br><span class="line">    m_dispatchMap[<span class="string">"Debugger.setBlackboxedRanges"</span>] = &amp;DispatcherImpl::setBlackboxedRanges;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你会发现，V8 有 <code>m_dispatchMap</code> 这样一个 Map。专门用来处理所有 JavaScript 调试相关的处理。<br>其中就有本文即将重点讲述的:</p>
<ul>
<li>Debuggger.enable</li>
<li>Debugger.getScriptSource</li>
<li>setBreakpointByUrl</li>
</ul>
<p>这些都需要在 V8 的源码中找到答案。顺便给大家推荐一个查看 Chromium/V8 最正确的方式是使用 <a href="https://cs.chromium.org/" target="_blank" rel="external">https://cs.chromium.org</a>，比 SourceInsight 还要方便。</p>
<h4 id="Debugger-enable"><a href="#Debugger-enable" class="headerlink" title="Debugger.enable"></a>Debugger.enable</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> V8Debugger::enable() &#123;</span><br><span class="line">    <span class="keyword">if</span> (m_enableCount++) <span class="keyword">return</span>;</span><br><span class="line">    DCHECK(!enabled());</span><br><span class="line">    v8::<span class="function">HandleScope <span class="title">scope</span><span class="params">(m_isolate)</span></span>;</span><br><span class="line">    v8::Debug::SetDebugEventListener(m_isolate, &amp;V8Debugger::v8DebugEventCallback,</span><br><span class="line">    v8::External::New(m_isolate, <span class="keyword">this</span>));</span><br><span class="line">    m_debuggerContext.Reset(m_isolate, v8::Debug::GetDebugContext(m_isolate));</span><br><span class="line">    compileDebuggerScript();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个接口的名称叫 <code>Debugger.enable</code>，但是收到这条消息，V8 其实就干了两件事情事情：</p>
<ul>
<li><p>SetDebugEventListener：<br>给 JavaScript 调试安装监听器，并设置 <code>v8DebugEventCallback</code> 这个回调函数。JavaScript 所有的调试事件，都会被这个监听器捕获，包括：JavaScript 异常停止，断点停止，单步调试等等。</p>
</li>
<li><p>compileDebuggerScript:<br>编译 V8 内置的 JavaScript 文件 <a href="https://cs.chromium.org/chromium/src/v8/src/inspector/debugger-script.js?q=debugger-script.js&amp;sq=package:chromium&amp;dr" target="_blank" rel="external">debugger-script.js</a>。由于这文件比较长，我这里就不贴出来了，感兴趣的同学点击这个链接进行查看源码。<code>debugger-script.js</code> 主要是定义了一些针对 JavaScript 断点进行操作的函数，例如设置断点、查找断点以及单步调试相关的函数。那么这个 <code>debugger-script.js</code> 文件，被 V8 进行编译之后，保存在 global 对象上，等待对 JavaScript 进行调试的时候，被调用。</p>
<h4 id="Debugger-getScriptSource"><a href="#Debugger-getScriptSource" class="headerlink" title="Debugger.getScriptSource"></a>Debugger.getScriptSource</h4><p>在 Chrome 解析引擎解析到 <code>&lt;script&gt;</code> 标签之后，Chrome 将会把 script 标签对应的 JavaScript 源码扔给 V8 编译执行。同时，V8 将会对所有的 JavaScript 源码片段进行编号并保存。所以，当 chrome devtool 需要获取要调试的 JavaScript 文件的时候，只需要通过 <code>Debugger.getScriptSource</code>，给 V8 传递一个 scriptId，V8 将会把 JavaScript 源码返回。我们再回头看看这个图中的消息：<br><img src="https://img.alicdn.com/tps/TB1h2UANpXXXXaYXpXXXXXXXXXX-912-214.png" alt="-"><br>上面 id 为 23 的 <code>scriptSource</code> 就是 V8 返回的 JavaScript 源码，如此以来，我们就可以在 devtool 中看到我们要调试的 JavaScript 源码了。</p>
</li>
</ul>
<h4 id="Debugger-setBreakpointByUrl"><a href="#Debugger-setBreakpointByUrl" class="headerlink" title="Debugger.setBreakpointByUrl"></a>Debugger.setBreakpointByUrl</h4><p>所有准备工作都做好了，现在就可以开始设置断点了。从上面的几个图中，已经可以很清楚的看到，<code>Debugger.setBreakpointByUrl</code> 给目标 Chrome 传递了一个 JavaScript 的 url 和断点的行号。</p>
<p>首先，V8 会去找，是否已经存在了该 URL 对应的 JavaScript 源码了：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; script : m_scripts) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!matches(m_inspector, script.second-&gt;sourceURL(), url, isRegex))</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;protocol::Debugger::Location&gt; location = resolveBreakpoint(</span><br><span class="line">    breakpointId, script.first, breakpoint, UserBreakpointSource);</span><br><span class="line">  <span class="keyword">if</span> (location) (*locations)-&gt;addItem(<span class="built_in">std</span>::move(location));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*outBreakpointId = breakpointId;</span><br></pre></td></tr></table></figure></p>
<p>V8 给所有的断点，创建一个 breakpointObject。并将这些 braekpointObject 以 <key, value=""> 的形式存放在一个 Map 里面，而这个 Key，就是这个 JavaScript 文件的 URL。看到这里，已经可以解释很多同学在调试 JavaScript 遇到的一个问题：</key,></p>
<blockquote>
<p>有些同学为了防止页面的 JavaScript 文件不更新，对于一些重要的 JavaScript 文件的 URL 添加访问时间戳，对于这些添加了访问时间戳的 JavaScript 文件进行设置断点然后刷新调试的时候，Chrome 会打印一个 warnning，告诉你断点丢失。</p>
</blockquote>
<p>原因很简单，在调试的时候，V8 发现这个 breakpointMap 里面找不到对应的 breakpointObject，因为 URL 发生了变化，这个 brakpointObject 就丢失了，所以 V8 就找不到了，无法进行断点调试。</p>
<p>根据我们的正常思维，你可能会认为 V8 会将断点设置在 C++ 中，其实一开始我也是这么认为。随着对 V8 的探索，让我看到了我时曾相识的一些函数名：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">v8::Local&lt;v8::Function&gt; setBreakpointFunction = v8::Local&lt;v8::Function&gt;::Cast(</span><br><span class="line">    m_debuggerScript.Get(m_isolate)</span><br><span class="line">    -&gt;Get(context, toV8StringInternalized(m_isolate, <span class="string">"setBreakpoint"</span>))</span><br><span class="line">      .ToLocalChecked());</span><br><span class="line">v8::Local&lt;v8::Value&gt; breakpointId =</span><br><span class="line">  v8::Debug::Call(debuggerContext(), setBreakpointFunction, info)</span><br><span class="line">    .ToLocalChecked();</span><br></pre></td></tr></table></figure></p>
<p>其中，<code>m_debuggerScript</code>，就是我前面提到的 <code>debugger-script.js</code>。随着对 V8 Debugger 的进一步探索，我发现，V8 实际上对这个对这个 breakpointObject 设置了 2 次。一次是通过在 C++ 中调用 m_debuggerScript 的 setBreakpoint 设置到 JavaScript 的 context 里面，也就是上面这段 C++ 逻辑做的事情。另一次是，<code>m_debuggerScript</code> 反过来将断点信息设置到了 V8 的 C++ Runtime 中，为要调试的 JavaScript 的某一行设置一个 JavaScript 的回调函数。</p>
<h4 id="断点命中"><a href="#断点命中" class="headerlink" title="断点命中"></a>断点命中</h4><p>由于 V8 对 JavaScript 是及时编译执行的，没有生成 bytecode，而是直接生成的 machine code 执行的，所以这个断点回调函数也会被设置到这个 machine code 里面。</p>
<p>最终触发断点事件，也是 V8 的 C++ Runtime。当用户刷新或者直接执行 JavaScript 的逻辑的时候，实际上是 V8 C++ Runtime 在运行 JavaScript 片段产生的 machine code，这个 machine code 已经包含了断点回调函数了。一旦这个 machine code 里面的回调函数被触发，接着就会触发之前 Debugger.enable 设置的调试事件监听器 DebugEventListener 的回调函数。并返回一条消息给 Chrome 的 devtool，告诉 Chrome devtool，当前 JavaScript 被 pause 的行号。到此为止，一个断点就被命中了。</p>
<p>关于 JavaScript 断点命中，其实是一个很复杂的过程。后面有时间的话，会专门讲讲 JavaScript 断点命中的详细逻辑。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>浏览器的调试，最终都落脚到引擎：渲染引擎和 JavaScipt 引擎。那么对于 JavaScript 调试来说，难点就在于 V8 如何给 JavaScript 某一行进行标记然后进行断点，这需要有一点 V8 的知识。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="https://img.alicdn.com/tfs/TB1MZ9aNVXXXXaQXFXXXXXXXXXX-900-500.jpg" alt="揭秘浏览器远程调试技术"></p>
<h2 id="调试技术的起源"><a href="#调试技术的起源" ]]>
    </summary>
    
      <category term="远程调试" scheme="http://taobaofed.org/tags/%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/"/>
    
      <category term="工具&amp;平台" scheme="http://taobaofed.org/categories/%E5%B7%A5%E5%85%B7-%E5%B9%B3%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Velocity NYC 2016 参会总结]]></title>
    <link href="http://taobaofed.org/blog/2016/10/11/thinking-in-velocity-nyc-2016/"/>
    <id>http://taobaofed.org/blog/2016/10/11/thinking-in-velocity-nyc-2016/</id>
    <published>2016-10-11T10:38:34.000Z</published>
    <updated>2017-03-18T09:50:27.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img.alicdn.com/tfs/TB1H9LFNFXXXXb_aXXXXXXXXXXX-900-500.jpg" alt="Velocity NYC 2016 参会总结"></p>
<p>就在刚刚过去的九月，作为 FED 团队的代表有幸参加了美国纽约的 Velocity Web 性能和敏捷运维大会。在大约一周的行程中，会议团队组织了十分丰富的行程，会议团队也在内部对于 Velocity 的演讲内容做了多次讨论。整个行程在我看来是十分圆满的。</p>
<h1 id="Velocity-NYC"><a href="#Velocity-NYC" class="headerlink" title="Velocity @ NYC"></a>Velocity @ NYC</h1><p>Velocity 作为 <a href="http://www.oreilly.com/conferences/" target="_blank" rel="external">O’Reilly</a> 旗下的老牌会议品牌，从 2008 年开始专著 Web 性能、DevOps（运维或开发自运维）等领域。在会议组织、开发者关系和商业运作等方面都十分老道。国内的开发者社区方兴未艾，也有诸如 SegmentFault D-Day、JSConf、D2 等类似定位的会议，但从各方面来讲都与 Velocity 有云泥之别。这也是为何在汇报中把会议组织本身感想放在了最前面。</p>
<p>会议组织方固定在圣克拉拉（美国加州）、纽约（美国纽约州）、阿姆斯特丹（荷兰）、北京（中国）四个城市巡回举办，可见其国际化程度之高。正是如此的多元化的组织形式，不仅吸引了全球不同国家的参会者，对于赞助商和讲师来说，也让自己的思想和意志传播到得更广。另一方面，由于有固定的巡回议程，举办方在现场把控上容易积累更多的经验。这是体现在各种细节上的，例如：</p>
<ul>
<li>会场位于纽约中央公园旁边，对于第一次来纽约的人来说，太好找了；另外由于地处曼哈顿中心，即使当日会议日程安排的很晚，也不用担心治安问题；</li>
<li>会议前夕，收到邮件告知参会信息以及领取胸牌的操作指南，并且提供了一个会议伴侣 App，方便当天查询会日日程；</li>
<li>茶歇区即赞助商展位，互利互惠；作为参会者，还是很有激情一边吃吃喝喝一边参观摊位的；</li>
<li>赞助商的展位都有非常专业的一对一讲解、游戏、抽奖等各类活动；</li>
<li>赞助商参与的演讲均有明显标示，参会者可以自行选择；</li>
<li>…</li>
</ul>
<p>当然，国内的技术会议也办的的越来越好了。</p>
<p>补充下没有论据的一家之言：健康良好的开发者社区不应该只是默默的搞开源项目，而是应该包括线上和线下；如今开发者 BBS、博客、微博大V、公众号等富媒体已经产生了大量的技术内容，但是还以搬运国外原创内容和互相捧臭脚为主；而线下的会议和其他形式活动（编程马拉松、培训等）缺乏成熟稳健的商业模式，导致要么昙花一现，要么沦为大厂的宣传和招聘工具。</p>
<p>根据 <a href="https://www.infoq.com/news/2014/01/IDC-software-developers" target="_blank" rel="external">IDC 数据</a>，国内 2014 年开发者人群约有 185 万，相信随着互联网的火爆发展，近几年这个数据只会增长的更快。阿里作为国内首屈一指的互联网综合体，拥有丰富的开发者资源、良好品牌效应，理应在这个领域发出更大的声音。</p>
<h1 id="Keynote-心得：意料之外，情理之中"><a href="#Keynote-心得：意料之外，情理之中" class="headerlink" title="Keynote 心得：意料之外，情理之中"></a>Keynote 心得：意料之外，情理之中</h1><p>Velocity 的主题限定了 Web 性能和 DevOps 两个领域，但实际上这两个领域又都非常宽泛，所以导致一次会议中演讲的具体内容并没有非常清晰的关联关系。本次的会议有一个宴会厅和五个会议室，每个会议室至多一天分为五场演讲顺序进行。作为参与者，是不可能全部全部听完的。但整体上还是有有不少热门主题被多次提到，所以后文还是以这些较为聚焦的话题进行归纳总结。</p>
<h2 id="微服务趋于理性"><a href="#微服务趋于理性" class="headerlink" title="微服务趋于理性"></a>微服务趋于理性</h2><p>微服务架构至少被个大厂商（Google、Facebook、Twitter、Netflix）布道有两年有余，那些能够接受的公司早已改造完毕。如今甜蜜期已过，新架构带来的各种问题也接踵而来。</p>
<p>这次直接和微服务有关的演讲有：</p>
<ul>
<li><a href="http://conferences.oreilly.com/velocity/devops-web-performance-ny/public/schedule/detail/51097" target="_blank" rel="external">Mitigating sprawl with microservices and containerization</a></li>
<li><a href="http://conferences.oreilly.com/velocity/devops-web-performance-ny/public/schedule/detail/51220" target="_blank" rel="external">Running Consul at scale: Service discovery in the cloud</a></li>
<li><a href="http://conferences.oreilly.com/velocity/devops-web-performance-ny/public/schedule/detail/51313" target="_blank" rel="external">Distributed tracing: How to do latency analysis for microservices-based applications</a></li>
<li><a href="http://conferences.oreilly.com/velocity/devops-web-performance-ny/public/schedule/detail/51230" target="_blank" rel="external">The once and future layer 5: Resilient, Twitter-style microservices</a></li>
</ul>
<p>这些话题（包括其他的话题）大多有一个特征——它们聚焦一个问题，给出一个思路，结合一个解决方案，最后给出实践成果。被各位演讲者提到的问题：</p>
<ol>
<li>编码成本提高：代码越来越复杂，一个是在代码行数上，另外就是服务组件越来越多</li>
<li>人员成本提高：团队越来越复杂，细化后的组件总会依赖至少一个团队去负责维护</li>
<li>调试成本提高：新架构下的会话跟踪、重放、日志以及自动测试等中间件都要改造以及积累经验</li>
<li>稳定性成本提高：监控、容灾和资源调度也都出现了新的问题</li>
</ol>
<p><img src="https://img.alicdn.com/tps/TB17.vVNFXXXXcVXFXXXXXXXXXX-668-384.png" alt="2"></p>
<p>社区里针对这些问题给了不少开源方案，例如 <a href="https://www.consul.io/" target="_blank" rel="external">Consul</a>、<a href="https://twitter.github.io/finagle/" target="_blank" rel="external">Finage</a>、<a href="https://github.com/openzipkin/zipkin" target="_blank" rel="external">Zipkin</a>。</p>
<p>阿里内部由于有一个强大的中间件团队，所以这些基础设施均为自建。虽然实现不一样，其实大家的理论都基本类似。集团的 HSF 服务出现的很早，如今也是 PandoraBoot 的实现基础；EagleEye 也是老牌的 Tracer，基本能适配到任何应用场景了。</p>
<p>除了在部分细节不如开源方案来得好。例如，HSF 对超时处理、分布式事物等处理欠缺、容灾方案常常只有机房热冷备诸如此类的问题。但阿里的中间件实际表现是十分出色的，并且经过了时间的考验。</p>
<p>反过来想也有些后怕，在中小型企业对极为积极的采纳这些开源方案并玩的正欢的时候，集团的技术人员由于没有实际的应用场景，其实并不是很热衷于去了解这些东西，是否会和外界社区脱节呢？当然大厂留着各种私货是很正常的事情（包括 Google、Facebook）。</p>
<h2 id="DevOps-全家桶越来越大：Serverless、CloudNative、Infrastructure-as-Code…"><a href="#DevOps-全家桶越来越大：Serverless、CloudNative、Infrastructure-as-Code…" class="headerlink" title="DevOps 全家桶越来越大：Serverless、CloudNative、Infrastructure as Code…"></a>DevOps 全家桶越来越大：Serverless、CloudNative、Infrastructure as Code…</h2><p>今年围绕 DevOps 的新名词 Serverless、CloudNative、Infrastructure as Code 等新名词如数出现在了演讲的标题中。</p>
<p>对技术人员来讲，是大家开始从吹捧 DevOps 概念，到了各种实践和解决方案，然后并进入下一轮概念炒作的过程了（注意此处炒作并不是贬义）。</p>
<p>Serverless 是一种和微服务有关的开发和部署形式（即 DevOps 的一种实践方案）。Serverless 的模式下，开发者不再关注计算资源（集群、服务器等）、不再关心虚拟化（VM、Docker 等）、不再关心进程模型（进程启动、停止、重启等），只需利用各种云计算资源（对象存储、消息服务、离线任务等）提供实现业务逻辑的函数或方法。Amazon 的 AWS 最近提供的一种新的服务类型 <a href="https://aws.amazon.com/cn/documentation/lambda/" target="_blank" rel="external">Lambda</a> 所掀起的新一轮浪潮，预计其他云服务厂商会迅速跟进。这种模式也非常适合在集团内部推广，为业务开发减负，同时提高整体资源利用率。当然，目前 AWS 推的还是动态语言的服务类型，诸如 Node.js、Python，预计 Scala 也快了，也许这也是让多语言在业务层面得到支持的一个好机会。</p>
<p>Serverless 的主题演讲有：</p>
<ul>
<li><a href="http://conferences.oreilly.com/velocity/devops-web-performance-ny/public/schedule/detail/51002" target="_blank" rel="external">Managing serverless: Ops for NoOps</a></li>
<li><a href="http://conferences.oreilly.com/velocity/devops-web-performance-ny/public/schedule/detail/53601" target="_blank" rel="external">Ops in the time of serverless containerized webscale</a></li>
</ul>
<p>由于时间关系我只去了第二个，但比较失望的是一个多人对话形式的访谈，并没有什么逻辑可言。多为介绍自己公司的在 Docker、Serverless（沾了点边）方面的实践。透过第一个演讲的 Keynote 可以判断内容还是有很高价值的，讲的是第一轮 Serverless 实践中遇到的各种问题，主要集中在监控方法、编程模式、安全模型的变化，并且讽刺的是其内容透出的担忧标示 Serverless 并不能让开发者完全不关心服务器。</p>
<p><a href="http://conferences.oreilly.com/velocity/devops-web-performance-ny/public/schedule/detail/51192" target="_blank" rel="external">Implementing infrastructure as code</a> 是一个布道性质的演讲，从零开始介绍了其概念、组成部分（以及顺便推销了自己的书）。</p>
<p>Infrastructure as Code 也不是什么全新的概念，是指利用软件工程的工具和方法来管理基础设施的一种思路。近几年 Docker 火的的一塌糊涂，其一大特性就是所有资源都可以通过 API 操控，这也是 Infrastructure as Code 在实践上成为可能的一大支柱。在此之上的 <a href="http://kubernetes.io/" target="_blank" rel="external">kubernetes</a> 等开源项目又在集群纬度提供了可编程的编排能力。这样开发者是能够面向集群编程管理的，这才是真正意义上的 DevOps。题外话，这里也期望明年的 Docker 改造中起码能把 DockerCompose 的能力开放出来。</p>
<p><img src="https://img.alicdn.com/tps/TB1tGweNFXXXXa7XXXXXXXXXXXX-1017-576.png" alt="4.png"></p>
<p>最后，CloudNative 是一套包括 CD（持续交付）、Microservice（微服务）、DevOps、容器思想的集合，所以这次会议的演讲中不会直接将其作为主题，但都命中 CloudNative 这个关键字。再说几个厂商的名字 Pivotal、Cloud Foundry，都是这些概念的布道者，也是此次 Velocity 会议的演讲者和赞助商。</p>
<h2 id="Web-相关"><a href="#Web-相关" class="headerlink" title="Web 相关"></a>Web 相关</h2><h3 id="MobileWeb-性能优化和趋势"><a href="#MobileWeb-性能优化和趋势" class="headerlink" title="MobileWeb 性能优化和趋势"></a>MobileWeb 性能优化和趋势</h3><p>这次来自 Google 的两场演讲分别介绍了 PWA、AMP</p>
<ul>
<li><a href="http://conferences.oreilly.com/velocity/devops-web-performance-ny/public/schedule/detail/50799" target="_blank" rel="external">The future of the mobile Web</a></li>
<li><a href="http://conferences.oreilly.com/velocity/devops-web-performance-ny/public/schedule/detail/50798" target="_blank" rel="external">The Accelerated Mobile Pages (AMP) Project: What lies ahead?</a></li>
</ul>
<p>总的来讲，Google 作为 Chrome、ChormeOS、V8、Blink 等 Web 技术产品的维护者，自然对 MobileWeb 的前景相当看好，因此每年都会推出一些新的技术来增强 Web 平台的能力。AMP推广的时间很长了，其本质是一套前端优化的最佳实践。PWA 是今年的新技术，也为未来的 MobileWeb 注入了新的活力，但基于 H5 的 MobileWeb 的颓势是不会改变的。</p>
<p>此次也有演讲对 Web 和 App 重新做了对比和思考：<a href="http://conferences.oreilly.com/velocity/devops-web-performance-ny/public/schedule/detail/54229" target="_blank" rel="external"> Web versus apps revisited</a>。里面的数据是血淋淋的，只有 13% 的用户时间花在 MobileWeb 上。</p>
<p>个人观点是，虽然以 HTML5 页面再也不可能成为入口或主要产品，但在碎片场景下是有巨大发挥空间的。例如微信公众号、微信微应用等场景，均是以 HTML5 技术为基础的。</p>
<p>当然 Web 和 App 的竞争还在继续，<a href="https://developer.android.com/topic/instant-apps/index.html" target="_blank" rel="external">Android Instant Apps</a> 这样的技术出现意味着原声应用正在挑战 Web 应用的易传播性这样的优势。而 ReactNative 这样的技术，则在结合 Web 技术和 App 技术来挑战传统 App 的开发成本问题。</p>
<p>阿里旗下产品都有自己的航母应用，所以更多考虑的在闭环生态下增强用户体验的技术改进，Weex、ZCache 这类技术从实际效果来讲远超 Google 给的任何方案，但是 Google 的这些方案是通用方案，我们的是限于 App 内的方案。</p>
<h3 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h3><p>正如上文指出的，大多数演讲都是围绕某个开源项目或自家公司产品进行的，很少有讲解基础技术或原理的。由于时间排期，我听到的数量有限的演讲中，只有 <a href="http://conferences.oreilly.com/velocity/devops-web-performance-ny/public/schedule/detail/51303" target="_blank" rel="external">HTTP/2: What no one is telling you</a> 是讲解 HTTP2 原理和应用的。碍于 40 分钟的时长限制，演讲者也大多在讲时间过程中遇到的问题和一些关键数据。</p>
<p>目前来看 HTTP2 最大的问题就是它并没有想象中的那么好。头压缩、socket 复用等技术在效果上并没有各大浏览器厂商优化了多年的 HTTP1.1 效果好，反而在弱网环境下，简单粗暴占用多连接的 HTTP1.1 效果更好。</p>
<p>HTTP2 在草案期间就广受开发者追捧，可如今标准确定，却罕见实质改变。也许 HTTP2 会让 HTTP 技术在一些 RPC 场景中会有明显优势，但在传统页面浏览方面，并不会得到非常迅速的应用。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Velocity 的会议总的来说，在演讲内容上是中规中矩的，毕竟也不是专门的学术会议或事领域论坛。但正是成熟稳定的运作，让厂商和开发者有持续的交流机会。DevOps 相关话题依然热门，微服务和容器必然成为互联网公司的必备武器。新技术在国内都是慢热的，但最终结果会保持和社区同步，可预见集团在未来也会在这些领域有所沉淀和输出。</p>
<p><img src="https://img.alicdn.com/tps/TB1jK3cNFXXXXbZXXXXXXXXXXXX-800-600.jpg" alt="5.png"></p>
<p>多元化的社会和多元化的会议组成，让我们对于此次美国之行十分充实。行程的最后我们短暂的参观了谷歌位于纽约的分公司。几位华人研发的同事接待了我们，听了他们讲的经历和工作，也感受到在多元化冲击下对于企业和员工的种种机遇是巨大的。也很是期待，阿里集团能拓展更多的国际业务，成为在国际上更具影响力的跨国企业。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img.alicdn.com/tfs/TB1H9LFNFXXXXb_aXXXXXXXXXXX-900-500.jpg" alt="Velocity NYC 2016 参会总结"></p>
<p>就在刚刚过去的九月，作为 FED 团队的代表有]]>
    </summary>
    
      <category term="Velocity" scheme="http://taobaofed.org/tags/Velocity/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[理解 Babel 插件]]></title>
    <link href="http://taobaofed.org/blog/2016/09/29/babel-plugins/"/>
    <id>http://taobaofed.org/blog/2016/09/29/babel-plugins/</id>
    <published>2016-09-29T10:58:03.000Z</published>
    <updated>2017-03-18T09:50:27.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img.alicdn.com/tfs/TB1cVgDNpXXXXb2XFXXXXXXXXXX-900-500.jpg" alt="理解 Babel 插件"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>相信目前常与 ES6 代码打交道的同学对 Babel 应该不会陌生，在 ES6 代码被编译转化为 ES5 代码的过程中，Babel 插件显得尤为重要，我们最后经由 Babel 生成的代码取决于插件在这一层中做了什么事，在探索这其中的过程之前，我们先来了解下一些所需的基础知识。</p>
<h2 id="抽象语法树"><a href="#抽象语法树" class="headerlink" title="抽象语法树"></a>抽象语法树</h2><p>Babel 的工作流可以用下面一张图来表示，代码首先经由 <code>babylon</code> 解析成<a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" target="_blank" rel="external">抽象语法树</a>（AST），后经一些遍历和分析转换（主要过程），最后根据转换后的 AST 生成新的常规代码。</p>
<p><img src="https://img.alicdn.com/tps/TB1nP2ONpXXXXb_XpXXXXXXXXXX-1958-812.png" alt=""></p>
<p>在这其中，理解清楚 AST 十分重要，我们之所以需要将代码转换为 AST 也是为了让计算机能够更好地进行理解。我们可以来看看下面这段代码被解析成 AST 后对应的结构图：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abs</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (number &gt;= <span class="number">0</span>) &#123;  <span class="comment">// test</span></span><br><span class="line">    <span class="keyword">return</span> number;  <span class="comment">// consequent</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> -number; <span class="comment">// alternate</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img.alicdn.com/tps/TB1NnDQNpXXXXXmXFXXXXXXXXXX-1015-756.png" alt=""></p>
<p>所有的 AST 根节点都是 Program 节点，从上图中我们可以看到解析生成的 AST 的结构的各个 Node 节点都很细微，<a href="https://github.com/babel/babylon/blob/master/ast/spec.md" target="_blank" rel="external">Babylon AST</a> 有个文档对每个节点类型都做了详细的说明，你可以对照各个节点类型在这查找到所需要的信息。在这个例子中，我们主要关注函数声明里的内容， <code>IfStatement</code> 对应代码中的 <code>if...else</code> 区块的内容，我们先对条件（<code>test</code>）进行判断，这里是个简单的二进制表达式，我们的分支也会从这个条件继续进行下去，<code>consequent</code> 代表条件值为 true 的分支，<code>alternate</code> 代表条件值为 false 的分支，最后两条分支各自在 <code>ReturnStatement</code> 节点进行返回。</p>
<p>了解 AST 各个节点的类型是后续编写插件的关紧，AST 通常情况下都是比较复杂的，上述一段简单的函数定义也生成了比较大的 AST，对于一些复杂的程序，我们可以借助 <a href="https://astexplorer.net/" target="_blank" rel="external">astexplorer</a> 来帮我们分析 AST 的结构。</p>
<h2 id="遍历节点"><a href="#遍历节点" class="headerlink" title="遍历节点"></a>遍历节点</h2><p>在插件里进行节点遍历需要先了解 visitor 和 path 的概念，前者相当于从众多节点类型中选择开发者所需要的节点，后者相当于对节点之间的关系的访问。</p>
<h3 id="visitor"><a href="#visitor" class="headerlink" title="visitor"></a>visitor</h3><p>Babel 使用 <code>babel-traverse</code> 进行树状的遍历，对于 AST 树上的每一个分支我们都会先向下遍历走到尽头，然后向上遍历退出遍历过的节点寻找下一个分支。Babel 提供我们一个 <a href="https://en.wikipedia.org/wiki/Visitor_pattern" target="_blank" rel="external">visitor</a> 对象供我们获取 AST 里所需的具体节点来进行访问，比如我只想访问 <code>if...else</code> 生成的节点，我们可以在 visitor 里指定获取它所对应的节点：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> visitor = &#123;</span><br><span class="line">  IfStatement() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'get if'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>继续上述所说的遍历，其实这种遍历会让每个节点都会被访问两次，一次是向下遍历代表进入（enter），一次是向上退出（exit）。因此实际上每个节点都会有 <code>enter</code> 和 <code>exit</code> 方法，在实际操作的时候需要注意这种遍历方式可能会引起的一些问题，上述例子是省略掉 <code>enter</code> 的简写。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> visitor = &#123;</span><br><span class="line">  IfStatement: &#123;</span><br><span class="line">    enter() &#123;&#125;,</span><br><span class="line">    exit() &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="path"><a href="#path" class="headerlink" title="path"></a>path</h3><p>visitor 模式中我们对节点的访问实际上是对节点路径的访问，在这个模式中我们一般把 <code>path</code> 当作参数传入节点选择器中。<code>path</code> 表示两个节点之间的连接，通过这个对象我们可以访问到节点、父节点以及进行一系列跟节点操作相关的方法（类似 DOM 的操作）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> babel = <span class="built_in">require</span>(<span class="string">'babel-core'</span>);</span><br><span class="line"><span class="keyword">var</span> t = <span class="built_in">require</span>(<span class="string">'babel-types'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> code = <span class="string">`d = a + b + c`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> visitor = &#123;</span><br><span class="line">	Identifier(path) &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(path.node.name);  <span class="comment">// d a b c</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = babel.transform(code, &#123;</span><br><span class="line">	plugins: [&#123;</span><br><span class="line">		visitor: visitor</span><br><span class="line">	&#125;]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="替换节点"><a href="#替换节点" class="headerlink" title="替换节点"></a>替换节点</h2><p>具备了 AST 相关知识和了解 visitor、path 后，就可以编写一个简单的 Babel 插件了。我们要把上述的 <code>abs</code> 函数换成原生支持的 <code>Math.abs</code> 来进行调用 。</p>
<p>首先我们先解析下 <code>abs(-8)</code> 的 AST 结构，直接从表达式语句（ExpressionStatement）开始：</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="symbol">  type:</span> <span class="string">"ExpressionStatement"</span>,</span><br><span class="line"><span class="symbol">  expression:</span> &#123;</span><br><span class="line"><span class="symbol">    type:</span> <span class="string">"CallExpression"</span>,</span><br><span class="line"><span class="symbol">    callee:</span> &#123;</span><br><span class="line"><span class="symbol">      type:</span> <span class="string">"Identifier"</span>,</span><br><span class="line"><span class="symbol">      name:</span> <span class="string">"abs"</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="symbol">    arguments:</span> [&#123;</span><br><span class="line"><span class="symbol">      type:</span> <span class="string">"UnaryExpression"</span>,</span><br><span class="line"><span class="symbol">      operator:</span> <span class="string">"-"</span>,</span><br><span class="line"><span class="symbol">      prefix:</span> true,</span><br><span class="line"><span class="symbol">      arguments:</span> &#123;</span><br><span class="line"><span class="symbol">        type:</span> <span class="string">"NumericLiteral"</span>,</span><br><span class="line"><span class="symbol">        value:</span> <span class="number">8</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到表达式语句下面的 <code>expression</code> 主要是函数调用表达式（<code>CallExpression</code>），因此我们也需要创建一个函数调用表达式，此外，<code>Math.abs</code> 是一个二元操作表达式，属于 <code>MemberExpression</code> 类型。上述两个 AST 节点我们可以借助 <a href="https://github.com/babel/babel/tree/master/packages/babel-types" target="_blank" rel="external">babel-types</a> 里提供的一些方法帮我们快速创建。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建函数调用表达式</span></span><br><span class="line">t.CallExpression(</span><br><span class="line">  <span class="comment">// 创建对象属性引用</span></span><br><span class="line">	t.MemberExpression(t.identifier(<span class="string">'Math'</span>), t.identifier(<span class="string">'abs'</span>)), </span><br><span class="line">	<span class="comment">// 原始节点函数调用参数</span></span><br><span class="line">	path.node.arguments </span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>最后我们需要对此次函数调用不符合的节点进行过滤，过滤掉名字不等于 abs 的函数调用，因为 Babel 在遍历的过程是递归的，如果不过滤做限制的话，程序将会一直运行最终报调用栈超过阈值的错误。</p>
<p><code>RangeError: unknown: Maximum call stack size exceeded</code></p>
<p>最终代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> babel = <span class="built_in">require</span>(<span class="string">'babel-core'</span>);</span><br><span class="line"><span class="keyword">var</span> t = <span class="built_in">require</span>(<span class="string">'babel-types'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> code = <span class="string">`abs(-8);`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> visitor = &#123;</span><br><span class="line">	CallExpression(path) &#123;</span><br><span class="line">		<span class="keyword">if</span> (path.node.callee.name !== <span class="string">'abs'</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">		path.replaceWith(t.CallExpression(</span><br><span class="line">			t.MemberExpression(t.identifier(<span class="string">'Math'</span>), t.identifier(<span class="string">'abs'</span>)),</span><br><span class="line">			path.node.arguments</span><br><span class="line">		));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = babel.transform(code, &#123;</span><br><span class="line">	plugins: [&#123;</span><br><span class="line">		visitor: visitor</span><br><span class="line">	&#125;]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Math.abs(-8)</span></span><br><span class="line"><span class="built_in">console</span>.log(result.code);</span><br></pre></td></tr></table></figure>
<p>上述例子使用了 <code>transform</code> api 直接解析转换生成了新的代码，另外在单独编写 Babel 插件的时候，暴露的参数里一般都含有常用的 <code>babel-types</code> 对象供使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">&#123; types: t &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    visitor: &#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过编写 Babel 插件我们能对 AST 有一定的了解，另外，我认为现阶段 Babel 插件不仅仅止于对 ES6 代码的转换上，<a href="https://www.npmjs.com/search?q=babel-plugin" target="_blank" rel="external">npm</a> 上有一系列的插件覆盖了许多适合的应用场景，后续具有一定的探索性。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://github.com/babel/babylon/blob/master/ast/spec.md" target="_blank" rel="external">babylon-spec</a></li>
<li><a href="https://github.com/babel/babel/tree/master/packages/babel-types" target="_blank" rel="external">babel-types</a></li>
<li><a href="https://www.h5jun.com/post/babel-for-es6-and-beyond.html" target="_blank" rel="external">babel-for-es6-and-beyond</a></li>
<li><a href="https://www.sitepoint.com/understanding-asts-building-babel-plugin/" target="_blank" rel="external">understanding-asts-building-babel-plugin</a></li>
<li><a href="https://github.com/thejameskyle/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#toc-visitors" target="_blank" rel="external">babel-handbook</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img.alicdn.com/tfs/TB1cVgDNpXXXXb2XFXXXXXXXXXX-900-500.jpg" alt="理解 Babel 插件"></p>
<h2 id="前言"><a href="#前言" class="head]]>
    </summary>
    
      <category term="Babel" scheme="http://taobaofed.org/tags/Babel/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Node.js 和 C++ 之间的类型转换]]></title>
    <link href="http://taobaofed.org/blog/2016/09/20/type-casts-between-node-and-cpp/"/>
    <id>http://taobaofed.org/blog/2016/09/20/type-casts-between-node-and-cpp/</id>
    <published>2016-09-20T03:18:23.000Z</published>
    <updated>2017-03-18T09:50:27.000Z</updated>
    <content type="html"><![CDATA[<p><img src="//img.alicdn.com/tfs/TB1h_SoNpXXXXcMXXXXXXXXXXXX-900-500.jpg" alt="Node.js 和 C++ 之间的类型转换"></p>
<p>我非常喜欢使用 Node.js，但是当涉及到计算密集型的场景时 Node.js 就不能够很好地胜任了。而在这样的情况下 C++  是一个很好的选择，非常幸运 Node.js 官方提供了 <a href="https://nodejs.org/dist/latest-v6.x/docs/api/addons.html" target="_blank" rel="external">C/C++ Addons</a> 的机制让我们能够使用 V8 API 把 Node.js 和 C++ 结合起来。</p>
<p>虽然在 Node.js 官方网站有很多的关于怎么使用这些 API 的文档，但是在 JavaScript 和 C++ 之间传递数据是一件非常麻烦的事情，C++ 是强类型语言（”1024” 是字符串类型而不是整数类型），而 JavaScript 却总是默认的帮我们做一些类型转换。</p>
<p>JavaScript 的基本类型包括 String，Number，Boolean，null，undefined，V8 使用类继承的方式来定义这类型，这些类型都继承了 <code>Primitive</code> 类，而 <code>Primitive</code> 继承了 <code>Value</code>，v8 也支持整型（包括 <code>Int32</code> 和 <code>Uint32</code>），而所有的类型定义都可以从 V8 <a href="https://v8docs.nodesource.com/node-6.0/d0/d4a/classv8_1_1_primitive.html" target="_blank" rel="external">类型文档</a>中看到，除了基本的类型，还有 Object，Array，Map 等类型的定义。</p>
<p>基本类型的继承关系如下图：<br><img src="https://img.alicdn.com/tfs/TB1JspRNpXXXXajapXXXXXXXXXX-804-860.png" alt="primitive"></p>
<p>在 V8 中所有 JavaScript 值都是被放在 <code>Local</code> 对象中，通过这个对象指定了 JavaScript 运行时的内存单元。</p>
<p>下面这段代定义了一个 <code>Number</code> 类型的值，其中 Test 函数中声明的 isolate 变量代表着 V8 虚拟机中的堆内存，当创建新变量的时候就需要用到它，接下来的一行代码就通过 isolate 声明了一个 <code>Number</code> 类型的变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;node.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;v8.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> v8;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">const</span> v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">    Isolate* isolate = args.GetIsolate();</span><br><span class="line">    <span class="comment">// 声明变量</span></span><br><span class="line">    Local&lt;Number&gt; retval = v8::Number::New(isolate, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Local &lt;Object&gt; exports, Local&lt;Object&gt; module)</span> </span>&#123;</span><br><span class="line">    NODE_SET_METHOD(exports, <span class="string">"getTestValue"</span>, Test);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NODE_MODULE(returnValue, init)</span><br></pre></td></tr></table></figure>
<p>看了 V8 <a href="https://v8docs.nodesource.com/node-6.0/d0/d4a/classv8_1_1_primitive.html" target="_blank" rel="external">类型 API 文档</a> 你会发现对于基本的 JavaScript 类型，只有变量的声明而没有变量的赋值。最初想可能觉得这个非常的奇怪，可是仔细想一想后发现这个是合理的。主要由以下几点原因：</p>
<ul>
<li>JavaScript 的基本类型是不可变类型，变量都是指向一个不可变的内存单元，var a = 10，则 a 指向的内存单元中包含的值为 5，重新赋值 a = 100，没有改变这个内存单元的值，而是使得 a 指向了另外一个内存单元，其中的值为 100。如果声明两个变量 x，y 的值都为 10，则他们指向的是同一个内存单元。</li>
<li>函数的传参都是传值，而不是传引用，当在 JavaScript 中调用 C++ 的函数时，如果参数是基本类型则每次都是把这个值拷贝过去，改变参数的值不会影响原来的值。</li>
<li>使用 <code>Local&lt;Value&gt;</code> 声明基本类型的变量都是对内存单元的引用，因为第一条原因不可能改变引用的值使其指向另外一个内存单元，因此不存在变量的重新赋值。</li>
</ul>
<h3 id="数据流向-C-gt-JavaScript"><a href="#数据流向-C-gt-JavaScript" class="headerlink" title="数据流向 C++ -&gt; JavaScript"></a>数据流向 C++ -&gt; JavaScript</h3><p>下面 demo 定义了一些常用的 JavaScript 类型，包括基本类型的以及 Object, Array, Fuction。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;node.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;v8.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> v8;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyFunction</span><span class="params">(<span class="keyword">const</span> v8::FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">    Isolate* isolate = args.GetIsolate();</span><br><span class="line">    args.GetReturnValue().Set(String::NewFromUtf8(isolate, <span class="string">"Hello World!"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">const</span> v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">    Isolate* isolate = args.GetIsolate();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Number 类型的声明</span></span><br><span class="line">    Local&lt;Number&gt; retval = v8::Number::New(isolate, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// String 类型的声明</span></span><br><span class="line">    Local&lt;String&gt; str = v8::String::NewFromUtf8(isolate, <span class="string">"Hello World!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Object 类型的声明</span></span><br><span class="line">    Local&lt;Object&gt; obj = v8::Object::New(isolate);</span><br><span class="line">    <span class="comment">// 对象的赋值</span></span><br><span class="line">    obj-&gt;Set(v8::String::NewFromUtf8(isolate, <span class="string">"arg1"</span>), str);</span><br><span class="line">    obj-&gt;Set(v8::String::NewFromUtf8(isolate, <span class="string">"arg2"</span>), retval);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Function 类型的声明并赋值</span></span><br><span class="line">    Local&lt;FunctionTemplate&gt; tpl = v8::FunctionTemplate::New(isolate, MyFunction);</span><br><span class="line">    Local&lt;Function&gt; fn = tpl-&gt;GetFunction();</span><br><span class="line">    <span class="comment">// 函数名字</span></span><br><span class="line">    fn-&gt;SetName(String::NewFromUtf8(isolate, <span class="string">"theFunction"</span>));</span><br><span class="line">    obj-&gt;Set(v8::String::NewFromUtf8(isolate, <span class="string">"arg3"</span>), fn);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Boolean 类型的声明</span></span><br><span class="line">    Local&lt;Boolean&gt; flag = Boolean::New(isolate, <span class="literal">true</span>);</span><br><span class="line">    obj-&gt;Set(String::NewFromUtf8(isolate, <span class="string">"arg4"</span>), flag);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Array 类型的声明</span></span><br><span class="line">    Local&lt;Array&gt; arr = Array::New(isolate);</span><br><span class="line">    <span class="comment">// Array 赋值</span></span><br><span class="line">    arr-&gt;Set(<span class="number">0</span>, Number::New(isolate, <span class="number">1</span>));</span><br><span class="line">    arr-&gt;Set(<span class="number">1</span>, Number::New(isolate, <span class="number">10</span>));</span><br><span class="line">    arr-&gt;Set(<span class="number">2</span>, Number::New(isolate, <span class="number">100</span>));</span><br><span class="line">    arr-&gt;Set(<span class="number">3</span>, Number::New(isolate, <span class="number">1000</span>));</span><br><span class="line">    obj-&gt;Set(String::NewFromUtf8(isolate, <span class="string">"arg5"</span>), arr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Undefined 类型的声明</span></span><br><span class="line">    Local&lt;Value&gt; und = Undefined(isolate);</span><br><span class="line">    obj-&gt;Set(String::NewFromUtf8(isolate, <span class="string">"arg6"</span>), und);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// null 类型的声明</span></span><br><span class="line">    Local&lt;Value&gt; null = Null(isolate);</span><br><span class="line">    obj-&gt;Set(String::NewFromUtf8(isolate, <span class="string">"arg7"</span>), null);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回给 JavaScript 调用时的返回值</span></span><br><span class="line">    args.GetReturnValue().Set(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Local &lt;Object&gt; exports, Local&lt;Object&gt; module)</span> </span>&#123;</span><br><span class="line">    NODE_SET_METHOD(exports, <span class="string">"getTestValue"</span>, Test);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NODE_MODULE(returnValue, init)</span><br></pre></td></tr></table></figure>
<p>所有的 addon 都需要一个初始化的函数，如下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Initialize</span><span class="params">(Local&lt;Object&gt; exports)</span></span>;</span><br><span class="line">NODE_MODULE(module_name, Initialize)</span><br></pre></td></tr></table></figure>
<p><code>Initialize</code> 是初始化的函数，<code>module_name</code> 是编译后产生的二进制文件名，上述代码的模块名为 <code>returnValue</code>。</p>
<p>上述代码通过 node-gyp 编译后（编译过程官方文档 <a href="https://nodejs.org/dist/latest-v6.x/docs/api/addons.html" target="_blank" rel="external">C/C++ Addons</a> 有详细的介绍），可以通过如下的方式调用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// returnValue.node 这个文件就是编译后产生的文件，通过 NODE_MODULE(returnValue, init) 决定的文件名</span></span><br><span class="line"><span class="keyword">const</span> returnValue = <span class="built_in">require</span>(<span class="string">'./build/Release/returnValue.node'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(returnValue.getTestValue());</span><br></pre></td></tr></table></figure>
<p>运行结果如下:<br><img src="https://img.alicdn.com/tfs/TB1jb80NpXXXXXYaXXXXXXXXXXX-840-324.png" alt="returnValue"></p>
<h3 id="数据流向-javaScript-gt-C"><a href="#数据流向-javaScript-gt-C" class="headerlink" title="数据流向 javaScript -&gt; C++"></a>数据流向 javaScript -&gt; C++</h3><p>上面的 demo 展示了怎样在在 C++ 定义 JavaScript 类型，数据的是从 C++ 流向 JavaScript，反过来数据也需要从 javaScript 流向 C++，也就是调用 C++ 函数的时候需要传入一些参数。</p>
<p>下面的代码展示了参数个数判断，参数类型判断，以及参数类型装换成 V8 类型的过程，包括基本类型以及 Object, Array, Fuction。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;node.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;v8.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> v8;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetArgument</span><span class="params">(<span class="keyword">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">    Isolate* isolate = args.GetIsolate();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数长度判断</span></span><br><span class="line">    <span class="keyword">if</span> (args.Length() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        isolate-&gt;ThrowException(Exception::TypeError(</span><br><span class="line">            String::NewFromUtf8(isolate, <span class="string">"Wrong number of arguments"</span>)));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数类型判断</span></span><br><span class="line">    <span class="keyword">if</span> (!args[<span class="number">0</span>]-&gt;IsNumber() || !args[<span class="number">1</span>]-&gt;IsNumber()) &#123;</span><br><span class="line">        <span class="comment">//抛出错误</span></span><br><span class="line">        isolate-&gt;ThrowException(Exception::TypeError(</span><br><span class="line">            String::NewFromUtf8(isolate, <span class="string">"argumnets must be number"</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!args[<span class="number">0</span>]-&gt;IsObject()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I am not Object\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!args[<span class="number">0</span>]-&gt;IsBoolean()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I am not Boolean\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!args[<span class="number">0</span>]-&gt;IsArray()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I am not Array\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!args[<span class="number">0</span>]-&gt;IsString()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I am not String\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!args[<span class="number">0</span>]-&gt;IsFunction()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I am not Function\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!args[<span class="number">0</span>]-&gt;IsNull()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I am not Null\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!args[<span class="number">0</span>]-&gt;IsUndefined()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I am not Undefined\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// js Number 类型转换成 v8 Number 类型</span></span><br><span class="line">    Local&lt;Number&gt; value1 = Local&lt;Number&gt;::Cast(args[<span class="number">0</span>]);</span><br><span class="line">    Local&lt;Number&gt; value2 = Local&lt;Number&gt;::Cast(args[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">double</span> value = value1-&gt;NumberValue() + value2-&gt;NumberValue();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// js String 类型转换成 v8 String 类型</span></span><br><span class="line">    Local&lt;String&gt; str = Local&lt;String&gt;::Cast(args[<span class="number">2</span>]);</span><br><span class="line">    String::<span class="function">Utf8Value <span class="title">utfValue</span><span class="params">(str)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">string</span>(*utfValue)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// js Array 类型转换成 v8 Array 类型</span></span><br><span class="line">    Local&lt;Array&gt; input_array = Local&lt;Array&gt;::Cast(args[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d, %f %f\n"</span>, input_array-&gt;Length(), input_array-&gt;Get(<span class="number">0</span>)-&gt;NumberValue(), input_array-&gt;Get(<span class="number">1</span>)-&gt;NumberValue());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// js Object 类型转换成 v8 Object 类型</span></span><br><span class="line">    Local&lt;Object&gt; obj = Local&lt;Object&gt;::Cast(args[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 key 获取对象中的值</span></span><br><span class="line">    Local&lt;Value&gt; a = obj-&gt;Get(String::NewFromUtf8(isolate, <span class="string">"a"</span>));</span><br><span class="line">    Local&lt;Value&gt; b = obj-&gt;Get(String::NewFromUtf8(isolate, <span class="string">"b"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// js Array 类型转换成 v8 Array 类型</span></span><br><span class="line">    Local&lt;Array&gt; c = Local&lt;Array&gt;::Cast(obj-&gt;Get(String::NewFromUtf8(isolate, <span class="string">"c"</span>)));</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a-&gt;NumberValue()&lt;&lt;<span class="string">"   "</span>&lt;&lt;b-&gt;NumberValue()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d, %f %f\n"</span>, c-&gt;Length(), c-&gt;Get(<span class="number">0</span>)-&gt;NumberValue(), c-&gt;Get(<span class="number">1</span>)-&gt;NumberValue());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// js String 类型转换成 v8 String 类型</span></span><br><span class="line">    Local&lt;String&gt; cString = Local&lt;String&gt;::Cast(c-&gt;Get(<span class="number">2</span>));</span><br><span class="line">    String::<span class="function">Utf8Value <span class="title">utfValueD</span><span class="params">(cString)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">string</span>(*utfValueD)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 key 获取对象中的值</span></span><br><span class="line">    Local&lt;Object&gt; d = Local&lt;Object&gt;::Cast(obj-&gt;Get(String::NewFromUtf8(isolate, <span class="string">"d"</span>)));</span><br><span class="line">    Local&lt;String&gt; dString1 = Local&lt;String&gt;::Cast(d-&gt;Get(String::NewFromUtf8(isolate, <span class="string">"m"</span>)));</span><br><span class="line">    String::<span class="function">Utf8Value <span class="title">utfValued1</span><span class="params">(dString1)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">string</span>(*utfValued1)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 key 获取对象中的值</span></span><br><span class="line">    Local&lt;String&gt; dString2 = Local&lt;String&gt;::Cast(d-&gt;Get(String::NewFromUtf8(isolate, <span class="string">"n"</span>)));</span><br><span class="line">    String::<span class="function">Utf8Value <span class="title">utfValued2</span><span class="params">(dString2)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">string</span>(*utfValued2)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// js Booelan 类型转换成 v8 Boolean 类型</span></span><br><span class="line">    Local&lt;Boolean&gt; FlagTrue = Local&lt;Boolean&gt;::Cast(args[<span class="number">5</span>]);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Flag: "</span>&lt;&lt;FlagTrue-&gt;BooleanValue()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// js Function 类型转换成 v8 Function 类型</span></span><br><span class="line">    Local&lt;Function&gt; cb = Local&lt;Function&gt;::Cast(args[<span class="number">8</span>]);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> argc = <span class="number">2</span>;</span><br><span class="line">    Local&lt;Value&gt; argv[<span class="number">2</span>];</span><br><span class="line">    argv[<span class="number">0</span>] = a;</span><br><span class="line">    argv[<span class="number">1</span>] = b;</span><br><span class="line">    cb-&gt;Call(Null(isolate), argc, argv);</span><br><span class="line"></span><br><span class="line">    args.GetReturnValue().Set(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(Local &lt;Object&gt; exports, Local &lt;Object&gt; module)</span> </span>&#123;</span><br><span class="line">    NODE_SET_METHOD(module, <span class="string">"exports"</span>, GetArgument);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NODE_MODULE(argumentss, Init)</span><br></pre></td></tr></table></figure>
<p>通过 node-gyp 编译后，可以通过如下的方式调用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getArguments = <span class="built_in">require</span>(<span class="string">'./build/Release/arguments'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getArguments(<span class="number">2</span>, <span class="number">3</span>, <span class="string">'Hello Arguments'</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], &#123;</span><br><span class="line">        a: <span class="number">10</span>,</span><br><span class="line">        b: <span class="number">100</span>,</span><br><span class="line">        c: [<span class="number">23</span>, <span class="number">22</span>, <span class="string">"我是33"</span>],</span><br><span class="line">        d: &#123; m: <span class="string">'我是22'</span>, n: <span class="string">'我是23'</span> &#125;</span><br><span class="line">    &#125;, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">undefined</span>,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'I am Function!'</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(...args);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'I am Function!'</span>);</span><br><span class="line">    &#125;));</span><br></pre></td></tr></table></figure>
<p>运行结果如下:</p>
<p><img src="https://img.alicdn.com/tfs/TB11tB4NpXXXXaLXVXXXXXXXXXX-796-796.png" alt="argument"></p>
<p>关于其他的类型，我这里就就不一一介绍，V8 文档里面都有对应的 API。</p>
<h3 id="NAN"><a href="#NAN" class="headerlink" title="NAN"></a>NAN</h3><p>由于 V8 的 API 还没有彻底稳定下来，所以对于不同版本的 Node.js 类型相关的 API 会发生变化，而 <a href="https://github.com/nodejs/nan" target="_blank" rel="external">NAN</a> 帮我们做了封装，在编码的时候不需要关心版本问题，只需要引入相应的头文件即可。</p>
<p>引入头文件后，可以如下使用方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v8::Local&lt;v8::Primitive&gt; Nan::Undefined()</span><br><span class="line">v8::Local&lt;v8::Primitive&gt; Nan::Null()</span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="http://blog.scottfrees.com/type-conversions-from-javascript-to-c-in-v8" target="_blank" rel="external">Type conversions from JavaScript to C++ in V8</a></li>
<li><a href="https://nodejs.org/dist/latest-v6.x/docs/api/addons.html" target="_blank" rel="external">node addon</a></li>
<li><a href="https://v8docs.nodesource.com/node-6.0/d0/d4a/classv8_1_1_primitive.html" target="_blank" rel="external">v8 types documentation</a></li>
<li><a href="https://github.com/nodejs/node-gyp" target="_blank" rel="external">node-gyp</a></li>
<li><a href="https://gyp.gsrc.io/docs/UserDocumentation.md" target="_blank" rel="external">gyp user documentation</a></li>
<li><a href="https://github.com/nodejs/nan" target="_blank" rel="external">nan</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="//img.alicdn.com/tfs/TB1h_SoNpXXXXcMXXXXXXXXXXXX-900-500.jpg" alt="Node.js 和 C++ 之间的类型转换"></p>
<p>我非常喜欢使用 Node.js，但是当涉及到计算密集型的场]]>
    </summary>
    
      <category term="类型转换" scheme="http://taobaofed.org/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    
      <category term="addons" scheme="http://taobaofed.org/tags/addons/"/>
    
      <category term="Node.js" scheme="http://taobaofed.org/categories/Node-js/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[细说 webpack 之流程篇]]></title>
    <link href="http://taobaofed.org/blog/2016/09/09/webpack-flow/"/>
    <id>http://taobaofed.org/blog/2016/09/09/webpack-flow/</id>
    <published>2016-09-09T04:02:58.000Z</published>
    <updated>2017-03-18T09:50:27.000Z</updated>
    <content type="html"><![CDATA[<p><img src="//img.alicdn.com/tfs/TB1_ZnHNXXXXXXBXpXXXXXXXXXX-900-500.jpg" alt="细说 webpack 之流程篇"></p>
<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>目前，几乎所有业务的开发构建都会用到 webpack 。的确，作为模块加载和打包神器，只需配置几个文件，加载各种 loader 就可以享受无痛流程化开发。但对于 webpack 这样一个复杂度较高的插件集合，它的整体流程及思想对我们来说还是很透明的。那么接下来我会带你了解 webpack 这样一个构建黑盒，首先来谈谈它的流程。</p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h5 id="1-webstorm-中配置-webpack-webstorm-debugger-script"><a href="#1-webstorm-中配置-webpack-webstorm-debugger-script" class="headerlink" title="1. webstorm 中配置 webpack-webstorm-debugger-script"></a>1. webstorm 中配置 webpack-webstorm-debugger-script</h5><p>在开始了解之前，必须要能对 webpack 整个流程进行 debug ，配置过程比较简单。</p>
<p>先将 <a href="https://www.npmjs.com/package/webpack-webstorm-debugger-script" target="_blank" rel="external">webpack-webstorm-debugger-script</a> 中的 <code>webstorm-debugger.js</code> 置于 <code>webpack.config.js</code> 的同一目录下，搭建好你的脚手架后就可以直接 Debug 这个 webstorm-debugger.js 文件了。</p>
<h5 id="2-webpack-config-js-配置"><a href="#2-webpack-config-js-配置" class="headerlink" title="2. webpack.config.js 配置"></a>2. webpack.config.js 配置</h5><p>估计大家对 webpack.config.js 的配置也尝试过不少次了，这里就大致对这个配置文件进行个分析。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">var</span> node_modules = path.resolve(__dirname, <span class="string">'node_modules'</span>);</span><br><span class="line"><span class="keyword">var</span> pathToReact = path.resolve(node_modules, <span class="string">'react/dist/react.min.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 入口文件，是模块构建的起点，同时每一个入口文件对应最后生成的一个 chunk。</span></span><br><span class="line">  entry: &#123;</span><br><span class="line">    bundle: [</span><br><span class="line">      <span class="string">'webpack/hot/dev-server'</span>,</span><br><span class="line">      <span class="string">'webpack-dev-server/client?http://localhost:8080'</span>,</span><br><span class="line">      path.resolve(__dirname, <span class="string">'app/app.js'</span>)</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 文件路径指向(可加快打包过程)。</span></span><br><span class="line">  resolve: &#123;</span><br><span class="line">    alias: &#123;</span><br><span class="line">      <span class="string">'react'</span>: pathToReact</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 生成文件，是模块构建的终点，包括输出文件与输出路径。</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'build'</span>),</span><br><span class="line">    filename: <span class="string">'[name].js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 这里配置了处理各模块的 loader ，包括 css 预处理 loader ，es6 编译 loader，图片处理 loader。</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    loaders: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        loader: <span class="string">'babel'</span>,</span><br><span class="line">        query: &#123;</span><br><span class="line">          presets: [<span class="string">'es2015'</span>, <span class="string">'react'</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    noParse: [pathToReact]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// webpack 各插件对象，在 webpack 的事件流中执行对应的方法。</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>除此之外再大致介绍下 webpack 的一些核心概念：</p>
<ul>
<li>loader：能转换各类资源，并处理成对应模块的加载器。loader 间可以串行使用。</li>
<li>chunk：code splitting 后的产物，也就是按需加载的分块，装载了不同的 module。</li>
</ul>
<p>对于 module 和 chunk 的关系可以参照 webpack 官方的这张图：</p>
<p><img src="https://img.alicdn.com/tps/TB1B0DXNXXXXXXdXFXXXXXXXXXX-368-522.jpg" alt=""></p>
<ul>
<li><p>plugin：webpack 的插件实体，这里以 UglifyJsPlugin 为例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UglifyJsPlugin</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.options = options;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = UglifyJsPlugin;</span><br><span class="line"></span><br><span class="line">UglifyJsPlugin.prototype.apply = <span class="function"><span class="keyword">function</span>(<span class="params">compiler</span>) </span>&#123;</span><br><span class="line">  compiler.plugin(<span class="string">"compilation"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">compilation</span>) </span>&#123;</span><br><span class="line">    compilation.plugin(<span class="string">"build-module"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">module</span>) </span>&#123;</span><br><span class="line">    &#125;);</span><br><span class="line">    compilation.plugin(<span class="string">"optimize-chunk-assets"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunks, callback</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// Uglify 逻辑</span></span><br><span class="line">    &#125;);</span><br><span class="line">    compilation.plugin(<span class="string">"normal-module-loader"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在 webpack 中你经常可以看到 compilation.plugin(‘xxx’, callback) ，你可以把它当作是一个事件的绑定，这些事件在打包时由 webpack 来触发。</p>
</li>
</ul>
<h5 id="3-流程总览"><a href="#3-流程总览" class="headerlink" title="3. 流程总览"></a>3. 流程总览</h5><p>在具体流程学习前，可以先通过这幅 <a href="https://img.alicdn.com/tps/TB1GVGFNXXXXXaTapXXXXXXXXXX-4436-4244.jpg" target="_blank" rel="external">webpack 整体流程图</a> 了解一下大致流程（建议保存下来查看）。</p>
<p><img src="https://img.alicdn.com/tps/TB1GVGFNXXXXXaTapXXXXXXXXXX-4436-4244.jpg" alt=""></p>
<h3 id="shell-与-config-解析"><a href="#shell-与-config-解析" class="headerlink" title="shell 与 config 解析"></a>shell 与 config 解析</h3><p>每次在命令行输入 webpack 后，操作系统都会去调用 <code>./node_modules/.bin/webpack</code> 这个 shell 脚本。这个脚本会去调用 <code>./node_modules/webpack/bin/webpack.js</code> 并追加输入的参数，如 -p , -w 。(图中 webpack.js 是 webpack 的启动文件，而 $@ 是后缀参数)</p>
<p><img src="https://img.alicdn.com/tps/TB1kvfbNXXXXXarXpXXXXXXXXXX-500-111.jpg" alt=""></p>
<p>在 webpack.js 这个文件中 webpack 通过 optimist 将用户配置的 webpack.config.js 和 shell 脚本传过来的参数整合成 options 对象传到了下一个流程的控制对象中。</p>
<h5 id="1-optimist"><a href="#1-optimist" class="headerlink" title="1. optimist"></a>1. optimist</h5><p>和 commander 一样，<a href="https://github.com/substack/node-optimist" target="_blank" rel="external">optimist</a> 实现了 node 命令行的解析，其 API 调用非常方便。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> optimist = <span class="built_in">require</span>(<span class="string">"optimist"</span>);</span><br><span class="line"></span><br><span class="line">optimist</span><br><span class="line">  .boolean(<span class="string">"json"</span>).alias(<span class="string">"json"</span>, <span class="string">"j"</span>).describe(<span class="string">"json"</span>)</span><br><span class="line">  .boolean(<span class="string">"colors"</span>).alias(<span class="string">"colors"</span>, <span class="string">"c"</span>).describe(<span class="string">"colors"</span>)</span><br><span class="line">  .boolean(<span class="string">"watch"</span>).alias(<span class="string">"watch"</span>, <span class="string">"w"</span>).describe(<span class="string">"watch"</span>)</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>获取到后缀参数后，optimist 分析参数并以键值对的形式把参数对象保存在 optimist.argv 中，来看看 argv 究竟有什么？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// webpack --hot -w</span><br><span class="line">&#123;</span><br><span class="line">  hot: true,</span><br><span class="line">  profile: false,</span><br><span class="line">  watch: true,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-config-合并与插件加载"><a href="#2-config-合并与插件加载" class="headerlink" title="2. config 合并与插件加载"></a>2. config 合并与插件加载</h5><p>在加载插件之前，webpack 将 webpack.config.js 中的各个配置项拷贝到 options 对象中，并加载用户配置在 webpack.config.js 的 plugins 。接着 optimist.argv 会被传入到 <code>./node_modules/webpack/bin/convert-argv.js</code> 中，通过判断 argv 中参数的值决定是否去加载对应插件。(至于 webpack 插件运行机制，在之后的运行机制篇会提到)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ifBooleanArg(<span class="string">"hot"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ensureArray(options, <span class="string">"plugins"</span>);</span><br><span class="line">  <span class="keyword">var</span> HotModuleReplacementPlugin = <span class="built_in">require</span>(<span class="string">"../lib/HotModuleReplacementPlugin"</span>);</span><br><span class="line">  options.plugins.push(<span class="keyword">new</span> HotModuleReplacementPlugin());</span><br><span class="line">&#125;);</span><br><span class="line">...</span><br><span class="line">return options;</span><br></pre></td></tr></table></figure>
<p><code>options</code> 作为最后返回结果，包含了之后构建阶段所需的重要信息。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  entry: &#123;&#125;,//入口配置</span><br><span class="line">  output: &#123;&#125;, //输出配置</span><br><span class="line">  plugins: [], //插件集合(配置文件 + shell指令) </span><br><span class="line">  module: &#123; loaders: [ [Object] ] &#125;, //模块配置</span><br><span class="line">  context: //工程路径</span><br><span class="line">  ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这和 webpack.config.js 的配置非常相似，只是多了一些经 shell 传入的插件对象。插件对象一初始化完毕， options 也就传入到了下个流程中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">"../lib/webpack.js"</span>);</span><br><span class="line"><span class="keyword">var</span> compiler = webpack(options);</span><br></pre></td></tr></table></figure>
<h3 id="编译与构建流程"><a href="#编译与构建流程" class="headerlink" title="编译与构建流程"></a>编译与构建流程</h3><p>在加载配置文件和 shell 后缀参数申明的插件，并传入构建信息 options 对象后，开始整个 webpack 打包最漫长的一步。而这个时候，真正的 webpack 对象才刚被初始化，具体的初始化逻辑在 <code>lib/webpack.js</code> 中，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">webpack</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> compiler = <span class="keyword">new</span> Compiler();</span><br><span class="line">  ...<span class="comment">// 检查options,若watch字段为true,则开启watch线程</span></span><br><span class="line">  <span class="keyword">return</span> compiler;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>webpack 的实际入口是 Compiler 中的 run 方法，run 一旦执行后，就开始了编译和构建流程 ，其中有几个比较关键的 webpack 事件节点。</p>
<ul>
<li><code>compile</code>    开始编译</li>
<li><code>make</code>    从入口点分析模块及其依赖的模块，创建这些模块对象</li>
<li><code>build-module</code>    构建模块</li>
<li><code>after-compile</code>     完成构建</li>
<li><code>seal</code>     封装构建结果</li>
<li><code>emit</code>     把各个chunk输出到结果文件</li>
<li><code>after-emit</code>     完成输出</li>
</ul>
<h5 id="1-核心对象-Compilation"><a href="#1-核心对象-Compilation" class="headerlink" title="1. 核心对象 Compilation"></a>1. 核心对象 Compilation</h5><p>compiler.run 后首先会触发 compile ，这一步会构建出 Compilation 对象：</p>
<p><img src="https://img.alicdn.com/tps/TB1UgS4NXXXXXXZXVXXXXXXXXXX-693-940.png" alt="compilation类图"></p>
<p>这个对象有两个作用，一是负责组织整个打包过程，包含了每个构建环节及输出环节所对应的方法，可以从图中看到比较关键的步骤，如 <code>addEntry()</code> ,  <code>_addModuleChain()</code> ,  <code>buildModule()</code> ,  <code>seal()</code> ,  <code>createChunkAssets()</code>  (在每一个节点都会触发 webpack 事件去调用各插件)。二是该对象内部存放着所有 module ，chunk，生成的 asset 以及用来生成最后打包文件的 template 的信息。</p>
<h5 id="2-编译与构建主流程"><a href="#2-编译与构建主流程" class="headerlink" title="2. 编译与构建主流程"></a>2. 编译与构建主流程</h5><p>在创建 module 之前，Compiler 会触发 make，并调用 <code>Compilation.addEntry</code> 方法，通过 options 对象的 entry 字段找到我们的入口js文件。之后，在 addEntry 中调用私有方法 <code>_addModuleChain</code> ，这个方法主要做了两件事情。一是根据模块的类型获取对应的模块工厂并创建模块，二是构建模块。</p>
<p>而构建模块作为最耗时的一步，又可细化为三步：</p>
<ul>
<li><p>调用各 loader 处理模块之间的依赖</p>
<p>webpack 提供的一个很大的便利就是能将所有资源都整合成模块，不仅仅是 js 文件。所以需要一些 loader ，比如 <code>url-loader</code> ， <code>jsx-loader</code> ， <code>css-loader</code> 等等来让我们可以直接在源文件中引用各类资源。webpack 调用 <code>doBuild()</code> ，对每一个 require() 用对应的 loader 进行加工，最后生成一个 js module。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Compilation.prototype._addModuleChain = <span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">context, dependency, onModule, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> start = <span class="keyword">this</span>.profile &amp;&amp; +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 根据模块的类型获取对应的模块工厂并创建模块</span></span><br><span class="line">  <span class="keyword">var</span> moduleFactory = <span class="keyword">this</span>.dependencyFactories.get(dependency.constructor);</span><br><span class="line">  ...</span><br><span class="line">  moduleFactory.create(context, dependency, <span class="function"><span class="keyword">function</span>(<span class="params">err, module</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">this</span>.addModule(<span class="built_in">module</span>);</span><br><span class="line">    ...</span><br><span class="line">    this.buildModule(<span class="built_in">module</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">// 构建模块，添加依赖模块</span></span><br><span class="line">    &#125;.bind(<span class="keyword">this</span>));</span><br><span class="line">  &#125;.bind(<span class="keyword">this</span>));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用 <a href="https://github.com/ternjs/acorn" target="_blank" rel="external">acorn</a> 解析经 loader 处理后的源文件生成抽象语法树 AST</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> Parser.prototype.parse = <span class="function"><span class="keyword">function</span> <span class="title">parse</span>(<span class="params">source, initialState</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ast;</span><br><span class="line">  <span class="keyword">if</span> (!ast) &#123;</span><br><span class="line">    <span class="comment">// acorn以es6的语法进行解析</span></span><br><span class="line">    ast = acorn.parse(source, &#123;</span><br><span class="line">      ranges: <span class="literal">true</span>,</span><br><span class="line">      locations: <span class="literal">true</span>,</span><br><span class="line">      ecmaVersion: <span class="number">6</span>,</span><br><span class="line">      sourceType: <span class="string">"module"</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历 AST，构建该模块所依赖的模块</p>
<p>对于当前模块，或许存在着多个依赖模块。当前模块会开辟一个依赖模块的数组，在遍历 AST 时，将 require() 中的模块通过 <code>addDependency()</code> 添加到数组中。当前模块构建完成后，webpack 调用 <code>processModuleDependencies</code> 开始递归处理依赖的 module，接着就会重复之前的构建步骤。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> Compilation.prototype.addModuleDependencies = <span class="function"><span class="keyword">function</span>(<span class="params">module, dependencies, bail, cacheGroup, recursive, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 根据依赖数组(dependencies)创建依赖模块对象</span></span><br><span class="line">  <span class="keyword">var</span> factories = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; dependencies.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> factory = _this.dependencyFactories.get(dependencies[i][<span class="number">0</span>].constructor);</span><br><span class="line">    factories[i] = [factory, dependencies[i]];</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 与当前模块构建步骤相同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="3-构建细节"><a href="#3-构建细节" class="headerlink" title="3. 构建细节"></a>3. 构建细节</h5><p>module 是 webpack 构建的核心实体，也是所有 module 的 父类，它有几种不同子类：<code>NormalModule</code> ,  <code>MultiModule</code> ,  <code>ContextModule</code> , <code>DelegatedModule</code>  等。但这些核心实体都是在构建中都会去调用对应方法，也就是 <code>build()</code> 。来看看其中具体做了什么：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化module信息，如context,id,chunks,dependencies等。</span></span><br><span class="line">NormalModule.prototype.build = <span class="function"><span class="keyword">function</span> <span class="title">build</span>(<span class="params">options, compilation, resolver, fs, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.buildTimestamp = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime(); <span class="comment">// 构建计时</span></span><br><span class="line">  <span class="keyword">this</span>.built = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.doBuild(options, compilation, resolver, fs, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 指定模块引用，不经acorn解析</span></span><br><span class="line">    <span class="keyword">if</span> (options.module &amp;&amp; options.module.noParse) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(options.module.noParse)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (options.module.noParse.some(<span class="function"><span class="keyword">function</span>(<span class="params">regExp</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">typeof</span> regExp === <span class="string">"string"</span> ?</span><br><span class="line">            <span class="keyword">this</span>.request.indexOf(regExp) === <span class="number">0</span> :</span><br><span class="line">              regExp.test(<span class="keyword">this</span>.request);</span><br><span class="line">          &#125;, <span class="keyword">this</span>)) &#123;</span><br><span class="line">          <span class="keyword">return</span> callback();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> options.module.noParse === <span class="string">"string"</span> ?</span><br><span class="line">        <span class="keyword">this</span>.request.indexOf(options.module.noParse) === <span class="number">0</span> :</span><br><span class="line">          options.module.noParse.test(<span class="keyword">this</span>.request)) &#123;</span><br><span class="line">        <span class="keyword">return</span> callback();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 由acorn解析生成ast</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.parser.parse(<span class="keyword">this</span>._source.source(), &#123;</span><br><span class="line">        current: <span class="keyword">this</span>,</span><br><span class="line">        <span class="built_in">module</span>: <span class="keyword">this</span>,</span><br><span class="line">        compilation: compilation,</span><br><span class="line">        options: options</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">var</span> source = <span class="keyword">this</span>._source.source();</span><br><span class="line">      <span class="keyword">this</span>._source = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">return</span> callback(<span class="keyword">new</span> ModuleParseError(<span class="keyword">this</span>, source, e));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> callback();</span><br><span class="line">  &#125;.bind(<span class="keyword">this</span>));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于每一个 module ，它都会有这样一个构建方法。当然，它还包括了从构建到输出的一系列的有关 module 生命周期的函数，我们通过 module 父类类图其子类类图(这里以 NormalModule 为例)来观察其真实形态：</p>
<p><img src="https://img.alicdn.com/tps/TB1WOiRNXXXXXcJaXXXXXXXXXXX-445-1228.png" alt="module类图"></p>
<p>可以看到无论是构建流程，处理依赖流程，包括后面的封装流程都是与 module 密切相关的。</p>
<h3 id="打包输出"><a href="#打包输出" class="headerlink" title="打包输出"></a>打包输出</h3><p>在所有模块及其依赖模块 build 完成后，webpack 会监听 <code>seal</code> 事件调用各插件对构建后的结果进行封装，要逐次对每个 module 和 chunk 进行整理，生成编译后的源码，合并，拆分，生成 hash 。 同时这是我们在开发时进行代码优化和功能添加的关键环节。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Compilation.prototype.seal = <span class="function"><span class="keyword">function</span> <span class="title">seal</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.applyPlugins(<span class="string">"seal"</span>); <span class="comment">// 触发插件的seal事件</span></span><br><span class="line">  <span class="keyword">this</span>.preparedChunks.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.name &lt; b.name) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a.name &gt; b.name) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">this</span>.preparedChunks.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">preparedChunk</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">module</span> = preparedChunk.module;</span><br><span class="line">    <span class="keyword">var</span> chunk = <span class="keyword">this</span>.addChunk(preparedChunk.name, <span class="built_in">module</span>);</span><br><span class="line">    chunk.initial = chunk.entry = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 整理每个Module和chunk，每个chunk对应一个输出文件。</span></span><br><span class="line">    chunk.addModule(<span class="built_in">module</span>);</span><br><span class="line">    <span class="built_in">module</span>.addChunk(chunk);</span><br><span class="line">  &#125;, <span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.applyPluginsAsync(<span class="string">"optimize-tree"</span>, <span class="keyword">this</span>.chunks, <span class="keyword">this</span>.modules, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span> callback(err);</span><br><span class="line">    &#125;</span><br><span class="line">    ... <span class="comment">// 触发插件的事件</span></span><br><span class="line">    <span class="keyword">this</span>.createChunkAssets(); <span class="comment">// 生成最终assets</span></span><br><span class="line">    ... <span class="comment">// 触发插件的事件</span></span><br><span class="line">  &#125;.bind(<span class="keyword">this</span>));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="1-生成最终-assets"><a href="#1-生成最终-assets" class="headerlink" title="1. 生成最终 assets"></a>1. 生成最终 assets</h5><p>在封装过程中，webpack 会调用 Compilation 中的 <code>createChunkAssets</code> 方法进行打包后代码的生成。 createChunkAssets 流程如下：</p>
<p><img src="https://img.alicdn.com/tps/TB1cz5.NXXXXXc7XpXXXXXXXXXX-959-807.png" alt="createChunkAssets流程"></p>
<ul>
<li><p>不同的 Template</p>
<p>从上图可以看出通过判断是入口 js 还是需要异步加载的 js 来选择不同的模板对象进行封装，入口 js 会采用 webpack 事件流的 render 事件来触发 <code>Template类</code> 中的 <code>renderChunkModules()</code> (异步加载的 js 会调用 chunkTemplate 中的 render 方法)。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(chunk.entry) &#123;</span><br><span class="line">  source = <span class="keyword">this</span>.mainTemplate.render(<span class="keyword">this</span>.hash, chunk, <span class="keyword">this</span>.moduleTemplate, <span class="keyword">this</span>.dependencyTemplates);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  source = <span class="keyword">this</span>.chunkTemplate.render(chunk, <span class="keyword">this</span>.moduleTemplate, <span class="keyword">this</span>.dependencyTemplates);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 webpack 中有四个 Template 的子类，分别是 <code>MainTemplate.js</code>  ， <code>ChunkTemplate.js</code> ，<code>ModuleTemplate.js</code> ， <code>HotUpdateChunkTemplate.js</code> ，前两者先前已大致有介绍，而 ModuleTemplate 是对所有模块进行一个代码生成，HotUpdateChunkTemplate 是对热替换模块的一个处理。</p>
</li>
<li><p>模块封装</p>
<p>模块在封装的时候和它在构建时一样，都是调用各模块类中的方法。封装通过调用 <code>module.source()</code> 来进行各操作，比如说 require() 的替换。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MainTemplate.prototype.requireFn = <span class="string">"__webpack_require__"</span>;</span><br><span class="line">MainTemplate.prototype.render = <span class="function"><span class="keyword">function</span>(<span class="params">hash, chunk, moduleTemplate, dependencyTemplates</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> buf = [];</span><br><span class="line">    <span class="comment">// 每一个module都有一个moduleId,在最后会替换。</span></span><br><span class="line">    buf.push(<span class="string">"function "</span> + <span class="keyword">this</span>.requireFn + <span class="string">"(moduleId) &#123;"</span>);</span><br><span class="line">    buf.push(<span class="keyword">this</span>.indent(<span class="keyword">this</span>.applyPluginsWaterfall(<span class="string">"require"</span>, <span class="string">""</span>, chunk, hash)));</span><br><span class="line">    buf.push(<span class="string">"&#125;"</span>);</span><br><span class="line">    buf.push(<span class="string">""</span>);</span><br><span class="line">    ... <span class="comment">// 其余封装操作</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成 assets</p>
<p>各模块进行 doBlock 后，把 module 的最终代码循环添加到 source 中。一个 source 对应着一个 asset 对象，该对象保存了单个文件的文件名( name )和最终代码( value )。</p>
</li>
</ul>
<h5 id="2-输出"><a href="#2-输出" class="headerlink" title="2. 输出"></a>2. 输出</h5><p>最后一步，webpack 调用 Compiler 中的 <code>emitAssets()</code> ，按照 output 中的配置项将文件输出到了对应的 path 中，从而 webpack 整个打包过程结束。要注意的是，若想对结果进行处理，则需要在 <code>emit</code> 触发后对自定义插件进行扩展。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>webpack 的整体流程主要还是依赖于 <code>compilation</code> 和 <code>module</code> 这两个对象，但其思想远不止这么简单。最开始也说过，webpack 本质是个插件集合，并且由 <code>tapable</code> 控制各插件在 webpack 事件流上运行，至于具体的思想和细节，将会在后一篇文章中提到。同时，在业务开发中，无论是为了提升构建效率，或是减小打包文件大小，我们都可以通过编写 webpack 插件来进行流程上的控制，这个也会在之后提到。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="//img.alicdn.com/tfs/TB1_ZnHNXXXXXXBXpXXXXXXXXXX-900-500.jpg" alt="细说 webpack 之流程篇"></p>
<h3 id="引言"><a href="#引言" class="heade]]>
    </summary>
    
      <category term="webpack" scheme="http://taobaofed.org/tags/webpack/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
</feed>
